{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.util.FilenameUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.PushCommand;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.diff.DiffFormatter;\nimport org.eclipse.jgit.diff.RawTextComparator;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.errors.StopWalkException;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Ref;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.RepositoryBuilder;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevFlag;\nimport org.eclipse.jgit.revwalk.RevSort;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.revwalk.filter.CommitTimeRevFilter;\nimport org.eclipse.jgit.revwalk.filter.RevFilter;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.util.io.DisabledOutputStream;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.eclipse.jgit.lib.Constants.R_TAGS;\n\n/**\n * JGit utility functions.\n *\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitUtils\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger( JGitUtils.class );\n\n    private JGitUtils()\n    {\n        // no op\n    }\n\n    /**\n     * Opens a JGit repository in the current directory or a parent directory.\n     * @param basedir The directory to start with\n     * @throws IOException If the repository cannot be opened\n     */\n    public static Git openRepo( File basedir ) throws IOException\n    {\n        return new Git( new RepositoryBuilder().readEnvironment().findGitDir( basedir ).setMustExist( true ).build() );\n    }\n\n    /**\n     * Closes the repository wrapped by the passed git object\n     * @param git\n     */\n    public static void closeRepo( Git git )\n    {\n        if ( git != null && git.getRepository() != null )\n        {\n            git.getRepository().close();\n        }\n    }\n\n    /**\n     * Construct a logging ProgressMonitor for all JGit operations.\n     *\n     * @return a ProgressMonitor for use\n     */\n    public static ProgressMonitor getMonitor()\n    {\n        // X TODO write an own ProgressMonitor which logs to ScmLogger!\n        return new TextProgressMonitor();\n    }\n\n    /**\n     * Prepares the in memory configuration of git to connect to the configured\n     * repository. It configures the following settings in memory: <br>\n     * <ul><li>push url<\/li> <li>fetch url<\/li><\/ul>\n     * <p>\n     *\n     * @param git        the instance to configure (only in memory, not saved)\n     * @param repository the repo config to be used\n     * @return {@link CredentialsProvider} in case there are credentials\n     *         informations configured in the repository.\n     */\n    public static CredentialsProvider prepareSession( Git git, GitScmProviderRepository repository )\n    {\n        StoredConfig config = git.getRepository().getConfig();\n        config.setString( \"remote\", \"origin\", \"url\", repository.getFetchUrl() );\n        config.setString( \"remote\", \"origin\", \"pushURL\", repository.getPushUrl() );\n\n        // make sure we do not log any passwords to the output\n        String password =\n            StringUtils.isNotBlank( repository.getPassword() ) ? repository.getPassword().trim() : \"no-pwd-defined\";\n        // if password contains special characters it won't match below.\n        // Try encoding before match. (Passwords without will be unaffected)\n        try\n        {\n            password = URLEncoder.encode( password, \"UTF-8\" );\n        }\n        catch ( UnsupportedEncodingException e )\n        {\n            // UTF-8 should be valid\n            // TODO use a logger\n            System.out.println( \"Ignore UnsupportedEncodingException when trying to encode password\" );\n        }\n        LOGGER.info( \"fetch url: \" + repository.getFetchUrl().replace( password, \"******\" ) );\n        LOGGER.info( \"push url: \" + repository.getPushUrl().replace( password, \"******\" ) );\n        return getCredentials( repository );\n    }\n\n    /**\n     * Creates a credentials provider from the information passed in the\n     * repository. Current implementation supports: <br>\n     * <ul><li>UserName/Password<\/li><\/ul>\n     * <p>\n     *\n     * @param repository the config to get the details from\n     * @return <code>null<\/code> if there is not enough info to create a\n     *         provider with\n     */\n    public static CredentialsProvider getCredentials( GitScmProviderRepository repository )\n    {\n        if ( StringUtils.isNotBlank( repository.getUser() ) && StringUtils.isNotBlank( repository.getPassword() ) )\n        {\n            return new UsernamePasswordCredentialsProvider( repository.getUser().trim(),\n                                                            repository.getPassword().trim() );\n        }\n\n\n        return null;\n    }\n\n    public static Iterable<PushResult> push( Git git, GitScmProviderRepository repo, RefSpec refSpec )\n        throws GitAPIException, InvalidRemoteException, TransportException\n    {\n        CredentialsProvider credentials = prepareSession( git, repo );\n        PushCommand command = git.push().setRefSpecs( refSpec ).setCredentialsProvider( credentials )\n                .setTransportConfigCallback(\n                       new JGitTransportConfigCallback( new ScmProviderAwareSshdSessionFactory( repo, LOGGER ) )\n                 );\n\n        Iterable<PushResult> pushResultList = command.call();\n        for ( PushResult pushResult : pushResultList )\n        {\n            Collection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n            for ( RemoteRefUpdate remoteRefUpdate : ru )\n            {\n                LOGGER.info( remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate );\n            }\n        }\n        return pushResultList;\n    }\n\n    /**\n     * Does the Repository have any commits?\n     *\n     * @param repo\n     * @return false if there are no commits\n     */\n    public static boolean hasCommits( Repository repo )\n    {\n        if ( repo != null && repo.getDirectory().exists() )\n        {\n            return ( new File( repo.getDirectory(), \"objects\" ).list().length > 2 ) || (\n                new File( repo.getDirectory(), \"objects/pack\" ).list().length > 0 );\n        }\n        return false;\n    }\n\n    /**\n     * get a list of all files in the given commit\n     *\n     * @param repository the repo\n     * @param commit     the commit to get the files from\n     * @return a list of files included in the commit\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     * @throws CorruptObjectException\n     * @throws IOException\n     */\n    public static List<ScmFile> getFilesInCommit( Repository repository, RevCommit commit )\n        throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException\n    {\n        List<ScmFile> list = new ArrayList<>();\n        if ( JGitUtils.hasCommits( repository ) )\n        {\n\n            try ( RevWalk rw = new RevWalk( repository );\n                  DiffFormatter df = new DiffFormatter( DisabledOutputStream.INSTANCE ) )\n            {\n                RevCommit realParent = commit.getParentCount() > 0 ? commit.getParent( 0 ) : commit;\n                RevCommit parent = rw.parseCommit( realParent.getId() );\n                    df.setRepository( repository );\n                df.setDiffComparator( RawTextComparator.DEFAULT );\n                df.setDetectRenames( true );\n                List<DiffEntry> diffs = df.scan( parent.getTree(), commit.getTree() );\n                for ( DiffEntry diff : diffs )\n                {\n                    list.add( new ScmFile( diff.getNewPath(), ScmFileStatus.CHECKED_IN ) );\n                }\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n     *\n     * @param changeType\n     * @return the matching ScmFileStatus\n     */\n    public static ScmFileStatus getScmFileStatus( ChangeType changeType )\n    {\n        switch ( changeType )\n        {\n            case ADD:\n                return ScmFileStatus.ADDED;\n            case MODIFY:\n                return ScmFileStatus.MODIFIED;\n            case DELETE:\n                return ScmFileStatus.DELETED;\n            case RENAME:\n                return ScmFileStatus.RENAMED;\n            case COPY:\n                return ScmFileStatus.COPIED;\n            default:\n                return ScmFileStatus.UNKNOWN;\n        }\n    }\n\n    /**\n     * Adds all files in the given fileSet to the repository.\n     *\n     * @param git     the repo to add the files to\n     * @param fileSet the set of files within the workspace, the files are added\n     *                relative to the basedir of this fileset\n     * @return a list of added files\n     * @throws GitAPIException\n     * @throws NoFilepatternException\n     */\n    public static List<ScmFile> addAllFiles( Git git, ScmFileSet fileSet )\n        throws GitAPIException, NoFilepatternException\n    {\n        URI baseUri = fileSet.getBasedir().toURI();\n        AddCommand add = git.add();\n        for ( File file : fileSet.getFileList() )\n        {\n            if ( !file.isAbsolute() )\n            {\n                file = new File( fileSet.getBasedir().getPath(), file.getPath() );\n            }\n\n            if ( file.exists() )\n            {\n                String path = relativize( baseUri, file );\n                add.addFilepattern( path );\n                add.addFilepattern( file.getAbsolutePath() );\n            }\n        }\n        add.call();\n\n        Status status = git.status().call();\n\n        Set<String> allInIndex = new HashSet<>();\n        allInIndex.addAll( status.getAdded() );\n        allInIndex.addAll( status.getChanged() );\n\n        // System.out.println(\"All in index: \"+allInIndex.size());\n\n        List<ScmFile> addedFiles = new ArrayList<>( allInIndex.size() );\n\n        // rewrite all detected files to now have status 'checked_in'\n        for ( String entry : allInIndex )\n        {\n            ScmFile scmfile = new ScmFile( entry, ScmFileStatus.ADDED );\n\n            // if a specific fileSet is given, we have to check if the file is\n            // really tracked\n            for ( Iterator<File> itfl = fileSet.getFileList().iterator(); itfl.hasNext(); )\n            {\n                String path = FilenameUtils.normalizeFilename( relativize( baseUri, itfl.next() ) );\n                if ( path.equals( FilenameUtils.normalizeFilename( scmfile.getPath() ) ) )\n                {\n                    addedFiles.add( scmfile );\n                }\n            }\n        }\n        return addedFiles;\n    }\n\n    private static String relativize( URI baseUri, File f )\n    {\n        String path = f.getPath();\n        if ( f.isAbsolute() )\n        {\n            path = baseUri.relativize( new File( path ).toURI() ).getPath();\n        }\n        return path;\n    }\n\n    /**\n     * Get a list of commits between two revisions.\n     *\n     * @param repo     the repository to work on\n     * @param sortings sorting\n     * @param fromRev  start revision\n     * @param toRev    if null, falls back to head\n     * @param fromDate from which date on\n     * @param toDate   until which date\n     * @param maxLines max number of lines\n     * @return a list of commits, might be empty, but never <code>null<\/code>\n     * @throws IOException\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     */\n    public static List<RevCommit> getRevCommits( Repository repo, RevSort[] sortings, String fromRev, String toRev,\n                                                 final Date fromDate, final Date toDate, int maxLines )\n        throws IOException, MissingObjectException, IncorrectObjectTypeException\n    {\n\n        List<RevCommit> revs = new ArrayList<>();\n\n        ObjectId fromRevId = fromRev != null ? repo.resolve( fromRev ) : null;\n        ObjectId toRevId = toRev != null ? repo.resolve( toRev ) : null;\n\n        if ( sortings == null || sortings.length == 0 )\n        {\n            sortings = new RevSort[]{ RevSort.TOPO, RevSort.COMMIT_TIME_DESC };\n        }\n\n        try ( RevWalk walk = new RevWalk( repo ) )\n        {\n            for ( final RevSort s : sortings )\n            {\n                walk.sort( s, true );\n            }\n\n            if ( fromDate != null && toDate != null )\n            {\n                //walk.setRevFilter( CommitTimeRevFilter.between( fromDate, toDate ) );\n                walk.setRevFilter( new RevFilter()\n                {\n                    @Override\n                    public boolean include( RevWalk walker, RevCommit cmit )\n                        throws StopWalkException, MissingObjectException, IncorrectObjectTypeException, IOException\n                    {\n                        int cmtTime = cmit.getCommitTime();\n\n                        return ( cmtTime >= ( fromDate.getTime() / 1000 ) )\n                                && ( cmtTime <= ( toDate.getTime() / 1000 ) );\n                    }\n\n                    @Override\n                    public RevFilter clone()\n                    {\n                        return this;\n                    }\n                } );\n            }\n            else\n            {\n                if ( fromDate != null )\n                {\n                    walk.setRevFilter( CommitTimeRevFilter.after( fromDate ) );\n                }\n                if ( toDate != null )\n                {\n                    walk.setRevFilter( CommitTimeRevFilter.before( toDate ) );\n                }\n            }\n\n            if ( fromRevId != null )\n            {\n                RevCommit c = walk.parseCommit( fromRevId );\n                c.add( RevFlag.UNINTERESTING );\n                RevCommit real = walk.parseCommit( c );\n                walk.markUninteresting( real );\n            }\n\n            if ( toRevId != null )\n            {\n                RevCommit c = walk.parseCommit( toRevId );\n                c.remove( RevFlag.UNINTERESTING );\n                RevCommit real = walk.parseCommit( c );\n                walk.markStart( real );\n            }\n            else\n            {\n                final ObjectId head = repo.resolve( Constants.HEAD );\n                if ( head == null )\n                {\n                    throw new RuntimeException( \"Cannot resolve \" + Constants.HEAD );\n                }\n                RevCommit real = walk.parseCommit( head );\n                walk.markStart( real );\n            }\n\n            int n = 0;\n            for ( final RevCommit c : walk )\n            {\n                n++;\n                if ( maxLines != -1 && n > maxLines )\n                {\n                    break;\n                }\n\n                revs.add( c );\n            }\n            return revs;\n        }\n    }\n\n    /**\n     * Get a list of tags that has been set in the specified commit.\n     *\n     * @param repo the repository to work on\n     * @param commit the commit for which we want the tags\n     * @return a list of tags, might be empty, and never <code>null<\/code>\n     */\n    public static List<String> getTags( Repository repo, RevCommit commit ) throws IOException\n    {\n        Map<String, Ref> refList = repo.getRefDatabase().getRefs( R_TAGS );\n\n        RevWalk revWalk = new RevWalk( repo );\n\n        ObjectId commitId = commit.getId();\n        List<String> result = new ArrayList<>();\n\n        for ( Map.Entry<String, Ref> refEntry : refList.entrySet() )\n        {\n            ObjectId tagId = refEntry.getValue().getObjectId();\n            RevCommit tagCommit = revWalk.parseCommit( tagId );\n            if ( tagCommit != null && commitId.equals( tagCommit.getId() ) )\n            {\n                result.add( refEntry.getKey() );\n            }\n        }\n        return result;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.util.FilenameUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.PushCommand;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.diff.DiffFormatter;\nimport org.eclipse.jgit.diff.RawTextComparator;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.errors.StopWalkException;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Ref;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.RepositoryBuilder;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevFlag;\nimport org.eclipse.jgit.revwalk.RevSort;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.revwalk.filter.CommitTimeRevFilter;\nimport org.eclipse.jgit.revwalk.filter.RevFilter;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.util.io.DisabledOutputStream;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.eclipse.jgit.lib.Constants.R_TAGS;\n\n/**\n * JGit utility functions.\n *\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitUtils\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger( JGitUtils.class );\n\n    private JGitUtils()\n    {\n        // no op\n    }\n\n    /**\n     * Opens a JGit repository in the current directory or a parent directory.\n     * @param basedir The directory to start with\n     * @throws IOException If the repository cannot be opened\n     */\n    public static Git openRepo( File basedir ) throws IOException\n    {\n        return new Git( new RepositoryBuilder().readEnvironment().findGitDir( basedir ).setMustExist( true ).build() );\n    }\n\n    /**\n     * Closes the repository wrapped by the passed git object\n     * @param git\n     */\n    public static void closeRepo( Git git )\n    {\n        if ( git != null && git.getRepository() != null )\n        {\n            git.getRepository().close();\n        }\n    }\n\n    /**\n     * Construct a logging ProgressMonitor for all JGit operations.\n     *\n     * @return a ProgressMonitor for use\n     */\n    public static ProgressMonitor getMonitor()\n    {\n        // X TODO write an own ProgressMonitor which logs to ScmLogger!\n        return new TextProgressMonitor();\n    }\n\n    /**\n     * Prepares the in memory configuration of git to connect to the configured\n     * repository. It configures the following settings in memory: <br>\n     * <ul><li>push url<\/li> <li>fetch url<\/li><\/ul>\n     * <p>\n     *\n     * @param git        the instance to configure (only in memory, not saved)\n     * @param repository the repo config to be used\n     * @return {@link CredentialsProvider} in case there are credentials\n     *         informations configured in the repository.\n     */\n    public static CredentialsProvider prepareSession( Git git, GitScmProviderRepository repository )\n    {\n        StoredConfig config = git.getRepository().getConfig();\n        config.setString( \"remote\", \"origin\", \"url\", repository.getFetchUrl() );\n        config.setString( \"remote\", \"origin\", \"pushURL\", repository.getPushUrl() );\n\n        // make sure we do not log any passwords to the output\n        String password =\n            StringUtils.isNotBlank( repository.getPassword() ) ? repository.getPassword().trim() : \"no-pwd-defined\";\n        // if password contains special characters it won't match below.\n        // Try encoding before match. (Passwords without will be unaffected)\n        try\n        {\n            password = URLEncoder.encode( password, \"UTF-8\" );\n        }\n        catch ( UnsupportedEncodingException e )\n        {\n            // UTF-8 should be valid\n            // TODO use a logger\n            System.out.println( \"Ignore UnsupportedEncodingException when trying to encode password\" );\n        }\n        LOGGER.info( \"fetch url: \" + repository.getFetchUrl().replace( password, \"******\" ) );\n        LOGGER.info( \"push url: \" + repository.getPushUrl().replace( password, \"******\" ) );\n        return getCredentials( repository );\n    }\n\n    /**\n     * Creates a credentials provider from the information passed in the\n     * repository. Current implementation supports: <br>\n     * <ul><li>UserName/Password<\/li><\/ul>\n     * <p>\n     *\n     * @param repository the config to get the details from\n     * @return <code>null<\/code> if there is not enough info to create a\n     *         provider with\n     */\n    public static CredentialsProvider getCredentials( GitScmProviderRepository repository )\n    {\n        if ( StringUtils.isNotBlank( repository.getUser() ) && StringUtils.isNotBlank( repository.getPassword() ) )\n        {\n            return new UsernamePasswordCredentialsProvider( repository.getUser().trim(),\n                                                            repository.getPassword().trim() );\n        }\n\n\n        return null;\n    }\n\n    public static Iterable<PushResult> push( Git git, GitScmProviderRepository repo, RefSpec refSpec )\n        throws GitAPIException, InvalidRemoteException, TransportException\n    {\n        CredentialsProvider credentials = prepareSession( git, repo );\n        PushCommand command = git.push().setRefSpecs( refSpec ).setCredentialsProvider( credentials )\n                .setTransportConfigCallback(\n                       new JGitTransportConfigCallback( new ScmProviderAwareSshdSessionFactory( repo, LOGGER ) )\n                 );\n\n        Iterable<PushResult> pushResultList = command.call();\n        for ( PushResult pushResult : pushResultList )\n        {\n            Collection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n            for ( RemoteRefUpdate remoteRefUpdate : ru )\n            {\n                LOGGER.info( remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate );\n            }\n        }\n        return pushResultList;\n    }\n\n    /**\n     * Does the Repository have any commits?\n     *\n     * @param repo\n     * @return false if there are no commits\n     */\n    public static boolean hasCommits( Repository repo )\n    {\n        if ( repo != null && repo.getDirectory().exists() )\n        {\n            return ( new File( repo.getDirectory(), \"objects\" ).list().length > 2 ) || (\n                new File( repo.getDirectory(), \"objects/pack\" ).list().length > 0 );\n        }\n        return false;\n    }\n\n    /**\n     * get a list of all files in the given commit\n     *\n     * @param repository the repo\n     * @param commit     the commit to get the files from\n     * @return a list of files included in the commit\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     * @throws CorruptObjectException\n     * @throws IOException\n     */\n    public static List<ScmFile> getFilesInCommit( Repository repository, RevCommit commit )\n        throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException\n    {\n        return getFilesInCommit( repository, commit, null );\n    }\n\n    /**\n     * get a list of all files in the given commit\n     *\n     * @param repository the repo\n     * @param commit     the commit to get the files from\n     * @param baseDir    the directory to which the returned files should be relative.\n     *                   May be {@code null} in case they should be relative to the working directory root.\n     * @return a list of files included in the commit\n     *\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     * @throws CorruptObjectException\n     * @throws IOException\n     */\n    public static List<ScmFile> getFilesInCommit( Repository repository, RevCommit commit, File baseDir )\n        throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException\n    {\n        List<ScmFile> list = new ArrayList<>();\n        if ( JGitUtils.hasCommits( repository ) )\n        {\n\n            try ( RevWalk rw = new RevWalk( repository );\n                  DiffFormatter df = new DiffFormatter( DisabledOutputStream.INSTANCE ) )\n            {\n                RevCommit realParent = commit.getParentCount() > 0 ? commit.getParent( 0 ) : commit;\n                RevCommit parent = rw.parseCommit( realParent.getId() );\n                    df.setRepository( repository );\n                df.setDiffComparator( RawTextComparator.DEFAULT );\n                df.setDetectRenames( true );\n                List<DiffEntry> diffs = df.scan( parent.getTree(), commit.getTree() );\n                for ( DiffEntry diff : diffs )\n                {\n                    final String path;\n                    if ( baseDir != null )\n                    {\n                        path = relativize ( baseDir.toURI(), new File( repository.getWorkTree(), diff.getNewPath() ) );\n                    }\n                    else\n                    {\n                        path = diff.getNewPath();\n                    }\n                    list.add( new ScmFile( path, ScmFileStatus.CHECKED_IN ) );\n                }\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n     *\n     * @param changeType\n     * @return the matching ScmFileStatus\n     */\n    public static ScmFileStatus getScmFileStatus( ChangeType changeType )\n    {\n        switch ( changeType )\n        {\n            case ADD:\n                return ScmFileStatus.ADDED;\n            case MODIFY:\n                return ScmFileStatus.MODIFIED;\n            case DELETE:\n                return ScmFileStatus.DELETED;\n            case RENAME:\n                return ScmFileStatus.RENAMED;\n            case COPY:\n                return ScmFileStatus.COPIED;\n            default:\n                return ScmFileStatus.UNKNOWN;\n        }\n    }\n\n    /**\n     * Adds all files in the given fileSet to the repository.\n     *\n     * @param git     the repo to add the files to\n     * @param fileSet the set of files within the workspace, the files are added\n     *                relative to the basedir of this fileset\n     * @return a list of added files\n     * @throws GitAPIException\n     * @throws NoFilepatternException\n     */\n    public static List<ScmFile> addAllFiles( Git git, ScmFileSet fileSet )\n        throws GitAPIException, NoFilepatternException\n    {\n        URI workingCopyRootUri = git.getRepository().getWorkTree().toURI();\n        AddCommand add = git.add();\n        for ( File file : fileSet.getFileList() )\n        {\n            if ( !file.isAbsolute() )\n            {\n                file = new File( fileSet.getBasedir().getPath(), file.getPath() );\n            }\n\n            if ( file.exists() )\n            {\n                String path = relativize( workingCopyRootUri, file );\n                add.addFilepattern( path );\n            }\n        }\n        add.call();\n\n        Status status = git.status().call();\n\n        Set<String> allInIndex = new HashSet<>();\n        allInIndex.addAll( status.getAdded() );\n        allInIndex.addAll( status.getChanged() );\n\n        // System.out.println(\"All in index: \"+allInIndex.size());\n\n        List<ScmFile> addedFiles = new ArrayList<>( allInIndex.size() );\n\n        // rewrite all detected files to now have status 'checked_in'\n        for ( String entry : allInIndex )\n        {\n            // if a specific fileSet is given, we have to check if the file is\n            // really tracked\n            for ( File file : fileSet.getFileList() )\n            {\n                if ( !file.isAbsolute() )\n                {\n                    file = new File( fileSet.getBasedir(), file.getPath() );\n                }\n                String path = FilenameUtils.normalizeFilename( relativize( workingCopyRootUri, file ) );\n                if ( path.equals( FilenameUtils.normalizeFilename( entry ) ) )\n                {\n                    // returned ScmFiles should be relative to given fileset's basedir\n                    ScmFile scmfile = new ScmFile( relativize( fileSet.getBasedir().toURI(), file ),\n                            ScmFileStatus.ADDED );\n                    addedFiles.add( scmfile );\n                }\n            }\n        }\n        return addedFiles;\n    }\n\n    private static String relativize( URI baseUri, File f )\n    {\n        String path = f.getPath();\n        if ( f.isAbsolute() )\n        {\n            path = baseUri.relativize( new File( path ).toURI() ).getPath();\n        }\n        return path;\n    }\n\n    /**\n     * Get a list of commits between two revisions.\n     *\n     * @param repo     the repository to work on\n     * @param sortings sorting\n     * @param fromRev  start revision\n     * @param toRev    if null, falls back to head\n     * @param fromDate from which date on\n     * @param toDate   until which date\n     * @param maxLines max number of lines\n     * @return a list of commits, might be empty, but never <code>null<\/code>\n     * @throws IOException\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     */\n    public static List<RevCommit> getRevCommits( Repository repo, RevSort[] sortings, String fromRev, String toRev,\n                                                 final Date fromDate, final Date toDate, int maxLines )\n        throws IOException, MissingObjectException, IncorrectObjectTypeException\n    {\n\n        List<RevCommit> revs = new ArrayList<>();\n\n        ObjectId fromRevId = fromRev != null ? repo.resolve( fromRev ) : null;\n        ObjectId toRevId = toRev != null ? repo.resolve( toRev ) : null;\n\n        if ( sortings == null || sortings.length == 0 )\n        {\n            sortings = new RevSort[]{ RevSort.TOPO, RevSort.COMMIT_TIME_DESC };\n        }\n\n        try ( RevWalk walk = new RevWalk( repo ) )\n        {\n            for ( final RevSort s : sortings )\n            {\n                walk.sort( s, true );\n            }\n\n            if ( fromDate != null && toDate != null )\n            {\n                //walk.setRevFilter( CommitTimeRevFilter.between( fromDate, toDate ) );\n                walk.setRevFilter( new RevFilter()\n                {\n                    @Override\n                    public boolean include( RevWalk walker, RevCommit cmit )\n                        throws StopWalkException, MissingObjectException, IncorrectObjectTypeException, IOException\n                    {\n                        int cmtTime = cmit.getCommitTime();\n\n                        return ( cmtTime >= ( fromDate.getTime() / 1000 ) )\n                                && ( cmtTime <= ( toDate.getTime() / 1000 ) );\n                    }\n\n                    @Override\n                    public RevFilter clone()\n                    {\n                        return this;\n                    }\n                } );\n            }\n            else\n            {\n                if ( fromDate != null )\n                {\n                    walk.setRevFilter( CommitTimeRevFilter.after( fromDate ) );\n                }\n                if ( toDate != null )\n                {\n                    walk.setRevFilter( CommitTimeRevFilter.before( toDate ) );\n                }\n            }\n\n            if ( fromRevId != null )\n            {\n                RevCommit c = walk.parseCommit( fromRevId );\n                c.add( RevFlag.UNINTERESTING );\n                RevCommit real = walk.parseCommit( c );\n                walk.markUninteresting( real );\n            }\n\n            if ( toRevId != null )\n            {\n                RevCommit c = walk.parseCommit( toRevId );\n                c.remove( RevFlag.UNINTERESTING );\n                RevCommit real = walk.parseCommit( c );\n                walk.markStart( real );\n            }\n            else\n            {\n                final ObjectId head = repo.resolve( Constants.HEAD );\n                if ( head == null )\n                {\n                    throw new RuntimeException( \"Cannot resolve \" + Constants.HEAD );\n                }\n                RevCommit real = walk.parseCommit( head );\n                walk.markStart( real );\n            }\n\n            int n = 0;\n            for ( final RevCommit c : walk )\n            {\n                n++;\n                if ( maxLines != -1 && n > maxLines )\n                {\n                    break;\n                }\n\n                revs.add( c );\n            }\n            return revs;\n        }\n    }\n\n    /**\n     * Get a list of tags that has been set in the specified commit.\n     *\n     * @param repo the repository to work on\n     * @param commit the commit for which we want the tags\n     * @return a list of tags, might be empty, and never <code>null<\/code>\n     */\n    public static List<String> getTags( Repository repo, RevCommit commit ) throws IOException\n    {\n        Map<String, Ref> refList = repo.getRefDatabase().getRefs( R_TAGS );\n\n        RevWalk revWalk = new RevWalk( repo );\n\n        ObjectId commitId = commit.getId();\n        List<String> result = new ArrayList<>();\n\n        for ( Map.Entry<String, Ref> refEntry : refList.entrySet() )\n        {\n            ObjectId tagId = refEntry.getValue().getObjectId();\n            RevCommit tagCommit = revWalk.parseCommit( tagId );\n            if ( tagCommit != null && commitId.equals( tagCommit.getId() ) )\n            {\n                result.add( refEntry.getKey() );\n            }\n        }\n        return result;\n    }\n}\n","lineNo":276}
{"Smelly Sample":"package org.apache.maven.scm.tck.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTckTestCase;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.junit.Test;\n\nimport java.util.Date;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * Test Changlog command. <br>\n * 1. Get initial log <br>\n * 2. Add one revision <br>\n * 3. Get the two logs <br>\n * 4. Get the last log based on date <br>\n * 5. Test last log for date and comment <br>\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbj�rn Eikli Sm�rgrav<\/a>\n */\npublic abstract class ChangeLogCommandTckTest\n    extends ScmTckTestCase\n{\n    private static final String COMMIT_MSG = \"Second changelog\";\n\n    @Test\n    public void testChangeLogCommand()\n        throws Exception\n    {\n        Thread.sleep( 1000 );\n        ScmProvider provider = getScmManager().getProviderByRepository( getScmRepository() );\n        ScmFileSet fileSet = new ScmFileSet( getWorkingCopy() );\n\n        ChangeLogScmResult firstResult =\n            provider.changeLog( getScmRepository(), fileSet, null, null, 0, (ScmBranch) null, null );\n        assertTrue( firstResult.getProviderMessage() + \": \" + firstResult.getCommandLine() + \"\\n\"\n                        + firstResult.getCommandOutput(), firstResult.isSuccess() );\n\n        // for svn and git the repo get recreated for each test and therefore initial changelog size is 1\n        int firstLogSize = firstResult.getChangeLog().getChangeSets().size();\n        assertTrue( \"Unexpected initial log size\", firstLogSize >= 1 );\n\n        // Make a timestamp that we know are after initial revision but before the second\n        Date timeBeforeSecond = new Date(); //Current time\n\n        // pause a couple seconds... [SCM-244]\n        Thread.sleep( 2000 );\n\n        //Make a change to the readme.txt and commit the change\n        this.edit( getWorkingCopy(), \"readme.txt\", null, getScmRepository() );\n        ScmTestCase.makeFile( getWorkingCopy(), \"/readme.txt\", \"changed readme.txt\" );\n        CheckInScmResult checkInResult = provider.checkIn( getScmRepository(), fileSet, COMMIT_MSG );\n        assertTrue( \"Unable to checkin changes to the repository\", checkInResult.isSuccess() );\n\n        ChangeLogScmResult secondResult = provider.changeLog( getScmRepository(), fileSet, (ScmVersion) null, null );\n        assertTrue( secondResult.getProviderMessage(), secondResult.isSuccess() );\n        assertEquals( firstLogSize + 1, secondResult.getChangeLog().getChangeSets().size() );\n\n        //Now only retrieve the changelog after timeBeforeSecondChangeLog\n        Date currentTime = new Date();\n        ChangeLogScmResult thirdResult = provider\n            .changeLog( getScmRepository(), fileSet, timeBeforeSecond, currentTime, 0, new ScmBranch( \"\" ) );\n\n        //Thorough assert of the last result\n        assertTrue( thirdResult.getProviderMessage(), thirdResult.isSuccess() );\n        assertEquals( 1, thirdResult.getChangeLog().getChangeSets().size() );\n        ChangeSet changeset = thirdResult.getChangeLog().getChangeSets().get( 0 );\n        assertTrue( changeset.getDate().after( timeBeforeSecond ) );\n\n\n        assertEquals( COMMIT_MSG, changeset.getComment() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.tck.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.ScmTckTestCase;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.junit.Test;\n\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * Test Changlog command. <br>\n * 1. Get initial log <br>\n * 2. Add one revision <br>\n * 3. Get the two logs <br>\n * 4. Get the last log based on date <br>\n * 5. Test last log for date and comment <br>\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbj�rn Eikli Sm�rgrav<\/a>\n */\npublic abstract class ChangeLogCommandTckTest\n    extends ScmTckTestCase\n{\n    private static final String COMMIT_MSG = \"Second changelog\";\n    private static final String COMMIT_TAG = \"v3.14\";\n\n    /**\n     * In some SCMs (Hg) adding a tag creates an extra commit which offsets the expectations.\n     * @return If an extra commit will be present for a tag.\n     */\n    public boolean isTagAnExtraCommit()\n    {\n        return false;\n    }\n\n    @Test\n    public void testChangeLogCommand()\n        throws Exception\n    {\n        Thread.sleep( 1000 );\n        ScmProvider provider = getScmManager().getProviderByRepository( getScmRepository() );\n        ScmFileSet fileSet = new ScmFileSet( getWorkingCopy() );\n\n        ChangeLogScmResult firstResult =\n            provider.changeLog( getScmRepository(), fileSet, null, null, 0, (ScmBranch) null, null );\n        assertTrue( firstResult.getProviderMessage() + \": \" + firstResult.getCommandLine() + \"\\n\"\n                        + firstResult.getCommandOutput(), firstResult.isSuccess() );\n\n        // for svn and git the repo get recreated for each test and therefore initial changelog size is 1\n        int firstLogSize = firstResult.getChangeLog().getChangeSets().size();\n        assertTrue( \"Unexpected initial log size\", firstLogSize >= 1 );\n\n        // Make a timestamp that we know are after initial revision but before the second\n        Date timeBeforeSecond = new Date(); //Current time\n\n        // pause a couple seconds... [SCM-244]\n        Thread.sleep( 2000 );\n\n        //Make a change to the readme.txt and commit the change\n        this.edit( getWorkingCopy(), \"readme.txt\", null, getScmRepository() );\n        ScmTestCase.makeFile( getWorkingCopy(), \"/readme.txt\", \"changed readme.txt\" );\n        CheckInScmResult checkInResult = provider.checkIn( getScmRepository(), fileSet, COMMIT_MSG );\n        assertTrue( \"Unable to checkin changes to the repository\", checkInResult.isSuccess() );\n\n        ScmTagParameters scmTagParameters = new ScmTagParameters();\n        TagScmResult tagResult = provider.tag( getScmRepository(), fileSet, COMMIT_TAG, scmTagParameters );\n        assertTrue( \"Unable to tag the changes in the repository\", tagResult.isSuccess() );\n\n        ChangeLogScmRequest changeLogScmRequest = new ChangeLogScmRequest( getScmRepository(), fileSet );\n        ChangeLogScmResult secondResult = provider.changeLog( changeLogScmRequest );\n        assertTrue( secondResult.getProviderMessage(), secondResult.isSuccess() );\n\n        List<ChangeSet> changeSets = secondResult.getChangeLog().getChangeSets();\n\n        int expectedChangeSets = firstLogSize + 1;\n        boolean lastCommitIsCausedByTagging = false;\n        int lastCodeCommitIndex = 0;\n\n        if ( isTagAnExtraCommit() )\n        {\n            // This is for example Mercurial which creates an extra commit after tagging.\n            lastCommitIsCausedByTagging = true;\n            expectedChangeSets += 1;\n            lastCodeCommitIndex = 1;\n        }\n\n        assertEquals( expectedChangeSets, changeSets.size() );\n\n        // Check if the tag has been retrieved again\n        ChangeSet changeSetWithTag = changeSets.get( lastCodeCommitIndex );\n        assertEquals( Collections.singletonList( COMMIT_TAG ), changeSetWithTag.getTags() );\n\n        //Now only retrieve the changelog after timeBeforeSecondChangeLog\n        Date currentTime = new Date();\n        changeLogScmRequest = new ChangeLogScmRequest( getScmRepository(), fileSet );\n        changeLogScmRequest.setStartDate( timeBeforeSecond );\n        changeLogScmRequest.setEndDate( currentTime );\n        changeLogScmRequest.setScmBranch( new ScmBranch( \"\" ) );\n        ChangeLogScmResult thirdResult = provider.changeLog( changeLogScmRequest );\n\n        //Thorough assert of the last result\n        assertTrue( thirdResult.getProviderMessage(), thirdResult.isSuccess() );\n\n        List<ChangeSet> thirdChangeSets = thirdResult.getChangeLog().getChangeSets();\n        assertEquals( lastCommitIsCausedByTagging ? 2 : 1, thirdChangeSets.size() );\n        ChangeSet changeset = thirdChangeSets.get( lastCodeCommitIndex );\n        assertTrue( changeset.getDate().after( timeBeforeSecond ) );\n        assertTrue( changeset.getComment().startsWith( COMMIT_MSG ) );\n    }\n}\n","lineNo":100}
{"Smelly Sample":"package org.apache.maven.scm.tck.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTckTestCase;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.junit.Test;\n\nimport java.util.Date;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * Test Changlog command. <br>\n * 1. Get initial log <br>\n * 2. Add one revision <br>\n * 3. Get the two logs <br>\n * 4. Get the last log based on date <br>\n * 5. Test last log for date and comment <br>\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbj�rn Eikli Sm�rgrav<\/a>\n */\npublic abstract class ChangeLogCommandTckTest\n    extends ScmTckTestCase\n{\n    private static final String COMMIT_MSG = \"Second changelog\";\n\n    @Test\n    public void testChangeLogCommand()\n        throws Exception\n    {\n        Thread.sleep( 1000 );\n        ScmProvider provider = getScmManager().getProviderByRepository( getScmRepository() );\n        ScmFileSet fileSet = new ScmFileSet( getWorkingCopy() );\n\n        ChangeLogScmResult firstResult =\n            provider.changeLog( getScmRepository(), fileSet, null, null, 0, (ScmBranch) null, null );\n        assertTrue( firstResult.getProviderMessage() + \": \" + firstResult.getCommandLine() + \"\\n\"\n                        + firstResult.getCommandOutput(), firstResult.isSuccess() );\n\n        // for svn and git the repo get recreated for each test and therefore initial changelog size is 1\n        int firstLogSize = firstResult.getChangeLog().getChangeSets().size();\n        assertTrue( \"Unexpected initial log size\", firstLogSize >= 1 );\n\n        // Make a timestamp that we know are after initial revision but before the second\n        Date timeBeforeSecond = new Date(); //Current time\n\n        // pause a couple seconds... [SCM-244]\n        Thread.sleep( 2000 );\n\n        //Make a change to the readme.txt and commit the change\n        this.edit( getWorkingCopy(), \"readme.txt\", null, getScmRepository() );\n        ScmTestCase.makeFile( getWorkingCopy(), \"/readme.txt\", \"changed readme.txt\" );\n        CheckInScmResult checkInResult = provider.checkIn( getScmRepository(), fileSet, COMMIT_MSG );\n        assertTrue( \"Unable to checkin changes to the repository\", checkInResult.isSuccess() );\n\n        ChangeLogScmResult secondResult = provider.changeLog( getScmRepository(), fileSet, (ScmVersion) null, null );\n        assertTrue( secondResult.getProviderMessage(), secondResult.isSuccess() );\n        assertEquals( firstLogSize + 1, secondResult.getChangeLog().getChangeSets().size() );\n\n        //Now only retrieve the changelog after timeBeforeSecondChangeLog\n        Date currentTime = new Date();\n        ChangeLogScmResult thirdResult = provider\n            .changeLog( getScmRepository(), fileSet, timeBeforeSecond, currentTime, 0, new ScmBranch( \"\" ) );\n\n        //Thorough assert of the last result\n        assertTrue( thirdResult.getProviderMessage(), thirdResult.isSuccess() );\n        assertEquals( 1, thirdResult.getChangeLog().getChangeSets().size() );\n        ChangeSet changeset = thirdResult.getChangeLog().getChangeSets().get( 0 );\n        assertTrue( changeset.getDate().after( timeBeforeSecond ) );\n\n\n        assertEquals( COMMIT_MSG, changeset.getComment() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.tck.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.ScmTckTestCase;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.junit.Test;\n\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * Test Changlog command. <br>\n * 1. Get initial log <br>\n * 2. Add one revision <br>\n * 3. Get the two logs <br>\n * 4. Get the last log based on date <br>\n * 5. Test last log for date and comment <br>\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbj�rn Eikli Sm�rgrav<\/a>\n */\npublic abstract class ChangeLogCommandTckTest\n    extends ScmTckTestCase\n{\n    private static final String COMMIT_MSG = \"Second changelog\";\n    private static final String COMMIT_TAG = \"v3.14\";\n\n    /**\n     * In some SCMs (Hg) adding a tag creates an extra commit which offsets the expectations.\n     * @return If an extra commit will be present for a tag.\n     */\n    public boolean isTagAnExtraCommit()\n    {\n        return false;\n    }\n\n    @Test\n    public void testChangeLogCommand()\n        throws Exception\n    {\n        Thread.sleep( 1000 );\n        ScmProvider provider = getScmManager().getProviderByRepository( getScmRepository() );\n        ScmFileSet fileSet = new ScmFileSet( getWorkingCopy() );\n\n        ChangeLogScmResult firstResult =\n            provider.changeLog( getScmRepository(), fileSet, null, null, 0, (ScmBranch) null, null );\n        assertTrue( firstResult.getProviderMessage() + \": \" + firstResult.getCommandLine() + \"\\n\"\n                        + firstResult.getCommandOutput(), firstResult.isSuccess() );\n\n        // for svn and git the repo get recreated for each test and therefore initial changelog size is 1\n        int firstLogSize = firstResult.getChangeLog().getChangeSets().size();\n        assertTrue( \"Unexpected initial log size\", firstLogSize >= 1 );\n\n        // Make a timestamp that we know are after initial revision but before the second\n        Date timeBeforeSecond = new Date(); //Current time\n\n        // pause a couple seconds... [SCM-244]\n        Thread.sleep( 2000 );\n\n        //Make a change to the readme.txt and commit the change\n        this.edit( getWorkingCopy(), \"readme.txt\", null, getScmRepository() );\n        ScmTestCase.makeFile( getWorkingCopy(), \"/readme.txt\", \"changed readme.txt\" );\n        CheckInScmResult checkInResult = provider.checkIn( getScmRepository(), fileSet, COMMIT_MSG );\n        assertTrue( \"Unable to checkin changes to the repository\", checkInResult.isSuccess() );\n\n        ScmTagParameters scmTagParameters = new ScmTagParameters();\n        TagScmResult tagResult = provider.tag( getScmRepository(), fileSet, COMMIT_TAG, scmTagParameters );\n        assertTrue( \"Unable to tag the changes in the repository\", tagResult.isSuccess() );\n\n        ChangeLogScmRequest changeLogScmRequest = new ChangeLogScmRequest( getScmRepository(), fileSet );\n        ChangeLogScmResult secondResult = provider.changeLog( changeLogScmRequest );\n        assertTrue( secondResult.getProviderMessage(), secondResult.isSuccess() );\n\n        List<ChangeSet> changeSets = secondResult.getChangeLog().getChangeSets();\n\n        int expectedChangeSets = firstLogSize + 1;\n        boolean lastCommitIsCausedByTagging = false;\n        int lastCodeCommitIndex = 0;\n\n        if ( isTagAnExtraCommit() )\n        {\n            // This is for example Mercurial which creates an extra commit after tagging.\n            lastCommitIsCausedByTagging = true;\n            expectedChangeSets += 1;\n            lastCodeCommitIndex = 1;\n        }\n\n        assertEquals( expectedChangeSets, changeSets.size() );\n\n        // Check if the tag has been retrieved again\n        ChangeSet changeSetWithTag = changeSets.get( lastCodeCommitIndex );\n        assertEquals( Collections.singletonList( COMMIT_TAG ), changeSetWithTag.getTags() );\n\n        //Now only retrieve the changelog after timeBeforeSecondChangeLog\n        Date currentTime = new Date();\n        changeLogScmRequest = new ChangeLogScmRequest( getScmRepository(), fileSet );\n        changeLogScmRequest.setStartDate( timeBeforeSecond );\n        changeLogScmRequest.setEndDate( currentTime );\n        changeLogScmRequest.setScmBranch( new ScmBranch( \"\" ) );\n        ChangeLogScmResult thirdResult = provider.changeLog( changeLogScmRequest );\n\n        //Thorough assert of the last result\n        assertTrue( thirdResult.getProviderMessage(), thirdResult.isSuccess() );\n\n        List<ChangeSet> thirdChangeSets = thirdResult.getChangeLog().getChangeSets();\n        assertEquals( lastCommitIsCausedByTagging ? 2 : 1, thirdChangeSets.size() );\n        ChangeSet changeset = thirdChangeSets.get( lastCodeCommitIndex );\n        assertTrue( changeset.getDate().after( timeBeforeSecond ) );\n        assertTrue( changeset.getComment().startsWith( COMMIT_MSG ) );\n    }\n}\n","lineNo":106}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.IOException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Dump changelog contents to console. It is mainly used to test maven-scm-api's changelog command.\n *\n * @author <a href=\"dantran@gmail.com\">Dan Tran<\/a>\n * @author Olivier Lamy\n */\n@Mojo( name = \"changelog\", aggregator = true )\npublic class ChangeLogMojo\n    extends AbstractScmMojo\n{\n    private static final String DEFAULT_DATE_FORMAT = \"yyyy-MM-dd\";\n\n    /**\n     * Start Date.\n     */\n    @Parameter( property = \"startDate\" )\n    private String startDate;\n\n    /**\n     * End Date.\n     */\n    @Parameter( property = \"endDate\" )\n    private String endDate;\n\n    /**\n     * Start Scm Version.\n     */\n    @Parameter( property = \"startScmVersion\" )\n    private String startScmVersion;\n\n    /**\n     * End Scm Version.\n     */\n    @Parameter( property = \"endScmVersion\" )\n    private String endScmVersion;\n\n    /**\n     * Start Scm Version Type.\n     */\n    @Parameter( property = \"startScmVersionType\" )\n    private String startScmVersionType;\n\n    /**\n     * End Scm Version Type.\n     */\n    @Parameter( property = \"endScmVersionType\" )\n    private String endScmVersionType;\n\n    /**\n     * Date Format in changelog output of scm tool.\n     */\n    @Parameter( property = \"dateFormat\" )\n    private String dateFormat;\n\n    /**\n     * Date format to use for the specified startDate and/or endDate.\n     */\n    @Parameter( property = \"userDateFormat\", defaultValue = \"yyyy-MM-dd\" )\n    private String userDateFormat = DEFAULT_DATE_FORMAT;\n\n    /**\n     * The version type (branch/tag) of scmVersion.\n     */\n    @Parameter( property = \"scmVersionType\" )\n    private String scmVersionType;\n\n    /**\n     * The version (revision number/branch name/tag name).\n     */\n    @Parameter( property = \"scmVersion\" )\n    private String scmVersion;\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        SimpleDateFormat localFormat = new SimpleDateFormat( userDateFormat );\n\n        try\n        {\n            ScmRepository repository = getScmRepository();\n\n            ScmProvider provider = getScmManager().getProviderByRepository( repository );\n\n            ScmVersion startRev =\n                getScmVersion( StringUtils.isEmpty( startScmVersionType ) ? VERSION_TYPE_REVISION\n                               : startScmVersionType, startScmVersion );\n            ScmVersion endRev =\n                getScmVersion( StringUtils.isEmpty( endScmVersionType ) ? VERSION_TYPE_REVISION\n                               : endScmVersionType, endScmVersion );\n\n            ChangeLogScmResult result;\n            if ( startRev != null || endRev != null )\n            {\n                result = provider.changeLog( repository, getFileSet(), startRev, endRev, dateFormat );\n            }\n            else\n            {\n                result = provider.changeLog( repository, getFileSet(), this.parseDate( localFormat, this.startDate ),\n                                             this.parseDate( localFormat, this.endDate ), 0,\n                                             (ScmBranch) getScmVersion( scmVersionType, scmVersion ), dateFormat );\n            }\n            checkResult( result );\n\n            ChangeLogSet changeLogSet = result.getChangeLog();\n\n            for ( ChangeSet changeSet : changeLogSet.getChangeSets() )\n            {\n                getLog().info( changeSet.toString() );\n            }\n\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run changelog command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run changelog command : \", e );\n        }\n    }\n\n    /**\n     * Converts the localized date string pattern to date object.\n     *\n     * @return A date\n     */\n    private Date parseDate( SimpleDateFormat format, String date )\n        throws MojoExecutionException\n    {\n        if ( date == null || date.trim().length() == 0 )\n        {\n            return null;\n        }\n\n        try\n        {\n            return format.parse( date.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new MojoExecutionException( \"Please use this date pattern: \" + format.toLocalizedPattern().toString(),\n                                              e );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.IOException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Dump changelog contents to console. It is mainly used to test maven-scm-api's changelog command.\n *\n * @author <a href=\"dantran@gmail.com\">Dan Tran<\/a>\n * @author Olivier Lamy\n */\n@Mojo( name = \"changelog\", aggregator = true )\npublic class ChangeLogMojo\n    extends AbstractScmMojo\n{\n\n    private static final String DEFAULT_DATE_FORMAT = \"yyyy-MM-dd\";\n\n    /**\n     * Start Date.\n     */\n    @Parameter( property = \"startDate\" )\n    private String startDate;\n\n    /**\n     * End Date.\n     */\n    @Parameter( property = \"endDate\" )\n    private String endDate;\n\n    /**\n     * Start Scm Version.\n     */\n    @Parameter( property = \"startScmVersion\" )\n    private String startScmVersion;\n\n    /**\n     * End Scm Version.\n     */\n    @Parameter( property = \"endScmVersion\" )\n    private String endScmVersion;\n\n    /**\n     * Start Scm Version Type.\n     */\n    @Parameter( property = \"startScmVersionType\" )\n    private String startScmVersionType;\n\n    /**\n     * End Scm Version Type.\n     */\n    @Parameter( property = \"endScmVersionType\" )\n    private String endScmVersionType;\n\n    /**\n     * Date Format in changelog output of scm tool.\n     */\n    @Parameter( property = \"dateFormat\" )\n    private String dateFormat;\n\n    /**\n     * Date format to use for the specified startDate and/or endDate.\n     */\n    @Parameter( property = \"userDateFormat\", defaultValue = \"yyyy-MM-dd\" )\n    private String userDateFormat = DEFAULT_DATE_FORMAT;\n\n    /**\n     * The version type (branch/tag) of scmVersion.\n     */\n    @Parameter( property = \"scmVersionType\" )\n    private String scmVersionType;\n\n    /**\n     * The version (revision number/branch name/tag name).\n     */\n    @Parameter( property = \"scmVersion\" )\n    private String scmVersion;\n\n    /**\n     * The branch name (TODO find out what this is for).\n     */\n    @Parameter( property = \"scmBranch\" )\n    private String scmBranch;\n\n    /**\n     * The number of change log items to return.\n     */\n    @Parameter( property = \"limit\" )\n    private Integer limit;\n\n    /**\n     * The number of days to look back for change log items to return.\n     */\n    @Parameter( property = \"numDays\" )\n    private Integer numDays;\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        SimpleDateFormat localFormat = new SimpleDateFormat( userDateFormat );\n\n        try\n        {\n            ScmRepository repository = getScmRepository();\n\n            ScmProvider provider = getScmManager().getProviderByRepository( repository );\n\n            ChangeLogScmRequest request = new ChangeLogScmRequest( repository, getFileSet() );\n\n            request.setDatePattern( dateFormat );\n\n            if ( StringUtils.isNotEmpty( startDate ) )\n            {\n                request.setStartDate( parseDate( localFormat, startDate ) );\n            }\n\n            if ( StringUtils.isNotEmpty( endDate ) )\n            {\n                request.setEndDate( parseDate( localFormat, endDate ) );\n            }\n\n            if ( StringUtils.isNotEmpty( startScmVersion ) )\n            {\n                ScmVersion startRev =\n                    getScmVersion( StringUtils.isEmpty( startScmVersionType ) ? VERSION_TYPE_REVISION\n                        : startScmVersionType, startScmVersion );\n                request.setStartRevision( startRev );\n            }\n\n            if ( StringUtils.isNotEmpty( endScmVersion ) )\n            {\n                ScmVersion endRev =\n                    getScmVersion( StringUtils.isEmpty( endScmVersionType ) ? VERSION_TYPE_REVISION\n                        : endScmVersionType, endScmVersion );\n                request.setEndRevision( endRev );\n            }\n\n            request.setLimit( limit );\n\n            if ( numDays != null )\n            {\n                request.setNumDays( numDays );\n            }\n\n            if ( StringUtils.isNotEmpty( scmVersion ) )\n            {\n                ScmVersion rev =\n                    getScmVersion( StringUtils.isEmpty( scmVersionType ) ? VERSION_TYPE_REVISION\n                        : scmVersionType, scmVersion );\n                request.setRevision( rev );\n            }\n\n            if ( StringUtils.isNotEmpty( scmBranch ) )\n            {\n                request.setScmBranch( new ScmBranch( scmBranch ) );\n            }\n\n            ChangeLogScmResult result = provider.changeLog( request );\n\n            checkResult( result );\n\n            ChangeLogSet changeLogSet = result.getChangeLog();\n\n            for ( ChangeSet changeSet : changeLogSet.getChangeSets() )\n            {\n                getLog().info( changeSet.toString() );\n            }\n\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run changelog command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run changelog command : \", e );\n        }\n    }\n\n    /**\n     * Converts the localized date string pattern to date object.\n     *\n     * @return A date\n     */\n    private Date parseDate( SimpleDateFormat format, String date )\n        throws MojoExecutionException\n    {\n        if ( date == null || date.trim().length() == 0 )\n        {\n            return null;\n        }\n\n        try\n        {\n            return format.parse( date.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new MojoExecutionException( \"Please use this date pattern: \" + format.toLocalizedPattern().toString(),\n                                              e );\n        }\n    }\n}\n","lineNo":148}
{"Smelly Sample":"package org.apache.maven.scm.command.untag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/** {@inheritDoc} */\npublic abstract class AbstractUntagCommand\n    extends AbstractCommand\n{\n    protected abstract ScmResult executeUntagCommand( ScmProviderRepository repository,\n        ScmFileSet fileSet, String tagName )\n        throws ScmException;\n\n    /** {@inheritDoc} */\n    public ScmResult executeCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        String tagName = parameters.getString( CommandParameter.TAG_NAME );\n\n        return executeUntagCommand( repository, fileSet, tagName );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.command.untag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmUntagParameters;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/** {@inheritDoc} */\npublic abstract class AbstractUntagCommand\n    extends AbstractCommand\n{\n    /**\n     * execute untag command\n     *\n     * @param repository         scm repo\n     * @param fileSet            set of files (unused)\n     * @param scmUntagParameters parameters used by untag implementations\n     * @return result of untag command\n     * @throws ScmException  in case of error\n     */\n    protected abstract ScmResult executeUntagCommand( ScmProviderRepository repository,\n                                                      ScmFileSet fileSet, ScmUntagParameters scmUntagParameters )\n        throws ScmException;\n\n    /** {@inheritDoc} */\n    @Override\n    public ScmResult executeCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        String tagName = parameters.getString( CommandParameter.TAG_NAME );\n        String message = parameters.getString( CommandParameter.MESSAGE, \"[maven-scm] remove tag \" + tagName );\n        ScmUntagParameters scmUntagParameters = new ScmUntagParameters( tagName, message );\n\n        return executeUntagCommand( repository, fileSet, scmUntagParameters );\n    }\n\n}\n","lineNo":55}
{"Smelly Sample":"package org.apache.maven.scm.command.untag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/** {@inheritDoc} */\npublic abstract class AbstractUntagCommand\n    extends AbstractCommand\n{\n    protected abstract ScmResult executeUntagCommand( ScmProviderRepository repository,\n        ScmFileSet fileSet, String tagName )\n        throws ScmException;\n\n    /** {@inheritDoc} */\n    public ScmResult executeCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        String tagName = parameters.getString( CommandParameter.TAG_NAME );\n\n        return executeUntagCommand( repository, fileSet, tagName );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.command.untag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmUntagParameters;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/** {@inheritDoc} */\npublic abstract class AbstractUntagCommand\n    extends AbstractCommand\n{\n    /**\n     * execute untag command\n     *\n     * @param repository         scm repo\n     * @param fileSet            set of files (unused)\n     * @param scmUntagParameters parameters used by untag implementations\n     * @return result of untag command\n     * @throws ScmException  in case of error\n     */\n    protected abstract ScmResult executeUntagCommand( ScmProviderRepository repository,\n                                                      ScmFileSet fileSet, ScmUntagParameters scmUntagParameters )\n        throws ScmException;\n\n    /** {@inheritDoc} */\n    @Override\n    public ScmResult executeCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        String tagName = parameters.getString( CommandParameter.TAG_NAME );\n        String message = parameters.getString( CommandParameter.MESSAGE, \"[maven-scm] remove tag \" + tagName );\n        ScmUntagParameters scmUntagParameters = new ScmUntagParameters( tagName, message );\n\n        return executeUntagCommand( repository, fileSet, scmUntagParameters );\n    }\n\n}\n","lineNo":56}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.remoteinfo.RemoteInfoScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.jgit.command.branch.JGitBranchCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.remoteinfo.JGitRemoteInfoCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.CloneCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.storage.file.WindowCacheConfig;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements GitCommand\n{\n    /**\n     * For git, the given repository is a remote one. We have to clone it first if the working directory does not\n     * contain a git repo yet, otherwise we have to git-pull it.\n     * <p/>\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                       ScmVersion version, boolean recursive, boolean shallow )\n        throws ScmException\n    {\n        GitScmProviderRepository repository = (GitScmProviderRepository) repo;\n\n        if ( GitScmProviderRepository.PROTOCOL_FILE.equals( repository.getFetchInfo().getProtocol() )\n            && repository.getFetchInfo().getPath().indexOf( fileSet.getBasedir().getPath() ) >= 0 )\n        {\n            throw new ScmException( \"remote repository must not be the working directory\" );\n        }\n\n        Git git = null;\n        try\n        {\n\n            ProgressMonitor monitor = JGitUtils.getMonitor( getLogger() );\n\n            String branch = version != null ? version.getName() : null;\n\n            if ( StringUtils.isBlank( branch ) )\n            {\n                branch = Constants.MASTER;\n            }\n\n            getLogger().debug( \"try checkout of branch: \" + branch );\n\n            if ( !fileSet.getBasedir().exists() || !( new File( fileSet.getBasedir(), \".git\" ).exists() ) )\n            {\n                if ( fileSet.getBasedir().exists() )\n                {\n                    // git refuses to clone otherwise\n                    fileSet.getBasedir().delete();\n                }\n\n                // FIXME only if windauze\n                WindowCacheConfig cfg = new WindowCacheConfig();\n                cfg.setPackedGitMMAP( false );\n                cfg.install();\n\n                // no git repo seems to exist, let's clone the original repo\n                CredentialsProvider credentials = JGitUtils.getCredentials( (GitScmProviderRepository) repo );\n                getLogger().info( \"cloning [\" + branch + \"] to \" + fileSet.getBasedir() );\n                CloneCommand command = Git.cloneRepository().setURI( repository.getFetchUrl() );\n                command.setCredentialsProvider( credentials ).setBranch( branch ).setDirectory( fileSet.getBasedir() );\n                command.setProgressMonitor( monitor );\n                git = command.call();\n            }\n\n            JGitRemoteInfoCommand remoteInfoCommand = new JGitRemoteInfoCommand();\n            remoteInfoCommand.setLogger( getLogger() );\n            RemoteInfoScmResult result = remoteInfoCommand.executeRemoteInfoCommand( repository, fileSet, null );\n\n            if ( git == null )\n            {\n                // deliberately not using JGitUtils.openRepo(), the caller told us exactly where to checkout\n                git = Git.open( fileSet.getBasedir() );\n            }\n            \n            if ( fileSet.getBasedir().exists() && new File( fileSet.getBasedir(), \".git\" ).exists()\n                && result.getBranches().size() > 0 )\n            {\n                // git repo exists, so we must git-pull the changes\n                CredentialsProvider credentials = JGitUtils.prepareSession( getLogger(), git, repository );\n\n                if ( version != null && StringUtils.isNotEmpty( version.getName() ) && ( version instanceof ScmTag ) )\n                {\n                    // A tag will not be pulled but we only fetch all the commits from the upstream repo\n                    // This is done because checking out a tag might not happen on the current branch\n                    // but create a 'detached HEAD'.\n                    // In fact, a tag in git may be in multiple branches. This occurs if\n                    // you create a branch after the tag has been created\n                    getLogger().debug( \"fetch...\" );\n                    git.fetch().setCredentialsProvider( credentials ).setProgressMonitor( monitor ).call();\n                }\n                else\n                {\n                    getLogger().debug( \"pull...\" );\n                    git.pull().setCredentialsProvider( credentials ).setProgressMonitor( monitor ).call();\n                }\n            }\n\n            Set<String> localBranchNames = JGitBranchCommand.getShortLocalBranchNames( git );\n            if ( version instanceof ScmTag )\n            {\n                getLogger().info( \"checkout tag [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else if ( localBranchNames.contains( branch ) )\n            {\n                getLogger().info( \"checkout [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else\n            {\n                getLogger().info( \"checkout remote branch [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).setCreateBranch( true ).setStartPoint( Constants.DEFAULT_REMOTE_NAME\n                                                                                            + \"/\" + branch ).call();\n            }\n\n            RevWalk revWalk = new RevWalk( git.getRepository() );\n            RevCommit commit = revWalk.parseCommit( git.getRepository().resolve( Constants.HEAD ) );\n            revWalk.close();\n\n            final TreeWalk walk = new TreeWalk( git.getRepository() );\n            walk.reset(); // drop the first empty tree, which we do not need here\n            walk.setRecursive( true );\n            walk.addTree( commit.getTree() );\n\n            List<ScmFile> listedFiles = new ArrayList<ScmFile>();\n            while ( walk.next() )\n            {\n                listedFiles.add( new ScmFile( walk.getPathString(), ScmFileStatus.CHECKED_OUT ) );\n            }\n            walk.close();\n\n            getLogger().debug( \"current branch: \" + git.getRepository().getBranch() );\n\n            return new CheckOutScmResult( \"checkout via JGit\", listedFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit checkout failure!\", e );\n        }\n        finally\n        {\n            JGitUtils.closeRepo( git );\n        }\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.remoteinfo.RemoteInfoScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitTransportConfigCallback;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.jgit.command.branch.JGitBranchCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.remoteinfo.JGitRemoteInfoCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.*;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.storage.file.WindowCacheConfig;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements GitCommand\n{\n    /**\n     * For git, the given repository is a remote one. We have to clone it first if the working directory does not\n     * contain a git repo yet, otherwise we have to git-pull it.\n     * <p/>\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                       ScmVersion version, boolean recursive, boolean shallow )\n        throws ScmException\n    {\n        GitScmProviderRepository repository = (GitScmProviderRepository) repo;\n\n        if ( GitScmProviderRepository.PROTOCOL_FILE.equals( repository.getFetchInfo().getProtocol() )\n            && repository.getFetchInfo().getPath().indexOf( fileSet.getBasedir().getPath() ) >= 0 )\n        {\n            throw new ScmException( \"remote repository must not be the working directory\" );\n        }\n\n        Git git = null;\n        try\n        {\n\n            ProgressMonitor monitor = JGitUtils.getMonitor( getLogger() );\n\n            String branch = version != null ? version.getName() : null;\n\n            if ( StringUtils.isBlank( branch ) )\n            {\n                branch = Constants.MASTER;\n            }\n\n            getLogger().debug( \"try checkout of branch: \" + branch );\n\n            if ( !fileSet.getBasedir().exists() || !( new File( fileSet.getBasedir(), \".git\" ).exists() ) )\n            {\n                if ( fileSet.getBasedir().exists() )\n                {\n                    // git refuses to clone otherwise\n                    fileSet.getBasedir().delete();\n                }\n\n                // FIXME only if windauze\n                WindowCacheConfig cfg = new WindowCacheConfig();\n                cfg.setPackedGitMMAP( false );\n                cfg.install();\n\n                // no git repo seems to exist, let's clone the original repo\n                CredentialsProvider credentials = JGitUtils.getCredentials( (GitScmProviderRepository) repo );\n                getLogger().info( \"cloning [\" + branch + \"] to \" + fileSet.getBasedir() );\n                CloneCommand command = Git.cloneRepository().setURI( repository.getFetchUrl() );\n\n                command.setCredentialsProvider( credentials ).setBranch( branch ).setDirectory( fileSet.getBasedir() );\n\n                TransportConfigCallback transportConfigCallback = new JGitTransportConfigCallback(\n                        (GitScmProviderRepository) repo, getLogger());\n                command.setTransportConfigCallback(transportConfigCallback);\n\n                command.setProgressMonitor( monitor );\n                git = command.call();\n            }\n\n            JGitRemoteInfoCommand remoteInfoCommand = new JGitRemoteInfoCommand();\n            remoteInfoCommand.setLogger( getLogger() );\n            RemoteInfoScmResult result = remoteInfoCommand.executeRemoteInfoCommand( repository, fileSet, null );\n\n            if ( git == null )\n            {\n                // deliberately not using JGitUtils.openRepo(), the caller told us exactly where to checkout\n                git = Git.open( fileSet.getBasedir() );\n            }\n            \n            if ( fileSet.getBasedir().exists() && new File( fileSet.getBasedir(), \".git\" ).exists()\n                && result.getBranches().size() > 0 )\n            {\n                // git repo exists, so we must git-pull the changes\n                CredentialsProvider credentials = JGitUtils.prepareSession( getLogger(), git, repository );\n                TransportConfigCallback transportConfigCallback = new JGitTransportConfigCallback(\n                        (GitScmProviderRepository) repo, getLogger());\n\n                if ( version != null && StringUtils.isNotEmpty( version.getName() ) && ( version instanceof ScmTag ) )\n                {\n                    // A tag will not be pulled but we only fetch all the commits from the upstream repo\n                    // This is done because checking out a tag might not happen on the current branch\n                    // but create a 'detached HEAD'.\n                    // In fact, a tag in git may be in multiple branches. This occurs if\n                    // you create a branch after the tag has been created\n                    getLogger().debug( \"fetch...\" );\n                    FetchCommand command = git.fetch().setCredentialsProvider(credentials).setProgressMonitor(monitor);\n                    command.setTransportConfigCallback(transportConfigCallback);\n                    command.call();\n\n                }\n                else\n                {\n                    getLogger().debug( \"pull...\" );\n                    PullCommand command = git.pull().setCredentialsProvider(credentials).setProgressMonitor(monitor);\n                    command.setTransportConfigCallback(transportConfigCallback);\n                    command.call();\n                }\n            }\n\n            Set<String> localBranchNames = JGitBranchCommand.getShortLocalBranchNames( git );\n            if ( version instanceof ScmTag )\n            {\n                getLogger().info( \"checkout tag [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else if ( localBranchNames.contains( branch ) )\n            {\n                getLogger().info( \"checkout [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else\n            {\n                getLogger().info( \"checkout remote branch [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).setCreateBranch( true ).setStartPoint( Constants.DEFAULT_REMOTE_NAME\n                                                                                            + \"/\" + branch ).call();\n            }\n\n            RevWalk revWalk = new RevWalk( git.getRepository() );\n            RevCommit commit = revWalk.parseCommit( git.getRepository().resolve( Constants.HEAD ) );\n            revWalk.close();\n\n            final TreeWalk walk = new TreeWalk( git.getRepository() );\n            walk.reset(); // drop the first empty tree, which we do not need here\n            walk.setRecursive( true );\n            walk.addTree( commit.getTree() );\n\n            List<ScmFile> listedFiles = new ArrayList<ScmFile>();\n            while ( walk.next() )\n            {\n                listedFiles.add( new ScmFile( walk.getPathString(), ScmFileStatus.CHECKED_OUT ) );\n            }\n            walk.close();\n\n            getLogger().debug( \"current branch: \" + git.getRepository().getBranch() );\n\n            return new CheckOutScmResult( \"checkout via JGit\", listedFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit checkout failure!\", e );\n        }\n        finally\n        {\n            JGitUtils.closeRepo( git );\n        }\n    }\n\n}\n","lineNo":149}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.remoteinfo.RemoteInfoScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.jgit.command.branch.JGitBranchCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.remoteinfo.JGitRemoteInfoCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.CloneCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.storage.file.WindowCacheConfig;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements GitCommand\n{\n    /**\n     * For git, the given repository is a remote one. We have to clone it first if the working directory does not\n     * contain a git repo yet, otherwise we have to git-pull it.\n     * <p/>\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                       ScmVersion version, boolean recursive, boolean shallow )\n        throws ScmException\n    {\n        GitScmProviderRepository repository = (GitScmProviderRepository) repo;\n\n        if ( GitScmProviderRepository.PROTOCOL_FILE.equals( repository.getFetchInfo().getProtocol() )\n            && repository.getFetchInfo().getPath().indexOf( fileSet.getBasedir().getPath() ) >= 0 )\n        {\n            throw new ScmException( \"remote repository must not be the working directory\" );\n        }\n\n        Git git = null;\n        try\n        {\n\n            ProgressMonitor monitor = JGitUtils.getMonitor( getLogger() );\n\n            String branch = version != null ? version.getName() : null;\n\n            if ( StringUtils.isBlank( branch ) )\n            {\n                branch = Constants.MASTER;\n            }\n\n            getLogger().debug( \"try checkout of branch: \" + branch );\n\n            if ( !fileSet.getBasedir().exists() || !( new File( fileSet.getBasedir(), \".git\" ).exists() ) )\n            {\n                if ( fileSet.getBasedir().exists() )\n                {\n                    // git refuses to clone otherwise\n                    fileSet.getBasedir().delete();\n                }\n\n                // FIXME only if windauze\n                WindowCacheConfig cfg = new WindowCacheConfig();\n                cfg.setPackedGitMMAP( false );\n                cfg.install();\n\n                // no git repo seems to exist, let's clone the original repo\n                CredentialsProvider credentials = JGitUtils.getCredentials( (GitScmProviderRepository) repo );\n                getLogger().info( \"cloning [\" + branch + \"] to \" + fileSet.getBasedir() );\n                CloneCommand command = Git.cloneRepository().setURI( repository.getFetchUrl() );\n                command.setCredentialsProvider( credentials ).setBranch( branch ).setDirectory( fileSet.getBasedir() );\n                command.setProgressMonitor( monitor );\n                git = command.call();\n            }\n\n            JGitRemoteInfoCommand remoteInfoCommand = new JGitRemoteInfoCommand();\n            remoteInfoCommand.setLogger( getLogger() );\n            RemoteInfoScmResult result = remoteInfoCommand.executeRemoteInfoCommand( repository, fileSet, null );\n\n            if ( git == null )\n            {\n                // deliberately not using JGitUtils.openRepo(), the caller told us exactly where to checkout\n                git = Git.open( fileSet.getBasedir() );\n            }\n            \n            if ( fileSet.getBasedir().exists() && new File( fileSet.getBasedir(), \".git\" ).exists()\n                && result.getBranches().size() > 0 )\n            {\n                // git repo exists, so we must git-pull the changes\n                CredentialsProvider credentials = JGitUtils.prepareSession( getLogger(), git, repository );\n\n                if ( version != null && StringUtils.isNotEmpty( version.getName() ) && ( version instanceof ScmTag ) )\n                {\n                    // A tag will not be pulled but we only fetch all the commits from the upstream repo\n                    // This is done because checking out a tag might not happen on the current branch\n                    // but create a 'detached HEAD'.\n                    // In fact, a tag in git may be in multiple branches. This occurs if\n                    // you create a branch after the tag has been created\n                    getLogger().debug( \"fetch...\" );\n                    git.fetch().setCredentialsProvider( credentials ).setProgressMonitor( monitor ).call();\n                }\n                else\n                {\n                    getLogger().debug( \"pull...\" );\n                    git.pull().setCredentialsProvider( credentials ).setProgressMonitor( monitor ).call();\n                }\n            }\n\n            Set<String> localBranchNames = JGitBranchCommand.getShortLocalBranchNames( git );\n            if ( version instanceof ScmTag )\n            {\n                getLogger().info( \"checkout tag [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else if ( localBranchNames.contains( branch ) )\n            {\n                getLogger().info( \"checkout [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else\n            {\n                getLogger().info( \"checkout remote branch [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).setCreateBranch( true ).setStartPoint( Constants.DEFAULT_REMOTE_NAME\n                                                                                            + \"/\" + branch ).call();\n            }\n\n            RevWalk revWalk = new RevWalk( git.getRepository() );\n            RevCommit commit = revWalk.parseCommit( git.getRepository().resolve( Constants.HEAD ) );\n            revWalk.close();\n\n            final TreeWalk walk = new TreeWalk( git.getRepository() );\n            walk.reset(); // drop the first empty tree, which we do not need here\n            walk.setRecursive( true );\n            walk.addTree( commit.getTree() );\n\n            List<ScmFile> listedFiles = new ArrayList<ScmFile>();\n            while ( walk.next() )\n            {\n                listedFiles.add( new ScmFile( walk.getPathString(), ScmFileStatus.CHECKED_OUT ) );\n            }\n            walk.close();\n\n            getLogger().debug( \"current branch: \" + git.getRepository().getBranch() );\n\n            return new CheckOutScmResult( \"checkout via JGit\", listedFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit checkout failure!\", e );\n        }\n        finally\n        {\n            JGitUtils.closeRepo( git );\n        }\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.remoteinfo.RemoteInfoScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitTransportConfigCallback;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.jgit.command.branch.JGitBranchCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.remoteinfo.JGitRemoteInfoCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.*;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.storage.file.WindowCacheConfig;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements GitCommand\n{\n    /**\n     * For git, the given repository is a remote one. We have to clone it first if the working directory does not\n     * contain a git repo yet, otherwise we have to git-pull it.\n     * <p/>\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                       ScmVersion version, boolean recursive, boolean shallow )\n        throws ScmException\n    {\n        GitScmProviderRepository repository = (GitScmProviderRepository) repo;\n\n        if ( GitScmProviderRepository.PROTOCOL_FILE.equals( repository.getFetchInfo().getProtocol() )\n            && repository.getFetchInfo().getPath().indexOf( fileSet.getBasedir().getPath() ) >= 0 )\n        {\n            throw new ScmException( \"remote repository must not be the working directory\" );\n        }\n\n        Git git = null;\n        try\n        {\n\n            ProgressMonitor monitor = JGitUtils.getMonitor( getLogger() );\n\n            String branch = version != null ? version.getName() : null;\n\n            if ( StringUtils.isBlank( branch ) )\n            {\n                branch = Constants.MASTER;\n            }\n\n            getLogger().debug( \"try checkout of branch: \" + branch );\n\n            if ( !fileSet.getBasedir().exists() || !( new File( fileSet.getBasedir(), \".git\" ).exists() ) )\n            {\n                if ( fileSet.getBasedir().exists() )\n                {\n                    // git refuses to clone otherwise\n                    fileSet.getBasedir().delete();\n                }\n\n                // FIXME only if windauze\n                WindowCacheConfig cfg = new WindowCacheConfig();\n                cfg.setPackedGitMMAP( false );\n                cfg.install();\n\n                // no git repo seems to exist, let's clone the original repo\n                CredentialsProvider credentials = JGitUtils.getCredentials( (GitScmProviderRepository) repo );\n                getLogger().info( \"cloning [\" + branch + \"] to \" + fileSet.getBasedir() );\n                CloneCommand command = Git.cloneRepository().setURI( repository.getFetchUrl() );\n\n                command.setCredentialsProvider( credentials ).setBranch( branch ).setDirectory( fileSet.getBasedir() );\n\n                TransportConfigCallback transportConfigCallback = new JGitTransportConfigCallback(\n                        (GitScmProviderRepository) repo, getLogger());\n                command.setTransportConfigCallback(transportConfigCallback);\n\n                command.setProgressMonitor( monitor );\n                git = command.call();\n            }\n\n            JGitRemoteInfoCommand remoteInfoCommand = new JGitRemoteInfoCommand();\n            remoteInfoCommand.setLogger( getLogger() );\n            RemoteInfoScmResult result = remoteInfoCommand.executeRemoteInfoCommand( repository, fileSet, null );\n\n            if ( git == null )\n            {\n                // deliberately not using JGitUtils.openRepo(), the caller told us exactly where to checkout\n                git = Git.open( fileSet.getBasedir() );\n            }\n            \n            if ( fileSet.getBasedir().exists() && new File( fileSet.getBasedir(), \".git\" ).exists()\n                && result.getBranches().size() > 0 )\n            {\n                // git repo exists, so we must git-pull the changes\n                CredentialsProvider credentials = JGitUtils.prepareSession( getLogger(), git, repository );\n                TransportConfigCallback transportConfigCallback = new JGitTransportConfigCallback(\n                        (GitScmProviderRepository) repo, getLogger());\n\n                if ( version != null && StringUtils.isNotEmpty( version.getName() ) && ( version instanceof ScmTag ) )\n                {\n                    // A tag will not be pulled but we only fetch all the commits from the upstream repo\n                    // This is done because checking out a tag might not happen on the current branch\n                    // but create a 'detached HEAD'.\n                    // In fact, a tag in git may be in multiple branches. This occurs if\n                    // you create a branch after the tag has been created\n                    getLogger().debug( \"fetch...\" );\n                    FetchCommand command = git.fetch().setCredentialsProvider(credentials).setProgressMonitor(monitor);\n                    command.setTransportConfigCallback(transportConfigCallback);\n                    command.call();\n\n                }\n                else\n                {\n                    getLogger().debug( \"pull...\" );\n                    PullCommand command = git.pull().setCredentialsProvider(credentials).setProgressMonitor(monitor);\n                    command.setTransportConfigCallback(transportConfigCallback);\n                    command.call();\n                }\n            }\n\n            Set<String> localBranchNames = JGitBranchCommand.getShortLocalBranchNames( git );\n            if ( version instanceof ScmTag )\n            {\n                getLogger().info( \"checkout tag [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else if ( localBranchNames.contains( branch ) )\n            {\n                getLogger().info( \"checkout [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).call();\n            }\n            else\n            {\n                getLogger().info( \"checkout remote branch [\" + branch + \"] at \" + fileSet.getBasedir() );\n                git.checkout().setName( branch ).setCreateBranch( true ).setStartPoint( Constants.DEFAULT_REMOTE_NAME\n                                                                                            + \"/\" + branch ).call();\n            }\n\n            RevWalk revWalk = new RevWalk( git.getRepository() );\n            RevCommit commit = revWalk.parseCommit( git.getRepository().resolve( Constants.HEAD ) );\n            revWalk.close();\n\n            final TreeWalk walk = new TreeWalk( git.getRepository() );\n            walk.reset(); // drop the first empty tree, which we do not need here\n            walk.setRecursive( true );\n            walk.addTree( commit.getTree() );\n\n            List<ScmFile> listedFiles = new ArrayList<ScmFile>();\n            while ( walk.next() )\n            {\n                listedFiles.add( new ScmFile( walk.getPathString(), ScmFileStatus.CHECKED_OUT ) );\n            }\n            walk.close();\n\n            getLogger().debug( \"current branch: \" + git.getRepository().getBranch() );\n\n            return new CheckOutScmResult( \"checkout via JGit\", listedFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit checkout failure!\", e );\n        }\n        finally\n        {\n            JGitUtils.closeRepo( git );\n        }\n    }\n\n}\n","lineNo":157}
{"Smelly Sample":"package org.apache.maven.scm.provider.integrity.command.blame;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.blame.AbstractBlameCommand;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.integrity.repository.IntegrityScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * MKS Integrity implementation for Maven's AbstractBlameCommand\n * <br>This class will execute a 'si annotate' command for the specified filename\n *\n * @author <a href=\"mailto:cletus@mks.com\">Cletus D'Souza<\/a>\n * @since 1.6\n */\npublic class IntegrityBlameCommand\n    extends AbstractBlameCommand\n{\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public BlameScmResult executeBlameCommand( ScmProviderRepository repository, ScmFileSet workingDirectory,\n                                               String filename )\n        throws ScmException\n    {\n        getLogger().info( \"Attempting to display blame results for file: \" + filename );\n        if ( null == filename || filename.length() == 0 )\n        {\n            throw new ScmException( \"A single filename is required to execute the blame command!\" );\n        }\n        BlameScmResult result;\n        IntegrityScmProviderRepository iRepo = (IntegrityScmProviderRepository) repository;\n        // Since the si annotate command is not completely API ready, we will use the CLI for this command\n        // Ensure shell 'si' client is connected.\n        doShellConnect( iRepo, workingDirectory );\n        result = doShellAnnotate( iRepo, workingDirectory, filename );\n\n        return result;\n    }\n\n    /**\n     * Execute 'si connect' command in current shell.\n     *\n     * @param iRepo            the Integrity repository instance.\n     * @param workingDirectory the SCM working directory.\n     * @throws ScmException if connect command failed.\n     */\n    private void doShellConnect( IntegrityScmProviderRepository iRepo, ScmFileSet workingDirectory )\n        throws ScmException\n    {\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( workingDirectory.getBasedir() );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"connect\" );\n        shell.createArg().setValue( \"--hostname=\" + iRepo.getHost() );\n        shell.createArg().setValue( \"--port=\" + iRepo.getPort() );\n        shell.createArg().setValue( \"--user=\" + iRepo.getUser() );\n        shell.createArg().setValue( \"--batch\" );\n        shell.createArg().setValue( \"--password=\" + iRepo.getPassword() );\n        CommandLineUtils.StringStreamConsumer shellConsumer = new CommandLineUtils.StringStreamConsumer();\n\n        try\n        {\n            getLogger().debug( \"Executing: \" + CommandLineUtils.toString( shell.getCommandline() ) );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer, shellConsumer );\n            if ( exitCode != 0 )\n            {\n                throw new ScmException( \"Can't login to integrity. Message : \" + shellConsumer.toString() );\n            }\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Connect Exception: \" + cle.getMessage() );\n            throw new ScmException( \"Can't login to integrity. Message : \" + cle.getMessage() );\n        }\n\n    }\n\n    /**\n     * Execute 'si annotate' command in current shell and process output as {@link BlameScmResult} instance.\n     *\n     * @param iRepo            the Integrity repository instance.\n     * @param workingDirectory the SCM working directory.\n     * @param filename         the file name.\n     * @return the {@link BlameScmResult} instance.\n     */\n    private BlameScmResult doShellAnnotate( IntegrityScmProviderRepository iRepo, ScmFileSet workingDirectory,\n                                            String filename )\n    {\n        BlameScmResult result;\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( workingDirectory.getBasedir() );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"annotate\" );\n        shell.createArg().setValue( \"--hostname=\" + iRepo.getHost() );\n        shell.createArg().setValue( \"--port=\" + iRepo.getPort() );\n        shell.createArg().setValue( \"--user=\" + iRepo.getUser() );\n        shell.createArg().setValue( \"--fields=date,revision,author\" );\n        shell.createArg().setValue( '\"' + filename + '\"' );\n        IntegrityBlameConsumer shellConsumer = new IntegrityBlameConsumer( getLogger() );\n\n        try\n        {\n            getLogger().debug( \"Executing: \" + CommandLineUtils.toString( shell.getCommandline() ) );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer,\n                                                                new CommandLineUtils.StringStreamConsumer() );\n            boolean success = ( exitCode == 0 ? true : false );\n            ScmResult scmResult =\n                new ScmResult( shell.getCommandline().toString(), \"\", \"Exit Code: \" + exitCode, success );\n            return new BlameScmResult( shellConsumer.getBlameList(), scmResult );\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Exception: \" + cle.getMessage() );\n            result = new BlameScmResult( shell.getCommandline().toString(), cle.getMessage(), \"\", false );\n        }\n\n        return result;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.integrity.command.blame;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.blame.AbstractBlameCommand;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.integrity.repository.IntegrityScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * MKS Integrity implementation for Maven's AbstractBlameCommand\n * <br>This class will execute a 'si annotate' command for the specified filename\n *\n * @author <a href=\"mailto:cletus@mks.com\">Cletus D'Souza<\/a>\n * @since 1.6\n */\npublic class IntegrityBlameCommand\n    extends AbstractBlameCommand\n{\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public BlameScmResult executeBlameCommand( ScmProviderRepository repository, ScmFileSet workingDirectory,\n                                               String filename )\n        throws ScmException\n    {\n        getLogger().info( \"Attempting to display blame results for file: \" + filename );\n        if ( null == filename || filename.length() == 0 )\n        {\n            throw new ScmException( \"A single filename is required to execute the blame command!\" );\n        }\n        BlameScmResult result;\n        IntegrityScmProviderRepository iRepo = (IntegrityScmProviderRepository) repository;\n        // Since the si annotate command is not completely API ready, we will use the CLI for this command\n        // Ensure shell 'si' client is connected.\n        doShellConnect( iRepo, workingDirectory );\n        result = doShellAnnotate( iRepo, workingDirectory, filename );\n\n        return result;\n    }\n\n    /**\n     * Execute 'si connect' command in current shell.\n     *\n     * @param iRepo            the Integrity repository instance.\n     * @param workingDirectory the SCM working directory.\n     * @throws ScmException if connect command failed.\n     */\n    private void doShellConnect( IntegrityScmProviderRepository iRepo, ScmFileSet workingDirectory )\n        throws ScmException\n    {\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( workingDirectory.getBasedir() );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"connect\" );\n        shell.createArg().setValue( \"--hostname=\" + iRepo.getHost() );\n        shell.createArg().setValue( \"--port=\" + iRepo.getPort() );\n        shell.createArg().setValue( \"--user=\" + iRepo.getUser() );\n        shell.createArg().setValue( \"--batch\" );\n        shell.createArg().setValue( \"--password=\" + iRepo.getPassword() );\n        CommandLineUtils.StringStreamConsumer shellConsumer = new CommandLineUtils.StringStreamConsumer();\n\n        try\n        {\n            getLogger().debug( \"Executing: \" + CommandLineUtils.toString( shell.getCommandline() ) );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer, shellConsumer );\n            if ( exitCode != 0 )\n            {\n                throw new ScmException( \"Can't login to integrity. Message : \" + shellConsumer.toString() );\n            }\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Connect Exception: \" + cle.getMessage() );\n            throw new ScmException( \"Can't login to integrity. Message : \" + cle.getMessage() );\n        }\n\n    }\n\n    /**\n     * Execute 'si annotate' command in current shell and process output as {@link BlameScmResult} instance.\n     *\n     * @param iRepo            the Integrity repository instance.\n     * @param workingDirectory the SCM working directory.\n     * @param filename         the file name.\n     * @return the {@link BlameScmResult} instance.\n     */\n    private BlameScmResult doShellAnnotate( IntegrityScmProviderRepository iRepo, ScmFileSet workingDirectory,\n                                            String filename )\n    {\n        BlameScmResult result;\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( workingDirectory.getBasedir() );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"annotate\" );\n        shell.createArg().setValue( \"--hostname=\" + iRepo.getHost() );\n        shell.createArg().setValue( \"--port=\" + iRepo.getPort() );\n        shell.createArg().setValue( \"--user=\" + iRepo.getUser() );\n        shell.createArg().setValue( \"--fields=date,revision,author\" );\n        shell.createArg().setValue( '\"' + filename + '\"' );\n        IntegrityBlameConsumer shellConsumer = new IntegrityBlameConsumer( getLogger() );\n        String commandLine = CommandLineUtils.toString( shell.getCommandline() );\n\n        try\n        {\n            getLogger().debug( \"Executing: \" +  commandLine );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer,\n                                                                new CommandLineUtils.StringStreamConsumer() );\n            boolean success = ( exitCode == 0 ? true : false );\n            ScmResult scmResult =\n                new ScmResult( commandLine, \"\", \"Exit Code: \" + exitCode, success );\n            return new BlameScmResult( shellConsumer.getBlameList(), scmResult );\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Exception: \" + cle.getMessage() );\n            result = new BlameScmResult( commandLine, cle.getMessage(), \"\", false );\n        }\n\n        return result;\n    }\n\n}\n","lineNo":126}
{"Smelly Sample":"package org.apache.maven.scm.provider.integrity.command.diff;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.diff.AbstractDiffCommand;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.integrity.APISession;\nimport org.apache.maven.scm.provider.integrity.repository.IntegrityScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n/**\n * MKS Integrity implementation for Maven's AbstractDiffCommand\n * <br>Since MKS Integrity doesn't have a notion of arbitrarily differencing\n * by a revision across the sandbox, this command will difference the\n * current Sandbox working file against the server version.\n *\n * @author <a href=\"mailto:cletus@mks.com\">Cletus D'Souza<\/a>\n * @since 1.6\n */\npublic class IntegrityDiffCommand\n    extends AbstractDiffCommand\n{\n    /**\n     * Since we can't arbitrarily apply the same start and end revisions to all files in the sandbox,\n     * this command will be adapted to show differences between the local version and the repository\n     */\n    @Override\n    public DiffScmResult executeDiffCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                             ScmVersion startRevision, ScmVersion endRevision )\n        throws ScmException\n    {\n        DiffScmResult result;\n        IntegrityScmProviderRepository iRepo = (IntegrityScmProviderRepository) repository;\n        APISession api = iRepo.getAPISession();\n        getLogger().info( \"Showing differences bettween local files in \" + fileSet.getBasedir().getAbsolutePath()\n                              + \" and server project \" + iRepo.getConfigruationPath() );\n\n        // Since the si diff command is not completely API ready, we will use the CLI for this command\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( fileSet.getBasedir() );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"diff\" );\n        shell.createArg().setValue( \"--hostname=\" + api.getHostName() );\n        shell.createArg().setValue( \"--port=\" + api.getPort() );\n        shell.createArg().setValue( \"--user=\" + api.getUserName() );\n        shell.createArg().setValue( \"-R\" );\n        shell.createArg().setValue( \"--filter=changed:all\" );\n        shell.createArg().setValue( \"--filter=format:text\" );\n        IntegrityDiffConsumer shellConsumer = new IntegrityDiffConsumer( getLogger() );\n\n        try\n        {\n            getLogger().debug( \"Executing: \" + shell.getCommandline() );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer,\n                                                                new CommandLineUtils.StringStreamConsumer() );\n            boolean success = ( exitCode == 128 ? false : true );\n            ScmResult scmResult =\n                new ScmResult( shell.getCommandline().toString(), \"\", \"Exit Code: \" + exitCode, success );\n            // Since we can't really parse the differences output, we'll just have to go by the command output\n            // Returning a DiffScmResult(List changedFiles, Map differences, String patch, ScmResult result) to avoid\n            // a NPE in org.codehaus.plexus.util.FileUtils.fileWrite(FileUtils.java:426)\n            return new DiffScmResult( new ArrayList<ScmFile>(), new HashMap<String, CharSequence>(), \"\", scmResult );\n\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Exception: \" + cle.getMessage() );\n            result = new DiffScmResult( shell.getCommandline().toString(), cle.getMessage(), \"\", false );\n        }\n\n        return result;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.integrity.command.diff;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.diff.AbstractDiffCommand;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.integrity.APISession;\nimport org.apache.maven.scm.provider.integrity.repository.IntegrityScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n/**\n * MKS Integrity implementation for Maven's AbstractDiffCommand\n * <br>Since MKS Integrity doesn't have a notion of arbitrarily differencing\n * by a revision across the sandbox, this command will difference the\n * current Sandbox working file against the server version.\n *\n * @author <a href=\"mailto:cletus@mks.com\">Cletus D'Souza<\/a>\n * @since 1.6\n */\npublic class IntegrityDiffCommand\n    extends AbstractDiffCommand\n{\n    /**\n     * Since we can't arbitrarily apply the same start and end revisions to all files in the sandbox,\n     * this command will be adapted to show differences between the local version and the repository\n     */\n    @Override\n    public DiffScmResult executeDiffCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                             ScmVersion startRevision, ScmVersion endRevision )\n        throws ScmException\n    {\n        DiffScmResult result;\n        IntegrityScmProviderRepository iRepo = (IntegrityScmProviderRepository) repository;\n        APISession api = iRepo.getAPISession();\n        getLogger().info( \"Showing differences bettween local files in \" + fileSet.getBasedir().getAbsolutePath()\n                              + \" and server project \" + iRepo.getConfigruationPath() );\n\n        // Since the si diff command is not completely API ready, we will use the CLI for this command\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( fileSet.getBasedir() );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"diff\" );\n        shell.createArg().setValue( \"--hostname=\" + api.getHostName() );\n        shell.createArg().setValue( \"--port=\" + api.getPort() );\n        shell.createArg().setValue( \"--user=\" + api.getUserName() );\n        shell.createArg().setValue( \"-R\" );\n        shell.createArg().setValue( \"--filter=changed:all\" );\n        shell.createArg().setValue( \"--filter=format:text\" );\n        IntegrityDiffConsumer shellConsumer = new IntegrityDiffConsumer( getLogger() );\n        String commandLine = CommandLineUtils.toString( shell.getCommandline() );\n\n        try\n        {\n            getLogger().debug( \"Executing: \" + commandLine );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer,\n                                                                new CommandLineUtils.StringStreamConsumer() );\n            boolean success = ( exitCode == 128 ? false : true );\n            ScmResult scmResult = new ScmResult( commandLine, \"\", \"Exit Code: \" + exitCode, success );\n            // Since we can't really parse the differences output, we'll just have to go by the command output\n            // Returning a DiffScmResult(List changedFiles, Map differences, String patch, ScmResult result) to avoid\n            // a NPE in org.codehaus.plexus.util.FileUtils.fileWrite(FileUtils.java:426)\n            return new DiffScmResult( new ArrayList<ScmFile>(), new HashMap<String, CharSequence>(), \"\", scmResult );\n\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Exception: \" + cle.getMessage() );\n            result = new DiffScmResult( commandLine, cle.getMessage(), \"\", false );\n        }\n\n        return result;\n    }\n\n}\n","lineNo":78}
{"Smelly Sample":"package org.apache.maven.scm.provider.integrity.command.fileinfo;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.fileinfo.AbstractFileInfoCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.integrity.APISession;\nimport org.apache.maven.scm.provider.integrity.repository.IntegrityScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * MKS Integrity implementation for Maven's AbstractFileInfoCommand\n * <br>This command will run a 'si memberinfo' command.  Even though this\n * command is supported via the API, we're using the CLI to execute as\n * its not clear what exactly this command is supposed to be returning\n * to the Maven SCM framework.  Hence the CLI output is returned to the\n * console verbatim\n *\n * @author <a href=\"mailto:cletus@mks.com\">Cletus D'Souza<\/a>\n * @since 1.6\n */\npublic class IntegrityFileInfoCommand\n    extends AbstractFileInfoCommand\n{\n    /**\n     * Even though this command is supported via the MKS JAVA API, since at this time we really don't\n     * know what the SCM plugin is looking to get in return for this command, we're simply going to\n     * run this command via the CLI and return the output verbatim\n     */\n    @Override\n    public ScmResult executeFileInfoCommand( ScmProviderRepository repository, File workingDirectory, String filename )\n        throws ScmException\n    {\n        getLogger().info( \"Attempting to display scm file information for file: \" + filename );\n        if ( null == filename || filename.length() == 0 )\n        {\n            throw new ScmException( \"A single filename is required to execute the fileinfo command!\" );\n        }\n        ScmResult result;\n        IntegrityScmProviderRepository iRepo = (IntegrityScmProviderRepository) repository;\n        APISession api = iRepo.getAPISession();\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( workingDirectory );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"memberinfo\" );\n        shell.createArg().setValue( \"--hostname=\" + api.getHostName() );\n        shell.createArg().setValue( \"--port=\" + api.getPort() );\n        shell.createArg().setValue( \"--user=\" + api.getUserName() );\n        shell.createArg().setValue( '\"' + filename + '\"' );\n        IntegrityFileInfoConsumer shellConsumer = new IntegrityFileInfoConsumer( getLogger() );\n\n        try\n        {\n            getLogger().debug( \"Executing: \" + shell.getCommandline() );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer,\n                                                                new CommandLineUtils.StringStreamConsumer() );\n            boolean success = ( exitCode == 128 ? false : true );\n            result = new ScmResult( shell.getCommandline().toString(), \"\", \"Exit Code: \" + exitCode, success );\n\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Exception: \" + cle.getMessage() );\n            result = new ScmResult( shell.getCommandline().toString(), cle.getMessage(), \"\", false );\n        }\n\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected ScmResult executeCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                        CommandParameters parameters )\n        throws ScmException\n    {\n        return executeFileInfoCommand( repository, fileSet.getBasedir(),\n                                       parameters.getString( CommandParameter.FILE ) );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.integrity.command.fileinfo;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.fileinfo.AbstractFileInfoCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.integrity.APISession;\nimport org.apache.maven.scm.provider.integrity.repository.IntegrityScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * MKS Integrity implementation for Maven's AbstractFileInfoCommand\n * <br>This command will run a 'si memberinfo' command.  Even though this\n * command is supported via the API, we're using the CLI to execute as\n * its not clear what exactly this command is supposed to be returning\n * to the Maven SCM framework.  Hence the CLI output is returned to the\n * console verbatim\n *\n * @author <a href=\"mailto:cletus@mks.com\">Cletus D'Souza<\/a>\n * @since 1.6\n */\npublic class IntegrityFileInfoCommand\n    extends AbstractFileInfoCommand\n{\n    /**\n     * Even though this command is supported via the MKS JAVA API, since at this time we really don't\n     * know what the SCM plugin is looking to get in return for this command, we're simply going to\n     * run this command via the CLI and return the output verbatim\n     */\n    @Override\n    public ScmResult executeFileInfoCommand( ScmProviderRepository repository, File workingDirectory, String filename )\n        throws ScmException\n    {\n        getLogger().info( \"Attempting to display scm file information for file: \" + filename );\n        if ( null == filename || filename.length() == 0 )\n        {\n            throw new ScmException( \"A single filename is required to execute the fileinfo command!\" );\n        }\n        ScmResult result;\n        IntegrityScmProviderRepository iRepo = (IntegrityScmProviderRepository) repository;\n        APISession api = iRepo.getAPISession();\n        Commandline shell = new Commandline();\n        shell.setWorkingDirectory( workingDirectory );\n        shell.setExecutable( \"si\" );\n        shell.createArg().setValue( \"memberinfo\" );\n        shell.createArg().setValue( \"--hostname=\" + api.getHostName() );\n        shell.createArg().setValue( \"--port=\" + api.getPort() );\n        shell.createArg().setValue( \"--user=\" + api.getUserName() );\n        shell.createArg().setValue( '\"' + filename + '\"' );\n        IntegrityFileInfoConsumer shellConsumer = new IntegrityFileInfoConsumer( getLogger() );\n        String commandLine = CommandLineUtils.toString( shell.getCommandline() );\n\n        try\n        {\n            getLogger().debug( \"Executing: \" + commandLine );\n            int exitCode = CommandLineUtils.executeCommandLine( shell, shellConsumer,\n                                                                new CommandLineUtils.StringStreamConsumer() );\n            boolean success = ( exitCode == 128 ? false : true );\n            result = new ScmResult( commandLine, \"\", \"Exit Code: \" + exitCode, success );\n\n        }\n        catch ( CommandLineException cle )\n        {\n            getLogger().error( \"Command Line Exception: \" + cle.getMessage() );\n            result = new ScmResult( commandLine, cle.getMessage(), \"\", false );\n        }\n\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected ScmResult executeCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                        CommandParameters parameters )\n        throws ScmException\n    {\n        return executeFileInfoCommand( repository, fileSet.getBasedir(),\n                                       parameters.getString( CommandParameter.FILE ) );\n    }\n\n}\n","lineNo":77}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        return executeChangeLogCommand( request.getScmRepository().getProviderRepository(), fileSet,\n            request.getStartDate(), request.getEndDate(), request.getScmBranch(), datePattern, startVersion,\n                endVersion, request.getLimit() );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n            \n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n            \n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n            \n            cl.createArg().setValue( versionRange.toString() ); \n\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                                          ScmVersion version, String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repository, fileSet, null, null, null, datePattern, null, null, null, version );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmVersion revision = request.getRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        final ScmProviderRepository providerRepository = request.getScmRepository().getProviderRepository();\n        final Date startDate = request.getStartDate();\n        final Date endDate = request.getEndDate();\n        final ScmBranch branch = request.getScmBranch();\n        final Integer limit = request.getLimit();\n\n        return executeChangeLogCommand( providerRepository, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, revision );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit, ScmVersion version )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit, version );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                          ScmBranch branch, Date startDate, Date endDate,\n                                          ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                            limit, null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit,\n                                                 ScmVersion version )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n\n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n\n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n\n            cl.createArg().setValue( versionRange.toString() );\n\n        }\n        else if ( version != null )\n        {\n            cl.createArg().setValue( StringUtils.escape( version.getName() ) );\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","lineNo":99}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        return executeChangeLogCommand( request.getScmRepository().getProviderRepository(), fileSet,\n            request.getStartDate(), request.getEndDate(), request.getScmBranch(), datePattern, startVersion,\n                endVersion, request.getLimit() );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n            \n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n            \n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n            \n            cl.createArg().setValue( versionRange.toString() ); \n\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                                          ScmVersion version, String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repository, fileSet, null, null, null, datePattern, null, null, null, version );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmVersion revision = request.getRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        final ScmProviderRepository providerRepository = request.getScmRepository().getProviderRepository();\n        final Date startDate = request.getStartDate();\n        final Date endDate = request.getEndDate();\n        final ScmBranch branch = request.getScmBranch();\n        final Integer limit = request.getLimit();\n\n        return executeChangeLogCommand( providerRepository, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, revision );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit, ScmVersion version )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit, version );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                          ScmBranch branch, Date startDate, Date endDate,\n                                          ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                            limit, null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit,\n                                                 ScmVersion version )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n\n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n\n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n\n            cl.createArg().setValue( versionRange.toString() );\n\n        }\n        else if ( version != null )\n        {\n            cl.createArg().setValue( StringUtils.escape( version.getName() ) );\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","lineNo":100}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        return executeChangeLogCommand( request.getScmRepository().getProviderRepository(), fileSet,\n            request.getStartDate(), request.getEndDate(), request.getScmBranch(), datePattern, startVersion,\n                endVersion, request.getLimit() );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n            \n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n            \n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n            \n            cl.createArg().setValue( versionRange.toString() ); \n\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                                          ScmVersion version, String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repository, fileSet, null, null, null, datePattern, null, null, null, version );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmVersion revision = request.getRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        final ScmProviderRepository providerRepository = request.getScmRepository().getProviderRepository();\n        final Date startDate = request.getStartDate();\n        final Date endDate = request.getEndDate();\n        final ScmBranch branch = request.getScmBranch();\n        final Integer limit = request.getLimit();\n\n        return executeChangeLogCommand( providerRepository, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, revision );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit, ScmVersion version )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit, version );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                          ScmBranch branch, Date startDate, Date endDate,\n                                          ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                            limit, null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit,\n                                                 ScmVersion version )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n\n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n\n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n\n            cl.createArg().setValue( versionRange.toString() );\n\n        }\n        else if ( version != null )\n        {\n            cl.createArg().setValue( StringUtils.escape( version.getName() ) );\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","lineNo":101}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        return executeChangeLogCommand( request.getScmRepository().getProviderRepository(), fileSet,\n            request.getStartDate(), request.getEndDate(), request.getScmBranch(), datePattern, startVersion,\n                endVersion, request.getLimit() );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n            \n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n            \n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n            \n            cl.createArg().setValue( versionRange.toString() ); \n\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                                          ScmVersion version, String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repository, fileSet, null, null, null, datePattern, null, null, null, version );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmVersion revision = request.getRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        final ScmProviderRepository providerRepository = request.getScmRepository().getProviderRepository();\n        final Date startDate = request.getStartDate();\n        final Date endDate = request.getEndDate();\n        final ScmBranch branch = request.getScmBranch();\n        final Integer limit = request.getLimit();\n\n        return executeChangeLogCommand( providerRepository, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, revision );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit, ScmVersion version )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit, version );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                          ScmBranch branch, Date startDate, Date endDate,\n                                          ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                            limit, null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit,\n                                                 ScmVersion version )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n\n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n\n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n\n            cl.createArg().setValue( versionRange.toString() );\n\n        }\n        else if ( version != null )\n        {\n            cl.createArg().setValue( StringUtils.escape( version.getName() ) );\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","lineNo":102}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        return executeChangeLogCommand( request.getScmRepository().getProviderRepository(), fileSet,\n            request.getStartDate(), request.getEndDate(), request.getScmBranch(), datePattern, startVersion,\n                endVersion, request.getLimit() );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n            \n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n            \n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n            \n            cl.createArg().setValue( versionRange.toString() ); \n\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.apache.maven.scm.provider.git.gitexe.command.GitCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n *\n */\npublic class GitChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements GitCommand\n{\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                                          ScmVersion version, String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repository, fileSet, null, null, null, datePattern, null, null, null, version );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, startVersion,\n                                        endVersion, null, null );\n    }\n\n    @Override\n    protected ChangeLogScmResult executeChangeLogCommand( ChangeLogScmRequest request )\n        throws ScmException\n    {\n        final ScmVersion startVersion = request.getStartRevision();\n        final ScmVersion endVersion = request.getEndRevision();\n        final ScmVersion revision = request.getRevision();\n        final ScmFileSet fileSet = request.getScmFileSet();\n        final String datePattern = request.getDatePattern();\n        final ScmProviderRepository providerRepository = request.getScmRepository().getProviderRepository();\n        final Date startDate = request.getStartDate();\n        final Date endDate = request.getEndDate();\n        final ScmBranch branch = request.getScmBranch();\n        final Integer limit = request.getLimit();\n\n        return executeChangeLogCommand( providerRepository, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, revision );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern,\n                                        startVersion, endVersion, limit, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion, Integer limit, ScmVersion version )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (GitScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion, limit, version );\n\n        GitChangeLogConsumer consumer = new GitChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        exitCode = GitCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The git-log command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * this constructs creates the commandline for the git-whatchanged command.\n     * Since it uses --since and --until for the start and end date, the branch\n     * and version parameters can be used simultanously. \n     */\n    public static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                                  null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                          ScmBranch branch, Date startDate, Date endDate,\n                                          ScmVersion startVersion, ScmVersion endVersion, Integer limit )\n    {\n        return createCommandLine( repository, workingDirectory, branch, startDate, endDate, startVersion, endVersion,\n                            limit, null );\n    }\n\n    static Commandline createCommandLine( GitScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion, Integer limit,\n                                                 ScmVersion version )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = GitCommandLineUtils.getBaseGitCommandLine( workingDirectory, \"whatchanged\" );\n\n        if ( startDate != null || endDate != null )\n        {\n            if ( startDate != null )\n            {\n                cl.createArg().setValue( \"--since=\" + StringUtils.escape( dateFormat.format( startDate ) ) );\n            }\n\n            if ( endDate != null )\n            {\n                cl.createArg().setValue( \"--until=\" + StringUtils.escape( dateFormat.format( endDate ) ) );\n            }\n\n        }\n\n        // since this parameter is also used for the output formatting, we need it also if no start nor end date is\n        // given\n        cl.createArg().setValue( \"--date=iso\" );\n\n        if ( startVersion != null || endVersion != null )\n        {\n            StringBuilder versionRange = new StringBuilder();\n\n            if ( startVersion != null )\n            {\n                versionRange.append( StringUtils.escape( startVersion.getName() ) );\n            }\n\n            versionRange.append( \"..\" );\n\n            if ( endVersion != null )\n            {\n                versionRange.append( StringUtils.escape( endVersion.getName() ) );\n            }\n\n            cl.createArg().setValue( versionRange.toString() );\n\n        }\n        else if ( version != null )\n        {\n            cl.createArg().setValue( StringUtils.escape( version.getName() ) );\n        }\n\n        if ( limit != null && limit > 0 )\n        {\n            cl.createArg().setValue( \"--max-count=\" + limit );\n        }\n\n        if ( branch != null && branch.getName() != null && branch.getName().length() > 0 )\n        {\n            cl.createArg().setValue( branch.getName() );\n        }\n\n        // Insert a separator to make sure that files aren't interpreted as part of the version spec\n        cl.createArg().setValue( \"--\" );\n        \n        // We have to report only the changes of the current project.\n        // This is needed for child projects, otherwise we would get the changelog of the \n        // whole parent-project including all childs.\n        cl.createArg().setFile( workingDirectory );\n        \n        return cl;\n    }\n}\n","lineNo":103}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.List;\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.util.SvnUtil;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * Command line construction utility.\n *\n * @author Brett Porter\n * @author Olivier Lamy\n *\n */\npublic final class SvnCommandLineUtils\n{\n    private SvnCommandLineUtils()\n    {\n    }\n\n    public static void addTarget( Commandline cl, List<File> files )\n        throws IOException\n    {\n        if ( files == null || files.isEmpty() )\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        String ls = System.getProperty( \"line.separator\" );\n        for ( File f : files )\n        {\n            sb.append( f.getPath().replace( '\\\\', '/' ) );\n            sb.append( ls );\n        }\n\n        File targets = File.createTempFile( \"maven-scm-\", \"-targets\" );\n        PrintStream out = new PrintStream( new FileOutputStream( targets ) );\n        out.print( sb.toString() );\n        out.flush();\n        out.close();\n\n        cl.createArg().setValue( \"--targets\" );\n        cl.createArg().setValue( targets.getAbsolutePath() );\n\n        targets.deleteOnExit();\n    }\n\n    public static Commandline getBaseSvnCommandLine( File workingDirectory, SvnScmProviderRepository repository )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n        try\n        {\n            cl.addSystemEnvironment();\n            cl.addEnvironment( \"LC_MESSAGES\", \"C\" );\n        }\n        catch ( Exception e )\n        {\n            //Do nothing\n        }\n\n        if ( workingDirectory != null )\n        {\n            cl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n        }\n\n        if ( !StringUtils.isEmpty( System.getProperty( \"maven.scm.svn.config_directory\" ) ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( System.getProperty( \"maven.scm.svn.config_directory\" ) );\n        }\n        else if ( !StringUtils.isEmpty( SvnUtil.getSettings().getConfigDirectory() ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( SvnUtil.getSettings().getConfigDirectory() );\n        }\n\n        boolean hasAuthInfo = false; \n        if ( repository != null && !StringUtils.isEmpty( repository.getUser() ) )\n        {\n            hasAuthInfo = true; \n            cl.createArg().setValue( \"--username\" );\n            cl.createArg().setValue( repository.getUser() );\n        }\n\n        if ( repository != null && !StringUtils.isEmpty( repository.getPassword() ) )\n        {\n            hasAuthInfo = true; \n            cl.createArg().setValue( \"--password\" );\n            cl.createArg().setValue( repository.getPassword() );\n        }\n\n        // [by Lenik] don't overwrite existing auth cache by default. \n        if ( hasAuthInfo && !SvnUtil.getSettings().isUseAuthCache() ) \n        {\n            cl.createArg().setValue( \"--no-auth-cache\" ); \n        }\n\n        if ( SvnUtil.getSettings().isUseNonInteractive() )\n        {\n            cl.createArg().setValue( \"--non-interactive\" );\n        }\n\n        if ( SvnUtil.getSettings().isTrustServerCert() )\n        {\n            cl.createArg().setValue( \"--trust-server-cert\" );\n        }\n\n        return cl;\n    }\n\n    public static int execute( Commandline cl, StreamConsumer consumer, CommandLineUtils.StringStreamConsumer stderr,\n                               ScmLogger logger )\n        throws CommandLineException\n    {\n        // SCM-482: force English resource bundle\n        cl.addEnvironment( \"LC_MESSAGES\", \"en\" );\n\n        int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, consumer, stderr, logger );\n\n        return exitCode;\n    }\n\n    public static int execute( Commandline cl, CommandLineUtils.StringStreamConsumer stdout,\n                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        int exitCode = CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, stdout, stderr, logger );\n\n        return exitCode;\n    }\n\n    private static int checkIfCleanUpIsNeeded( int exitCode, Commandline cl, StreamConsumer consumer,\n                                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        if ( exitCode != 0 && stderr.getOutput() != null && stderr.getOutput().indexOf( \"'svn cleanup'\" ) > 0\n            && stderr.getOutput().indexOf( \"'svn help cleanup'\" ) > 0 )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Svn command failed due to some locks in working copy. We try to run a 'svn cleanup'.\" );\n            }\n\n            if ( executeCleanUp( cl.getWorkingDirectory(), consumer, stderr, logger ) == 0 )\n            {\n                exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n            }\n        }\n        return exitCode;\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr )\n        throws CommandLineException\n    {\n        return executeCleanUp( workinDirectory, stdout, stderr, null );\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr,\n                                      ScmLogger logger )\n        throws CommandLineException\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n\n        cl.setWorkingDirectory( workinDirectory.getAbsolutePath() );\n\n        if ( logger != null )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n\n                if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n                {\n                    logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n                }\n            }\n        }\n\n        return CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n    }\n\n    public static String cryptPassword( Commandline cl )\n    {\n        String clString = cl.toString();\n\n        int pos = clString.indexOf( \"--password\" );\n\n        if ( pos > 0 )\n        {\n            String beforePassword = clString.substring( 0, pos + \"--password \".length() );\n            String afterPassword = clString.substring( pos + \"--password \".length() );\n            afterPassword = afterPassword.substring( afterPassword.indexOf( ' ' ) );\n            if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n            {\n                clString = beforePassword + \"*****\" + afterPassword;\n            }\n            else\n            {\n                clString = beforePassword + \"'*****'\" + afterPassword;\n            }\n        }\n\n        return clString;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.List;\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.util.SvnUtil;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * Command line construction utility.\n *\n * @author Brett Porter\n * @author Olivier Lamy\n *\n */\npublic final class SvnCommandLineUtils\n{\n    private SvnCommandLineUtils()\n    {\n    }\n\n    public static void addTarget( Commandline cl, List<File> files )\n        throws IOException\n    {\n        if ( files == null || files.isEmpty() )\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        String ls = System.getProperty( \"line.separator\" );\n        for ( File f : files )\n        {\n            sb.append( f.getPath().replace( '\\\\', '/' ) );\n            sb.append( ls );\n        }\n\n        File targets = File.createTempFile( \"maven-scm-\", \"-targets\" );\n        PrintStream out = new PrintStream( new FileOutputStream( targets ) );\n        out.print( sb.toString() );\n        out.flush();\n        out.close();\n\n        cl.createArg().setValue( \"--targets\" );\n        cl.createArg().setValue( targets.getAbsolutePath() );\n\n        targets.deleteOnExit();\n    }\n\n    public static Commandline getBaseSvnCommandLine( File workingDirectory, SvnScmProviderRepository repository )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n        try\n        {\n            cl.addSystemEnvironment();\n            cl.addEnvironment( \"LC_MESSAGES\", \"C\" );\n        }\n        catch ( Exception e )\n        {\n            //Do nothing\n        }\n\n        if ( workingDirectory != null )\n        {\n            cl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n        }\n\n        if ( !StringUtils.isEmpty( System.getProperty( \"maven.scm.svn.config_directory\" ) ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( System.getProperty( \"maven.scm.svn.config_directory\" ) );\n        }\n        else if ( !StringUtils.isEmpty( SvnUtil.getSettings().getConfigDirectory() ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( SvnUtil.getSettings().getConfigDirectory() );\n        }\n\n        boolean hasAuthInfo = false;\n        if ( repository != null && !StringUtils.isEmpty( repository.getUser() ) )\n        {\n            hasAuthInfo = true;\n            cl.createArg().setValue( \"--username\" );\n            cl.createArg().setValue( repository.getUser() );\n        }\n\n        if ( repository != null && !StringUtils.isEmpty( repository.getPassword() ) )\n        {\n            hasAuthInfo = true;\n            cl.createArg().setValue( \"--password\" );\n            cl.createArg().setValue( repository.getPassword() );\n        }\n\n        // [by Lenik] don't overwrite existing auth cache by default.\n        if ( hasAuthInfo && !SvnUtil.getSettings().isUseAuthCache() )\n        {\n            cl.createArg().setValue( \"--no-auth-cache\" );\n        }\n\n        if ( SvnUtil.getSettings().isUseNonInteractive() )\n        {\n            cl.createArg().setValue( \"--non-interactive\" );\n        }\n\n        if ( SvnUtil.getSettings().isTrustServerCert() )\n        {\n            cl.createArg().setValue( \"--trust-server-cert\" );\n        }\n\n        return cl;\n    }\n\n    public static int execute( Commandline cl, StreamConsumer consumer, CommandLineUtils.StringStreamConsumer stderr,\n                               ScmLogger logger )\n        throws CommandLineException\n    {\n        // SCM-482: force English resource bundle\n        cl.addEnvironment( \"LC_MESSAGES\", \"en\" );\n\n        int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, consumer, stderr, logger );\n\n        return exitCode;\n    }\n\n    public static int execute( Commandline cl, CommandLineUtils.StringStreamConsumer stdout,\n                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        int exitCode = CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, stdout, stderr, logger );\n\n        return exitCode;\n    }\n\n    private static int checkIfCleanUpIsNeeded( int exitCode, Commandline cl, StreamConsumer consumer,\n                                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        if ( exitCode != 0 && stderr.getOutput() != null && stderr.getOutput().indexOf( \"'svn cleanup'\" ) > 0\n            && stderr.getOutput().indexOf( \"'svn help cleanup'\" ) > 0 )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Svn command failed due to some locks in working copy. We try to run a 'svn cleanup'.\" );\n            }\n\n            if ( executeCleanUp( cl.getWorkingDirectory(), consumer, stderr, logger ) == 0 )\n            {\n                exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n            }\n        }\n        return exitCode;\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr )\n        throws CommandLineException\n    {\n        return executeCleanUp( workinDirectory, stdout, stderr, null );\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr,\n                                      ScmLogger logger )\n        throws CommandLineException\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n\n        cl.setWorkingDirectory( workinDirectory.getAbsolutePath() );\n\n        if ( logger != null )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n\n                if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n                {\n                    logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n                }\n            }\n        }\n\n        return CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n    }\n\n    public static String cryptPassword( Commandline cl )\n    {\n        String clString = cl.toString();\n\n        final String passwordArg = \"--password \";\n        String quoteChar;\n        String escapedQuoteChar;\n        String cryptedPassword;\n\n        int pos = clString.indexOf( passwordArg );\n\n        if ( pos > 0 )\n        {\n            String beforePassword = clString.substring( 0, pos + passwordArg.length() );\n            String afterPassword = clString.substring( pos + passwordArg.length() );\n\n            if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n            {\n                 quoteChar = \"\\\"\";\n                 escapedQuoteChar = \"\\\"\\\"\";\n                 cryptedPassword = \"*****\";\n            }\n            else\n            {\n                quoteChar = \"'\";\n                escapedQuoteChar = \"'\\\\''\";\n                cryptedPassword = \"'*****'\";\n            }\n\n            if ( afterPassword.startsWith( quoteChar ) )\n            {\n                pos = 1;\n                while ( afterPassword.indexOf( escapedQuoteChar, pos ) != -1 )\n                {\n                    pos = afterPassword.indexOf( escapedQuoteChar, pos ) + escapedQuoteChar.length();\n                }\n                afterPassword = afterPassword.substring ( afterPassword.indexOf( quoteChar, pos )\n                                                          + quoteChar.length() );\n            }\n            else\n            {\n                afterPassword = afterPassword.substring( afterPassword.indexOf( ' ' ) );\n            }\n\n            clString = beforePassword + cryptedPassword + afterPassword;\n\n        }\n\n        return clString;\n    }\n}\n","lineNo":225}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.List;\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.util.SvnUtil;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * Command line construction utility.\n *\n * @author Brett Porter\n * @author Olivier Lamy\n *\n */\npublic final class SvnCommandLineUtils\n{\n    private SvnCommandLineUtils()\n    {\n    }\n\n    public static void addTarget( Commandline cl, List<File> files )\n        throws IOException\n    {\n        if ( files == null || files.isEmpty() )\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        String ls = System.getProperty( \"line.separator\" );\n        for ( File f : files )\n        {\n            sb.append( f.getPath().replace( '\\\\', '/' ) );\n            sb.append( ls );\n        }\n\n        File targets = File.createTempFile( \"maven-scm-\", \"-targets\" );\n        PrintStream out = new PrintStream( new FileOutputStream( targets ) );\n        out.print( sb.toString() );\n        out.flush();\n        out.close();\n\n        cl.createArg().setValue( \"--targets\" );\n        cl.createArg().setValue( targets.getAbsolutePath() );\n\n        targets.deleteOnExit();\n    }\n\n    public static Commandline getBaseSvnCommandLine( File workingDirectory, SvnScmProviderRepository repository )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n        try\n        {\n            cl.addSystemEnvironment();\n            cl.addEnvironment( \"LC_MESSAGES\", \"C\" );\n        }\n        catch ( Exception e )\n        {\n            //Do nothing\n        }\n\n        if ( workingDirectory != null )\n        {\n            cl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n        }\n\n        if ( !StringUtils.isEmpty( System.getProperty( \"maven.scm.svn.config_directory\" ) ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( System.getProperty( \"maven.scm.svn.config_directory\" ) );\n        }\n        else if ( !StringUtils.isEmpty( SvnUtil.getSettings().getConfigDirectory() ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( SvnUtil.getSettings().getConfigDirectory() );\n        }\n\n        boolean hasAuthInfo = false; \n        if ( repository != null && !StringUtils.isEmpty( repository.getUser() ) )\n        {\n            hasAuthInfo = true; \n            cl.createArg().setValue( \"--username\" );\n            cl.createArg().setValue( repository.getUser() );\n        }\n\n        if ( repository != null && !StringUtils.isEmpty( repository.getPassword() ) )\n        {\n            hasAuthInfo = true; \n            cl.createArg().setValue( \"--password\" );\n            cl.createArg().setValue( repository.getPassword() );\n        }\n\n        // [by Lenik] don't overwrite existing auth cache by default. \n        if ( hasAuthInfo && !SvnUtil.getSettings().isUseAuthCache() ) \n        {\n            cl.createArg().setValue( \"--no-auth-cache\" ); \n        }\n\n        if ( SvnUtil.getSettings().isUseNonInteractive() )\n        {\n            cl.createArg().setValue( \"--non-interactive\" );\n        }\n\n        if ( SvnUtil.getSettings().isTrustServerCert() )\n        {\n            cl.createArg().setValue( \"--trust-server-cert\" );\n        }\n\n        return cl;\n    }\n\n    public static int execute( Commandline cl, StreamConsumer consumer, CommandLineUtils.StringStreamConsumer stderr,\n                               ScmLogger logger )\n        throws CommandLineException\n    {\n        // SCM-482: force English resource bundle\n        cl.addEnvironment( \"LC_MESSAGES\", \"en\" );\n\n        int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, consumer, stderr, logger );\n\n        return exitCode;\n    }\n\n    public static int execute( Commandline cl, CommandLineUtils.StringStreamConsumer stdout,\n                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        int exitCode = CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, stdout, stderr, logger );\n\n        return exitCode;\n    }\n\n    private static int checkIfCleanUpIsNeeded( int exitCode, Commandline cl, StreamConsumer consumer,\n                                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        if ( exitCode != 0 && stderr.getOutput() != null && stderr.getOutput().indexOf( \"'svn cleanup'\" ) > 0\n            && stderr.getOutput().indexOf( \"'svn help cleanup'\" ) > 0 )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Svn command failed due to some locks in working copy. We try to run a 'svn cleanup'.\" );\n            }\n\n            if ( executeCleanUp( cl.getWorkingDirectory(), consumer, stderr, logger ) == 0 )\n            {\n                exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n            }\n        }\n        return exitCode;\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr )\n        throws CommandLineException\n    {\n        return executeCleanUp( workinDirectory, stdout, stderr, null );\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr,\n                                      ScmLogger logger )\n        throws CommandLineException\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n\n        cl.setWorkingDirectory( workinDirectory.getAbsolutePath() );\n\n        if ( logger != null )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n\n                if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n                {\n                    logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n                }\n            }\n        }\n\n        return CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n    }\n\n    public static String cryptPassword( Commandline cl )\n    {\n        String clString = cl.toString();\n\n        int pos = clString.indexOf( \"--password\" );\n\n        if ( pos > 0 )\n        {\n            String beforePassword = clString.substring( 0, pos + \"--password \".length() );\n            String afterPassword = clString.substring( pos + \"--password \".length() );\n            afterPassword = afterPassword.substring( afterPassword.indexOf( ' ' ) );\n            if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n            {\n                clString = beforePassword + \"*****\" + afterPassword;\n            }\n            else\n            {\n                clString = beforePassword + \"'*****'\" + afterPassword;\n            }\n        }\n\n        return clString;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.List;\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.util.SvnUtil;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * Command line construction utility.\n *\n * @author Brett Porter\n * @author Olivier Lamy\n *\n */\npublic final class SvnCommandLineUtils\n{\n    private SvnCommandLineUtils()\n    {\n    }\n\n    public static void addTarget( Commandline cl, List<File> files )\n        throws IOException\n    {\n        if ( files == null || files.isEmpty() )\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        String ls = System.getProperty( \"line.separator\" );\n        for ( File f : files )\n        {\n            sb.append( f.getPath().replace( '\\\\', '/' ) );\n            sb.append( ls );\n        }\n\n        File targets = File.createTempFile( \"maven-scm-\", \"-targets\" );\n        PrintStream out = new PrintStream( new FileOutputStream( targets ) );\n        out.print( sb.toString() );\n        out.flush();\n        out.close();\n\n        cl.createArg().setValue( \"--targets\" );\n        cl.createArg().setValue( targets.getAbsolutePath() );\n\n        targets.deleteOnExit();\n    }\n\n    public static Commandline getBaseSvnCommandLine( File workingDirectory, SvnScmProviderRepository repository )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n        try\n        {\n            cl.addSystemEnvironment();\n            cl.addEnvironment( \"LC_MESSAGES\", \"C\" );\n        }\n        catch ( Exception e )\n        {\n            //Do nothing\n        }\n\n        if ( workingDirectory != null )\n        {\n            cl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n        }\n\n        if ( !StringUtils.isEmpty( System.getProperty( \"maven.scm.svn.config_directory\" ) ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( System.getProperty( \"maven.scm.svn.config_directory\" ) );\n        }\n        else if ( !StringUtils.isEmpty( SvnUtil.getSettings().getConfigDirectory() ) )\n        {\n            cl.createArg().setValue( \"--config-dir\" );\n            cl.createArg().setValue( SvnUtil.getSettings().getConfigDirectory() );\n        }\n\n        boolean hasAuthInfo = false;\n        if ( repository != null && !StringUtils.isEmpty( repository.getUser() ) )\n        {\n            hasAuthInfo = true;\n            cl.createArg().setValue( \"--username\" );\n            cl.createArg().setValue( repository.getUser() );\n        }\n\n        if ( repository != null && !StringUtils.isEmpty( repository.getPassword() ) )\n        {\n            hasAuthInfo = true;\n            cl.createArg().setValue( \"--password\" );\n            cl.createArg().setValue( repository.getPassword() );\n        }\n\n        // [by Lenik] don't overwrite existing auth cache by default.\n        if ( hasAuthInfo && !SvnUtil.getSettings().isUseAuthCache() )\n        {\n            cl.createArg().setValue( \"--no-auth-cache\" );\n        }\n\n        if ( SvnUtil.getSettings().isUseNonInteractive() )\n        {\n            cl.createArg().setValue( \"--non-interactive\" );\n        }\n\n        if ( SvnUtil.getSettings().isTrustServerCert() )\n        {\n            cl.createArg().setValue( \"--trust-server-cert\" );\n        }\n\n        return cl;\n    }\n\n    public static int execute( Commandline cl, StreamConsumer consumer, CommandLineUtils.StringStreamConsumer stderr,\n                               ScmLogger logger )\n        throws CommandLineException\n    {\n        // SCM-482: force English resource bundle\n        cl.addEnvironment( \"LC_MESSAGES\", \"en\" );\n\n        int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, consumer, stderr, logger );\n\n        return exitCode;\n    }\n\n    public static int execute( Commandline cl, CommandLineUtils.StringStreamConsumer stdout,\n                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        int exitCode = CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n\n        exitCode = checkIfCleanUpIsNeeded( exitCode, cl, stdout, stderr, logger );\n\n        return exitCode;\n    }\n\n    private static int checkIfCleanUpIsNeeded( int exitCode, Commandline cl, StreamConsumer consumer,\n                                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws CommandLineException\n    {\n        if ( exitCode != 0 && stderr.getOutput() != null && stderr.getOutput().indexOf( \"'svn cleanup'\" ) > 0\n            && stderr.getOutput().indexOf( \"'svn help cleanup'\" ) > 0 )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Svn command failed due to some locks in working copy. We try to run a 'svn cleanup'.\" );\n            }\n\n            if ( executeCleanUp( cl.getWorkingDirectory(), consumer, stderr, logger ) == 0 )\n            {\n                exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n            }\n        }\n        return exitCode;\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr )\n        throws CommandLineException\n    {\n        return executeCleanUp( workinDirectory, stdout, stderr, null );\n    }\n\n    public static int executeCleanUp( File workinDirectory, StreamConsumer stdout, StreamConsumer stderr,\n                                      ScmLogger logger )\n        throws CommandLineException\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n\n        cl.setWorkingDirectory( workinDirectory.getAbsolutePath() );\n\n        if ( logger != null )\n        {\n            if ( logger.isInfoEnabled() )\n            {\n                logger.info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n\n                if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n                {\n                    logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n                }\n            }\n        }\n\n        return CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n    }\n\n    public static String cryptPassword( Commandline cl )\n    {\n        String clString = cl.toString();\n\n        final String passwordArg = \"--password \";\n        String quoteChar;\n        String escapedQuoteChar;\n        String cryptedPassword;\n\n        int pos = clString.indexOf( passwordArg );\n\n        if ( pos > 0 )\n        {\n            String beforePassword = clString.substring( 0, pos + passwordArg.length() );\n            String afterPassword = clString.substring( pos + passwordArg.length() );\n\n            if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n            {\n                 quoteChar = \"\\\"\";\n                 escapedQuoteChar = \"\\\"\\\"\";\n                 cryptedPassword = \"*****\";\n            }\n            else\n            {\n                quoteChar = \"'\";\n                escapedQuoteChar = \"'\\\\''\";\n                cryptedPassword = \"'*****'\";\n            }\n\n            if ( afterPassword.startsWith( quoteChar ) )\n            {\n                pos = 1;\n                while ( afterPassword.indexOf( escapedQuoteChar, pos ) != -1 )\n                {\n                    pos = afterPassword.indexOf( escapedQuoteChar, pos ) + escapedQuoteChar.length();\n                }\n                afterPassword = afterPassword.substring ( afterPassword.indexOf( quoteChar, pos )\n                                                          + quoteChar.length() );\n            }\n            else\n            {\n                afterPassword = afterPassword.substring( afterPassword.indexOf( ' ' ) );\n            }\n\n            clString = beforePassword + cryptedPassword + afterPassword;\n\n        }\n\n        return clString;\n    }\n}\n","lineNo":228}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.cvsjava.util;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.netbeans.lib.cvsclient.CVSRoot;\nimport org.netbeans.lib.cvsclient.Client;\nimport org.netbeans.lib.cvsclient.admin.StandardAdminHandler;\nimport org.netbeans.lib.cvsclient.command.Command;\nimport org.netbeans.lib.cvsclient.command.CommandAbortedException;\nimport org.netbeans.lib.cvsclient.command.CommandException;\nimport org.netbeans.lib.cvsclient.command.GlobalOptions;\nimport org.netbeans.lib.cvsclient.commandLine.CommandFactory;\nimport org.netbeans.lib.cvsclient.commandLine.GetOpt;\nimport org.netbeans.lib.cvsclient.connection.AbstractConnection;\nimport org.netbeans.lib.cvsclient.connection.AuthenticationException;\nimport org.netbeans.lib.cvsclient.connection.Connection;\nimport org.netbeans.lib.cvsclient.connection.ConnectionFactory;\nimport org.netbeans.lib.cvsclient.connection.PServerConnection;\nimport org.netbeans.lib.cvsclient.connection.StandardScrambler;\nimport org.netbeans.lib.cvsclient.event.CVSListener;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\n/**\n * A Cvs connection that simulates a command line interface.\n *\n * @author <a href=\"mailto:epugh@upstate.com\">Eric Pugh<\/a>\n *\n */\npublic class CvsConnection\n{\n\n    /**\n     * The path to the repository on the server\n     */\n    @SuppressWarnings( \"unused\" )\n    private String repository;\n\n    /**\n     * The local path to use to perform operations (the top level)\n     */\n    private String localPath;\n\n    /**\n     * The connection to the server\n     */\n    private Connection connection;\n\n    /**\n     * The client that manages interactions with the server\n     */\n    private Client client;\n\n    /**\n     * The global options being used. GlobalOptions are only global for a\n     * particular command.\n     */\n    private GlobalOptions globalOptions;\n\n    private CvsConnection()\n    {\n    }\n\n    /**\n     * Execute a configured CVS command\n     *\n     * @param command the command to execute\n     * @throws CommandException if there is an error running the command\n     */\n    public boolean executeCommand( Command command )\n        throws CommandException, AuthenticationException\n    {\n        return client.executeCommand( command, globalOptions );\n    }\n\n    public void setRepository( String repository )\n    {\n        this.repository = repository;\n    }\n\n    public void setLocalPath( String localPath )\n    {\n        this.localPath = localPath;\n    }\n\n    public void setGlobalOptions( GlobalOptions globalOptions )\n    {\n        this.globalOptions = globalOptions;\n    }\n\n    /**\n     * Creates the connection and the client and connects.\n     */\n    private void connect( CVSRoot root, String password )\n        throws AuthenticationException, CommandAbortedException\n    {\n        if ( CVSRoot.METHOD_EXT.equals( root.getMethod() ) )\n        {\n            String cvsRsh = System.getProperty( \"maven.scm.cvs.java.cvs_rsh\" );\n            if ( cvsRsh == null )\n            {\n                try\n                {\n                    cvsRsh = CommandLineUtils.getSystemEnvVars().getProperty( \"CVS_RSH\" );\n                }\n                catch ( IOException e )\n                {\n                    // we assume searching env var can't fail\n                }\n            }\n\n            if ( cvsRsh != null )\n            {\n                if ( cvsRsh.indexOf( ' ' ) < 0 )\n                {\n                    //cvs_rsh should be 'rsh' or 'ssh'\n                    //Complete the command to use\n                    String username = root.getUserName();\n                    if ( username == null )\n                    {\n                        username = System.getProperty( \"user.name\" );\n                    }\n\n                    cvsRsh += \" \" + username + \"@\" + root.getHostName() + \" cvs server\";\n                }\n\n                AbstractConnection conn = new org.netbeans.lib.cvsclient.connection.ExtConnection( cvsRsh );\n                conn.setRepository( root.getRepository() );\n                connection = conn;\n            }\n            else\n            {\n                connection = new ExtConnection( root );\n            }\n        }\n        else\n        {\n            connection = ConnectionFactory.getConnection( root );\n            if ( CVSRoot.METHOD_PSERVER.equals( root.getMethod() ) )\n            {\n                ( (PServerConnection) connection ).setEncodedPassword( password );\n            }\n        }\n        connection.open();\n\n        client = new Client( connection, new StandardAdminHandler() );\n        client.setLocalPath( localPath );\n    }\n\n    private void disconnect()\n    {\n        if ( connection != null && connection.isOpen() )\n        {\n            try\n            {\n                connection.close();\n            }\n            catch ( IOException e )\n            {\n                //ignore\n            }\n        }\n    }\n\n    private void addListener( CVSListener listener )\n    {\n        if ( client != null )\n        {\n            // add a listener to the client\n            client.getEventManager().addCVSListener( listener );\n        }\n    }\n\n    /**\n     * Obtain the CVS root, either from the -D option cvs.root or from the CVS\n     * directory\n     *\n     * @return the CVSRoot string\n     */\n    private static String getCVSRoot( String workingDir )\n    {\n        String root = null;\n        BufferedReader r = null;\n        if ( workingDir == null )\n        {\n            workingDir = System.getProperty( \"user.dir\" );\n        }\n        try\n        {\n            File f = new File( workingDir );\n            File rootFile = new File( f, \"CVS/Root\" );\n            if ( rootFile.exists() )\n            {\n                r = new BufferedReader( new FileReader( rootFile ) );\n                root = r.readLine();\n            }\n        }\n        catch ( IOException e )\n        {\n            // ignore\n        }\n        finally\n        {\n            try\n            {\n                if ( r != null )\n                {\n                    r.close();\n                }\n            }\n            catch ( IOException e )\n            {\n                System.err.println( \"Warning: could not close CVS/Root file!\" );\n            }\n        }\n        if ( root == null )\n        {\n            root = System.getProperty( \"cvs.root\" );\n        }\n        return root;\n    }\n\n    /**\n     * Process global options passed into the application\n     *\n     * @param args          the argument list, complete\n     * @param globalOptions the global options structure that will be passed to\n     *                      the command\n     */\n    private static int processGlobalOptions( String[] args, GlobalOptions globalOptions )\n    {\n        final String getOptString = globalOptions.getOptString();\n        GetOpt go = new GetOpt( args, getOptString );\n        int ch;\n        while ( ( ch = go.getopt() ) != GetOpt.optEOF )\n        {\n            //System.out.println(\"Global option '\"+((char) ch)+\"',\n            // '\"+go.optArgGet()+\"'\");\n            String arg = go.optArgGet();\n            boolean success = globalOptions.setCVSCommand( (char) ch, arg );\n            if ( !success )\n            {\n                throw new IllegalArgumentException( \"Failed to set CVS Command: -\" + ch + \" = \" + arg );\n            }\n        }\n\n        return go.optIndexGet();\n    }\n\n    /**\n     * Lookup the password in the .cvspass file. This file is looked for in the\n     * user.home directory if the option cvs.passfile is not set\n     *\n     * @param cvsRoot the CVS root for which the password is being searched\n     * @return the password, scrambled\n     */\n    private static String lookupPassword( String cvsRoot, ScmLogger logger )\n    {\n        File passFile = new File( System.getProperty( \"cygwin.user.home\", System.getProperty( \"user.home\" ) ) + File\n            .separatorChar + \".cvspass\" );\n\n        BufferedReader reader = null;\n        String password = null;\n\n        try\n        {\n            reader = new BufferedReader( new FileReader( passFile ) );\n            password = processCvspass( cvsRoot, reader );\n        }\n        catch ( IOException e )\n        {\n            if ( logger.isWarnEnabled() )\n            {\n                logger.warn( \"Could not read password for '\" + cvsRoot + \"' from '\" + passFile + \"'\", e );\n            }\n            return null;\n        }\n        finally\n        {\n            if ( reader != null )\n            {\n                try\n                {\n                    reader.close();\n                }\n                catch ( IOException e )\n                {\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( \"Warning: could not close password file.\" );\n                    }\n                }\n            }\n        }\n        if ( password == null )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Didn't find password for CVSROOT '\" + cvsRoot + \"'.\" );\n            }\n        }\n        return password;\n    }\n\n    /**\n     * Read in a list of return delimited lines from .cvspass and retreive\n     * the password.  Return null if the cvsRoot can't be found.\n     *\n     * @param cvsRoot the CVS root for which the password is being searched\n     * @param reader  A buffered reader of lines of cvspass information\n     * @return The password, or null if it can't be found.\n     * @throws IOException\n     */\n    static String processCvspass( String cvsRoot, BufferedReader reader )\n        throws IOException\n    {\n        String line;\n        String password = null;\n        while ( ( line = reader.readLine() ) != null )\n        {\n            if ( line.startsWith( \"/\" ) )\n            {\n                String[] cvspass = StringUtils.split( line, \" \" );\n                String cvspassRoot = cvspass[1];\n                if ( compareCvsRoot( cvsRoot, cvspassRoot ) )\n                {\n                    int index = line.indexOf( cvspassRoot ) + cvspassRoot.length() + 1;\n                    password = line.substring( index );\n                    break;\n                }\n            }\n            else if ( line.startsWith( cvsRoot ) )\n            {\n                password = line.substring( cvsRoot.length() + 1 );\n                break;\n            }\n        }\n        return password;\n    }\n\n    static boolean compareCvsRoot( String cvsRoot, String target )\n    {\n        String s1 = completeCvsRootPort( cvsRoot );\n        String s2 = completeCvsRootPort( target );\n        return s1 != null && s1.equals( s2 );\n\n    }\n\n    private static String completeCvsRootPort( String cvsRoot )\n    {\n        String result = cvsRoot;\n        int idx = cvsRoot.indexOf( ':' );\n        for ( int i = 0; i < 2 && idx != -1; i++ )\n        {\n            idx = cvsRoot.indexOf( ':', idx + 1 );\n        }\n        if ( idx != -1 && cvsRoot.charAt( idx + 1 ) == '/' )\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.append( cvsRoot.substring( 0, idx + 1 ) );\n            sb.append( \"2401\" );\n            sb.append( cvsRoot.substring( idx + 1 ) );\n            result = sb.toString();\n        }\n        return result;\n\n    }\n\n    /**\n     * Process the CVS command passed in args[] array with all necessary\n     * options. The only difference from main() method is, that this method\n     * does not exit the JVM and provides command output.\n     *\n     * @param args The command with options\n     */\n    public static boolean processCommand( String[] args, String localPath, CVSListener listener, ScmLogger logger )\n        throws Exception\n    {\n        // Set up the CVSRoot. Note that it might still be null after this\n        // call if the user has decided to set it with the -d command line\n        // global option\n        GlobalOptions globalOptions = new GlobalOptions();\n        globalOptions.setCVSRoot( getCVSRoot( localPath ) );\n\n        // Set up any global options specified. These occur before the\n        // name of the command to run\n        int commandIndex;\n\n        try\n        {\n            commandIndex = processGlobalOptions( args, globalOptions );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Invalid argument: \" + e );\n            }\n            return false;\n        }\n\n        // if we don't have a CVS root by now, the user has messed up\n        if ( globalOptions.getCVSRoot() == null )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"No CVS root is set. Check your <repository> information in the POM.\" );\n            }\n            return false;\n        }\n\n        // parse the CVS root into its constituent parts\n        CVSRoot root;\n        final String cvsRoot = globalOptions.getCVSRoot();\n        try\n        {\n            root = CVSRoot.parse( cvsRoot );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Incorrect format for CVSRoot: \" + cvsRoot + \"\\nThe correct format is: \"\n                    + \"[:method:][[user][:password]@][hostname:[port]]/path/to/repository\"\n                    + \"\\nwhere \\\"method\\\" is pserver.\" );\n            }\n            return false;\n        }\n\n        final String command = args[commandIndex];\n\n        // this is not login, but a 'real' cvs command, so construct it,\n        // set the options, and then connect to the server and execute it\n\n        Command c;\n        try\n        {\n            c = CommandFactory.getDefault().createCommand( command, args, ++commandIndex, globalOptions, localPath );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Illegal argument: \" + e.getMessage() );\n            }\n            return false;\n        }\n\n        String password = null;\n\n        if ( CVSRoot.METHOD_PSERVER.equals( root.getMethod() ) )\n        {\n            password = root.getPassword();\n            if ( password != null )\n            {\n                password = StandardScrambler.getInstance().scramble( password );\n            }\n            else\n            {\n                password = lookupPassword( cvsRoot, logger );\n                if ( password == null )\n                {\n                    password = StandardScrambler.getInstance().scramble( \"\" );\n                    // an empty password\n                }\n            }\n        }\n        CvsConnection cvsCommand = new CvsConnection();\n        cvsCommand.setGlobalOptions( globalOptions );\n        cvsCommand.setRepository( root.getRepository() );\n        // the local path is just the path where we executed the\n        // command. This is the case for command-line CVS but not\n        // usually for GUI front-ends\n        cvsCommand.setLocalPath( localPath );\n\n        cvsCommand.connect( root, password );\n        cvsCommand.addListener( listener );\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"Executing CVS command: \" + c.getCVSCommand() );\n        }\n        boolean result = cvsCommand.executeCommand( c );\n        cvsCommand.disconnect();\n        return result;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.cvsjava.util;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.netbeans.lib.cvsclient.CVSRoot;\nimport org.netbeans.lib.cvsclient.Client;\nimport org.netbeans.lib.cvsclient.admin.StandardAdminHandler;\nimport org.netbeans.lib.cvsclient.command.Command;\nimport org.netbeans.lib.cvsclient.command.CommandAbortedException;\nimport org.netbeans.lib.cvsclient.command.CommandException;\nimport org.netbeans.lib.cvsclient.command.GlobalOptions;\nimport org.netbeans.lib.cvsclient.commandLine.CommandFactory;\nimport org.netbeans.lib.cvsclient.commandLine.GetOpt;\nimport org.netbeans.lib.cvsclient.connection.AbstractConnection;\nimport org.netbeans.lib.cvsclient.connection.AuthenticationException;\nimport org.netbeans.lib.cvsclient.connection.Connection;\nimport org.netbeans.lib.cvsclient.connection.ConnectionFactory;\nimport org.netbeans.lib.cvsclient.connection.PServerConnection;\nimport org.netbeans.lib.cvsclient.connection.StandardScrambler;\nimport org.netbeans.lib.cvsclient.event.CVSListener;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\n/**\n * A Cvs connection that simulates a command line interface.\n *\n * @author <a href=\"mailto:epugh@upstate.com\">Eric Pugh<\/a>\n *\n */\npublic class CvsConnection\n{\n\n    /**\n     * The path to the repository on the server\n     */\n    @SuppressWarnings( \"unused\" )\n    private String repository;\n\n    /**\n     * The local path to use to perform operations (the top level)\n     */\n    private String localPath;\n\n    /**\n     * The connection to the server\n     */\n    private Connection connection;\n\n    /**\n     * The client that manages interactions with the server\n     */\n    private Client client;\n\n    /**\n     * The global options being used. GlobalOptions are only global for a\n     * particular command.\n     */\n    private GlobalOptions globalOptions;\n\n    private CvsConnection()\n    {\n    }\n\n    /**\n     * Execute a configured CVS command\n     *\n     * @param command the command to execute\n     * @throws CommandException if there is an error running the command\n     */\n    public boolean executeCommand( Command command )\n        throws CommandException, AuthenticationException\n    {\n        return client.executeCommand( command, globalOptions );\n    }\n\n    public void setRepository( String repository )\n    {\n        this.repository = repository;\n    }\n\n    public void setLocalPath( String localPath )\n    {\n        this.localPath = localPath;\n    }\n\n    public void setGlobalOptions( GlobalOptions globalOptions )\n    {\n        this.globalOptions = globalOptions;\n    }\n\n    /**\n     * Creates the connection and the client and connects.\n     */\n    private void connect( CVSRoot root, String password )\n        throws AuthenticationException, CommandAbortedException\n    {\n        if ( CVSRoot.METHOD_EXT.equals( root.getMethod() ) )\n        {\n            String cvsRsh = System.getProperty( \"maven.scm.cvs.java.cvs_rsh\" );\n            if ( cvsRsh == null )\n            {\n                try\n                {\n                    cvsRsh = CommandLineUtils.getSystemEnvVars().getProperty( \"CVS_RSH\" );\n                }\n                catch ( IOException e )\n                {\n                    // we assume searching env var can't fail\n                }\n            }\n\n            if ( cvsRsh != null )\n            {\n                if ( cvsRsh.indexOf( ' ' ) < 0 )\n                {\n                    //cvs_rsh should be 'rsh' or 'ssh'\n                    //Complete the command to use\n                    String username = root.getUserName();\n                    if ( username == null )\n                    {\n                        username = System.getProperty( \"user.name\" );\n                    }\n\n                    cvsRsh += \" \" + username + \"@\" + root.getHostName() + \" cvs server\";\n                }\n\n                AbstractConnection conn = new org.netbeans.lib.cvsclient.connection.ExtConnection( cvsRsh );\n                conn.setRepository( root.getRepository() );\n                connection = conn;\n            }\n            else\n            {\n                connection = new ExtConnection( root );\n            }\n        }\n        else\n        {\n            connection = ConnectionFactory.getConnection( root );\n            if ( CVSRoot.METHOD_PSERVER.equals( root.getMethod() ) )\n            {\n                ( (PServerConnection) connection ).setEncodedPassword( password );\n            }\n        }\n        connection.open();\n\n        client = new Client( connection, new StandardAdminHandler() );\n        client.setLocalPath( localPath );\n    }\n\n    private void disconnect()\n    {\n        if ( connection != null && connection.isOpen() )\n        {\n            try\n            {\n                connection.close();\n            }\n            catch ( IOException e )\n            {\n                //ignore\n            }\n        }\n    }\n\n    private void addListener( CVSListener listener )\n    {\n        if ( client != null )\n        {\n            // add a listener to the client\n            client.getEventManager().addCVSListener( listener );\n        }\n    }\n\n    /**\n     * Obtain the CVS root, either from the -D option cvs.root or from the CVS\n     * directory\n     *\n     * @return the CVSRoot string\n     */\n    private static String getCVSRoot( String workingDir )\n    {\n        String root = null;\n        BufferedReader r = null;\n        if ( workingDir == null )\n        {\n            workingDir = System.getProperty( \"user.dir\" );\n        }\n        try\n        {\n            File f = new File( workingDir );\n            File rootFile = new File( f, \"CVS/Root\" );\n            if ( rootFile.exists() )\n            {\n                r = new BufferedReader( new FileReader( rootFile ) );\n                root = r.readLine();\n            }\n        }\n        catch ( IOException e )\n        {\n            // ignore\n        }\n        finally\n        {\n            try\n            {\n                if ( r != null )\n                {\n                    r.close();\n                }\n            }\n            catch ( IOException e )\n            {\n                System.err.println( \"Warning: could not close CVS/Root file!\" );\n            }\n        }\n        if ( root == null )\n        {\n            root = System.getProperty( \"cvs.root\" );\n        }\n        return root;\n    }\n\n    /**\n     * Process global options passed into the application\n     *\n     * @param args          the argument list, complete\n     * @param globalOptions the global options structure that will be passed to\n     *                      the command\n     */\n    private static int processGlobalOptions( String[] args, GlobalOptions globalOptions )\n    {\n        final String getOptString = globalOptions.getOptString();\n        GetOpt go = new GetOpt( args, getOptString );\n        int ch;\n        while ( ( ch = go.getopt() ) != GetOpt.optEOF )\n        {\n            //System.out.println(\"Global option '\"+((char) ch)+\"',\n            // '\"+go.optArgGet()+\"'\");\n            String arg = go.optArgGet();\n            boolean success = globalOptions.setCVSCommand( (char) ch, arg );\n            if ( !success )\n            {\n                throw new IllegalArgumentException( \"Failed to set CVS Command: -\" + ch + \" = \" + arg );\n            }\n        }\n\n        return go.optIndexGet();\n    }\n\n    /**\n     * Lookup the password in the .cvspass file. This file is looked for in the\n     * user.home directory if the option cvs.passfile is not set\n     *\n     * @param cvsRoot the CVS root for which the password is being searched\n     * @return the password, scrambled\n     */\n    private static String lookupPassword( String cvsRoot, ScmLogger logger )\n    {\n        File passFile = new File( System.getProperty( \"cygwin.user.home\", System.getProperty( \"user.home\" ) ) + File\n            .separatorChar + \".cvspass\" );\n\n        BufferedReader reader = null;\n        String password = null;\n\n        try\n        {\n            reader = new BufferedReader( new FileReader( passFile ) );\n            password = processCvspass( cvsRoot, reader );\n        }\n        catch ( IOException e )\n        {\n            if ( logger.isWarnEnabled() )\n            {\n                logger.warn( \"Could not read password for '\" + cvsRoot + \"' from '\" + passFile + \"'\", e );\n            }\n            return null;\n        }\n        finally\n        {\n            if ( reader != null )\n            {\n                try\n                {\n                    reader.close();\n                }\n                catch ( IOException e )\n                {\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( \"Warning: could not close password file.\" );\n                    }\n                }\n            }\n        }\n        if ( password == null )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Didn't find password for CVSROOT '\" + cvsRoot + \"'.\" );\n            }\n        }\n        return password;\n    }\n\n    /**\n     * Read in a list of return delimited lines from .cvspass and retreive\n     * the password.  Return null if the cvsRoot can't be found.\n     *\n     * @param cvsRoot the CVS root for which the password is being searched\n     * @param reader  A buffered reader of lines of cvspass information\n     * @return The password, or null if it can't be found.\n     * @throws IOException\n     */\n    static String processCvspass( String cvsRoot, BufferedReader reader )\n        throws IOException\n    {\n        String line;\n        String password = null;\n        while ( ( line = reader.readLine() ) != null )\n        {\n            if ( line.startsWith( \"/\" ) )\n            {\n                String[] cvspass = StringUtils.split( line, \" \" );\n                String cvspassRoot = cvspass[1];\n                if ( compareCvsRoot( cvsRoot, cvspassRoot ) )\n                {\n                    int index = line.indexOf( cvspassRoot ) + cvspassRoot.length() + 1;\n                    password = line.substring( index );\n                    break;\n                }\n            }\n            else if ( line.startsWith( cvsRoot ) )\n            {\n                password = line.substring( cvsRoot.length() + 1 );\n                break;\n            }\n        }\n        return password;\n    }\n\n    static boolean compareCvsRoot( String cvsRoot, String target )\n    {\n        String s1 = completeCvsRootPort( cvsRoot );\n        String s2 = completeCvsRootPort( target );\n        return s1 != null && s1.equals( s2 );\n\n    }\n\n    private static String completeCvsRootPort( String cvsRoot )\n    {\n        String result = cvsRoot;\n        int idx = cvsRoot.indexOf( ':' );\n        for ( int i = 0; i < 2 && idx != -1; i++ )\n        {\n            idx = cvsRoot.indexOf( ':', idx + 1 );\n        }\n        if ( idx != -1 && cvsRoot.charAt( idx + 1 ) == '/' )\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.append( cvsRoot.substring( 0, idx + 1 ) );\n            sb.append( \"2401\" );\n            sb.append( cvsRoot.substring( idx + 1 ) );\n            result = sb.toString();\n        }\n        return result;\n\n    }\n\n    /**\n     * Process the CVS command passed in args[] array with all necessary\n     * options. The only difference from main() method is, that this method\n     * does not exit the JVM and provides command output.\n     *\n     * @param args The command with options\n     */\n    public static boolean processCommand( String[] args, String localPath, CVSListener listener, ScmLogger logger )\n        throws Exception\n    {\n        GlobalOptions globalOptions = new GlobalOptions();\n\n        // Set up any global options specified. These occur before the\n        // name of the command to run\n        int commandIndex;\n\n        try\n        {\n            commandIndex = processGlobalOptions( args, globalOptions );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Invalid argument: \" + e );\n            }\n            return false;\n        }\n\n        // CVSRoot might still be null if the user has NOT decided to set\n        // it with the -d command line global option\n        if ( globalOptions.getCVSRoot() == null )\n        {\n            String cvsRoot = getCVSRoot( localPath );\n            if ( cvsRoot == null )\n            {\n                // if we don't have a CVS root by now, the user has messed up\n                if ( logger.isErrorEnabled() )\n                {\n                    logger.error( \"No CVS root is set. Check your <repository> information in the POM.\" );\n                }\n                return false;\n            }\n            globalOptions.setCVSRoot( cvsRoot );\n        }\n\n        // parse the CVS root into its constituent parts\n        CVSRoot root;\n        final String cvsRoot = globalOptions.getCVSRoot();\n        try\n        {\n            root = CVSRoot.parse( cvsRoot );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Incorrect format for CVSRoot: \" + cvsRoot + \"\\nThe correct format is: \"\n                    + \"[:method:][[user][:password]@][hostname:[port]]/path/to/repository\"\n                    + \"\\nwhere \\\"method\\\" is pserver.\" );\n            }\n            return false;\n        }\n\n        final String command = args[commandIndex];\n\n        // this is not login, but a 'real' cvs command, so construct it,\n        // set the options, and then connect to the server and execute it\n\n        Command c;\n        try\n        {\n            c = CommandFactory.getDefault().createCommand( command, args, ++commandIndex, globalOptions, localPath );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( \"Illegal argument: \" + e.getMessage() );\n            }\n            return false;\n        }\n\n        String password = null;\n\n        if ( CVSRoot.METHOD_PSERVER.equals( root.getMethod() ) )\n        {\n            password = root.getPassword();\n            if ( password != null )\n            {\n                password = StandardScrambler.getInstance().scramble( password );\n            }\n            else\n            {\n                password = lookupPassword( cvsRoot, logger );\n                if ( password == null )\n                {\n                    password = StandardScrambler.getInstance().scramble( \"\" );\n                    // an empty password\n                }\n            }\n        }\n        CvsConnection cvsCommand = new CvsConnection();\n        cvsCommand.setGlobalOptions( globalOptions );\n        cvsCommand.setRepository( root.getRepository() );\n        // the local path is just the path where we executed the\n        // command. This is the case for command-line CVS but not\n        // usually for GUI front-ends\n        cvsCommand.setLocalPath( localPath );\n\n        cvsCommand.connect( root, password );\n        cvsCommand.addListener( listener );\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"Executing CVS command: \" + c.getCVSCommand() );\n        }\n        boolean result = cvsCommand.executeCommand( c );\n        cvsCommand.disconnect();\n        return result;\n    }\n}\n","lineNo":425}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\n\n/**\n * @author Mike Perham\n * @author Olivier Lamy\n *\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n    private String actualRepoLocation = null;\n\n\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, files, tag, new ScmTagParameters( message ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag,\n                                           ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualRepoLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        createLabel( repo, files, tag, consumer, false );\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n        if ( consumer.isSuccess() )\n        {\n            // Now update the label if we need to lock it\n            if ( shouldLock() )\n            {\n                consumer = new PerforceTagConsumer();\n                createLabel( repo, files, tag, consumer, true );\n            }\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n\n        // Unclear what to pass as the first arg\n        return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n    }\n\n    private boolean shouldLock()\n    {\n        return Boolean.valueOf( System.getProperty( \"maven.scm.locktag\", \"true\" ) ).booleanValue();\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl =\n            createLabelsyncCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuilder msg = new StringBuilder( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer,\n                              boolean lock )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        DataOutputStream dos = null;\n        BufferedReader outReader = null;\n        BufferedReader errReader = null;\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            Process proc = cl.execute();\n            dos = new DataOutputStream( proc.getOutputStream() );\n            String label = createLabelSpecification( (PerforceScmProviderRepository) repo, tag, lock );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"LabelSpec: \" + NEWLINE + label );\n            }\n            dos.write( label.getBytes() );\n            dos.close();\n            dos = null;\n            // TODO find & use a less naive InputStream multiplexer\n            outReader = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            errReader = new BufferedReader( new InputStreamReader( proc.getErrorStream() ) );\n            for ( String line = outReader.readLine(); line != null; line = outReader.readLine() )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stdout: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            for ( String line = errReader.readLine(); line != null; line = errReader.readLine() )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stderr: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n\n            outReader.close();\n            outReader = null;\n\n            errReader.close();\n            errReader = null;\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"IOException \" + e.getMessage(), e );\n            }\n        }\n        finally\n        {\n            IOUtil.close( dos );\n            IOUtil.close( outReader );\n            IOUtil.close( errReader );\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"label\" );\n        command.createArg().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                          ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"labelsync\" );\n        command.createArg().setValue( \"-l\" );\n        command.createArg().setValue( tag );\n\n        List<File> fs = files.getFileList();\n        for ( File file : fs )\n        {\n            command.createArg().setValue( file.getPath() );\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label\n     * View: //depot/path/to/repos/...\n     * Owner: mperham\n     */\n    public String createLabelSpecification( PerforceScmProviderRepository repo, String tag, boolean lock )\n    {\n        StringBuilder buf = new StringBuilder();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( PerforceScmProvider.getCanonicalRepoPath( actualRepoLocation ) ).append(\n            NEWLINE );\n        String username = repo.getUser();\n        if ( username == null )\n        {\n            // I have no idea why but Perforce doesn't default the owner to the current user.\n            // Since the user is not explicitly set, we use 'p4 info' to query for the current user.\n            username = PerforceInfoCommand.getInfo( getLogger(), repo ).getEntry( \"User name\" );\n        }\n        buf.append( \"Owner: \" ).append( username ).append( NEWLINE );\n        buf.append( \"Options: \" ).append( lock ? \"\" : \"un\" ).append( \"locked\" ).append( NEWLINE );\n        return buf.toString();\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.util.List;\n\n/**\n * @author Mike Perham\n * @author Olivier Lamy\n *\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n    private String actualRepoLocation = null;\n\n\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, files, tag, new ScmTagParameters( message ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag,\n                                           ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualRepoLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        createLabel( repo, files, tag, consumer, false );\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n        if ( consumer.isSuccess() )\n        {\n            // Now update the label if we need to lock it\n            if ( shouldLock() )\n            {\n                consumer = new PerforceTagConsumer();\n                createLabel( repo, files, tag, consumer, true );\n            }\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n\n        // Unclear what to pass as the first arg\n        return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n    }\n\n    private boolean shouldLock()\n    {\n        return Boolean.valueOf( System.getProperty( \"maven.scm.locktag\", \"true\" ) ).booleanValue();\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl =\n            createLabelsyncCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuilder msg = new StringBuilder( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer,\n                              boolean lock )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        DataOutputStream dos = null;\n        InputStreamReader isReader = null;\n        InputStreamReader isReaderErr = null;\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            Process proc = cl.execute();\n            OutputStream out = proc.getOutputStream();\n            dos = new DataOutputStream( out );\n            String label = createLabelSpecification( (PerforceScmProviderRepository) repo, tag, lock );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"LabelSpec: \" + NEWLINE + label );\n            }\n            dos.write( label.getBytes() );\n            dos.close();\n            out.close();\n            // TODO find & use a less naive InputStream multiplexer\n            isReader = new InputStreamReader( proc.getInputStream() );\n            isReaderErr = new InputStreamReader( proc.getErrorStream() );\n            BufferedReader stdout = new BufferedReader( isReader );\n            BufferedReader stderr = new BufferedReader( isReaderErr );\n            String line;\n            while ( ( line = stdout.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stdout: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            while ( ( line = stderr.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stderr: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            stderr.close();\n            stdout.close();\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"IOException \" + e.getMessage(), e );\n            }\n        }\n        finally\n        {\n            IOUtil.close( dos );\n            IOUtil.close( isReader );\n            IOUtil.close( isReaderErr );\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"label\" );\n        command.createArg().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                          ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"labelsync\" );\n        command.createArg().setValue( \"-l\" );\n        command.createArg().setValue( tag );\n\n        List<File> fs = files.getFileList();\n        for ( File file : fs )\n        {\n            command.createArg().setValue( file.getPath() );\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label\n     * View: //depot/path/to/repos/...\n     * Owner: mperham\n     */\n    public String createLabelSpecification( PerforceScmProviderRepository repo, String tag, boolean lock )\n    {\n        StringBuilder buf = new StringBuilder();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( PerforceScmProvider.getCanonicalRepoPath( actualRepoLocation ) ).append(\n            NEWLINE );\n        String username = repo.getUser();\n        if ( username == null )\n        {\n            // I have no idea why but Perforce doesn't default the owner to the current user.\n            // Since the user is not explicitly set, we use 'p4 info' to query for the current user.\n            username = PerforceInfoCommand.getInfo( getLogger(), repo ).getEntry( \"User name\" );\n        }\n        buf.append( \"Owner: \" ).append( username ).append( NEWLINE );\n        buf.append( \"Options: \" ).append( lock ? \"\" : \"un\" ).append( \"locked\" ).append( NEWLINE );\n        return buf.toString();\n    }\n}\n","lineNo":152}
{"Smelly Sample":"package org.apache.maven.scm.tck.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTckTestCase;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * This test tests the check out command.\n *\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n */\npublic abstract class CheckInCommandTckTest\n    extends ScmTckTestCase\n{\n    public void testCheckInCommandTest()\n        throws Exception\n    {\n        // Make sure that the correct files was checked out\n        File fooJava = new File( getWorkingCopy(), \"src/main/java/Foo.java\" );\n\n        File barJava = new File( getWorkingCopy(), \"src/main/java/Bar.java\" );\n\n        File readmeTxt = new File( getWorkingCopy(), \"readme.txt\" );\n\n        assertFalse( \"check Foo.java doesn't yet exist\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't yet exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        // Change the files\n        createFooJava( fooJava );\n\n        createBarJava( barJava );\n\n        changeReadmeTxt( readmeTxt );\n\n        AddScmResult addResult = getScmManager().add( getScmRepository(),\n                                                      new ScmFileSet( getWorkingCopy(), \"src/main/java/Foo.java\",\n                                                                      null ) );\n\n        assertResultIsSuccess( addResult );\n\n        CheckInScmResult result =\n            getScmManager().checkIn( getScmRepository(), new ScmFileSet( getWorkingCopy() ), \"Commit message\" );\n\n        assertResultIsSuccess( result );\n\n        List<ScmFile> files = result.getCheckedInFiles();\n\n        assertNotNull( files );\n\n        assertEquals( 2, files.size() );\n\n        Map<String, ScmFile> fileMap = mapFilesByPath( files );\n        ScmFile file1 = fileMap.get( \"src/main/java/Foo.java\" );\n        assertNotNull( file1 );\n        assertEquals( ScmFileStatus.CHECKED_IN, file1.getStatus() );\n\n        ScmFile file2 = fileMap.get( \"readme.txt\" );\n        assertNotNull( file2 );\n        assertEquals( ScmFileStatus.CHECKED_IN, file2.getStatus() );\n\n        CheckOutScmResult checkoutResult =\n            getScmManager().checkOut( getScmRepository(), new ScmFileSet( getAssertionCopy() ) );\n\n        assertResultIsSuccess( checkoutResult );\n\n        fooJava = new File( getAssertionCopy(), \"src/main/java/Foo.java\" );\n\n        barJava = new File( getAssertionCopy(), \"src/main/java/Bar.java\" );\n\n        readmeTxt = new File( getAssertionCopy(), \"readme.txt\" );\n\n        assertTrue( \"check can read Foo.java\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        assertEquals( \"check readme.txt contents\", \"changed file\", FileUtils.fileRead( readmeTxt ) );\n    }\n\n    public void testCheckInCommandPartialFileset()\n        throws Exception\n    {\n        // Make sure that the correct files was checked out\n        File fooJava = new File( getWorkingCopy(), \"src/main/java/Foo.java\" );\n\n        File barJava = new File( getWorkingCopy(), \"src/main/java/Bar.java\" );\n\n        File readmeTxt = new File( getWorkingCopy(), \"readme.txt\" );\n\n        assertFalse( \"check Foo.java doesn't yet exist\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't yet exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        // Change the files\n        createFooJava( fooJava );\n\n        createBarJava( barJava );\n\n        changeReadmeTxt( readmeTxt );\n\n        AddScmResult addResult =\n            getScmManager().getProviderByUrl( getScmUrl() ).add( getScmRepository(),\n                                                                 new ScmFileSet( getWorkingCopy(),\n                                                                                 \"src/main/java/Foo.java\", null ) );\n\n        assertResultIsSuccess( addResult );\n\n        CheckInScmResult result =\n            getScmManager().checkIn( getScmRepository(), new ScmFileSet( getWorkingCopy(), \"**/Foo.java\", null ),\n                                     \"Commit message\" );\n\n        assertResultIsSuccess( result );\n\n        List<ScmFile> files = result.getCheckedInFiles();\n\n        assertNotNull( files );\n\n        assertEquals( 1, files.size() );\n\n        ScmFile file1 = files.get( 0 );\n\n        assertEquals( ScmFileStatus.CHECKED_IN, file1.getStatus() );\n\n        assertPath( \"/test-repo/check-in/Foo.java\", file1.getPath() );\n\n        CheckOutScmResult checkoutResult =\n            getScmManager().checkOut( getScmRepository(), new ScmFileSet( getAssertionCopy() ) );\n\n        assertResultIsSuccess( checkoutResult );\n\n        fooJava = new File( getAssertionCopy(), \"src/main/java/Foo.java\" );\n\n        barJava = new File( getAssertionCopy(), \"src/main/java/Bar.java\" );\n\n        readmeTxt = new File( getAssertionCopy(), \"readme.txt\" );\n\n        assertTrue( \"check can read Foo.java\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        assertEquals( \"check readme.txt contents\", \"/readme.txt\", FileUtils.fileRead( readmeTxt ) );\n    }\n\n    private void createFooJava( File fooJava )\n        throws Exception\n    {\n        PrintWriter writer = null;\n        try\n        {\n            writer = new PrintWriter( new FileWriter( fooJava ) );\n            writer.println( \"public class Foo\" );\n            writer.println( \"{\" );\n\n            writer.println( \"    public void foo()\" );\n            writer.println( \"    {\" );\n            writer.println( \"        int i = 10;\" );\n            writer.println( \"    }\" );\n\n            writer.println( \"}\" );\n\n            writer.close();\n            writer = null;\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    private void createBarJava( File barJava )\n        throws Exception\n    {\n        FileWriter output = new FileWriter( barJava );\n\n        PrintWriter printer = new PrintWriter( output );\n\n        printer.println( \"public class Bar\" );\n        printer.println( \"{\" );\n\n        printer.println( \"    public int bar()\" );\n        printer.println( \"    {\" );\n        printer.println( \"        return 20;\" );\n        printer.println( \"    }\" );\n\n        printer.println( \"}\" );\n\n        printer.close();\n\n        output.close();\n    }\n\n    private void changeReadmeTxt( File readmeTxt )\n        throws Exception\n    {\n        FileWriter output = null;\n        try\n        {\n            output = new FileWriter( readmeTxt );\n            output.write( \"changed file\" );\n            output.close();\n            output = null;\n        }\n        finally\n        {\n            IOUtil.close( output );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.tck.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTckTestCase;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * This test tests the check out command.\n *\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n */\npublic abstract class CheckInCommandTckTest\n    extends ScmTckTestCase\n{\n    public void testCheckInCommandTest()\n        throws Exception\n    {\n        // Make sure that the correct files was checked out\n        File fooJava = new File( getWorkingCopy(), \"src/main/java/Foo.java\" );\n\n        File barJava = new File( getWorkingCopy(), \"src/main/java/Bar.java\" );\n\n        File readmeTxt = new File( getWorkingCopy(), \"readme.txt\" );\n\n        assertFalse( \"check Foo.java doesn't yet exist\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't yet exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        // Change the files\n        createFooJava( fooJava );\n\n        createBarJava( barJava );\n\n        changeReadmeTxt( readmeTxt );\n\n        AddScmResult addResult = getScmManager().add( getScmRepository(),\n                                                      new ScmFileSet( getWorkingCopy(), \"src/main/java/Foo.java\",\n                                                                      null ) );\n\n        assertResultIsSuccess( addResult );\n\n        CheckInScmResult result =\n            getScmManager().checkIn( getScmRepository(), new ScmFileSet( getWorkingCopy() ), \"Commit message\" );\n\n        assertResultIsSuccess( result );\n\n        List<ScmFile> files = result.getCheckedInFiles();\n\n        assertNotNull( files );\n\n        assertEquals( 2, files.size() );\n\n        Map<String, ScmFile> fileMap = mapFilesByPath( files );\n        ScmFile file1 = fileMap.get( \"src/main/java/Foo.java\" );\n        assertNotNull( file1 );\n        assertEquals( ScmFileStatus.CHECKED_IN, file1.getStatus() );\n\n        ScmFile file2 = fileMap.get( \"readme.txt\" );\n        assertNotNull( file2 );\n        assertEquals( ScmFileStatus.CHECKED_IN, file2.getStatus() );\n\n        CheckOutScmResult checkoutResult =\n            getScmManager().checkOut( getScmRepository(), new ScmFileSet( getAssertionCopy() ) );\n\n        assertResultIsSuccess( checkoutResult );\n\n        fooJava = new File( getAssertionCopy(), \"src/main/java/Foo.java\" );\n\n        barJava = new File( getAssertionCopy(), \"src/main/java/Bar.java\" );\n\n        readmeTxt = new File( getAssertionCopy(), \"readme.txt\" );\n\n        assertTrue( \"check can read Foo.java\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        assertEquals( \"check readme.txt contents\", \"changed file\", FileUtils.fileRead( readmeTxt ) );\n    }\n\n    public void testCheckInCommandPartialFileset()\n        throws Exception\n    {\n        // Make sure that the correct files was checked out\n        File fooJava = new File( getWorkingCopy(), \"src/main/java/Foo.java\" );\n\n        File barJava = new File( getWorkingCopy(), \"src/main/java/Bar.java\" );\n\n        File readmeTxt = new File( getWorkingCopy(), \"readme.txt\" );\n\n        assertFalse( \"check Foo.java doesn't yet exist\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't yet exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        // Change the files\n        createFooJava( fooJava );\n\n        createBarJava( barJava );\n\n        changeReadmeTxt( readmeTxt );\n\n        AddScmResult addResult =\n            getScmManager().getProviderByUrl( getScmUrl() ).add( getScmRepository(),\n                                                                 new ScmFileSet( getWorkingCopy(),\n                                                                                 \"src/main/java/Foo.java\", null ) );\n\n        assertResultIsSuccess( addResult );\n\n        CheckInScmResult result =\n            getScmManager().checkIn( getScmRepository(), new ScmFileSet( getWorkingCopy(), \"**/Foo.java\", null ),\n                                     \"Commit message\" );\n\n        assertResultIsSuccess( result );\n\n        List<ScmFile> files = result.getCheckedInFiles();\n\n        assertNotNull( files );\n\n        assertEquals( 1, files.size() );\n\n        ScmFile file1 = files.get( 0 );\n\n        assertEquals( ScmFileStatus.CHECKED_IN, file1.getStatus() );\n\n        assertPath( \"/test-repo/check-in/Foo.java\", file1.getPath() );\n\n        CheckOutScmResult checkoutResult =\n            getScmManager().checkOut( getScmRepository(), new ScmFileSet( getAssertionCopy() ) );\n\n        assertResultIsSuccess( checkoutResult );\n\n        fooJava = new File( getAssertionCopy(), \"src/main/java/Foo.java\" );\n\n        barJava = new File( getAssertionCopy(), \"src/main/java/Bar.java\" );\n\n        readmeTxt = new File( getAssertionCopy(), \"readme.txt\" );\n\n        assertTrue( \"check can read Foo.java\", fooJava.canRead() );\n\n        assertFalse( \"check Bar.java doesn't exist\", barJava.canRead() );\n\n        assertTrue( \"check can read readme.txt\", readmeTxt.canRead() );\n\n        assertEquals( \"check readme.txt contents\", \"/readme.txt\", FileUtils.fileRead( readmeTxt ) );\n    }\n\n    private void createFooJava( File fooJava )\n        throws Exception\n    {\n        FileWriter output = new FileWriter( fooJava );\n\n        PrintWriter printer = new PrintWriter( output );\n        try\n        {\n            printer.println( \"public class Foo\" );\n            printer.println( \"{\" );\n\n            printer.println( \"    public void foo()\" );\n            printer.println( \"    {\" );\n            printer.println( \"        int i = 10;\" );\n            printer.println( \"    }\" );\n\n            printer.println( \"}\" );\n        }\n        finally\n        {\n            IOUtil.close( output );\n            IOUtil.close( printer );\n        }\n    }\n\n    private void createBarJava( File barJava )\n        throws Exception\n    {\n        FileWriter output = new FileWriter( barJava );\n\n        PrintWriter printer = new PrintWriter( output );\n\n        printer.println( \"public class Bar\" );\n        printer.println( \"{\" );\n\n        printer.println( \"    public int bar()\" );\n        printer.println( \"    {\" );\n        printer.println( \"        return 20;\" );\n        printer.println( \"    }\" );\n\n        printer.println( \"}\" );\n\n        printer.close();\n\n        output.close();\n    }\n\n    private void changeReadmeTxt( File readmeTxt )\n        throws Exception\n    {\n        FileWriter output = null;\n\n        try\n        {\n            output = new FileWriter( readmeTxt );\n\n            output.write( \"changed file\" );\n        }\n        finally\n        {\n            IOUtil.close( output );\n        }\n    }\n}\n","lineNo":186}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n */\npublic class GitStatusConsumer\n    implements StreamConsumer\n{\n\n    /**\n     * The pattern used to match added file lines\n     */\n    private static final Pattern ADDED_PATTERN = Pattern.compile( \"^A[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match modified file lines\n     */\n    private static final Pattern MODIFIED_PATTERN = Pattern.compile( \"^ *M[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match deleted file lines\n     */\n    private static final Pattern DELETED_PATTERN = Pattern.compile( \"^ *D * (.*)$\" );\n\n    /**\n     * The pattern used to match renamed file lines\n     */\n    private static final Pattern RENAMED_PATTERN = Pattern.compile( \"^R  (.*) -> (.*)$\" );\n\n    private ScmLogger logger;\n\n    private File workingDirectory;\n\n    /**\n     * Entries are relative to working directory, not to the repositoryroot\n     */\n    private List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n    private URI relativeRepositoryPath;\n    \n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Consumer when workingDirectory and repositoryRootDirectory are the same\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory )\n    {\n        this.logger = logger;\n        this.workingDirectory = workingDirectory;\n    }\n\n    /**\n     * Assuming that you have to discover the repositoryRoot, this is how you can get the\n     * <code>relativeRepositoryPath<\/code>\n     * <pre>\n     * URI.create( repositoryRoot ).relativize( fileSet.getBasedir().toURI() )\n     * <\/pre>\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     * @param relativeRepositoryPath the working directory relative to the repository root\n     * @since 1.9\n     * @see GitStatusCommand#createRevparseShowToplevelCommand(org.apache.maven.scm.ScmFileSet)\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory, URI relativeRepositoryPath )\n    {\n        this( logger, workingDirectory );\n        this.relativeRepositoryPath = relativeRepositoryPath;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( line );\n        }\n        if ( StringUtils.isEmpty( line ) )\n        {\n            return;\n        }\n\n        ScmFileStatus status = null;\n\n        List<String> files = new ArrayList<String>();\n        \n        Matcher matcher;\n        if ( ( matcher = ADDED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.ADDED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = MODIFIED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.MODIFIED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = DELETED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.DELETED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = RENAMED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.RENAMED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n            files.add( resolvePath( matcher.group( 2 ), relativeRepositoryPath ) );\n            logger.debug( \"RENAMED status for line '\" + line + \"' files added '\" + matcher.group( 1 ) + \"' '\"\n                              + matcher.group( 2 ) );\n        }\n        else\n        {\n            logger.warn( \"Ignoring unrecognized line: \" + line );\n            return;\n        }\n\n        // If the file isn't a file; don't add it.\n        if ( !files.isEmpty() && status != null )\n        {\n            if ( workingDirectory != null )\n            {\n                if ( status == ScmFileStatus.RENAMED )\n                {\n                    String oldFilePath = files.get( 0 );\n                    String newFilePath = files.get( 1 );\n                    if ( isFile( oldFilePath ) )\n                    {\n                        logger.debug( \"file '\" + oldFilePath + \"' is a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug( \"file '\" + oldFilePath + \"' not a file\" );\n                    }\n                    if ( !isFile( newFilePath ) )\n                    {\n                        logger.debug( \"file '\" + newFilePath + \"' not a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug( \"file '\" + newFilePath + \"' is a file\" );\n                    }\n                }\n                else if ( status == ScmFileStatus.DELETED )\n                {\n                    if ( isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n                else\n                {\n                    if ( !isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n            }\n\n            for ( String file : files )\n            {\n                changedFiles.add( new ScmFile( file, status ) );\n            }\n        }\n    }\n\n    private boolean isFile( String file )\n    {\n        File targetFile;\n        if ( relativeRepositoryPath == null )\n        {\n            targetFile = new File( workingDirectory, file );\n        }\n        else\n        {\n            targetFile = new File( relativeRepositoryPath.getPath(), file );\n        }\n        return targetFile.isFile();\n    }\n\n    protected static String resolvePath( String fileEntry, URI path )\n    {\n        if ( path != null )\n        {\n            return resolveURI( fileEntry, path ).getPath();\n        }\n        else\n        {\n            return fileEntry;\n        }\n    }\n\n    /**\n     * \n     * @param fileEntry the fileEntry, must not be {@code null}\n     * @param path the path, must not be {@code null}\n     * @return\n     */\n    public static URI resolveURI( String fileEntry, URI path )\n    {\n        // When using URI.create, spaces need to be escaped but not the slashes, so we can't use\n        // URLEncoder.encode( String, String )\n        // new File( String ).toURI() results in an absolute URI while path is relative, so that can't be used either.\n        String str = fileEntry.replace( \" \", \"%20\" );\n        return path.relativize( URI.create( str ) );\n    }\n\n\n    public List<ScmFile> getChangedFiles()\n    {\n        return changedFiles;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n */\npublic class GitStatusConsumer\n    implements StreamConsumer\n{\n\n    /**\n     * The pattern used to match added file lines\n     */\n    private static final Pattern ADDED_PATTERN = Pattern.compile( \"^A[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match modified file lines\n     */\n    private static final Pattern MODIFIED_PATTERN = Pattern.compile( \"^ *M[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match deleted file lines\n     */\n    private static final Pattern DELETED_PATTERN = Pattern.compile( \"^ *D * (.*)$\" );\n\n    /**\n     * The pattern used to match renamed file lines\n     */\n    private static final Pattern RENAMED_PATTERN = Pattern.compile( \"^R  (.*) -> (.*)$\" );\n\n    private ScmLogger logger;\n\n    private File workingDirectory;\n\n    /**\n     * Entries are relative to working directory, not to the repositoryroot\n     */\n    private List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n    private URI relativeRepositoryPath;\n    \n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Consumer when workingDirectory and repositoryRootDirectory are the same\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory )\n    {\n        this.logger = logger;\n        this.workingDirectory = workingDirectory;\n    }\n\n    /**\n     * Assuming that you have to discover the repositoryRoot, this is how you can get the\n     * <code>relativeRepositoryPath<\/code>\n     * <pre>\n     * URI.create( repositoryRoot ).relativize( fileSet.getBasedir().toURI() )\n     * <\/pre>\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     * @param relativeRepositoryPath the working directory relative to the repository root\n     * @since 1.9\n     * @see GitStatusCommand#createRevparseShowToplevelCommand(org.apache.maven.scm.ScmFileSet)\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory, URI relativeRepositoryPath )\n    {\n        this( logger, workingDirectory );\n        this.relativeRepositoryPath = relativeRepositoryPath;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( line );\n        }\n        if ( StringUtils.isEmpty( line ) )\n        {\n            return;\n        }\n\n        ScmFileStatus status = null;\n\n        List<String> files = new ArrayList<String>();\n        \n        Matcher matcher;\n        if ( ( matcher = ADDED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.ADDED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = MODIFIED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.MODIFIED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = DELETED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.DELETED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = RENAMED_PATTERN.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.RENAMED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n            files.add( resolvePath( matcher.group( 2 ), relativeRepositoryPath ) );\n            logger.debug( \"RENAMED status for line '\" + line + \"' files added '\" + matcher.group( 1 ) + \"' '\"\n                              + matcher.group( 2 ) );\n        }\n        else\n        {\n            logger.warn( \"Ignoring unrecognized line: \" + line );\n            return;\n        }\n\n        // If the file isn't a file; don't add it.\n        if ( !files.isEmpty() && status != null )\n        {\n            if ( workingDirectory != null )\n            {\n                if ( status == ScmFileStatus.RENAMED )\n                {\n                    String oldFilePath = files.get( 0 );\n                    String newFilePath = files.get( 1 );\n                    if ( isFile( oldFilePath ) )\n                    {\n                        logger.debug( \"file '\" + oldFilePath + \"' is a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug( \"file '\" + oldFilePath + \"' not a file\" );\n                    }\n                    if ( !isFile( newFilePath ) )\n                    {\n                        logger.debug( \"file '\" + newFilePath + \"' not a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug( \"file '\" + newFilePath + \"' is a file\" );\n                    }\n                }\n                else if ( status == ScmFileStatus.DELETED )\n                {\n                    if ( isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n                else\n                {\n                    if ( !isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n            }\n\n            for ( String file : files )\n            {\n                changedFiles.add( new ScmFile( file, status ) );\n            }\n        }\n    }\n\n    private boolean isFile( String file )\n    {\n        File targetFile;\n        if ( relativeRepositoryPath == null )\n        {\n            targetFile = new File( workingDirectory, file );\n        }\n        else\n        {\n            targetFile = new File( relativeRepositoryPath.getPath(), file );\n        }\n        return targetFile.isFile();\n    }\n\n    protected static String resolvePath(String fileEntry, URI path) {\n        /* Quotes may be included (from the git status line) when an fileEntry includes spaces */\n        String cleanedEntry = stripQuotes(fileEntry);\n        if (path != null) {\n            return resolveURI(cleanedEntry, path).getPath();\n        } else {\n            return cleanedEntry;\n        }\n    }\n\n    /**\n     * \n     * @param fileEntry the fileEntry, must not be {@code null}\n     * @param path the path, must not be {@code null}\n     * @return\n     */\n    public static URI resolveURI( String fileEntry, URI path )\n    {\n        // When using URI.create, spaces need to be escaped but not the slashes, so we can't use\n        // URLEncoder.encode( String, String )\n        // new File( String ).toURI() results in an absolute URI while path is relative, so that can't be used either.\n        return path.relativize(URI.create(stripQuotes(fileEntry).replace(\" \", \"%20\")));\n    }\n\n\n    public List<ScmFile> getChangedFiles()\n    {\n        return changedFiles;\n    }\n\n    /**\n     * @param str the (potentially quoted) string, must not be {@code null}\n     * @return the string with a pair of double quotes removed (if they existed)\n     */\n    private static String stripQuotes(String str) {\n        int strLen = str.length();\n        return (strLen > 0 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\")) ? str.substring(1, strLen - 1) : str;\n    }\n}\n","lineNo":227}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.accurev.util.WorkspaceUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\npublic class AccuRevScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    public static final String DEFAULT_TAG_FORMAT = \"%s\";\n\n    private AccuRev accurev;\n\n    private String streamName;\n\n    private String projectPath;\n\n    private String tagFormat = DEFAULT_TAG_FORMAT;\n\n    private ScmLogger logger;\n\n    public AccuRevScmProviderRepository()\n    {\n        super();\n        // True is a more sensible default (ie for tck tests)\n        // TODO raise jira so tck tests properly handle setPersist\n        setPersistCheckout( true );\n\n        setShouldUseExportForNonPersistentCheckout( true );\n    }\n\n    public String getTagFormat()\n    {\n        return tagFormat;\n    }\n\n    public void setTagFormat( String tagFormat )\n    {\n        if ( tagFormat == null || !tagFormat.contains( \"%s\" ) )\n        {\n            throw new IllegalArgumentException( \"tagFormat must contain '%s' to be replaced\" );\n        }\n        this.tagFormat = tagFormat;\n    }\n\n    public String getStreamName()\n    {\n        return streamName;\n    }\n\n    public void setStreamName( String streamName )\n    {\n        this.streamName = streamName;\n    }\n\n    public String getProjectPath()\n    {\n        return projectPath;\n    }\n\n    public void setProjectPath( String projectPath )\n    {\n        this.projectPath = projectPath;\n        setCheckoutRelativePath( projectPath );\n    }\n\n    public AccuRev getAccuRev()\n    {\n        return this.accurev;\n    }\n\n    public void setAccuRev( AccuRev accurev )\n    {\n        this.accurev = accurev;\n    }\n\n    /**\n     * @param info\n     * @return true if info indicates a root of the workspace.\n     */\n    public boolean isWorkSpaceRoot( AccuRevInfo info )\n    {\n        return ( ( getProjectPath() != null && WorkspaceUtils.isSameFile(info.getBasedir(), new File( info.getTop(), getProjectPath() ) ) ) || isWorkSpaceTop( info ) );\n    }\n\n    public boolean isWorkSpaceTop( AccuRevInfo info )\n    {\n        return info.isWorkSpaceTop();      \n\n    }\n\n   \n    String tagToStream( String tagName )\n    {\n        return String.format( getTagFormat(), tagName );\n    }\n\n    String streamToTag( String streamName )\n    {\n        tagFormat = getTagFormat();\n        // TODO - strictly we should quote either side of the %s\n        String tagPatternString = tagToStream( \"(.*)\" );\n        Pattern tagPattern = Pattern.compile( tagPatternString );\n\n        Matcher tagMatcher = tagPattern.matcher( streamName );\n        if ( tagMatcher.matches() )\n        {\n            return tagMatcher.group( 1 );\n        }\n        else\n        {\n            return streamName;\n        }\n\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    // TODO raise JIRA to pull up these methods to ScmProviderRepository\n\n    private String checkoutRelativePath;\n\n    private boolean shouldUseExportForNonPersistentCheckout = true;\n\n    /**\n     * The relative path of the directory of the checked out project in comparison to the checkout directory, or an\n     * empty String in case the checkout directory equals the project directory.\n     * <p/>\n     * With most SCMs, this is just an empty String, meaning that the checkout directory equals the project directory.\n     * But there are cases (e.g. ClearCase) where within the checkout directory, the directory structure of the SCM\n     * system is repeated. E.g. if you check out the project \"my/project\" to \"/some/dir\", the project sources are\n     * actually checked out to \"some/dir/my/project\". In this example, relativePathProjectDirectory would contain\n     * \"my/project\".\n     */\n    public String getCheckoutRelativePath()\n    {\n        if ( this.checkoutRelativePath == null )\n        {\n            return \"\";\n        }\n        return this.checkoutRelativePath;\n    }\n\n    public void setCheckoutRelativePath( String checkoutRelativePath )\n    {\n        this.checkoutRelativePath = checkoutRelativePath;\n    }\n\n    /**\n     * Relative project path for export\n     * \n     * @return default same as {@link #getCheckoutRelativePath()}\n     */\n    public String getExportRelativePath()\n    {\n        return getCheckoutRelativePath();\n    }\n\n    /**\n     * When checkout is not expected to be refreshed or committed, should export be used instead? Perforce, Clearcase\n     * and AccuRev store their meta-data about file status within the server rather than files in the source tree. This\n     * makes checkouts within checkouts (eg release:perform) difficult. Typically there is a way to do a lightweight\n     * export instead which can be implemented as the \"export\" command. This is a hint to downstream applications that\n     * \"export\" is available and should be used in preference to \"checkout\" in cases where \"update\" and \"commit\" are not\n     * intended to be used. (ie release:perform)\n     * \n     * @return false by default\n     */\n    public boolean shouldUseExportForNonPersistentCheckout()\n    {\n        return this.shouldUseExportForNonPersistentCheckout;\n    }\n\n    public void setShouldUseExportForNonPersistentCheckout( boolean shouldUseExportForNonPersistentCheckout )\n    {\n        this.shouldUseExportForNonPersistentCheckout = shouldUseExportForNonPersistentCheckout;\n    }\n\n    public String getDepotRelativeProjectPath()\n    {\n        return \"/./\" + ( projectPath == null ? \"\" : projectPath );\n    }\n\n    public AccuRevVersion getAccuRevVersion( ScmVersion scmVersion )\n    {\n\n        String tran = null;\n        String basisStream = null;\n\n        if ( scmVersion == null )\n        {\n            basisStream = getStreamName();\n        }\n        else\n        {\n            String name = StringUtils.clean( scmVersion.getName() );\n\n            String[] versionComponents = name.split( \"[/\\\\\\\\]\", 2 );\n            basisStream = versionComponents[0];\n            if ( basisStream.length() == 0 )\n            {\n                // Use the default stream from the URL\n                basisStream = getStreamName();\n            }\n            else\n            {\n                // name is a tag name - convert to a stream.\n                basisStream = tagToStream( basisStream );\n            }\n\n            if ( versionComponents.length == 2 && versionComponents[1].length() > 0 )\n            {\n                tran = versionComponents[1];\n            }\n        }\n\n        return new AccuRevVersion( basisStream, tran );\n    }\n\n    public String getSnapshotName( String tagName )\n    {\n        return tagToStream( tagName );\n    }\n\n    public String getRevision( String streamName, Date date )\n    {\n        return getRevision( streamName, AccuRev.ACCUREV_TIME_SPEC.format( date == null ? new Date() : date ) );\n    }\n\n    public String getRevision( String stream, long fromTranId )\n    {\n        return getRevision( stream, Long.toString( fromTranId ) );\n    }\n\n    public String getRevision( String streamName, String transaction )\n    {\n        return streamToTag( streamName ) + \"/\" + transaction;\n    }\n\n    public String getWorkSpaceRevision( String workspace )\n        throws AccuRevException\n    {\n        return getRevision( workspace, Long.toString( getCurrentTransactionId( workspace ) ) );\n    }\n\n    public Transaction getDepotTransaction( String stream, String tranSpec )\n        throws AccuRevException\n    {\n\n        if ( tranSpec == null )\n        {\n            tranSpec = \"now\";\n        }\n\n        List<Transaction> transactions = getAccuRev().history( stream, tranSpec, null, 1, true, true );\n\n        if ( transactions == null || transactions.isEmpty() )\n        {\n            logger.warn( \"Unable to find transaction for tranSpec=\" + tranSpec );\n            return null;\n        }\n        else\n        {\n            return transactions.get( 0 );\n        }\n\n    }\n\n    public String getDepotTransactionId( String stream, String tranSpec )\n        throws AccuRevException\n    {\n        Transaction t = getDepotTransaction( stream, tranSpec );\n\n        return t == null ? tranSpec : Long.toString( t.getTranId() );\n    }\n\n    private long getCurrentTransactionId( String workSpaceName )\n        throws AccuRevException\n    {\n        // AccuRev does not have a way to get at this workspace info by name.\n        // So we have to do it the hard way...\n\n        AccuRev accuRev = getAccuRev();\n\n        Map<String, WorkSpace> workSpaces = accuRev.showWorkSpaces();\n\n        WorkSpace workspace = workSpaces.get( workSpaceName );\n\n        if ( workspace == null )\n        {\n            // Must be a reftree\n            workSpaces = accuRev.showRefTrees();\n            workspace = workSpaces.get( workSpaceName );\n        }\n\n        if ( workspace == null )\n        {\n            throw new AccuRevException( \"Can't find workspace \" + workSpaceName );\n        }\n        return workspace.getTransactionId();\n    }\n\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder( \"AccuRevScmProviderRepository\" );\n        buff.append( \" user=\" );\n        buff.append( getUser() );\n        buff.append( \" pass=\" );\n        buff.append( getPassword() == null ? \"null\" : StringUtils.repeat( \"*\", getPassword().length() ) );\n        buff.append( \" host=\" );\n        buff.append( getHost() );\n        buff.append( \" port=\" );\n        buff.append( getPort() );\n        buff.append( \" stream=\" );\n        buff.append( getStreamName() );\n        buff.append( \" projectPath=\" );\n        buff.append( getProjectPath() );\n\n        return buff.toString();\n    }\n\n    public static String formatTimeSpec( Date when )\n    {\n\n        if ( when == null )\n        {\n            return \"now\";\n        }\n\n        return AccuRev.ACCUREV_TIME_SPEC.format( when );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.accurev.util.WorkspaceUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * \n */\npublic class AccuRevScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    public static final String DEFAULT_TAG_FORMAT = \"%s\";\n\n    private AccuRev accurev;\n\n    private String streamName;\n\n    private String projectPath;\n\n    private String tagFormat = DEFAULT_TAG_FORMAT;\n\n    private ScmLogger logger;\n\n    public AccuRevScmProviderRepository()\n    {\n        super();\n        // True is a more sensible default (ie for tck tests)\n        // TODO raise jira so tck tests properly handle setPersist\n        setPersistCheckout( true );\n\n        setShouldUseExportForNonPersistentCheckout( true );\n    }\n\n    public String getTagFormat()\n    {\n        return tagFormat;\n    }\n\n    public void setTagFormat( String tagFormat )\n    {\n        if ( tagFormat == null || !tagFormat.contains( \"%s\" ) )\n        {\n            throw new IllegalArgumentException( \"tagFormat must contain '%s' to be replaced\" );\n        }\n        this.tagFormat = tagFormat;\n    }\n\n    public String getStreamName()\n    {\n        return streamName;\n    }\n\n    public void setStreamName( String streamName )\n    {\n        this.streamName = streamName;\n    }\n\n    public String getProjectPath()\n    {\n        return projectPath;\n    }\n\n    public void setProjectPath( String projectPath )\n    {\n        this.projectPath = projectPath;\n        setCheckoutRelativePath( projectPath );\n    }\n\n    public AccuRev getAccuRev()\n    {\n        return this.accurev;\n    }\n\n    public void setAccuRev( AccuRev accurev )\n    {\n        this.accurev = accurev;\n    }\n\n    /**\n     * @param info\n     * @return true if info indicates a root of the workspace.\n     */\n    public boolean isWorkSpaceRoot( AccuRevInfo info )\n    {\n        String p = getProjectPath();\n        return ( p != null && WorkspaceUtils.isSameFile( info.getBasedir(), new File( info.getTop(), p ) ) )\n            || isWorkSpaceTop( info );\n    }\n\n    public boolean isWorkSpaceTop( AccuRevInfo info )\n    {\n        return info.isWorkSpaceTop();      \n\n    }\n\n    String tagToStream( String tagName )\n    {\n        return String.format( getTagFormat(), tagName );\n    }\n\n    String streamToTag( String streamName )\n    {\n        tagFormat = getTagFormat();\n        // TODO - strictly we should quote either side of the %s\n        String tagPatternString = tagToStream( \"(.*)\" );\n        Pattern tagPattern = Pattern.compile( tagPatternString );\n\n        Matcher tagMatcher = tagPattern.matcher( streamName );\n        if ( tagMatcher.matches() )\n        {\n            return tagMatcher.group( 1 );\n        }\n        else\n        {\n            return streamName;\n        }\n\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    // TODO raise JIRA to pull up these methods to ScmProviderRepository\n\n    private String checkoutRelativePath;\n\n    private boolean shouldUseExportForNonPersistentCheckout = true;\n\n    /**\n     * The relative path of the directory of the checked out project in comparison to the checkout directory, or an\n     * empty String in case the checkout directory equals the project directory.\n     * <p/>\n     * With most SCMs, this is just an empty String, meaning that the checkout directory equals the project directory.\n     * But there are cases (e.g. ClearCase) where within the checkout directory, the directory structure of the SCM\n     * system is repeated. E.g. if you check out the project \"my/project\" to \"/some/dir\", the project sources are\n     * actually checked out to \"some/dir/my/project\". In this example, relativePathProjectDirectory would contain\n     * \"my/project\".\n     */\n    public String getCheckoutRelativePath()\n    {\n        if ( this.checkoutRelativePath == null )\n        {\n            return \"\";\n        }\n        return this.checkoutRelativePath;\n    }\n\n    public void setCheckoutRelativePath( String checkoutRelativePath )\n    {\n        this.checkoutRelativePath = checkoutRelativePath;\n    }\n\n    /**\n     * Relative project path for export\n     * \n     * @return default same as {@link #getCheckoutRelativePath()}\n     */\n    public String getExportRelativePath()\n    {\n        return getCheckoutRelativePath();\n    }\n\n    /**\n     * When checkout is not expected to be refreshed or committed, should export be used instead? Perforce, Clearcase\n     * and AccuRev store their meta-data about file status within the server rather than files in the source tree. This\n     * makes checkouts within checkouts (eg release:perform) difficult. Typically there is a way to do a lightweight\n     * export instead which can be implemented as the \"export\" command. This is a hint to downstream applications that\n     * \"export\" is available and should be used in preference to \"checkout\" in cases where \"update\" and \"commit\" are not\n     * intended to be used. (ie release:perform)\n     * \n     * @return false by default\n     */\n    public boolean shouldUseExportForNonPersistentCheckout()\n    {\n        return this.shouldUseExportForNonPersistentCheckout;\n    }\n\n    public void setShouldUseExportForNonPersistentCheckout( boolean shouldUseExportForNonPersistentCheckout )\n    {\n        this.shouldUseExportForNonPersistentCheckout = shouldUseExportForNonPersistentCheckout;\n    }\n\n    public String getDepotRelativeProjectPath()\n    {\n        return \"/./\" + ( projectPath == null ? \"\" : projectPath );\n    }\n\n    public AccuRevVersion getAccuRevVersion( ScmVersion scmVersion )\n    {\n\n        String tran = null;\n        String basisStream = null;\n\n        if ( scmVersion == null )\n        {\n            basisStream = getStreamName();\n        }\n        else\n        {\n            String name = StringUtils.clean( scmVersion.getName() );\n\n            String[] versionComponents = name.split( \"[/\\\\\\\\]\", 2 );\n            basisStream = versionComponents[0];\n            if ( basisStream.length() == 0 )\n            {\n                // Use the default stream from the URL\n                basisStream = getStreamName();\n            }\n            else\n            {\n                // name is a tag name - convert to a stream.\n                basisStream = tagToStream( basisStream );\n            }\n\n            if ( versionComponents.length == 2 && versionComponents[1].length() > 0 )\n            {\n                tran = versionComponents[1];\n            }\n        }\n\n        return new AccuRevVersion( basisStream, tran );\n    }\n\n    public String getSnapshotName( String tagName )\n    {\n        return tagToStream( tagName );\n    }\n\n    public String getRevision( String streamName, Date date )\n    {\n        return getRevision( streamName, AccuRev.ACCUREV_TIME_SPEC.format( date == null ? new Date() : date ) );\n    }\n\n    public String getRevision( String stream, long fromTranId )\n    {\n        return getRevision( stream, Long.toString( fromTranId ) );\n    }\n\n    public String getRevision( String streamName, String transaction )\n    {\n        return streamToTag( streamName ) + \"/\" + transaction;\n    }\n\n    public String getWorkSpaceRevision( String workspace )\n        throws AccuRevException\n    {\n        return getRevision( workspace, Long.toString( getCurrentTransactionId( workspace ) ) );\n    }\n\n    public Transaction getDepotTransaction( String stream, String tranSpec )\n        throws AccuRevException\n    {\n\n        if ( tranSpec == null )\n        {\n            tranSpec = \"now\";\n        }\n\n        List<Transaction> transactions = getAccuRev().history( stream, tranSpec, null, 1, true, true );\n\n        if ( transactions == null || transactions.isEmpty() )\n        {\n            logger.warn( \"Unable to find transaction for tranSpec=\" + tranSpec );\n            return null;\n        }\n        else\n        {\n            return transactions.get( 0 );\n        }\n\n    }\n\n    public String getDepotTransactionId( String stream, String tranSpec )\n        throws AccuRevException\n    {\n        Transaction t = getDepotTransaction( stream, tranSpec );\n\n        return t == null ? tranSpec : Long.toString( t.getTranId() );\n    }\n\n    private long getCurrentTransactionId( String workSpaceName )\n        throws AccuRevException\n    {\n        // AccuRev does not have a way to get at this workspace info by name.\n        // So we have to do it the hard way...\n\n        AccuRev accuRev = getAccuRev();\n\n        Map<String, WorkSpace> workSpaces = accuRev.showWorkSpaces();\n\n        WorkSpace workspace = workSpaces.get( workSpaceName );\n\n        if ( workspace == null )\n        {\n            // Must be a reftree\n            workSpaces = accuRev.showRefTrees();\n            workspace = workSpaces.get( workSpaceName );\n        }\n\n        if ( workspace == null )\n        {\n            throw new AccuRevException( \"Can't find workspace \" + workSpaceName );\n        }\n        return workspace.getTransactionId();\n    }\n\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder( \"AccuRevScmProviderRepository\" );\n        buff.append( \" user=\" );\n        buff.append( getUser() );\n        buff.append( \" pass=\" );\n        buff.append( getPassword() == null ? \"null\" : StringUtils.repeat( \"*\", getPassword().length() ) );\n        buff.append( \" host=\" );\n        buff.append( getHost() );\n        buff.append( \" port=\" );\n        buff.append( getPort() );\n        buff.append( \" stream=\" );\n        buff.append( getStreamName() );\n        buff.append( \" projectPath=\" );\n        buff.append( getProjectPath() );\n\n        return buff.toString();\n    }\n\n    public static String formatTimeSpec( Date when )\n    {\n\n        if ( when == null )\n        {\n            return \"now\";\n        }\n\n        return AccuRev.ACCUREV_TIME_SPEC.format( when );\n\n    }\n\n}\n","lineNo":114}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) ) == 0 ? updatedFiles\n                        : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) ) == 0 ? promotedFiles\n                        : null;\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements ) ? matchingElements\n                        : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                     catElems.getNonMemberElements() ) ) ? catElems\n                        : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * \n */\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) );\n        return ret == 0 ? updatedFiles : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) );\n        return ret == 0 ? promotedFiles : null;\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements );\n        return ret ? matchingElements : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        boolean ret =\n            executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                  catElems.getNonMemberElements() ) );\n        return ret ? catElems : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","lineNo":302}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) ) == 0 ? updatedFiles\n                        : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) ) == 0 ? promotedFiles\n                        : null;\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements ) ? matchingElements\n                        : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                     catElems.getNonMemberElements() ) ) ? catElems\n                        : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * \n */\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) );\n        return ret == 0 ? updatedFiles : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) );\n        return ret == 0 ? promotedFiles : null;\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements );\n        return ret ? matchingElements : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        boolean ret =\n            executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                  catElems.getNonMemberElements() ) );\n        return ret ? catElems : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","lineNo":429}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) ) == 0 ? updatedFiles\n                        : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) ) == 0 ? promotedFiles\n                        : null;\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements ) ? matchingElements\n                        : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                     catElems.getNonMemberElements() ) ) ? catElems\n                        : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * \n */\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) );\n        return ret == 0 ? updatedFiles : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) );\n        return ret == 0 ? promotedFiles : null;\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements );\n        return ret ? matchingElements : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        boolean ret =\n            executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                  catElems.getNonMemberElements() ) );\n        return ret ? catElems : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","lineNo":535}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) ) == 0 ? updatedFiles\n                        : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) ) == 0 ? promotedFiles\n                        : null;\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements ) ? matchingElements\n                        : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                     catElems.getNonMemberElements() ) ) ? catElems\n                        : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * \n */\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) );\n        return ret == 0 ? updatedFiles : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) );\n        return ret == 0 ? promotedFiles : null;\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements );\n        return ret ? matchingElements : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        boolean ret =\n            executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                  catElems.getNonMemberElements() ) );\n        return ret ? catElems : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","lineNo":551}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) ) == 0 ? updatedFiles\n                        : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) ) == 0 ? promotedFiles\n                        : null;\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements ) ? matchingElements\n                        : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                     catElems.getNonMemberElements() ) ) ? catElems\n                        : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * \n */\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) );\n        return ret == 0 ? updatedFiles : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) );\n        return ret == 0 ? promotedFiles : null;\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements );\n        return ret ? matchingElements : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        boolean ret =\n            executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                  catElems.getNonMemberElements() ) );\n        return ret ? catElems : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","lineNo":581}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) ) == 0 ? updatedFiles\n                        : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) ) == 0 ? promotedFiles\n                        : null;\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements ) ? matchingElements\n                        : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                     catElems.getNonMemberElements() ) ) ? catElems\n                        : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * \n */\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StringBuilder commandLines = new StringBuilder();\n\n    private StringBuilder errorOutput = new StringBuilder();\n\n    private StreamConsumer systemErr;\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuilder();\n        errorOutput = new StringBuilder();\n        systemErr = new ErrorConsumer( getLogger(), errorOutput );\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) );\n        return ret == 0 ? updatedFiles : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        int ret = executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) );\n        return ret == 0 ? promotedFiles : null;\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements );\n        return ret ? matchingElements : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public List<File> popExternal( File basedir, String versionSpec, String tranSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        if ( StringUtils.isBlank( tranSpec ) )\n        {\n            tranSpec = \"now\";\n        }\n\n        String[] popArgs;\n        if ( AccuRevVersion.isNow( tranSpec ) )\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n        }\n        else\n        // this will BARF for pre 4.9.0, but clients are expected to check AccuRevCapability before calling.\n        {\n            popArgs = new String[] { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-t\", tranSpec, \"-R\" };\n        }\n\n        List<File> poppedFiles = new ArrayList<File>();\n        boolean ret = executeCommandLine( basedir, popArgs, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n        return ret ? poppedFiles : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        boolean ret =\n            executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                  catElems.getNonMemberElements() ) );\n        return ret ? catElems : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n    public boolean syncReplica()\n        throws AccuRevException\n    {\n        return executeCommandLine( new String[] { \"replica\", \"sync\" } );\n    }\n\n}\n","lineNo":597}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.export;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResultWithRevision;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevCapability;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevExtractSourceCommand;\n\npublic class AccuRevExportCommand\n    extends AbstractAccuRevExtractSourceCommand\n{\n\n    public AccuRevExportCommand( ScmLogger logger )\n    {\n        super( logger );\n    }\n\n    public ExportScmResult export( ScmProviderRepository repository, ScmFileSet scmFileSet, CommandParameters params )\n        throws ScmException\n    {\n        return (ExportScmResult) execute( repository, scmFileSet, params );\n    }\n\n    @Override\n    protected List<File> extractSource( AccuRevScmProviderRepository repository, File basedir, AccuRevVersion version )\n        throws AccuRevException\n    {\n        AccuRev accuRev = repository.getAccuRev();\n        AccuRevInfo info = accuRev.info( basedir );\n        String basisStream = version.getBasisStream();\n        String transactionId = version.getTimeSpec();\n\n        if ( !AccuRevVersion.isNow( transactionId )\n            && !AccuRevCapability.POPULATE_TO_TRANSACTION.isSupported( accuRev.getClientVersion() ) )\n        {\n            getLogger().warn(\n                              String.format( \"Ignoring transaction id %s, Export can only extract current sources\",\n                                             transactionId ) );\n            transactionId = \"now\";\n        } else {\n            //We might be heading to a transaction id that is not yet available on a replica\n            accuRev.syncReplica();            \n        }\n\n        boolean removedWorkspace = false;\n\n        // We'll do a pop -V.\n\n        if ( info.isWorkSpace() )\n        {\n\n            String stat = accuRev.stat( basedir );\n\n            if ( stat != null )\n            {\n                throw new AccuRevException(\n                                            String.format(\n                                                           \"Cannot populate %s, as it is a non-ignored subdirectory of workspace %s rooted at %s.\",\n                                                           basedir.getAbsolutePath(), info.getWorkSpace(),\n                                                           info.getTop() ) );\n            }\n\n            // ok, the subdirectory must be ignored. temporarily remove the workspace.\n            removedWorkspace = accuRev.rmws( info.getWorkSpace() );\n\n        }\n\n        try\n        {\n            return accuRev.popExternal(\n                                        basedir,\n                                        basisStream,\n                                        transactionId,\n                                        Collections.singletonList( new File( repository.getDepotRelativeProjectPath() ) ) );\n\n        }\n        finally\n        {\n            if ( removedWorkspace )\n            {\n                accuRev.reactivate( info.getWorkSpace() );\n            }\n        }\n    }\n\n    @Override\n    protected ScmResult getScmResult( AccuRevScmProviderRepository repository, List<ScmFile> scmFiles,\n                                      ScmVersion scmVersion )\n    {\n        AccuRev accuRev = repository.getAccuRev();\n        if ( scmFiles != null )\n        {\n            if ( scmVersion == null )\n            {\n                return new ExportScmResult( accuRev.getCommandLines(), scmFiles );\n            }\n            else\n            {\n                return new ExportScmResultWithRevision( accuRev.getCommandLines(), scmFiles, scmVersion.toString() );\n            }\n        }\n        else\n        {\n            return new ExportScmResult( accuRev.getCommandLines(), \"AccuRev Error\", accuRev.getErrorOutput(), false );\n        }\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.export;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResultWithRevision;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevCapability;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevExtractSourceCommand;\n\n/**\n * \n */\npublic class AccuRevExportCommand\n    extends AbstractAccuRevExtractSourceCommand\n{\n\n    public AccuRevExportCommand( ScmLogger logger )\n    {\n        super( logger );\n    }\n\n    public ExportScmResult export( ScmProviderRepository repository, ScmFileSet scmFileSet, CommandParameters params )\n        throws ScmException\n    {\n        return (ExportScmResult) execute( repository, scmFileSet, params );\n    }\n\n    @Override\n    protected List<File> extractSource( AccuRevScmProviderRepository repository, File basedir, AccuRevVersion version )\n        throws AccuRevException\n    {\n        AccuRev accuRev = repository.getAccuRev();\n        AccuRevInfo info = accuRev.info( basedir );\n        String basisStream = version.getBasisStream();\n        String transactionId = version.getTimeSpec();\n\n        if ( !AccuRevVersion.isNow( transactionId )\n            && !AccuRevCapability.POPULATE_TO_TRANSACTION.isSupported( accuRev.getClientVersion() ) )\n        {\n            getLogger().warn(\n                              String.format( \"Ignoring transaction id %s, Export can only extract current sources\",\n                                             transactionId ) );\n            transactionId = \"now\";\n        }\n        else\n        {\n            //We might be heading to a transaction id that is not yet available on a replica\n            accuRev.syncReplica();            \n        }\n\n        boolean removedWorkspace = false;\n\n        // We'll do a pop -V.\n\n        if ( info.isWorkSpace() )\n        {\n\n            String stat = accuRev.stat( basedir );\n\n            if ( stat != null )\n            {\n                throw new AccuRevException( String.format( \"Cannot populate %s, as it is a non-ignored \"\n                                                               + \"subdirectory of workspace %s rooted at %s.\",\n                                                           basedir.getAbsolutePath(), info.getWorkSpace(),\n                                                           info.getTop() ) );\n            }\n\n            // ok, the subdirectory must be ignored. temporarily remove the workspace.\n            removedWorkspace = accuRev.rmws( info.getWorkSpace() );\n\n        }\n\n        try\n        {\n            File path = new File( repository.getDepotRelativeProjectPath() );\n            return accuRev.popExternal( basedir, basisStream, transactionId, Collections.singletonList( path ) );\n        }\n        finally\n        {\n            if ( removedWorkspace )\n            {\n                accuRev.reactivate( info.getWorkSpace() );\n            }\n        }\n    }\n\n    @Override\n    protected ScmResult getScmResult( AccuRevScmProviderRepository repository, List<ScmFile> scmFiles,\n                                      ScmVersion scmVersion )\n    {\n        AccuRev accuRev = repository.getAccuRev();\n        if ( scmFiles != null )\n        {\n            if ( scmVersion == null )\n            {\n                return new ExportScmResult( accuRev.getCommandLines(), scmFiles );\n            }\n            else\n            {\n                return new ExportScmResultWithRevision( accuRev.getCommandLines(), scmFiles, scmVersion.toString() );\n            }\n        }\n        else\n        {\n            return new ExportScmResult( accuRev.getCommandLines(), \"AccuRev Error\", accuRev.getErrorOutput(), false );\n        }\n    }\n\n}\n","lineNo":109}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.UserConfig;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.RefSpec;\n\nimport java.io.File;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This provider uses the following strategy to discover the committer and author name/mail for a commit:\n * <ol>\n * <li>\"user\" section in .gitconfig<\/li>\n * <li>\"username\" passed to maven execution<\/li>\n * <li>default git config (system user and hostname for email)<\/li>\n * <\/ol>\n * the \"maven-scm\" config can be configured like this: <br>\n * the default email domain to be used (will be used to create an email from the username passed to maven):<br>\n * <code>git config --global maven-scm.maildomain mycomp.com<\/code> <br>\n * you can also enforce the usage of the username for the author and committer:<br>\n * <code>git config --global maven-scm.forceUsername true<\/code> <br>\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitCheckInCommand\n    extends AbstractCheckInCommand\n    implements GitCommand\n{\n\n    protected static final String GIT_MAVEN_SECTION = \"maven-scm\";\n\n    protected static final String GIT_MAILDOMAIN = \"maildomain\";\n\n    protected static final String GIT_FORCE = \"forceUsername\";\n\n    /**\n     * {@inheritDoc}\n     */\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      ScmVersion version )\n        throws ScmException\n    {\n\n        Git git = null;\n        try\n        {\n            File basedir = fileSet.getBasedir();\n            git = Git.open( basedir );\n\n            boolean doCommit = false;\n\n            if ( !fileSet.getFileList().isEmpty() )\n            {\n                doCommit = JGitUtils.addAllFiles( git, fileSet ).size() > 0;\n            }\n            else\n            {\n                // add all tracked files which are modified manually\n                Set<String> changeds = git.status().call().getModified();\n                if ( changeds.isEmpty() )\n                {\n                    // warn there is nothing to add\n                    getLogger().warn( \"there are no files to be added\" );\n                    doCommit = false;\n                }\n                else\n                {\n                    AddCommand add = git.add();\n                    for ( String changed : changeds )\n                    {\n                        getLogger().debug( \"add manualy: \" + changed );\n                        add.addFilepattern( changed );\n                        doCommit = true;\n                    }\n                    add.call();\n                }\n            }\n\n            List<ScmFile> checkedInFiles = Collections.emptyList();\n            if ( doCommit )\n            {\n                UserInfo author = getAuthor( repo, git );\n                UserInfo committer = getCommitter( repo, git );\n\n                RevCommit commitRev =\n                    git.commit().setMessage( message ).setAuthor( author.name, author.email ).setCommitter( committer.name,\n                                                                                                            committer.email ).call();\n                getLogger().info( \"commit done: \" + commitRev.getShortMessage() );\n                checkedInFiles = JGitUtils.getFilesInCommit( git.getRepository(), commitRev );\n                if ( getLogger().isDebugEnabled() )\n                {\n                    for ( ScmFile scmFile : checkedInFiles )\n                    {\n                        getLogger().debug( \"in commit: \" + scmFile );\n                    }\n                }\n            }\n\n            if ( repo.isPushChanges() )\n            {\n                String branch = version != null ? version.getName() : null;\n                if ( StringUtils.isBlank( branch ) )\n                {\n                    branch = git.getRepository().getBranch();\n                }\n                RefSpec refSpec = new RefSpec( Constants.R_HEADS + branch + \":\" + Constants.R_HEADS + branch );\n                getLogger().info( \"push changes to remote... \" + refSpec.toString() );\n                JGitUtils.push( getLogger(), git, (GitScmProviderRepository) repo, refSpec );\n            }\n\n            return new CheckInScmResult( \"JGit checkin\", checkedInFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit checkin failure!\", e );\n        }\n        finally\n        {\n            JGitUtils.closeRepo( git );\n        }\n    }\n\n    private static final class UserInfo\n    {\n        final String name;\n\n        final String email;\n\n        public UserInfo( String name, String email )\n        {\n            this.name = name;\n            this.email = email;\n        }\n    }\n\n    private UserInfo getCommitter( ScmProviderRepository repo, Git git )\n    {\n        boolean forceMvnUser = git.getRepository().getConfig().getBoolean( GIT_MAVEN_SECTION, GIT_FORCE, false );\n\n        // git config\n        UserConfig user = git.getRepository().getConfig().get( UserConfig.KEY );\n        String committerName = null;\n        if ( !forceMvnUser && !user.isCommitterNameImplicit() )\n        {\n            committerName = user.getCommitterName();\n        }\n\n        // mvn parameter\n        if ( StringUtils.isBlank( committerName ) )\n        {\n            committerName = repo.getUser();\n        }\n\n        // git default\n        if ( StringUtils.isBlank( committerName ) )\n        {\n            committerName = user.getCommitterName();\n        }\n\n        // git config\n        String committerMail = null;\n        if ( !user.isCommitterEmailImplicit() )\n        {\n            committerMail = user.getCommitterEmail();\n        }\n\n        if ( StringUtils.isBlank( committerMail ) )\n        {\n            String defaultDomain = git.getRepository().getConfig().getString( GIT_MAVEN_SECTION, null, GIT_MAILDOMAIN );\n            defaultDomain = StringUtils.isNotBlank( defaultDomain ) ? defaultDomain : getHostname();\n\n            // mvn parameter (constructed with username) or git default\n            committerMail =\n                StringUtils.isNotBlank( repo.getUser() ) ? repo.getUser() + \"@\" + defaultDomain\n                                : user.getCommitterEmail();\n        }\n\n        return new UserInfo( committerName, committerMail );\n    }\n\n    private UserInfo getAuthor( ScmProviderRepository repo, Git git )\n    {\n        boolean forceMvnUser = git.getRepository().getConfig().getBoolean( GIT_MAVEN_SECTION, GIT_FORCE, false );\n\n        // git config\n        UserConfig user = git.getRepository().getConfig().get( UserConfig.KEY );\n        String authorName = null;\n        if ( !forceMvnUser && !user.isAuthorNameImplicit() )\n        {\n            authorName = user.getAuthorName();\n        }\n\n        // mvn parameter\n        if ( StringUtils.isBlank( authorName ) )\n        {\n            authorName = repo.getUser();\n        }\n\n        // git default\n        if ( StringUtils.isBlank( authorName ) )\n        {\n            authorName = user.getAuthorName();\n        }\n\n        // git config\n        String authorMail = null;\n        if ( !user.isAuthorEmailImplicit() )\n        {\n            authorMail = user.getAuthorEmail();\n        }\n\n        if ( StringUtils.isBlank( authorMail ) )\n        {\n            String defaultDomain = git.getRepository().getConfig().getString( GIT_MAVEN_SECTION, null, GIT_MAILDOMAIN );\n            defaultDomain = StringUtils.isNotBlank( defaultDomain ) ? defaultDomain : getHostname();\n\n            // mvn parameter (constructed with username) or git default\n            authorMail =\n                StringUtils.isNotBlank( repo.getUser() ) ? repo.getUser() + \"@\" + defaultDomain : user.getAuthorEmail();\n        }\n\n        return new UserInfo( authorName, authorMail );\n    }\n\n    private String getHostname()\n    {\n        String hostname;\n        try\n        {\n            InetAddress localhost = java.net.InetAddress.getLocalHost();\n            hostname = localhost.getHostName();\n        }\n        catch ( UnknownHostException e )\n        {\n            getLogger().warn( \"failed to resolve hostname to create mail address, defaulting to 'maven-scm-provider-jgit'\" );\n            hostname = \"maven-scm-provider-jgit\";\n        }\n        return hostname;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.CommitCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.UserConfig;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.RefSpec;\n\nimport java.io.File;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This provider uses the following strategy to discover the committer and author name/mail for a commit:\n * <ol>\n * <li>\"user\" section in .gitconfig<\/li>\n * <li>\"username\" passed to maven execution<\/li>\n * <li>default git config (system user and hostname for email)<\/li>\n * <\/ol>\n * the \"maven-scm\" config can be configured like this: <br>\n * the default email domain to be used (will be used to create an email from the username passed to maven):<br>\n * <code>git config --global maven-scm.maildomain mycomp.com<\/code> <br>\n * you can also enforce the usage of the username for the author and committer:<br>\n * <code>git config --global maven-scm.forceUsername true<\/code> <br>\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @since 1.9\n */\npublic class JGitCheckInCommand\n    extends AbstractCheckInCommand\n    implements GitCommand\n{\n\n    protected static final String GIT_MAVEN_SECTION = \"maven-scm\";\n\n    protected static final String GIT_MAILDOMAIN = \"maildomain\";\n\n    protected static final String GIT_FORCE = \"forceUsername\";\n\n    /**\n     * {@inheritDoc}\n     */\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      ScmVersion version )\n        throws ScmException\n    {\n\n        Git git = null;\n        try\n        {\n            File basedir = fileSet.getBasedir();\n            git = Git.open( basedir );\n\n            boolean doCommit = false;\n\n            if ( !fileSet.getFileList().isEmpty() )\n            {\n                doCommit = JGitUtils.addAllFiles( git, fileSet ).size() > 0;\n            }\n            else\n            {\n                // add all tracked files which are modified manually\n                Set<String> changeds = git.status().call().getModified();\n                if ( changeds.isEmpty() )\n                {\n                    // warn there is nothing to add\n                    getLogger().warn( \"there are no files to be added\" );\n                    doCommit = false;\n                }\n                else\n                {\n                    AddCommand add = git.add();\n                    for ( String changed : changeds )\n                    {\n                        getLogger().debug( \"add manualy: \" + changed );\n                        add.addFilepattern( changed );\n                        doCommit = true;\n                    }\n                    add.call();\n                }\n            }\n\n            List<ScmFile> checkedInFiles = Collections.emptyList();\n            if ( doCommit )\n            {\n                UserInfo author = getAuthor( repo, git );\n                UserInfo committer = getCommitter( repo, git );\n\n                CommitCommand command = git.commit().setMessage( message ).setAuthor( author.name, author.email );\n                command.setCommitter( committer.name, committer.email );\n                RevCommit commitRev = command.call();\n\n                getLogger().info( \"commit done: \" + commitRev.getShortMessage() );\n                checkedInFiles = JGitUtils.getFilesInCommit( git.getRepository(), commitRev );\n                if ( getLogger().isDebugEnabled() )\n                {\n                    for ( ScmFile scmFile : checkedInFiles )\n                    {\n                        getLogger().debug( \"in commit: \" + scmFile );\n                    }\n                }\n            }\n\n            if ( repo.isPushChanges() )\n            {\n                String branch = version != null ? version.getName() : null;\n                if ( StringUtils.isBlank( branch ) )\n                {\n                    branch = git.getRepository().getBranch();\n                }\n                RefSpec refSpec = new RefSpec( Constants.R_HEADS + branch + \":\" + Constants.R_HEADS + branch );\n                getLogger().info( \"push changes to remote... \" + refSpec.toString() );\n                JGitUtils.push( getLogger(), git, (GitScmProviderRepository) repo, refSpec );\n            }\n\n            return new CheckInScmResult( \"JGit checkin\", checkedInFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit checkin failure!\", e );\n        }\n        finally\n        {\n            JGitUtils.closeRepo( git );\n        }\n    }\n\n    private static final class UserInfo\n    {\n        final String name;\n\n        final String email;\n\n        public UserInfo( String name, String email )\n        {\n            this.name = name;\n            this.email = email;\n        }\n    }\n\n    private UserInfo getCommitter( ScmProviderRepository repo, Git git )\n    {\n        boolean forceMvnUser = git.getRepository().getConfig().getBoolean( GIT_MAVEN_SECTION, GIT_FORCE, false );\n\n        // git config\n        UserConfig user = git.getRepository().getConfig().get( UserConfig.KEY );\n        String committerName = null;\n        if ( !forceMvnUser && !user.isCommitterNameImplicit() )\n        {\n            committerName = user.getCommitterName();\n        }\n\n        // mvn parameter\n        if ( StringUtils.isBlank( committerName ) )\n        {\n            committerName = repo.getUser();\n        }\n\n        // git default\n        if ( StringUtils.isBlank( committerName ) )\n        {\n            committerName = user.getCommitterName();\n        }\n\n        // git config\n        String committerMail = null;\n        if ( !user.isCommitterEmailImplicit() )\n        {\n            committerMail = user.getCommitterEmail();\n        }\n\n        if ( StringUtils.isBlank( committerMail ) )\n        {\n            String defaultDomain = git.getRepository().getConfig().getString( GIT_MAVEN_SECTION, null, GIT_MAILDOMAIN );\n            defaultDomain = StringUtils.isNotBlank( defaultDomain ) ? defaultDomain : getHostname();\n\n            // mvn parameter (constructed with username) or git default\n            committerMail =\n                StringUtils.isNotBlank( repo.getUser() ) ? repo.getUser() + \"@\" + defaultDomain\n                                : user.getCommitterEmail();\n        }\n\n        return new UserInfo( committerName, committerMail );\n    }\n\n    private UserInfo getAuthor( ScmProviderRepository repo, Git git )\n    {\n        boolean forceMvnUser = git.getRepository().getConfig().getBoolean( GIT_MAVEN_SECTION, GIT_FORCE, false );\n\n        // git config\n        UserConfig user = git.getRepository().getConfig().get( UserConfig.KEY );\n        String authorName = null;\n        if ( !forceMvnUser && !user.isAuthorNameImplicit() )\n        {\n            authorName = user.getAuthorName();\n        }\n\n        // mvn parameter\n        if ( StringUtils.isBlank( authorName ) )\n        {\n            authorName = repo.getUser();\n        }\n\n        // git default\n        if ( StringUtils.isBlank( authorName ) )\n        {\n            authorName = user.getAuthorName();\n        }\n\n        // git config\n        String authorMail = null;\n        if ( !user.isAuthorEmailImplicit() )\n        {\n            authorMail = user.getAuthorEmail();\n        }\n\n        if ( StringUtils.isBlank( authorMail ) )\n        {\n            String defaultDomain = git.getRepository().getConfig().getString( GIT_MAVEN_SECTION, null, GIT_MAILDOMAIN );\n            defaultDomain = StringUtils.isNotBlank( defaultDomain ) ? defaultDomain : getHostname();\n\n            // mvn parameter (constructed with username) or git default\n            authorMail =\n                StringUtils.isNotBlank( repo.getUser() ) ? repo.getUser() + \"@\" + defaultDomain : user.getAuthorEmail();\n        }\n\n        return new UserInfo( authorName, authorMail );\n    }\n\n    private String getHostname()\n    {\n        String hostname;\n        try\n        {\n            InetAddress localhost = java.net.InetAddress.getLocalHost();\n            hostname = localhost.getHostName();\n        }\n        catch ( UnknownHostException e )\n        {\n            getLogger().warn( \"failed to resolve hostname to create mail address, \"\n                                  + \"defaulting to 'maven-scm-provider-jgit'\" );\n            hostname = \"maven-scm-provider-jgit\";\n        }\n        return hostname;\n    }\n\n}\n","lineNo":125}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.status.AbstractStatusCommand;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceVerbMapper;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.apache.regexp.RE;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author Mike Perham\n *\n */\npublic class PerforceStatusCommand\n    extends AbstractStatusCommand\n    implements PerforceCommand\n{\n    private String actualLocation;\n\n    /** {@inheritDoc} */\n    protected StatusScmResult executeStatusCommand( ScmProviderRepository repo, ScmFileSet files )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n        PerforceStatusConsumer consumer = new PerforceStatusConsumer();\n        Commandline command = readOpened( prepo, files, consumer );\n\n        if ( consumer.isSuccess() )\n        {\n            List<ScmFile> scmfiles = createResults( actualLocation, consumer );\n            return new StatusScmResult( command.toString(), scmfiles );\n        }\n\n        return new StatusScmResult( command.toString(), \"Unable to get status\", consumer\n                .getOutput(), consumer.isSuccess() );\n    }\n\n    public static List<ScmFile> createResults( String repoPath, PerforceStatusConsumer consumer )\n    {\n        List<ScmFile> results = new ArrayList<ScmFile>();\n        List<String> files = consumer.getDepotfiles();\n        RE re = new RE( \"([^#]+)#\\\\d+ - ([^ ]+) .*\" );\n        for ( Iterator<String> it = files.iterator(); it.hasNext(); )\n        {\n            String filepath = it.next();\n            if ( !re.match( filepath ) )\n            {\n                System.err.println( \"Skipping \" + filepath );\n                continue;\n            }\n            String path = re.getParen( 1 );\n            String verb = re.getParen( 2 );\n\n            ScmFile scmfile = new ScmFile( path.substring( repoPath.length() + 1 ).trim(), PerforceVerbMapper\n                .toStatus( verb ) );\n            results.add( scmfile );\n        }\n        return results;\n    }\n\n    private Commandline readOpened( PerforceScmProviderRepository prepo, ScmFileSet files,\n                                    PerforceStatusConsumer consumer )\n    {\n        Commandline cl = createOpenedCommandLine( prepo, files.getBasedir(), actualLocation );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing \" + cl.toString() ) );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuilder msg = new StringBuilder( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        return cl;\n    }\n\n    public static Commandline createOpenedCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                       String location )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n        command.createArg().setValue( \"opened\" );\n        command.createArg().setValue( PerforceScmProvider.getCanonicalRepoPath( location ) );\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.status.AbstractStatusCommand;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceVerbMapper;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author Mike Perham\n *\n */\npublic class PerforceStatusCommand\n    extends AbstractStatusCommand\n    implements PerforceCommand\n{\n    private String actualLocation;\n\n    /** {@inheritDoc} */\n    protected StatusScmResult executeStatusCommand( ScmProviderRepository repo, ScmFileSet files )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n        PerforceStatusConsumer consumer = new PerforceStatusConsumer();\n        Commandline command = readOpened( prepo, files, consumer );\n\n        if ( consumer.isSuccess() )\n        {\n            List<ScmFile> scmfiles = createResults( actualLocation, consumer );\n            return new StatusScmResult( command.toString(), scmfiles );\n        }\n\n        return new StatusScmResult( command.toString(), \"Unable to get status\", consumer\n                .getOutput(), consumer.isSuccess() );\n    }\n\n    public static List<ScmFile> createResults( String repoPath, PerforceStatusConsumer consumer )\n    {\n        List<ScmFile> results = new ArrayList<ScmFile>();\n        List<String> files = consumer.getDepotfiles();\n        Pattern re = Pattern.compile( \"([^#]+)#\\\\d+ - ([^ ]+) .*\" );\n        for ( Iterator<String> it = files.iterator(); it.hasNext(); )\n        {\n            String filepath = it.next();\n            Matcher matcher = re.matcher( filepath );\n            if ( !matcher.matches() )\n            {\n                System.err.println( \"Skipping \" + filepath );\n                continue;\n            }\n            String path = matcher.group( 1 );\n            String verb = matcher.group( 2 );\n\n            ScmFile scmfile = new ScmFile( path.substring( repoPath.length() + 1 ).trim(), PerforceVerbMapper\n                .toStatus( verb ) );\n            results.add( scmfile );\n        }\n        return results;\n    }\n\n    private Commandline readOpened( PerforceScmProviderRepository prepo, ScmFileSet files,\n                                    PerforceStatusConsumer consumer )\n    {\n        Commandline cl = createOpenedCommandLine( prepo, files.getBasedir(), actualLocation );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing \" + cl.toString() ) );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuilder msg = new StringBuilder( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        return cl;\n    }\n\n    public static Commandline createOpenedCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                       String location )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n        command.createArg().setValue( \"opened\" );\n        command.createArg().setValue( PerforceScmProvider.getCanonicalRepoPath( location ) );\n        return command;\n    }\n}\n","lineNo":80}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.SvnChangeSet;\nimport org.apache.maven.scm.util.AbstractConsumer;\nimport org.apache.regexp.RE;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n *\n */\npublic class SvnChangeLogConsumer\n    extends AbstractConsumer\n{\n    /**\n     * Date formatter for svn timestamp (after a little massaging)\n     */\n    private static final String SVN_TIMESTAMP_PATTERN = \"yyyy-MM-dd HH:mm:ss zzzzzzzzz\";\n\n    /**\n     * State machine constant: expecting header\n     */\n    private static final int GET_HEADER = 1;\n\n    /**\n     * State machine constant: expecting file information\n     */\n    private static final int GET_FILE = 2;\n\n    /**\n     * State machine constant: expecting comments\n     */\n    private static final int GET_COMMENT = 3;\n\n    /**\n     * There is always action and affected path; when copying/moving, recognize also original path and revision\n     */\n    private static final RE FILE_PATTERN = new RE( \"^\\\\s\\\\s\\\\s([:upper:])\\\\s(.+)$\" );\n\n    /**\n     * This matches the 'original file info' part of the complete file line.\n     * Note the use of [:alpha:] instead of literal 'from' - this is meant to allow non-English localizations.\n     */\n    private static final RE ORIG_FILE_PATTERN = new RE( \"\\\\([:alpha:]+ (.+):(\\\\d+)\\\\)\" );\n\n    /**\n     * The file section ends with a blank line\n     */\n    private static final String FILE_END_TOKEN = \"\";\n\n    /**\n     * The comment section ends with a dashed line\n     */\n    private static final String COMMENT_END_TOKEN =\n        \"------------------------------------\" + \"------------------------------------\";\n\n    /**\n     * Current status of the parser\n     */\n    private int status = GET_HEADER;\n\n    /**\n     * List of change log entries\n     */\n    private List<ChangeSet> entries = new ArrayList<ChangeSet>();\n\n    /**\n     * The current log entry being processed by the parser\n     */\n    private SvnChangeSet currentChange;\n\n    /**\n     * The current revision of the entry being processed by the parser\n     */\n    private String currentRevision;\n\n    /**\n     * The current comment of the entry being processed by the parser\n     */\n    private StringBuilder currentComment;\n\n    /**\n     * The regular expression used to match header lines\n     */\n    private static final RE HEADER_REG_EXP = new RE( \"^(.+) \\\\| (.+) \\\\| (.+) \\\\|.*$\" );\n\n    private static final int REVISION_GROUP = 1;\n\n    private static final int AUTHOR_GROUP = 2;\n\n    private static final int DATE_GROUP = 3;\n\n    private static final RE REVISION_REG_EXP1 = new RE( \"rev (\\\\d+):\" );\n\n    private static final RE REVISION_REG_EXP2 = new RE( \"r(\\\\d+)\" );\n\n    private static final RE DATE_REG_EXP = new RE( \"(\\\\d+-\\\\d+-\\\\d+ \" +             // date 2002-08-24\n                                                       \"\\\\d+:\\\\d+:\\\\d+) \" +             // time 16:01:00\n                                                       \"([\\\\-+])(\\\\d\\\\d)(\\\\d\\\\d)\" );     // gmt offset -0400);)\n\n    private final String userDateFormat;\n\n    /**\n     * Default constructor.\n     */\n    public SvnChangeLogConsumer( ScmLogger logger, String userDateFormat )\n    {\n        super( logger );\n\n        this.userDateFormat = userDateFormat;\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        return entries;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( line );\n        }\n        switch ( status )\n        {\n            case GET_HEADER:\n                processGetHeader( line );\n                break;\n            case GET_FILE:\n                processGetFile( line );\n                break;\n            case GET_COMMENT:\n                processGetComment( line );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown state: \" + status );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Process the current input line in the GET_HEADER state.  The\n     * author, date, and the revision of the entry are gathered.  Note,\n     * Subversion does not have per-file revisions, instead, the entire\n     * repository is given a single revision number, which is used for\n     * the revision number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetHeader( String line )\n    {\n        if ( !HEADER_REG_EXP.match( line ) )\n        {\n            // The header line is not found. Intentionally do nothing.\n            return;\n        }\n\n        currentRevision = getRevision( HEADER_REG_EXP.getParen( REVISION_GROUP ) );\n\n        currentChange = new SvnChangeSet();\n\n        currentChange.setAuthor( HEADER_REG_EXP.getParen( AUTHOR_GROUP ) );\n\n        currentChange.setDate( getDate( HEADER_REG_EXP.getParen( DATE_GROUP ) ) );\n\n        currentChange.setRevision( currentRevision );\n\n        status = GET_FILE;\n    }\n\n    /**\n     * Gets the svn revision, from the svn log revision output.\n     *\n     * @param revisionOutput\n     * @return the svn revision\n     */\n    private String getRevision( final String revisionOutput )\n    {\n        if ( REVISION_REG_EXP1.match( revisionOutput ) )\n        {\n            return REVISION_REG_EXP1.getParen( 1 );\n        }\n        else if ( REVISION_REG_EXP2.match( revisionOutput ) )\n        {\n            return REVISION_REG_EXP2.getParen( 1 );\n        }\n        else\n        {\n            throw new IllegalOutputException( revisionOutput );\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_FILE state.  This state\n     * adds each file entry line to the current change log entry.  Note,\n     * the revision number for the entire entry is used for the revision\n     * number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetFile( String line )\n    {\n        if ( FILE_PATTERN.match( line ) )\n        {\n            final String fileinfo = FILE_PATTERN.getParen( 2 );\n            String name = fileinfo;\n            String originalName = null;\n            String originalRev = null;\n            final int n = fileinfo.indexOf( \" (\" );\n            if ( n > 1 && fileinfo.endsWith( \")\" ) )\n            {\n                final String origFileInfo = fileinfo.substring( n );\n                if ( ORIG_FILE_PATTERN.match( origFileInfo ) )\n                {\n                    // if original file is present, we must extract the affected one from the beginning\n                    name = fileinfo.substring( 0, n );\n                    originalName = ORIG_FILE_PATTERN.getParen( 1 );\n                    originalRev = ORIG_FILE_PATTERN.getParen( 2 );\n                }\n            }\n            final String actionStr = FILE_PATTERN.getParen( 1 );\n            final ScmFileStatus action;\n            if ( \"A\".equals( actionStr ) )\n            {\n                //TODO: this may even change to MOVED if we later explore whole changeset and find matching DELETED\n                action = originalRev == null ? ScmFileStatus.ADDED : ScmFileStatus.COPIED;\n            }\n            else if ( \"D\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.DELETED;\n            }\n            else if ( \"M\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.MODIFIED;\n            }\n            else if ( \"R\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.UPDATED; //== REPLACED in svn terms\n            }\n            else\n            {\n                action = ScmFileStatus.UNKNOWN;\n            }\n            System.out.println( actionStr + \" : \" + name );\n            final ChangeFile changeFile = new ChangeFile( name, currentRevision );\n            changeFile.setAction( action );\n            changeFile.setOriginalName( originalName );\n            changeFile.setOriginalRevision( originalRev );\n            currentChange.addFile( changeFile );\n\n            status = GET_FILE;\n        }\n        else if ( line.equals( FILE_END_TOKEN ) )\n        {\n            // Create a buffer for the collection of the comment now\n            // that we are leaving the GET_FILE state.\n            currentComment = new StringBuilder();\n\n            status = GET_COMMENT;\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_COMMENT state.  This\n     * state gathers all of the comments that are part of a log entry.\n     *\n     * @param line a line of text from the svn log output\n     */\n    private void processGetComment( String line )\n    {\n        if ( line.equals( COMMENT_END_TOKEN ) )\n        {\n            currentChange.setComment( currentComment.toString() );\n\n            entries.add( currentChange );\n\n            status = GET_HEADER;\n        }\n        else\n        {\n            currentComment.append( line ).append( '\\n' );\n        }\n    }\n\n    /**\n     * Converts the date time stamp from the svn output into a date\n     * object.\n     *\n     * @param dateOutput The date output from an svn log command.\n     * @return A date representing the time stamp of the log entry.\n     */\n    private Date getDate( final String dateOutput )\n    {\n        if ( !DATE_REG_EXP.match( dateOutput ) )\n        {\n            throw new IllegalOutputException( dateOutput );\n        }\n\n        final StringBuilder date = new StringBuilder();\n        date.append( DATE_REG_EXP.getParen( 1 ) );\n        date.append( \" GMT\" );\n        date.append( DATE_REG_EXP.getParen( 2 ) );\n        date.append( DATE_REG_EXP.getParen( 3 ) );\n        date.append( ':' );\n        date.append( DATE_REG_EXP.getParen( 4 ) );\n\n        return parseDate( date.toString(), userDateFormat, SVN_TIMESTAMP_PATTERN );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.SvnChangeSet;\nimport org.apache.maven.scm.util.AbstractConsumer;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n *\n */\npublic class SvnChangeLogConsumer\n    extends AbstractConsumer\n{\n    /**\n     * Date formatter for svn timestamp (after a little massaging)\n     */\n    private static final String SVN_TIMESTAMP_PATTERN = \"yyyy-MM-dd HH:mm:ss zzzzzzzzz\";\n\n    /**\n     * State machine constant: expecting header\n     */\n    private static final int GET_HEADER = 1;\n\n    /**\n     * State machine constant: expecting file information\n     */\n    private static final int GET_FILE = 2;\n\n    /**\n     * State machine constant: expecting comments\n     */\n    private static final int GET_COMMENT = 3;\n\n    /**\n     * There is always action and affected path; when copying/moving, recognize also original path and revision\n     */\n    private static final Pattern FILE_PATTERN = Pattern.compile(\"^\\\\s\\\\s\\\\s([A-Z])\\\\s(.+)$\");\n\n    /**\n     * This matches the 'original file info' part of the complete file line.\n     * Note the use of [:alpha:] instead of literal 'from' - this is meant to allow non-English localizations.\n     */\n    private static final Pattern ORIG_FILE_PATTERN = Pattern.compile( \"\\\\([A-Za-z]+ (.+):(\\\\d+)\\\\)\" );\n\n    /**\n     * The file section ends with a blank line\n     */\n    private static final String FILE_END_TOKEN = \"\";\n\n    /**\n     * The comment section ends with a dashed line\n     */\n    private static final String COMMENT_END_TOKEN =\n        \"------------------------------------\" + \"------------------------------------\";\n\n    /**\n     * Current status of the parser\n     */\n    private int status = GET_HEADER;\n\n    /**\n     * List of change log entries\n     */\n    private List<ChangeSet> entries = new ArrayList<ChangeSet>();\n\n    /**\n     * The current log entry being processed by the parser\n     */\n    private SvnChangeSet currentChange;\n\n    /**\n     * The current revision of the entry being processed by the parser\n     */\n    private String currentRevision;\n\n    /**\n     * The current comment of the entry being processed by the parser\n     */\n    private StringBuilder currentComment;\n\n    /**\n     * The regular expression used to match header lines\n     */\n    private static final Pattern HEADER_REG_EXP = Pattern.compile( \"^(.+) \\\\| (.+) \\\\| (.+) \\\\|.*$\" );\n\n    private static final int REVISION_GROUP = 1;\n\n    private static final int AUTHOR_GROUP = 2;\n\n    private static final int DATE_GROUP = 3;\n\n    private static final Pattern REVISION_REG_EXP1 = Pattern.compile( \"rev (\\\\d+):\" );\n\n    private static final Pattern REVISION_REG_EXP2 = Pattern.compile( \"r(\\\\d+)\" );\n\n    private static final Pattern DATE_REG_EXP = Pattern.compile( \"(\\\\d+-\\\\d+-\\\\d+ \" +   // date 2002-08-24\n                                                       \"\\\\d+:\\\\d+:\\\\d+) \" +             // time 16:01:00\n                                                       \"([\\\\-+])(\\\\d\\\\d)(\\\\d\\\\d)\" );    // gmt offset -0400);)\n\n    private final String userDateFormat;\n\n    /**\n     * Default constructor.\n     */\n    public SvnChangeLogConsumer( ScmLogger logger, String userDateFormat )\n    {\n        super( logger );\n\n        this.userDateFormat = userDateFormat;\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        return entries;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( line );\n        }\n        switch ( status )\n        {\n            case GET_HEADER:\n                processGetHeader( line );\n                break;\n            case GET_FILE:\n                processGetFile( line );\n                break;\n            case GET_COMMENT:\n                processGetComment( line );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown state: \" + status );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Process the current input line in the GET_HEADER state.  The\n     * author, date, and the revision of the entry are gathered.  Note,\n     * Subversion does not have per-file revisions, instead, the entire\n     * repository is given a single revision number, which is used for\n     * the revision number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetHeader( String line )\n    {\n        Matcher matcher = HEADER_REG_EXP.matcher( line );\n        if ( !matcher.matches() )\n        {\n            // The header line is not found. Intentionally do nothing.\n            return;\n        }\n\n        currentRevision = getRevision( matcher.group( REVISION_GROUP ) );\n\n        currentChange = new SvnChangeSet();\n\n        currentChange.setAuthor( matcher.group( AUTHOR_GROUP ) );\n\n        currentChange.setDate( getDate( matcher.group( DATE_GROUP ) ) );\n\n        currentChange.setRevision( currentRevision );\n\n        status = GET_FILE;\n    }\n\n    /**\n     * Gets the svn revision, from the svn log revision output.\n     *\n     * @param revisionOutput\n     * @return the svn revision\n     */\n    private String getRevision( final String revisionOutput )\n    {\n        Matcher matcher;\n        if ( ( matcher = REVISION_REG_EXP1.matcher( revisionOutput ) ).matches() )\n        {\n            return matcher.group( 1 );\n        }\n        else if ( ( matcher = REVISION_REG_EXP2.matcher( revisionOutput )).matches() )\n        {\n            return matcher.group( 1 );\n        }\n        else\n        {\n            throw new IllegalOutputException( revisionOutput );\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_FILE state.  This state\n     * adds each file entry line to the current change log entry.  Note,\n     * the revision number for the entire entry is used for the revision\n     * number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetFile( String line )\n    {\n        Matcher matcher = FILE_PATTERN.matcher( line );\n        if ( matcher.matches() )\n        {\n            final String fileinfo = matcher.group( 2 );\n            String name = fileinfo;\n            String originalName = null;\n            String originalRev = null;\n            final int n = fileinfo.indexOf( \" (\" );\n            if ( n > 1 && fileinfo.endsWith( \")\" ) )\n            {\n                final String origFileInfo = fileinfo.substring( n );\n                Matcher matcher2 = ORIG_FILE_PATTERN.matcher( origFileInfo );\n                if ( matcher2.find() )\n                {\n                    // if original file is present, we must extract the affected one from the beginning\n                    name = fileinfo.substring( 0, n );\n                    originalName = matcher2.group( 1 );\n                    originalRev = matcher2.group( 2 );\n                }\n            }\n            final String actionStr = matcher.group( 1 );\n            final ScmFileStatus action;\n            if ( \"A\".equals( actionStr ) )\n            {\n                //TODO: this may even change to MOVED if we later explore whole changeset and find matching DELETED\n                action = originalRev == null ? ScmFileStatus.ADDED : ScmFileStatus.COPIED;\n            }\n            else if ( \"D\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.DELETED;\n            }\n            else if ( \"M\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.MODIFIED;\n            }\n            else if ( \"R\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.UPDATED; //== REPLACED in svn terms\n            }\n            else\n            {\n                action = ScmFileStatus.UNKNOWN;\n            }\n            System.out.println( actionStr + \" : \" + name );\n            final ChangeFile changeFile = new ChangeFile( name, currentRevision );\n            changeFile.setAction( action );\n            changeFile.setOriginalName( originalName );\n            changeFile.setOriginalRevision( originalRev );\n            currentChange.addFile( changeFile );\n\n            status = GET_FILE;\n        }\n        else if ( line.equals( FILE_END_TOKEN ) )\n        {\n            // Create a buffer for the collection of the comment now\n            // that we are leaving the GET_FILE state.\n            currentComment = new StringBuilder();\n\n            status = GET_COMMENT;\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_COMMENT state.  This\n     * state gathers all of the comments that are part of a log entry.\n     *\n     * @param line a line of text from the svn log output\n     */\n    private void processGetComment( String line )\n    {\n        if ( line.equals( COMMENT_END_TOKEN ) )\n        {\n            currentChange.setComment( currentComment.toString() );\n\n            entries.add( currentChange );\n\n            status = GET_HEADER;\n        }\n        else\n        {\n            currentComment.append( line ).append( '\\n' );\n        }\n    }\n\n    /**\n     * Converts the date time stamp from the svn output into a date\n     * object.\n     *\n     * @param dateOutput The date output from an svn log command.\n     * @return A date representing the time stamp of the log entry.\n     */\n    private Date getDate( final String dateOutput )\n    {\n        Matcher matcher = DATE_REG_EXP.matcher( dateOutput );\n        if ( !matcher.find() )\n        {\n            throw new IllegalOutputException( dateOutput );\n        }\n\n        final StringBuilder date = new StringBuilder();\n        date.append( matcher.group( 1 ) );\n        date.append( \" GMT\" );\n        date.append( matcher.group( 2 ) );\n        date.append( matcher.group( 3 ) );\n        date.append( ':' );\n        date.append( matcher.group( 4 ) );\n\n        return parseDate( date.toString(), userDateFormat, SVN_TIMESTAMP_PATTERN );\n    }\n}\n","lineNo":242}
{"Smelly Sample":"package org.apache.maven.scm.provider.hg.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.hg.command.HgConsumer;\n\n/**\n * @author <a href=\"mailto:thurner.rupert@ymono.net\">thurner rupert<\/a>\n *\n */\npublic class HgChangeLogConsumer\n    extends HgConsumer\n{\n\n    private static final String TIME_PATTERN = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    private static final String REVNO_TAG = \"changeset: \";\n\n    private static final String TAG_TAG = \"tag:         \";\n\n    private static final String AUTHOR_TAG = \"user: \";\n\n    private static final String TIME_STAMP_TOKEN = \"date: \";\n\n    private static final String MESSAGE_TOKEN = \"description:\";\n\n    private static final String FILES_TOKEN = \"files: \";\n\n    private String prevLine = \"\";\n\n    private String prevPrevLine = \"\";\n\n    private List<ChangeSet> logEntries = new ArrayList<ChangeSet>();\n\n    private ChangeSet currentChange;\n\n    private String currentRevision;\n\n    @SuppressWarnings( \"unused\" )\n    private String currentTag; // don't know what to do with this\n\n    private String userDatePattern;\n\n    private boolean spoolingComments;\n\n    private List<String> currentComment = null;\n\n    public HgChangeLogConsumer( ScmLogger logger, String userDatePattern )\n    {\n        super( logger );\n\n        this.userDatePattern = userDatePattern;\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        return logEntries;\n    }\n\n    /** {@inheritDoc} */\n    public void consumeLine( String line )\n    {\n\n        // override default behaviour which tries to pick through things for some standard messages.  that\n        // does not apply here\n        doConsume( null, line );\n    }\n\n    /** {@inheritDoc} */\n    public void doConsume( ScmFileStatus status, String line )\n    {\n        String tmpLine = line;\n        // If current status == null then this is a new entry\n        // If the line == \"\" and previous line was \"\", then this is also a new entry\n        if ( ( line.equals( \"\" ) && ( prevLine.equals( \"\" ) && prevPrevLine.equals( \"\" ) ) ) || currentComment == null )\n        {\n            if ( currentComment != null )\n            {\n                StringBuilder comment = new StringBuilder();\n                for ( int i = 0; i < currentComment.size() - 1; i++ )\n                {\n                    comment.append( currentComment.get( i ) );\n                    if ( i + 1 < currentComment.size() - 1 )\n                    {\n                        comment.append( '\\n' );\n                    }\n                }\n                currentChange.setComment( comment.toString() );\n\n            }\n\n            spoolingComments = false;\n\n            //Init a new changeset\n            currentChange = new ChangeSet();\n            currentChange.setFiles( new ArrayList<ChangeFile>( 0 ) );\n            logEntries.add( currentChange );\n\n            //Reset memeber vars\n            currentComment = new ArrayList<String>();\n            currentRevision = \"\";\n        }\n\n        if ( spoolingComments )\n        {\n            currentComment.add( line );\n        }\n        else if ( line.startsWith( MESSAGE_TOKEN ) )\n        {\n            spoolingComments = true;\n        }\n        else if ( line.startsWith( REVNO_TAG ) )\n        {\n            tmpLine = line.substring( REVNO_TAG.length() );\n            tmpLine = tmpLine.trim();\n            currentRevision = tmpLine.substring( tmpLine.indexOf( ':' ) + 1 );\n            currentChange.setRevision( currentRevision );\n\n        }\n        else if ( line.startsWith( TAG_TAG ) )\n        {\n            tmpLine = line.substring( TAG_TAG.length() ).trim();\n            currentTag = tmpLine;\n        }\n        else if ( line.startsWith( AUTHOR_TAG ) )\n        {\n            tmpLine = line.substring( AUTHOR_TAG.length() );\n            tmpLine = tmpLine.trim();\n            currentChange.setAuthor( tmpLine );\n        }\n        else if ( line.startsWith( TIME_STAMP_TOKEN ) )\n        {\n            // TODO: FIX Date Parsing to match Mercurial or fix with template\n            tmpLine = line.substring( TIME_STAMP_TOKEN.length() ).trim();\n            Date date = parseDate( tmpLine, userDatePattern, TIME_PATTERN, Locale.ENGLISH );\n            currentChange.setDate( date );\n        }\n        else if ( line.startsWith( FILES_TOKEN ) )\n        {\n            tmpLine = line.substring( FILES_TOKEN.length() ).trim();\n            String[] files = tmpLine.split( \" \" );\n            for ( int i = 0; i < files.length; i++ )\n            {\n                String file = files[i];\n                ChangeFile changeFile = new ChangeFile( file, currentRevision );\n                currentChange.addFile( changeFile );\n            }\n        }\n        else if ( line.length() > 0 )\n        {\n            if ( getLogger().isWarnEnabled() )\n            {\n                getLogger().warn( \"Could not figure out: \" + line );\n            }\n        }\n\n        // record previous line\n        prevLine = line;\n        prevPrevLine = prevLine;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.hg.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.hg.command.HgConsumer;\n\n/**\n * @author <a href=\"mailto:thurner.rupert@ymono.net\">thurner rupert<\/a>\n * @author <a href=\"mailto:hr.mohr@gmail.com\">Mads Mohr Christensen<\/a>\n *\n */\npublic class HgChangeLogConsumer\n    extends HgConsumer\n{\n\n    private static final String TIME_PATTERN = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    private static final String REVNO_TAG = \"changeset:\";\n\n    private static final String TAG_TAG = \"tag:\";\n\n    private static final String BRANCH_TAG = \"branch:\";\n\n    private static final String AUTHOR_TAG = \"user:\";\n\n    private static final String TIME_STAMP_TOKEN = \"date:\";\n\n    private static final String MESSAGE_TOKEN = \"description:\";\n\n    private static final String FILES_TOKEN = \"files:\";\n\n    private List<ChangeSet> logEntries = new ArrayList<ChangeSet>();\n\n    private ChangeSet currentChange;\n\n    private String currentRevision;\n\n    @SuppressWarnings( \"unused\" )\n    private String currentTag; // don't know what to do with this\n\n    @SuppressWarnings( \"unused\" )\n    private String currentBranch; // don't know what to do with this\n\n    private String userDatePattern;\n\n    public HgChangeLogConsumer( ScmLogger logger, String userDatePattern )\n    {\n        super( logger );\n        this.userDatePattern = userDatePattern;\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        return logEntries;\n    }\n\n    /** {@inheritDoc} */\n    public void consumeLine( String line )\n    {\n        // override default behaviour which tries to pick through things for some standard messages.  that\n        // does not apply here\n        String trimmedLine = line.trim();\n        doConsume( null, trimmedLine );\n    }\n\n    /** {@inheritDoc} */\n    public void doConsume( ScmFileStatus status, String line )\n    {\n        String tmpLine;\n\n        // new changeset\n        if ( line.startsWith(REVNO_TAG) )\n        {\n            //Init a new changeset\n            currentChange = new ChangeSet();\n            currentChange.setFiles( new ArrayList<ChangeFile>( 0 ) );\n            logEntries.add( currentChange );\n\n            // parse revision\n            tmpLine = line.substring( REVNO_TAG.length() ).trim();\n            currentRevision = tmpLine.substring( tmpLine.indexOf( ':' ) + 1 );\n            currentChange.setRevision( currentRevision );\n        }\n        else if ( line.startsWith( BRANCH_TAG ) )\n        {\n            tmpLine = line.substring( BRANCH_TAG.length() ).trim();\n            currentBranch = tmpLine;\n        }\n        else if ( line.startsWith( AUTHOR_TAG ) )\n        {\n            tmpLine = line.substring( AUTHOR_TAG.length() ).trim();\n            currentChange.setAuthor( tmpLine );\n        }\n        else if ( line.startsWith( TIME_STAMP_TOKEN ) )\n        {\n            tmpLine = line.substring( TIME_STAMP_TOKEN.length() ).trim();\n            Date date = parseDate( tmpLine, userDatePattern, TIME_PATTERN, Locale.ENGLISH );\n            currentChange.setDate( date );\n        }\n        else if ( line.startsWith( TAG_TAG ) )\n        {\n            tmpLine = line.substring( TAG_TAG.length() ).trim();\n            currentTag = tmpLine;\n        }\n        else if ( line.startsWith( FILES_TOKEN ) )\n        {\n            tmpLine = line.substring( FILES_TOKEN.length() ).trim();\n            String[] files = tmpLine.split( \" \" );\n            for ( int i = 0; i < files.length; i++ )\n            {\n                String file = files[i];\n                ChangeFile changeFile = new ChangeFile( file, currentRevision );\n                currentChange.addFile( changeFile );\n            }\n        }\n        else if ( line.startsWith( MESSAGE_TOKEN ) )\n        {\n            currentChange.setComment(\"\");\n        }\n        else\n        {\n            StringBuilder comment = new StringBuilder( currentChange.getComment() );\n            comment.append( line );\n            comment.append( '\\n' );\n            currentChange.setComment( comment.toString() );\n        }\n    }\n}\n","lineNo":88}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.lib.Ref;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id $\n */\npublic class JGitTagCommand\n    extends AbstractTagCommand\n    implements GitCommand\n{\n\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, fileSet, tag, new ScmTagParameters( message ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag,\n                                        ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        if ( tag == null || StringUtils.isEmpty( tag.trim() ) )\n        {\n            throw new ScmException( \"tag name must be specified\" );\n        }\n\n        if ( !fileSet.getFileList().isEmpty() )\n        {\n            throw new ScmException( \"This provider doesn't support tagging subsets of a directory\" );\n        }\n\n        try\n        {\n            Git git = Git.open( fileSet.getBasedir() );\n\n            // tag the revision\n            String tagMessage = scmTagParameters.getMessage();\n            Ref tagRef = git.tag().setName( tag ).setMessage( tagMessage ).setForceUpdate( false ).call();\n\n            if ( repo.isPushChanges() )\n            {\n                getLogger().info( \"push tag [\" + tag + \"] to remote...\" );\n                JGitUtils.push( getLogger(), git, (GitScmProviderRepository) repo, new RefSpec( \"refs/tags/\" + tag ) );\n            }\n\n            // search for the tagged files\n            RevWalk revWalk = new RevWalk(git.getRepository());\n            RevCommit commit = revWalk.parseCommit(tagRef.getObjectId());\n         \n\t\t\tfinal TreeWalk walk = new TreeWalk(git.getRepository());\n        \twalk.reset(); // drop the first empty tree, which we do not need here\n        \twalk.setRecursive(true);\n        \twalk.addTree(commit.getTree());\n        \t\n        \tList<ScmFile> taggedFiles = new ArrayList<ScmFile>();\n        \twhile (walk.next()) {\n        \t\ttaggedFiles.add( new ScmFile( walk.getPathString(), ScmFileStatus.CHECKED_OUT));\n        \t}\n\n            return new TagScmResult( \"JGit tag\", taggedFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit tag failure!\", e );\n        }\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.Ref;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id $\n */\npublic class JGitTagCommand\n    extends AbstractTagCommand\n    implements GitCommand\n{\n\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, fileSet, tag, new ScmTagParameters( message ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag,\n                                        ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        if ( tag == null || StringUtils.isEmpty( tag.trim() ) )\n        {\n            throw new ScmException( \"tag name must be specified\" );\n        }\n\n        if ( !fileSet.getFileList().isEmpty() )\n        {\n            throw new ScmException( \"This provider doesn't support tagging subsets of a directory\" );\n        }\n\n        String escapedTagName = tag.trim().replace(' ', '_');\n        \n        try\n        {\n            Git git = Git.open( fileSet.getBasedir() );\n\n            // tag the revision\n            String tagMessage = scmTagParameters.getMessage();\n            Ref tagRef = git.tag().setName( escapedTagName ).setMessage( tagMessage ).setForceUpdate( false ).call();\n\n            if ( repo.isPushChanges() )\n            {\n                getLogger().info( \"push tag [\" + escapedTagName + \"] to remote...\" );\n                JGitUtils.push( getLogger(), git, (GitScmProviderRepository) repo, new RefSpec( Constants.R_TAGS + escapedTagName ) );\n            }\n\n            // search for the tagged files\n            RevWalk revWalk = new RevWalk(git.getRepository());\n            RevCommit commit = revWalk.parseCommit(tagRef.getObjectId());\n         \n\t\t\tfinal TreeWalk walk = new TreeWalk(git.getRepository());\n        \twalk.reset(); // drop the first empty tree, which we do not need here\n        \twalk.setRecursive(true);\n        \twalk.addTree(commit.getTree());\n        \t\n        \tList<ScmFile> taggedFiles = new ArrayList<ScmFile>();\n        \twhile (walk.next()) {\n        \t\ttaggedFiles.add( new ScmFile( walk.getPathString(), ScmFileStatus.CHECKED_OUT));\n        \t}\n\n            return new TagScmResult( \"JGit tag\", taggedFiles );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"JGit tag failure!\", e );\n        }\n\n    }\n\n}\n","lineNo":79}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevFlag;\nimport org.eclipse.jgit.revwalk.RevSort;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.revwalk.filter.CommitTimeRevFilter;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit utility functions.\n *\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils\n{\n\n    private JGitUtils()\n    {\n        // no op\n    }\n\n    /**\n     * Construct a logging ProgressMonitor for all JGit operations.\n     *\n     * @param logger\n     * @return a ProgressMonitor for use\n     */\n    public static ProgressMonitor getMonitor( ScmLogger logger )\n    {\n        // X TODO write an own ProgressMonitor which logs to ScmLogger!\n        return new TextProgressMonitor();\n    }\n\n    /**\n     * Prepares the in memory configuration of git to connect to the configured\n     * repository. It configures the following settings in memory: <br />\n     * <li>push url<\/li> <li>fetch url<\/li>\n     * <p/>\n     *\n     * @param logger     used to log some details\n     * @param git        the instance to configure (only in memory, not saved)\n     * @param repository the repo config to be used\n     * @return {@link CredentialsProvider} in case there are credentials\n     *         informations configured in the repository.\n     */\n    public static CredentialsProvider prepareSession( ScmLogger logger, Git git, GitScmProviderRepository repository )\n    {\n        StoredConfig config = git.getRepository().getConfig();\n        config.setString( \"remote\", \"origin\", \"url\", repository.getFetchUrl() );\n        config.setString( \"remote\", \"origin\", \"pushURL\", repository.getPushUrl() );\n\n        // make sure we do not log any passwords to the output\n        String password =\n            StringUtils.isNotBlank( repository.getPassword() ) ? repository.getPassword().trim() : \"no-pwd-defined\";\n        logger.info( \"fetch url: \" + repository.getFetchUrl().replace( password, \"******\" ) );\n        logger.info( \"push url: \" + repository.getPushUrl().replace( password, \"******\" ) );\n        return getCredentials( repository );\n    }\n\n    /**\n     * Creates a credentials provider from the information passed in the\n     * repository. Current implementation supports: <br />\n     * <li>UserName/Password<\/li>\n     * <p/>\n     *\n     * @param repository the config to get the details from\n     * @return <code>null<\/code> if there is not enough info to create a\n     *         provider with\n     */\n    public static CredentialsProvider getCredentials( GitScmProviderRepository repository )\n    {\n        if ( StringUtils.isNotBlank( repository.getUser() ) && StringUtils.isNotBlank( repository.getPassword() ) )\n        {\n            return new UsernamePasswordCredentialsProvider( repository.getUser().trim(),\n                                                            repository.getPassword().trim() );\n        }\n        return null;\n    }\n\n    public static Iterable<PushResult> push( ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec )\n        throws GitAPIException, InvalidRemoteException, TransportException\n    {\n        CredentialsProvider credentials = JGitUtils.prepareSession( logger, git, repo );\n        Iterable<PushResult> pushResultList =\n            git.push().setCredentialsProvider( credentials ).setRefSpecs( refSpec ).call();\n        for ( PushResult pushResult : pushResultList )\n        {\n            Collection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n            for ( RemoteRefUpdate remoteRefUpdate : ru )\n            {\n                logger.info( remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString() );\n            }\n        }\n        return pushResultList;\n    }\n\n    /**\n     * Does the Repository have any commits?\n     *\n     * @param repo\n     * @return false if there are no commits\n     */\n    public static boolean hasCommits( Repository repo )\n    {\n        if ( repo != null && repo.getDirectory().exists() )\n        {\n            return ( new File( repo.getDirectory(), \"objects\" ).list().length > 2 ) || (\n                new File( repo.getDirectory(), \"objects/pack\" ).list().length > 0 );\n        }\n        return false;\n    }\n\n    /**\n     * get a list of all files in the given commit\n     *\n     * @param repository the repo\n     * @param commit     the commit to get the files from\n     * @return a list of files included in the commit\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     * @throws CorruptObjectException\n     * @throws IOException\n     */\n    public static List<ScmFile> getFilesInCommit( Repository repository, RevCommit commit )\n        throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException\n    {\n        List<ScmFile> list = new ArrayList<ScmFile>();\n        if ( JGitUtils.hasCommits( repository ) )\n        {\n            TreeWalk tw = new TreeWalk( repository );\n            tw.reset();\n            tw.setRecursive( true );\n            tw.addTree( commit.getTree() );\n            while ( tw.next() )\n            {\n                list.add( new ScmFile( tw.getPathString(), ScmFileStatus.CHECKED_IN ) );\n            }\n            tw.release();\n        }\n        return list;\n    }\n\n    /**\n     * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n     *\n     * @param status\n     * @return the matching ScmFileStatus\n     * @throws ScmException if the given Status cannot be translated\n     */\n    public static ScmFileStatus getScmFileStatus( ChangeType changeType )\n        throws ScmException\n    {\n        switch ( changeType )\n        {\n            case ADD:\n                return ScmFileStatus.ADDED;\n            case MODIFY:\n                return ScmFileStatus.MODIFIED;\n            case DELETE:\n                return ScmFileStatus.DELETED;\n            case RENAME:\n                return ScmFileStatus.RENAMED;\n            case COPY:\n                return ScmFileStatus.COPIED;\n            default:\n                return ScmFileStatus.UNKNOWN;\n        }\n    }\n\n    /**\n     * Adds all files in the given fileSet to the repository.\n     *\n     * @param git     the repo to add the files to\n     * @param fileSet the set of files within the workspace, the files are added\n     *                relative to the basedir of this fileset\n     * @return a list of files changed\n     * @throws GitAPIException\n     * @throws NoFilepatternException\n     */\n    public static List<ScmFile> addAllFiles( Git git, ScmFileSet fileSet )\n        throws GitAPIException, NoFilepatternException\n    {\n        URI baseUri = fileSet.getBasedir().toURI();\n        AddCommand add = git.add();\n        for ( File file : fileSet.getFileList() )\n        {\n            if ( file.exists() )\n            {\n                String path = relativize( baseUri, file );\n                add.addFilepattern( path );\n            }\n        }\n        add.call();\n\n        Status status = git.status().call();\n        Set<String> changed = status.getChanged();\n\n        List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n        // rewrite all detected files to now have status 'checked_in'\n        for ( String entry : changed )\n        {\n            ScmFile scmfile = new ScmFile( entry, ScmFileStatus.MODIFIED );\n\n            // if a specific fileSet is given, we have to check if the file is\n            // really tracked\n            for ( Iterator<File> itfl = fileSet.getFileList().iterator(); itfl.hasNext(); )\n            {\n                String path = relativize( baseUri, itfl.next() );\n                if ( path.equals( scmfile.getPath() ) )\n                {\n                    changedFiles.add( scmfile );\n                }\n            }\n        }\n        return changedFiles;\n    }\n\n    private static String relativize( URI baseUri, File f )\n    {\n        String path = f.getPath();\n        if ( f.isAbsolute() )\n        {\n            path = baseUri.relativize( new File( path ).toURI() ).getPath();\n        }\n        return path;\n    }\n\n    /**\n     * Get a list of commits between two revisions.\n     *\n     * @param repo     the repository to work on\n     * @param sortings sorting\n     * @param fromRev  start revision\n     * @param toRev    if null, falls back to head\n     * @param fromDate from which date on\n     * @param toDate   until which date\n     * @param maxLines max number of lines\n     * @return a list of commits, might be empty, but never <code>null<\/code>\n     * @throws IOException\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     */\n    public static List<RevCommit> getRevCommits( Repository repo, RevSort[] sortings, String fromRev, String toRev,\n                                                 Date fromDate, Date toDate, int maxLines )\n        throws IOException, MissingObjectException, IncorrectObjectTypeException\n    {\n        List<RevCommit> revs = new ArrayList<RevCommit>();\n        RevWalk walk = new RevWalk( repo );\n\n        ObjectId fromRevId = fromRev != null ? repo.resolve( fromRev ) : null;\n        ObjectId toRevId = toRev != null ? repo.resolve( toRev ) : null;\n\n        if ( sortings == null || sortings.length == 0 )\n        {\n            sortings = new RevSort[]{ RevSort.TOPO, RevSort.COMMIT_TIME_DESC };\n        }\n\n        for ( final RevSort s : sortings )\n        {\n            walk.sort( s, true );\n        }\n\n        if ( fromDate != null && toDate != null )\n        {\n            walk.setRevFilter( CommitTimeRevFilter.between( fromDate, toDate ) );\n        }\n        else\n        {\n            if ( fromDate != null )\n            {\n                walk.setRevFilter( CommitTimeRevFilter.after( fromDate ) );\n            }\n\n            if ( toDate != null )\n            {\n                walk.setRevFilter( CommitTimeRevFilter.before( toDate ) );\n            }\n        }\n\n        if ( fromRevId != null )\n        {\n            RevCommit c = walk.parseCommit( fromRevId );\n            c.add( RevFlag.UNINTERESTING );\n            RevCommit real = walk.parseCommit( c );\n            walk.markUninteresting( real );\n        }\n\n        if ( toRevId != null )\n        {\n            RevCommit c = walk.parseCommit( toRevId );\n            c.remove( RevFlag.UNINTERESTING );\n            RevCommit real = walk.parseCommit( c );\n            walk.markStart( real );\n        }\n        else\n        {\n            final ObjectId head = repo.resolve( Constants.HEAD );\n            if ( head == null )\n            {\n                throw new RuntimeException( \"Cannot resolve \" + Constants.HEAD );\n            }\n            RevCommit real = walk.parseCommit( head );\n            walk.markStart( real );\n        }\n\n        int n = 0;\n        for ( final RevCommit c : walk )\n        {\n            n++;\n            if ( maxLines != -1 && n > maxLines )\n            {\n                break;\n            }\n\n            revs.add( c );\n        }\n        return revs;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevFlag;\nimport org.eclipse.jgit.revwalk.RevSort;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.revwalk.filter.CommitTimeRevFilter;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit utility functions.\n *\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils\n{\n\n    private JGitUtils()\n    {\n        // no op\n    }\n\n    /**\n     * Construct a logging ProgressMonitor for all JGit operations.\n     *\n     * @param logger\n     * @return a ProgressMonitor for use\n     */\n    public static ProgressMonitor getMonitor( ScmLogger logger )\n    {\n        // X TODO write an own ProgressMonitor which logs to ScmLogger!\n        return new TextProgressMonitor();\n    }\n\n    /**\n     * Prepares the in memory configuration of git to connect to the configured\n     * repository. It configures the following settings in memory: <br />\n     * <li>push url<\/li> <li>fetch url<\/li>\n     * <p/>\n     *\n     * @param logger     used to log some details\n     * @param git        the instance to configure (only in memory, not saved)\n     * @param repository the repo config to be used\n     * @return {@link CredentialsProvider} in case there are credentials\n     *         informations configured in the repository.\n     */\n    public static CredentialsProvider prepareSession( ScmLogger logger, Git git, GitScmProviderRepository repository )\n    {\n        StoredConfig config = git.getRepository().getConfig();\n        config.setString( \"remote\", \"origin\", \"url\", repository.getFetchUrl() );\n        config.setString( \"remote\", \"origin\", \"pushURL\", repository.getPushUrl() );\n\n        // make sure we do not log any passwords to the output\n        String password =\n            StringUtils.isNotBlank( repository.getPassword() ) ? repository.getPassword().trim() : \"no-pwd-defined\";\n        logger.info( \"fetch url: \" + repository.getFetchUrl().replace( password, \"******\" ) );\n        logger.info( \"push url: \" + repository.getPushUrl().replace( password, \"******\" ) );\n        return getCredentials( repository );\n    }\n\n    /**\n     * Creates a credentials provider from the information passed in the\n     * repository. Current implementation supports: <br />\n     * <li>UserName/Password<\/li>\n     * <p/>\n     *\n     * @param repository the config to get the details from\n     * @return <code>null<\/code> if there is not enough info to create a\n     *         provider with\n     */\n    public static CredentialsProvider getCredentials( GitScmProviderRepository repository )\n    {\n        if ( StringUtils.isNotBlank( repository.getUser() ) && StringUtils.isNotBlank( repository.getPassword() ) )\n        {\n            return new UsernamePasswordCredentialsProvider( repository.getUser().trim(),\n                                                            repository.getPassword().trim() );\n        }\n        return null;\n    }\n\n    public static Iterable<PushResult> push( ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec )\n        throws GitAPIException, InvalidRemoteException, TransportException\n    {\n        CredentialsProvider credentials = JGitUtils.prepareSession( logger, git, repo );\n        Iterable<PushResult> pushResultList =\n            git.push().setCredentialsProvider( credentials ).setRefSpecs( refSpec ).call();\n        for ( PushResult pushResult : pushResultList )\n        {\n            Collection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n            for ( RemoteRefUpdate remoteRefUpdate : ru )\n            {\n                logger.info( remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString() );\n            }\n        }\n        return pushResultList;\n    }\n\n    /**\n     * Does the Repository have any commits?\n     *\n     * @param repo\n     * @return false if there are no commits\n     */\n    public static boolean hasCommits( Repository repo )\n    {\n        if ( repo != null && repo.getDirectory().exists() )\n        {\n            return ( new File( repo.getDirectory(), \"objects\" ).list().length > 2 ) || (\n                new File( repo.getDirectory(), \"objects/pack\" ).list().length > 0 );\n        }\n        return false;\n    }\n\n    /**\n     * get a list of all files in the given commit\n     *\n     * @param repository the repo\n     * @param commit     the commit to get the files from\n     * @return a list of files included in the commit\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     * @throws CorruptObjectException\n     * @throws IOException\n     */\n    public static List<ScmFile> getFilesInCommit( Repository repository, RevCommit commit )\n        throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException\n    {\n        List<ScmFile> list = new ArrayList<ScmFile>();\n        if ( JGitUtils.hasCommits( repository ) )\n        {\n            TreeWalk tw = new TreeWalk( repository );\n            tw.reset();\n            tw.setRecursive( true );\n            tw.addTree( commit.getTree() );\n            while ( tw.next() )\n            {\n                list.add( new ScmFile( tw.getPathString(), ScmFileStatus.CHECKED_IN ) );\n            }\n            tw.release();\n        }\n        return list;\n    }\n\n    /**\n     * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n     *\n     * @param changeType\n     * @return the matching ScmFileStatus\n     * @throws ScmException if the given Status cannot be translated\n     */\n    public static ScmFileStatus getScmFileStatus( ChangeType changeType )\n        throws ScmException\n    {\n        switch ( changeType )\n        {\n            case ADD:\n                return ScmFileStatus.ADDED;\n            case MODIFY:\n                return ScmFileStatus.MODIFIED;\n            case DELETE:\n                return ScmFileStatus.DELETED;\n            case RENAME:\n                return ScmFileStatus.RENAMED;\n            case COPY:\n                return ScmFileStatus.COPIED;\n            default:\n                return ScmFileStatus.UNKNOWN;\n        }\n    }\n\n    /**\n     * Adds all files in the given fileSet to the repository.\n     *\n     * @param git     the repo to add the files to\n     * @param fileSet the set of files within the workspace, the files are added\n     *                relative to the basedir of this fileset\n     * @return a list of added files\n     * @throws GitAPIException\n     * @throws NoFilepatternException\n     */\n    public static List<ScmFile> addAllFiles( Git git, ScmFileSet fileSet )\n        throws GitAPIException, NoFilepatternException\n    {\n        URI baseUri = fileSet.getBasedir().toURI();\n        AddCommand add = git.add();\n        for ( File file : fileSet.getFileList() )\n        {\n            File scmFile = file;\n            if (!file.isAbsolute())\n            {\n                scmFile = new File( fileSet.getBasedir().getPath(), file.getPath() );\n            }\n\n            if ( scmFile.exists() )\n            {\n                String path = relativize( baseUri, file );\n                add.addFilepattern( path );\n            }\n        }\n        add.call();\n\n        Status status = git.status().call();\n        Set<String> added = status.getAdded();\n\n        List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n        // rewrite all detected files to now have status 'checked_in'\n        for ( String entry : added )\n        {\n            ScmFile scmfile = new ScmFile( entry, ScmFileStatus.ADDED );\n\n            // if a specific fileSet is given, we have to check if the file is\n            // really tracked\n            for ( Iterator<File> itfl = fileSet.getFileList().iterator(); itfl.hasNext(); )\n            {\n                String path = relativize( baseUri, itfl.next() );\n                if ( path.equals( scmfile.getPath() ) )\n                {\n                    changedFiles.add( scmfile );\n                }\n            }\n        }\n        return changedFiles;\n    }\n\n    private static String relativize( URI baseUri, File f )\n    {\n        String path = f.getPath();\n        if ( f.isAbsolute() )\n        {\n            path = baseUri.relativize( new File( path ).toURI() ).getPath();\n        }\n        return path;\n    }\n\n    /**\n     * Get a list of commits between two revisions.\n     *\n     * @param repo     the repository to work on\n     * @param sortings sorting\n     * @param fromRev  start revision\n     * @param toRev    if null, falls back to head\n     * @param fromDate from which date on\n     * @param toDate   until which date\n     * @param maxLines max number of lines\n     * @return a list of commits, might be empty, but never <code>null<\/code>\n     * @throws IOException\n     * @throws MissingObjectException\n     * @throws IncorrectObjectTypeException\n     */\n    public static List<RevCommit> getRevCommits( Repository repo, RevSort[] sortings, String fromRev, String toRev,\n                                                 Date fromDate, Date toDate, int maxLines )\n        throws IOException, MissingObjectException, IncorrectObjectTypeException\n    {\n        List<RevCommit> revs = new ArrayList<RevCommit>();\n        RevWalk walk = new RevWalk( repo );\n\n        ObjectId fromRevId = fromRev != null ? repo.resolve( fromRev ) : null;\n        ObjectId toRevId = toRev != null ? repo.resolve( toRev ) : null;\n\n        if ( sortings == null || sortings.length == 0 )\n        {\n            sortings = new RevSort[]{ RevSort.TOPO, RevSort.COMMIT_TIME_DESC };\n        }\n\n        for ( final RevSort s : sortings )\n        {\n            walk.sort( s, true );\n        }\n\n        if ( fromDate != null && toDate != null )\n        {\n            walk.setRevFilter( CommitTimeRevFilter.between( fromDate, toDate ) );\n        }\n        else\n        {\n            if ( fromDate != null )\n            {\n                walk.setRevFilter( CommitTimeRevFilter.after( fromDate ) );\n            }\n\n            if ( toDate != null )\n            {\n                walk.setRevFilter( CommitTimeRevFilter.before( toDate ) );\n            }\n        }\n\n        if ( fromRevId != null )\n        {\n            RevCommit c = walk.parseCommit( fromRevId );\n            c.add( RevFlag.UNINTERESTING );\n            RevCommit real = walk.parseCommit( c );\n            walk.markUninteresting( real );\n        }\n\n        if ( toRevId != null )\n        {\n            RevCommit c = walk.parseCommit( toRevId );\n            c.remove( RevFlag.UNINTERESTING );\n            RevCommit real = walk.parseCommit( c );\n            walk.markStart( real );\n        }\n        else\n        {\n            final ObjectId head = repo.resolve( Constants.HEAD );\n            if ( head == null )\n            {\n                throw new RuntimeException( \"Cannot resolve \" + Constants.HEAD );\n            }\n            RevCommit real = walk.parseCommit( head );\n            walk.markStart( real );\n        }\n\n        int n = 0;\n        for ( final RevCommit c : walk )\n        {\n            n++;\n            if ( maxLines != -1 && n > maxLines )\n            {\n                break;\n            }\n\n            revs.add( c );\n        }\n        return revs;\n    }\n\n}\n","lineNo":248}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit utility functions.\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils {\n\n\tprivate JGitUtils() {\n\t}\n\n\t/**\n\t * Construct a logging ProgressMonitor for all JGit operations.\n\t * \n\t * @param logger\n\t * @return a ProgressMonitor for use\n\t */\n\tpublic static ProgressMonitor getMonitor(ScmLogger logger) {\n\t\t// X TODO write an own ProgressMonitor which logs to ScmLogger!\n\t\treturn new TextProgressMonitor();\n\t}\n\n\t/**\n\t * Prepares the in memory configuration of git to connect to the configured\n\t * repository. It configures the following settings in memory: <br />\n\t * <li>push url<\/li> <li>fetch url<\/li>\n\t * <p />\n\t * \n\t * @param logger\n\t *            used to log some details\n\t * @param git\n\t *            the instance to configure (only in memory, not saved)\n\t * @param repository\n\t *            the repo config to be used\n\t * @return {@link CredentialsProvider} in case there are credentials\n\t *         informations configured in the repository.\n\t */\n\tpublic static CredentialsProvider prepareSession(ScmLogger logger, Git git, GitScmProviderRepository repository) {\n\t\tStoredConfig config = git.getRepository().getConfig();\n\t\tconfig.setString(\"remote\", \"origin\", \"url\", repository.getFetchUrl());\n\t\tconfig.setString(\"remote\", \"origin\", \"pushURL\", repository.getPushUrl());\n\t\t// make sure we do not log any passwords to the output\n\t\tlogger.info(\"fetch url: \" + repository.getFetchUrl().replace(repository.getPassword(), \"******\"));\n\t\tlogger.info(\"push url: \" + repository.getPushUrl().replace(repository.getPassword(), \"******\"));\n\t\treturn getCredentials(repository);\n\t}\n\n\t/**\n\t * Creates a credentials provider from the information passed in the\n\t * repository. Current implementation supports: <br />\n\t * <li>UserName/Password<\/li>\n\t * <p />\n\t * \n\t * @param repository\n\t *            the config to get the details from\n\t * @return <code>null<\/code> if there is not enough info to create a\n\t *         provider with\n\t */\n\tpublic static CredentialsProvider getCredentials(GitScmProviderRepository repository) {\n\t\tif (StringUtils.isNotBlank(repository.getUser())) {\n\t\t\treturn new UsernamePasswordCredentialsProvider(repository.getUser(), repository.getPassword());\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Iterable<PushResult> push(ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec) throws GitAPIException, InvalidRemoteException, TransportException {\n\t\tCredentialsProvider credentials = JGitUtils.prepareSession(logger, git, repo);\n\t\tIterable<PushResult> pushResultList = git.push().setCredentialsProvider(credentials).setRefSpecs(refSpec).call();\n\t\tfor (PushResult pushResult : pushResultList) {\n\t\t\tCollection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n\t\t\tfor (RemoteRefUpdate remoteRefUpdate : ru) {\n\t\t\t\tlogger.info(remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString());\n\t\t\t}\n\t\t}\n\t\treturn pushResultList;\n\t}\n\n\t/**\n\t * Does the Repository have any commits?\n\t * \n\t * @param repo\n\t * @return false if there are no commits\n\t */\n\tpublic static boolean hasCommits(Repository repo) {\n\t\tif (repo != null && repo.getDirectory().exists()) {\n\t\t\treturn (new File(repo.getDirectory(), \"objects\").list().length > 2) || (new File(repo.getDirectory(), \"objects/pack\").list().length > 0);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * get a list of all files in the given commit\n\t * \n\t * @param repository\n\t *            the repo\n\t * @param commit\n\t *            the commit to get the files from\n\t * @return a list of files included in the commit\n\t * @throws MissingObjectException\n\t * @throws IncorrectObjectTypeException\n\t * @throws CorruptObjectException\n\t * @throws IOException\n\t */\n\tpublic static List<ScmFile> getFilesInCommit(Repository repository, RevCommit commit) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {\n\t\tList<ScmFile> list = new ArrayList<ScmFile>();\n\t\tif (JGitUtils.hasCommits(repository)) {\n\t\t\tTreeWalk tw = new TreeWalk(repository);\n\t\t\ttw.reset();\n\t\t\ttw.setRecursive(true);\n\t\t\ttw.addTree(commit.getTree());\n\t\t\twhile (tw.next()) {\n\t\t\t\tlist.add(new ScmFile(tw.getPathString(), ScmFileStatus.CHECKED_IN));\n\t\t\t}\n\t\t\ttw.release();\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n\t * \n\t * @param status\n\t * @return the matching ScmFileStatus\n\t * @throws ScmException\n\t *             if the given Status cannot be translated\n\t */\n\tpublic static ScmFileStatus getScmFileStatus(ChangeType changeType) throws ScmException {\n\t\tswitch (changeType) {\n\t\tcase ADD:\n\t\t\treturn ScmFileStatus.ADDED;\n\t\tcase MODIFY:\n\t\t\treturn ScmFileStatus.MODIFIED;\n\t\tcase DELETE:\n\t\t\treturn ScmFileStatus.DELETED;\n\t\tcase RENAME:\n\t\t\treturn ScmFileStatus.RENAMED;\n\t\tcase COPY:\n\t\t\treturn ScmFileStatus.COPIED;\n\t\tdefault:\n\t\t\treturn ScmFileStatus.UNKNOWN;\n\t\t}\n\t}\n\n\t/**\n\t * Adds all files in the given fileSet to the repository.\n\t * \n\t * @param git\n\t *            the repo to add the files to\n\t * @param fileSet\n\t *            the set of files within the workspace, the files are added\n\t *            relative to the basedir of this fileset\n\t * @return a list of files changed\n\t * @throws GitAPIException\n\t * @throws NoFilepatternException\n\t */\n\tpublic static List<ScmFile> addAllFiles(Git git, ScmFileSet fileSet) throws GitAPIException, NoFilepatternException {\n\t\tURI baseUri = fileSet.getBasedir().toURI();\n\t\tAddCommand add = git.add();\n\t\tfor (File file : fileSet.getFileList()) {\n\t\t\tif (file.exists()) {\n\t\t\t\tString path = file.getPath();\n\t\t\t\tif (file.isAbsolute()) {\n\t\t\t\t\tpath = baseUri.relativize(new File(path).toURI()).getPath();\n\t\t\t\t}\n\t\t\t\tadd.addFilepattern(path);\n\t\t\t}\n\t\t}\n\t\tadd.call();\n\n\t\tStatus status = git.status().call();\n\t\tSet<String> changed = status.getChanged();\n\n\t\tList<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n\t\t// rewrite all detected files to now have status 'checked_in'\n\t\tfor (String entry : changed) {\n\t\t\tScmFile scmfile = new ScmFile(entry, ScmFileStatus.MODIFIED);\n\n\t\t\t// if a specific fileSet is given, we have to check if the file is\n\t\t\t// really tracked\n\t\t\tfor (Iterator<File> itfl = fileSet.getFileList().iterator(); itfl.hasNext();) {\n\t\t\t\tFile f = (File) itfl.next();\n\t\t\t\tif (f.toString().equals(scmfile.getPath())) {\n\t\t\t\t\tchangedFiles.add(scmfile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changedFiles;\n\t}\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit utility functions.\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils {\n\n\tprivate JGitUtils() {\n\t}\n\n\t/**\n\t * Construct a logging ProgressMonitor for all JGit operations.\n\t * \n\t * @param logger\n\t * @return a ProgressMonitor for use\n\t */\n\tpublic static ProgressMonitor getMonitor(ScmLogger logger) {\n\t\t// X TODO write an own ProgressMonitor which logs to ScmLogger!\n\t\treturn new TextProgressMonitor();\n\t}\n\n\t/**\n\t * Prepares the in memory configuration of git to connect to the configured\n\t * repository. It configures the following settings in memory: <br />\n\t * <li>push url<\/li> <li>fetch url<\/li>\n\t * <p />\n\t * \n\t * @param logger\n\t *            used to log some details\n\t * @param git\n\t *            the instance to configure (only in memory, not saved)\n\t * @param repository\n\t *            the repo config to be used\n\t * @return {@link CredentialsProvider} in case there are credentials\n\t *         informations configured in the repository.\n\t */\n\tpublic static CredentialsProvider prepareSession(ScmLogger logger, Git git, GitScmProviderRepository repository) {\n\t\tStoredConfig config = git.getRepository().getConfig();\n\t\tconfig.setString(\"remote\", \"origin\", \"url\", repository.getFetchUrl());\n\t\tconfig.setString(\"remote\", \"origin\", \"pushURL\", repository.getPushUrl());\n\t\t// make sure we do not log any passwords to the output\n\t\tString password = repository.getPassword() != null ? repository.getPassword() : \"\";\n\t\tlogger.info(\"fetch url: \" + repository.getFetchUrl().replace(password, \"******\"));\n\t\tlogger.info(\"push url: \" + repository.getPushUrl().replace(password, \"******\"));\n\t\treturn getCredentials(repository);\n\t}\n\n\t/**\n\t * Creates a credentials provider from the information passed in the\n\t * repository. Current implementation supports: <br />\n\t * <li>UserName/Password<\/li>\n\t * <p />\n\t * \n\t * @param repository\n\t *            the config to get the details from\n\t * @return <code>null<\/code> if there is not enough info to create a\n\t *         provider with\n\t */\n\tpublic static CredentialsProvider getCredentials(GitScmProviderRepository repository) {\n\t\tif (StringUtils.isNotBlank(repository.getUser()) && StringUtils.isNotBlank(repository.getPassword())) {\n\t\t\treturn new UsernamePasswordCredentialsProvider(repository.getUser(), repository.getPassword());\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Iterable<PushResult> push(ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec) throws GitAPIException, InvalidRemoteException, TransportException {\n\t\tCredentialsProvider credentials = JGitUtils.prepareSession(logger, git, repo);\n\t\tIterable<PushResult> pushResultList = git.push().setCredentialsProvider(credentials).setRefSpecs(refSpec).call();\n\t\tfor (PushResult pushResult : pushResultList) {\n\t\t\tCollection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n\t\t\tfor (RemoteRefUpdate remoteRefUpdate : ru) {\n\t\t\t\tlogger.info(remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString());\n\t\t\t}\n\t\t}\n\t\treturn pushResultList;\n\t}\n\n\t/**\n\t * Does the Repository have any commits?\n\t * \n\t * @param repo\n\t * @return false if there are no commits\n\t */\n\tpublic static boolean hasCommits(Repository repo) {\n\t\tif (repo != null && repo.getDirectory().exists()) {\n\t\t\treturn (new File(repo.getDirectory(), \"objects\").list().length > 2) || (new File(repo.getDirectory(), \"objects/pack\").list().length > 0);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * get a list of all files in the given commit\n\t * \n\t * @param repository\n\t *            the repo\n\t * @param commit\n\t *            the commit to get the files from\n\t * @return a list of files included in the commit\n\t * @throws MissingObjectException\n\t * @throws IncorrectObjectTypeException\n\t * @throws CorruptObjectException\n\t * @throws IOException\n\t */\n\tpublic static List<ScmFile> getFilesInCommit(Repository repository, RevCommit commit) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {\n\t\tList<ScmFile> list = new ArrayList<ScmFile>();\n\t\tif (JGitUtils.hasCommits(repository)) {\n\t\t\tTreeWalk tw = new TreeWalk(repository);\n\t\t\ttw.reset();\n\t\t\ttw.setRecursive(true);\n\t\t\ttw.addTree(commit.getTree());\n\t\t\twhile (tw.next()) {\n\t\t\t\tlist.add(new ScmFile(tw.getPathString(), ScmFileStatus.CHECKED_IN));\n\t\t\t}\n\t\t\ttw.release();\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n\t * \n\t * @param status\n\t * @return the matching ScmFileStatus\n\t * @throws ScmException\n\t *             if the given Status cannot be translated\n\t */\n\tpublic static ScmFileStatus getScmFileStatus(ChangeType changeType) throws ScmException {\n\t\tswitch (changeType) {\n\t\tcase ADD:\n\t\t\treturn ScmFileStatus.ADDED;\n\t\tcase MODIFY:\n\t\t\treturn ScmFileStatus.MODIFIED;\n\t\tcase DELETE:\n\t\t\treturn ScmFileStatus.DELETED;\n\t\tcase RENAME:\n\t\t\treturn ScmFileStatus.RENAMED;\n\t\tcase COPY:\n\t\t\treturn ScmFileStatus.COPIED;\n\t\tdefault:\n\t\t\treturn ScmFileStatus.UNKNOWN;\n\t\t}\n\t}\n\n\t/**\n\t * Adds all files in the given fileSet to the repository.\n\t * \n\t * @param git\n\t *            the repo to add the files to\n\t * @param fileSet\n\t *            the set of files within the workspace, the files are added\n\t *            relative to the basedir of this fileset\n\t * @return a list of files changed\n\t * @throws GitAPIException\n\t * @throws NoFilepatternException\n\t */\n\tpublic static List<ScmFile> addAllFiles(Git git, ScmFileSet fileSet) throws GitAPIException, NoFilepatternException {\n\t\tURI baseUri = fileSet.getBasedir().toURI();\n\t\tAddCommand add = git.add();\n\t\tfor (File file : fileSet.getFileList()) {\n\t\t\tif (file.exists()) {\n\t\t\t\tString path = file.getPath();\n\t\t\t\tif (file.isAbsolute()) {\n\t\t\t\t\tpath = baseUri.relativize(new File(path).toURI()).getPath();\n\t\t\t\t}\n\t\t\t\tadd.addFilepattern(path);\n\t\t\t}\n\t\t}\n\t\tadd.call();\n\n\t\tStatus status = git.status().call();\n\t\tSet<String> changed = status.getChanged();\n\n\t\tList<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n\t\t// rewrite all detected files to now have status 'checked_in'\n\t\tfor (String entry : changed) {\n\t\t\tScmFile scmfile = new ScmFile(entry, ScmFileStatus.MODIFIED);\n\n\t\t\t// if a specific fileSet is given, we have to check if the file is\n\t\t\t// really tracked\n\t\t\tfor (Iterator<File> itfl = fileSet.getFileList().iterator(); itfl.hasNext();) {\n\t\t\t\tFile f = (File) itfl.next();\n\t\t\t\tif (f.toString().equals(scmfile.getPath())) {\n\t\t\t\t\tchangedFiles.add(scmfile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changedFiles;\n\t}\n}\n","lineNo":104}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.PushCommand;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteConfig;\nimport org.eclipse.jgit.transport.URIish;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @version $Id: JGitCheckInCommand.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitCheckInCommand extends AbstractCheckInCommand implements GitCommand {\n\t/** {@inheritDoc} */\n\tprotected CheckInScmResult executeCheckInCommand(ScmProviderRepository repo, ScmFileSet fileSet, String message, ScmVersion version) throws ScmException {\n\n\t\ttry {\n\t\t\tGit git = Git.open(fileSet.getBasedir());\n\n\t\t\tboolean doCommit = false;\n\t\t\tif (!fileSet.getFileList().isEmpty()) {\n\t\t\t\tAddCommand add = git.add();\n\t\t\t\tfor (File file : fileSet.getFileList()) {\n\t\t\t\t\tdoCommit = true;\n\t\t\t\t\tadd.addFilepattern(file.getPath());\n\t\t\t\t}\n\t\t\t\tadd.call();\n\t\t\t} else {\n\t\t\t\t// add all tracked files which are modified manually\n\t\t\t\tSet<String> changeds = git.status().call().getModified();\n\t\t\t\tif (changeds.isEmpty()) {\n\t\t\t\t\t// warn there is nothing to add\n\t\t\t\t\tgetLogger().warn(\"there are no files to be added\");\n\t\t\t\t\tdoCommit = false;\n\t\t\t\t} else {\n\t\t\t\t\tAddCommand add = git.add();\n\t\t\t\t\tfor (String changed : changeds) {\n\t\t\t\t\t\tadd.addFilepattern(changed);\n\t\t\t\t\t\tdoCommit = true;\n\t\t\t\t\t}\n\t\t\t\t\tadd.call();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (doCommit) {\n\t\t\t\tRevCommit call = git.commit().setMessage(message).call();\n\t\t\t\tgetLogger().info(\"commit done: \" + call.getShortMessage());\n\t\t\t}\n\n\t\t\tif (repo.isPushChanges()) {\n\t\t\t\tString branch = version != null ? version.getName() : null;\n\t\t\t\tif (StringUtils.isBlank(branch)) {\n\t\t\t\t\tbranch = git.getRepository().getBranch();\n\t\t\t\t}\n\t\t\t\tRefSpec refSpec = new RefSpec(\"refs/heads/\" + branch + \":\" + \"refs/heads/\" + branch);\n\t\t\t\tgetLogger().info(\"push changes to remote... \" + refSpec.toString());\n\t\t\t\tJGitUtils.push(getLogger(), git, (GitScmProviderRepository) repo, refSpec);\n\t\t\t}\n\n\t\t\tList<ScmFile> checkedInFiles = new ArrayList<ScmFile>();\n\t\t\t// TODO get a list of the commited files\n\n\t\t\treturn new CheckInScmResult(\"JGit checkin\", checkedInFiles);\n\t\t} catch (Exception e) {\n\t\t\tthrow new ScmException(\"JGit checkin failure!\", e);\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.git.command.GitCommand;\nimport org.apache.maven.scm.provider.git.jgit.command.JGitUtils;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.RefSpec;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id: JGitCheckInCommand.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitCheckInCommand extends AbstractCheckInCommand implements GitCommand {\n\t/** {@inheritDoc} */\n\tprotected CheckInScmResult executeCheckInCommand(ScmProviderRepository repo, ScmFileSet fileSet, String message, ScmVersion version) throws ScmException {\n\n\t\ttry {\n\t\t\tFile basedir = fileSet.getBasedir();\n\t\t\tGit git = Git.open(basedir);\n\n\t\t\tboolean doCommit = false;\n\n\t\t\tif (!fileSet.getFileList().isEmpty()) {\n\t\t\t\tdoCommit = JGitUtils.addAllFiles(git, fileSet).size() > 0;\n\t\t\t} else {\n\t\t\t\t// add all tracked files which are modified manually\n\t\t\t\tSet<String> changeds = git.status().call().getModified();\n\t\t\t\tif (changeds.isEmpty()) {\n\t\t\t\t\t// warn there is nothing to add\n\t\t\t\t\tgetLogger().warn(\"there are no files to be added\");\n\t\t\t\t\tdoCommit = false;\n\t\t\t\t} else {\n\t\t\t\t\tAddCommand add = git.add();\n\t\t\t\t\tfor (String changed : changeds) {\n\t\t\t\t\t\tgetLogger().debug(\"add manualy: \" + changed);\n\t\t\t\t\t\tadd.addFilepattern(changed);\n\t\t\t\t\t\tdoCommit = true;\n\t\t\t\t\t}\n\t\t\t\t\tadd.call();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<ScmFile> checkedInFiles = Collections.emptyList();\n\t\t\tif (doCommit) {\n\t\t\t\tRevCommit commitRev = git.commit().setMessage(message).call();\n\t\t\t\tgetLogger().info(\"commit done: \" + commitRev.getShortMessage());\n\t\t\t\tcheckedInFiles = JGitUtils.getFilesInCommit(git.getRepository(), commitRev);\n\t\t\t\tif (getLogger().isDebugEnabled()) {\n\t\t\t\t\tfor (ScmFile scmFile : checkedInFiles) {\n\t\t\t\t\t\tgetLogger().debug(\"in commit: \" + scmFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isPushChanges()) {\n\t\t\t\tString branch = version != null ? version.getName() : null;\n\t\t\t\tif (StringUtils.isBlank(branch)) {\n\t\t\t\t\tbranch = git.getRepository().getBranch();\n\t\t\t\t}\n\t\t\t\tRefSpec refSpec = new RefSpec(\"refs/heads/\" + branch + \":\" + \"refs/heads/\" + branch);\n\t\t\t\tgetLogger().info(\"push changes to remote... \" + refSpec.toString());\n\t\t\t\tJGitUtils.push(getLogger(), git, (GitScmProviderRepository) repo, refSpec);\n\t\t\t}\n\n\t\t\treturn new CheckInScmResult(\"JGit checkin\", checkedInFiles);\n\t\t} catch (Exception e) {\n\t\t\tthrow new ScmException(\"JGit checkin failure!\", e);\n\t\t}\n\t}\n\n}\n","lineNo":53}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\n//import org.eclipse.jgit.simple.SimpleRepository;\n//import org.eclipse.jgit.simple.StatusEntry;\n//import org.eclipse.jgit.simple.StatusEntry.IndexStatus;\n//import org.eclipse.jgit.simple.StatusEntry.RepoStatus;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit SimpleRepository utility functions.\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils {\n\n\tprivate JGitUtils() {\n\t}\n\n\t/**\n\t * Construct a logging ProgressMonitor for all JGit operations.\n\t * \n\t * @param logger\n\t * @return a ProgressMonitor for use\n\t */\n\tpublic static ProgressMonitor getMonitor(ScmLogger logger) {\n\t\t// X TODO write an own ProgressMonitor which logs to ScmLogger!\n\t\treturn new TextProgressMonitor();\n\t}\n\n\tpublic static CredentialsProvider prepareSession(ScmLogger logger, Git git, GitScmProviderRepository repository) {\n\t\tStoredConfig config = git.getRepository().getConfig();\n\t\tconfig.setString(\"remote\", \"origin\", \"url\", repository.getFetchUrl());\n\t\tconfig.setString(\"remote\", \"origin\", \"pushURL\", repository.getPushUrl());\n\t\tlogger.info(\"fetch url: \" + repository.getFetchUrl().replace(repository.getPassword(), \"******\"));\n\t\tlogger.info(\"push url: \" + repository.getPushUrl().replace(repository.getPassword(), \"******\"));\n\t\treturn getCredentials(repository);\n\t}\n\n\tpublic static CredentialsProvider getCredentials(GitScmProviderRepository repository) {\n\t\tif (StringUtils.isNotBlank(repository.getUser())) {\n\t\t\treturn new UsernamePasswordCredentialsProvider(repository.getUser(), repository.getPassword());\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Iterable<PushResult> push(ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec) throws GitAPIException, InvalidRemoteException, TransportException {\n\t\tCredentialsProvider credentials = JGitUtils.prepareSession(logger, git, repo);\n\t\tIterable<PushResult> pushResultList = git.push().setCredentialsProvider(credentials).setRefSpecs(refSpec).call();\n\t\tfor (PushResult pushResult : pushResultList) {\n\t\t\tCollection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n\t\t\tfor (RemoteRefUpdate remoteRefUpdate : ru) {\n\t\t\t\tlogger.info(remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString());\n\t\t\t}\n\t\t}\n\t\treturn pushResultList;\n\t}\n\n\t//\n\t// /**\n\t// * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n\t// *\n\t// * @param status\n\t// * @return the matching ScmFileStatus\n\t// * @throws ScmException if the given Status cannot be translated\n\t// */\n\t// public static ScmFileStatus getScmFileStatus( StatusEntry status )\n\t// throws ScmException\n\t// {\n\t// IndexStatus is = status.getIndexStatus();\n\t// RepoStatus rs = status.getRepoStatus();\n\t//\n\t// if ( is.equals( IndexStatus.ADDED ) )\n\t// {\n\t// return ScmFileStatus.ADDED;\n\t// }\n\t// else if ( is.equals( IndexStatus.UNCHANGED ) && rs.equals(\n\t// RepoStatus.UNCHANGED ) )\n\t// {\n\t// return ScmFileStatus.CHECKED_IN;\n\t// }\n\t// else if ( is.equals( IndexStatus.MODIFIED ) )\n\t// {\n\t// return ScmFileStatus.MODIFIED;\n\t// }\n\t// else if ( is.equals( IndexStatus.DELETED ) && rs.equals(\n\t// RepoStatus.REMOVED ) )\n\t// {\n\t// return ScmFileStatus.DELETED;\n\t// }\n\t// else {\n\t// return ScmFileStatus.UNKNOWN;\n\t// }\n\t//\n\t// /*X\n\t// switch (status) {\n\t// case UNMERGED:\n\t// return ScmFileStatus.CONFLICT;\n\t// case OTHER:\n\t// return ScmFileStatus.ADDED;\n\t// default:\n\t//\n\t// }\n\t// */\n\t// }\n\t//\n\t// /**\n\t// * Get the branch name from the ScmVersion\n\t// * @param scmVersion\n\t// * @return branch name if the ScmVersion indicates a branch, with taking\n\t// <code>&quot;master&quot;<\/code>\n\t// * as default branch name. For tags <code>null<\/code> will be returned.\n\t// */\n\t// public static String getBranchName( ScmVersion scmVersion )\n\t// {\n\t// String branchName = \"master\";\n\t//\n\t// // we explicitly request branches, since tags will be handled differently\n\t// in git\n\t// if (scmVersion instanceof ScmTag) {\n\t// return null;\n\t// }\n\t//\n\t// if (scmVersion instanceof ScmBranch)\n\t// {\n\t// branchName = scmVersion.getName();\n\t// }\n\t//\n\t// return branchName;\n\t// }\n\t//\n\t// /**\n\t// * get the tag name from the ScmVersion\n\t// * @param scmVersion\n\t// * @return tag name if the ScmVersion indicates a tag, <code>null<\/code>\n\t// otherwise\n\t// */\n\t// public static String getTagName( ScmVersion scmVersion )\n\t// {\n\t// // we explicitly request branches, since tags will be handled differently\n\t// in git\n\t// if (scmVersion instanceof ScmTag) {\n\t// return scmVersion.getName();\n\t// }\n\t//\n\t// return null;\n\t// }\n\t//\n\t// /**\n\t// * Add all files of the given fileSet to the SimpleRepository.\n\t// * This will make all relative paths be under the repositories base\n\t// directory.\n\t// *\n\t// * @param srep\n\t// * @param fileSet\n\t// * @throws Exception\n\t// */\n\t// public static void addAllFiles( SimpleRepository srep, ScmFileSet fileSet\n\t// )\n\t// throws Exception\n\t// {\n\t// @SuppressWarnings(\"unchecked\")\n\t// List<File> addFiles = fileSet.getFileList();\n\t// if ( addFiles != null )\n\t// {\n\t// for ( File addFile : addFiles )\n\t// {\n\t// if ( !addFile.isAbsolute() )\n\t// {\n\t// addFile = new File( fileSet.getBasedir(), addFile.getPath() );\n\t// }\n\t//\n\t// srep.add( addFile, false );\n\t// }\n\t//\n\t// }\n\t// }\n\t//\n\t//\n\t// /**\n\t// * Convert from List<StatusEntry> to List<ScmFile>\n\t// * @param statusEntries\n\t// * @param addUnknown if <code>false<\/code>, this function will not add\n\t// files with 'unknown' status to the returned list\n\t// * @return list with ScmFiles ready for use in ScmResult and other\n\t// maven-scm APIs\n\t// * @throws ScmException\n\t// */\n\t// public static List<ScmFile> getChangedFiles( List<StatusEntry>\n\t// statusEntries, boolean addUnknown )\n\t// throws ScmException\n\t// {\n\t// if ( statusEntries == null )\n\t// {\n\t// return null;\n\t// }\n\t//\n\t// List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\t//\n\t// for ( StatusEntry statusEntry : statusEntries )\n\t// {\n\t// ScmFileStatus status = getScmFileStatus( statusEntry );\n\t// if ( addUnknown || !status.equals( ScmFileStatus.UNKNOWN ) )\n\t// {\n\t// changedFiles.add( new ScmFile( statusEntry.getFilePath(), status ) );\n\t// }\n\t//\n\t// }\n\t// return changedFiles;\n\t// }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit utility functions.\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils {\n\n\tprivate JGitUtils() {\n\t}\n\n\t/**\n\t * Construct a logging ProgressMonitor for all JGit operations.\n\t * \n\t * @param logger\n\t * @return a ProgressMonitor for use\n\t */\n\tpublic static ProgressMonitor getMonitor(ScmLogger logger) {\n\t\t// X TODO write an own ProgressMonitor which logs to ScmLogger!\n\t\treturn new TextProgressMonitor();\n\t}\n\n\t/**\n\t * Prepares the in memory configuration of git to connect to the configured\n\t * repository. It configures the following settings in memory: <br />\n\t * <li>push url<\/li> <li>fetch url<\/li>\n\t * <p />\n\t * \n\t * @param logger\n\t *            used to log some details\n\t * @param git\n\t *            the instance to configure (only in memory, not saved)\n\t * @param repository\n\t *            the repo config to be used\n\t * @return {@link CredentialsProvider} in case there are credentials\n\t *         informations configured in the repository.\n\t */\n\tpublic static CredentialsProvider prepareSession(ScmLogger logger, Git git, GitScmProviderRepository repository) {\n\t\tStoredConfig config = git.getRepository().getConfig();\n\t\tconfig.setString(\"remote\", \"origin\", \"url\", repository.getFetchUrl());\n\t\tconfig.setString(\"remote\", \"origin\", \"pushURL\", repository.getPushUrl());\n\t\t// make sure we do not log any passwords to the output\n\t\tlogger.info(\"fetch url: \" + repository.getFetchUrl().replace(repository.getPassword(), \"******\"));\n\t\tlogger.info(\"push url: \" + repository.getPushUrl().replace(repository.getPassword(), \"******\"));\n\t\treturn getCredentials(repository);\n\t}\n\n\t/**\n\t * Creates a credentials provider from the information passed in the\n\t * repository. Current implementation supports: <br />\n\t * <li>UserName/Password<\/li>\n\t * <p />\n\t * \n\t * @param repository\n\t *            the config to get the details from\n\t * @return <code>null<\/code> if there is not enough info to create a\n\t *         provider with\n\t */\n\tpublic static CredentialsProvider getCredentials(GitScmProviderRepository repository) {\n\t\tif (StringUtils.isNotBlank(repository.getUser())) {\n\t\t\treturn new UsernamePasswordCredentialsProvider(repository.getUser(), repository.getPassword());\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Iterable<PushResult> push(ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec) throws GitAPIException, InvalidRemoteException, TransportException {\n\t\tCredentialsProvider credentials = JGitUtils.prepareSession(logger, git, repo);\n\t\tIterable<PushResult> pushResultList = git.push().setCredentialsProvider(credentials).setRefSpecs(refSpec).call();\n\t\tfor (PushResult pushResult : pushResultList) {\n\t\t\tCollection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n\t\t\tfor (RemoteRefUpdate remoteRefUpdate : ru) {\n\t\t\t\tlogger.info(remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString());\n\t\t\t}\n\t\t}\n\t\treturn pushResultList;\n\t}\n\n\t/**\n\t * Does the Repository have any commits?\n\t * \n\t * @param repo\n\t * @return false if there are no commits\n\t */\n\tpublic static boolean hasCommits(Repository repo) {\n\t\tif (repo != null && repo.getDirectory().exists()) {\n\t\t\treturn (new File(repo.getDirectory(), \"objects\").list().length > 2) || (new File(repo.getDirectory(), \"objects/pack\").list().length > 0);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * get a list of all files in the given commit\n\t * \n\t * @param repository\n\t *            the repo\n\t * @param commit\n\t *            the commit to get the files from\n\t * @return a list of files included in the commit\n\t * @throws MissingObjectException\n\t * @throws IncorrectObjectTypeException\n\t * @throws CorruptObjectException\n\t * @throws IOException\n\t */\n\tpublic static List<ScmFile> getFilesInCommit(Repository repository, RevCommit commit) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {\n\t\tList<ScmFile> list = new ArrayList<ScmFile>();\n\t\tif (JGitUtils.hasCommits(repository)) {\n\t\t\tTreeWalk tw = new TreeWalk(repository);\n\t\t\ttw.reset();\n\t\t\ttw.setRecursive(true);\n\t\t\ttw.addTree(commit.getTree());\n\t\t\twhile (tw.next()) {\n\t\t\t\tlist.add(new ScmFile(tw.getPathString(), ScmFileStatus.CHECKED_IN));\n\t\t\t}\n\t\t\ttw.release();\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n\t * \n\t * @param status\n\t * @return the matching ScmFileStatus\n\t * @throws ScmException\n\t *             if the given Status cannot be translated\n\t */\n\tpublic static ScmFileStatus getScmFileStatus(ChangeType changeType) throws ScmException {\n\t\tswitch (changeType) {\n\t\tcase ADD:\n\t\t\treturn ScmFileStatus.ADDED;\n\t\tcase MODIFY:\n\t\t\treturn ScmFileStatus.MODIFIED;\n\t\tcase DELETE:\n\t\t\treturn ScmFileStatus.DELETED;\n\t\tcase RENAME:\n\t\t\treturn ScmFileStatus.RENAMED;\n\t\tcase COPY:\n\t\t\treturn ScmFileStatus.COPIED;\n\t\tdefault:\n\t\t\treturn ScmFileStatus.UNKNOWN;\n\t\t}\n\t}\n\n\t/**\n\t * Adds all files in the given fileSet to the repository.\n\t * \n\t * @param git\n\t *            the repo to add the files to\n\t * @param fileSet\n\t *            the set of files within the workspace, the files are added\n\t *            relative to the basedir of this fileset\n\t * @return a list of files changed\n\t * @throws GitAPIException\n\t * @throws NoFilepatternException\n\t */\n\tpublic static List<ScmFile> addAllFiles(Git git, ScmFileSet fileSet) throws GitAPIException, NoFilepatternException {\n\t\tURI baseUri = fileSet.getBasedir().toURI();\n\t\tAddCommand add = git.add();\n\t\tfor (File file : fileSet.getFileList()) {\n\t\t\tif (file.exists()) {\n\t\t\t\tString path = file.getPath();\n\t\t\t\tif (file.isAbsolute()) {\n\t\t\t\t\tpath = baseUri.relativize(new File(path).toURI()).getPath();\n\t\t\t\t}\n\t\t\t\tadd.addFilepattern(path);\n\t\t\t}\n\t\t}\n\t\tadd.call();\n\n\t\tStatus status = git.status().call();\n\t\tSet<String> changed = status.getChanged();\n\n\t\tList<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n\t\t// rewrite all detected files to now have status 'checked_in'\n\t\tfor (String entry : changed) {\n\t\t\tScmFile scmfile = new ScmFile(entry, ScmFileStatus.MODIFIED);\n\n\t\t\t// if a specific fileSet is given, we have to check if the file is\n\t\t\t// really tracked\n\t\t\tfor (Iterator<File> itfl = fileSet.getFileList().iterator(); itfl.hasNext();) {\n\t\t\t\tFile f = (File) itfl.next();\n\t\t\t\tif (f.toString().equals(scmfile.getPath())) {\n\t\t\t\t\tchangedFiles.add(scmfile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changedFiles;\n\t}\n}\n","lineNo":222}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\n//import org.eclipse.jgit.simple.SimpleRepository;\n//import org.eclipse.jgit.simple.StatusEntry;\n//import org.eclipse.jgit.simple.StatusEntry.IndexStatus;\n//import org.eclipse.jgit.simple.StatusEntry.RepoStatus;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit SimpleRepository utility functions.\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils {\n\n\tprivate JGitUtils() {\n\t}\n\n\t/**\n\t * Construct a logging ProgressMonitor for all JGit operations.\n\t * \n\t * @param logger\n\t * @return a ProgressMonitor for use\n\t */\n\tpublic static ProgressMonitor getMonitor(ScmLogger logger) {\n\t\t// X TODO write an own ProgressMonitor which logs to ScmLogger!\n\t\treturn new TextProgressMonitor();\n\t}\n\n\tpublic static CredentialsProvider prepareSession(ScmLogger logger, Git git, GitScmProviderRepository repository) {\n\t\tStoredConfig config = git.getRepository().getConfig();\n\t\tconfig.setString(\"remote\", \"origin\", \"url\", repository.getFetchUrl());\n\t\tconfig.setString(\"remote\", \"origin\", \"pushURL\", repository.getPushUrl());\n\t\tlogger.info(\"fetch url: \" + repository.getFetchUrl().replace(repository.getPassword(), \"******\"));\n\t\tlogger.info(\"push url: \" + repository.getPushUrl().replace(repository.getPassword(), \"******\"));\n\t\treturn getCredentials(repository);\n\t}\n\n\tpublic static CredentialsProvider getCredentials(GitScmProviderRepository repository) {\n\t\tif (StringUtils.isNotBlank(repository.getUser())) {\n\t\t\treturn new UsernamePasswordCredentialsProvider(repository.getUser(), repository.getPassword());\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Iterable<PushResult> push(ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec) throws GitAPIException, InvalidRemoteException, TransportException {\n\t\tCredentialsProvider credentials = JGitUtils.prepareSession(logger, git, repo);\n\t\tIterable<PushResult> pushResultList = git.push().setCredentialsProvider(credentials).setRefSpecs(refSpec).call();\n\t\tfor (PushResult pushResult : pushResultList) {\n\t\t\tCollection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n\t\t\tfor (RemoteRefUpdate remoteRefUpdate : ru) {\n\t\t\t\tlogger.info(remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString());\n\t\t\t}\n\t\t}\n\t\treturn pushResultList;\n\t}\n\n\t//\n\t// /**\n\t// * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n\t// *\n\t// * @param status\n\t// * @return the matching ScmFileStatus\n\t// * @throws ScmException if the given Status cannot be translated\n\t// */\n\t// public static ScmFileStatus getScmFileStatus( StatusEntry status )\n\t// throws ScmException\n\t// {\n\t// IndexStatus is = status.getIndexStatus();\n\t// RepoStatus rs = status.getRepoStatus();\n\t//\n\t// if ( is.equals( IndexStatus.ADDED ) )\n\t// {\n\t// return ScmFileStatus.ADDED;\n\t// }\n\t// else if ( is.equals( IndexStatus.UNCHANGED ) && rs.equals(\n\t// RepoStatus.UNCHANGED ) )\n\t// {\n\t// return ScmFileStatus.CHECKED_IN;\n\t// }\n\t// else if ( is.equals( IndexStatus.MODIFIED ) )\n\t// {\n\t// return ScmFileStatus.MODIFIED;\n\t// }\n\t// else if ( is.equals( IndexStatus.DELETED ) && rs.equals(\n\t// RepoStatus.REMOVED ) )\n\t// {\n\t// return ScmFileStatus.DELETED;\n\t// }\n\t// else {\n\t// return ScmFileStatus.UNKNOWN;\n\t// }\n\t//\n\t// /*X\n\t// switch (status) {\n\t// case UNMERGED:\n\t// return ScmFileStatus.CONFLICT;\n\t// case OTHER:\n\t// return ScmFileStatus.ADDED;\n\t// default:\n\t//\n\t// }\n\t// */\n\t// }\n\t//\n\t// /**\n\t// * Get the branch name from the ScmVersion\n\t// * @param scmVersion\n\t// * @return branch name if the ScmVersion indicates a branch, with taking\n\t// <code>&quot;master&quot;<\/code>\n\t// * as default branch name. For tags <code>null<\/code> will be returned.\n\t// */\n\t// public static String getBranchName( ScmVersion scmVersion )\n\t// {\n\t// String branchName = \"master\";\n\t//\n\t// // we explicitly request branches, since tags will be handled differently\n\t// in git\n\t// if (scmVersion instanceof ScmTag) {\n\t// return null;\n\t// }\n\t//\n\t// if (scmVersion instanceof ScmBranch)\n\t// {\n\t// branchName = scmVersion.getName();\n\t// }\n\t//\n\t// return branchName;\n\t// }\n\t//\n\t// /**\n\t// * get the tag name from the ScmVersion\n\t// * @param scmVersion\n\t// * @return tag name if the ScmVersion indicates a tag, <code>null<\/code>\n\t// otherwise\n\t// */\n\t// public static String getTagName( ScmVersion scmVersion )\n\t// {\n\t// // we explicitly request branches, since tags will be handled differently\n\t// in git\n\t// if (scmVersion instanceof ScmTag) {\n\t// return scmVersion.getName();\n\t// }\n\t//\n\t// return null;\n\t// }\n\t//\n\t// /**\n\t// * Add all files of the given fileSet to the SimpleRepository.\n\t// * This will make all relative paths be under the repositories base\n\t// directory.\n\t// *\n\t// * @param srep\n\t// * @param fileSet\n\t// * @throws Exception\n\t// */\n\t// public static void addAllFiles( SimpleRepository srep, ScmFileSet fileSet\n\t// )\n\t// throws Exception\n\t// {\n\t// @SuppressWarnings(\"unchecked\")\n\t// List<File> addFiles = fileSet.getFileList();\n\t// if ( addFiles != null )\n\t// {\n\t// for ( File addFile : addFiles )\n\t// {\n\t// if ( !addFile.isAbsolute() )\n\t// {\n\t// addFile = new File( fileSet.getBasedir(), addFile.getPath() );\n\t// }\n\t//\n\t// srep.add( addFile, false );\n\t// }\n\t//\n\t// }\n\t// }\n\t//\n\t//\n\t// /**\n\t// * Convert from List<StatusEntry> to List<ScmFile>\n\t// * @param statusEntries\n\t// * @param addUnknown if <code>false<\/code>, this function will not add\n\t// files with 'unknown' status to the returned list\n\t// * @return list with ScmFiles ready for use in ScmResult and other\n\t// maven-scm APIs\n\t// * @throws ScmException\n\t// */\n\t// public static List<ScmFile> getChangedFiles( List<StatusEntry>\n\t// statusEntries, boolean addUnknown )\n\t// throws ScmException\n\t// {\n\t// if ( statusEntries == null )\n\t// {\n\t// return null;\n\t// }\n\t//\n\t// List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\t//\n\t// for ( StatusEntry statusEntry : statusEntries )\n\t// {\n\t// ScmFileStatus status = getScmFileStatus( statusEntry );\n\t// if ( addUnknown || !status.equals( ScmFileStatus.UNKNOWN ) )\n\t// {\n\t// changedFiles.add( new ScmFile( statusEntry.getFilePath(), status ) );\n\t// }\n\t//\n\t// }\n\t// return changedFiles;\n\t// }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.jgit.command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.git.repository.GitScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.eclipse.jgit.api.AddCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.Status;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.api.errors.InvalidRemoteException;\nimport org.eclipse.jgit.api.errors.NoFilepatternException;\nimport org.eclipse.jgit.api.errors.TransportException;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.errors.CorruptObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.lib.ProgressMonitor;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.eclipse.jgit.lib.TextProgressMonitor;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.CredentialsProvider;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.treewalk.TreeWalk;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * JGit utility functions.\n * \n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Dominik Bartholdi (imod)\n * @version $Id: JGitUtils.java 894145 2009-12-28 10:13:39Z struberg $\n */\npublic class JGitUtils {\n\n\tprivate JGitUtils() {\n\t}\n\n\t/**\n\t * Construct a logging ProgressMonitor for all JGit operations.\n\t * \n\t * @param logger\n\t * @return a ProgressMonitor for use\n\t */\n\tpublic static ProgressMonitor getMonitor(ScmLogger logger) {\n\t\t// X TODO write an own ProgressMonitor which logs to ScmLogger!\n\t\treturn new TextProgressMonitor();\n\t}\n\n\t/**\n\t * Prepares the in memory configuration of git to connect to the configured\n\t * repository. It configures the following settings in memory: <br />\n\t * <li>push url<\/li> <li>fetch url<\/li>\n\t * <p />\n\t * \n\t * @param logger\n\t *            used to log some details\n\t * @param git\n\t *            the instance to configure (only in memory, not saved)\n\t * @param repository\n\t *            the repo config to be used\n\t * @return {@link CredentialsProvider} in case there are credentials\n\t *         informations configured in the repository.\n\t */\n\tpublic static CredentialsProvider prepareSession(ScmLogger logger, Git git, GitScmProviderRepository repository) {\n\t\tStoredConfig config = git.getRepository().getConfig();\n\t\tconfig.setString(\"remote\", \"origin\", \"url\", repository.getFetchUrl());\n\t\tconfig.setString(\"remote\", \"origin\", \"pushURL\", repository.getPushUrl());\n\t\t// make sure we do not log any passwords to the output\n\t\tlogger.info(\"fetch url: \" + repository.getFetchUrl().replace(repository.getPassword(), \"******\"));\n\t\tlogger.info(\"push url: \" + repository.getPushUrl().replace(repository.getPassword(), \"******\"));\n\t\treturn getCredentials(repository);\n\t}\n\n\t/**\n\t * Creates a credentials provider from the information passed in the\n\t * repository. Current implementation supports: <br />\n\t * <li>UserName/Password<\/li>\n\t * <p />\n\t * \n\t * @param repository\n\t *            the config to get the details from\n\t * @return <code>null<\/code> if there is not enough info to create a\n\t *         provider with\n\t */\n\tpublic static CredentialsProvider getCredentials(GitScmProviderRepository repository) {\n\t\tif (StringUtils.isNotBlank(repository.getUser())) {\n\t\t\treturn new UsernamePasswordCredentialsProvider(repository.getUser(), repository.getPassword());\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Iterable<PushResult> push(ScmLogger logger, Git git, GitScmProviderRepository repo, RefSpec refSpec) throws GitAPIException, InvalidRemoteException, TransportException {\n\t\tCredentialsProvider credentials = JGitUtils.prepareSession(logger, git, repo);\n\t\tIterable<PushResult> pushResultList = git.push().setCredentialsProvider(credentials).setRefSpecs(refSpec).call();\n\t\tfor (PushResult pushResult : pushResultList) {\n\t\t\tCollection<RemoteRefUpdate> ru = pushResult.getRemoteUpdates();\n\t\t\tfor (RemoteRefUpdate remoteRefUpdate : ru) {\n\t\t\t\tlogger.info(remoteRefUpdate.getStatus() + \" - \" + remoteRefUpdate.toString());\n\t\t\t}\n\t\t}\n\t\treturn pushResultList;\n\t}\n\n\t/**\n\t * Does the Repository have any commits?\n\t * \n\t * @param repo\n\t * @return false if there are no commits\n\t */\n\tpublic static boolean hasCommits(Repository repo) {\n\t\tif (repo != null && repo.getDirectory().exists()) {\n\t\t\treturn (new File(repo.getDirectory(), \"objects\").list().length > 2) || (new File(repo.getDirectory(), \"objects/pack\").list().length > 0);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * get a list of all files in the given commit\n\t * \n\t * @param repository\n\t *            the repo\n\t * @param commit\n\t *            the commit to get the files from\n\t * @return a list of files included in the commit\n\t * @throws MissingObjectException\n\t * @throws IncorrectObjectTypeException\n\t * @throws CorruptObjectException\n\t * @throws IOException\n\t */\n\tpublic static List<ScmFile> getFilesInCommit(Repository repository, RevCommit commit) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {\n\t\tList<ScmFile> list = new ArrayList<ScmFile>();\n\t\tif (JGitUtils.hasCommits(repository)) {\n\t\t\tTreeWalk tw = new TreeWalk(repository);\n\t\t\ttw.reset();\n\t\t\ttw.setRecursive(true);\n\t\t\ttw.addTree(commit.getTree());\n\t\t\twhile (tw.next()) {\n\t\t\t\tlist.add(new ScmFile(tw.getPathString(), ScmFileStatus.CHECKED_IN));\n\t\t\t}\n\t\t\ttw.release();\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * Translate a {@code FileStatus} in the matching {@code ScmFileStatus}.\n\t * \n\t * @param status\n\t * @return the matching ScmFileStatus\n\t * @throws ScmException\n\t *             if the given Status cannot be translated\n\t */\n\tpublic static ScmFileStatus getScmFileStatus(ChangeType changeType) throws ScmException {\n\t\tswitch (changeType) {\n\t\tcase ADD:\n\t\t\treturn ScmFileStatus.ADDED;\n\t\tcase MODIFY:\n\t\t\treturn ScmFileStatus.MODIFIED;\n\t\tcase DELETE:\n\t\t\treturn ScmFileStatus.DELETED;\n\t\tcase RENAME:\n\t\t\treturn ScmFileStatus.RENAMED;\n\t\tcase COPY:\n\t\t\treturn ScmFileStatus.COPIED;\n\t\tdefault:\n\t\t\treturn ScmFileStatus.UNKNOWN;\n\t\t}\n\t}\n\n\t/**\n\t * Adds all files in the given fileSet to the repository.\n\t * \n\t * @param git\n\t *            the repo to add the files to\n\t * @param fileSet\n\t *            the set of files within the workspace, the files are added\n\t *            relative to the basedir of this fileset\n\t * @return a list of files changed\n\t * @throws GitAPIException\n\t * @throws NoFilepatternException\n\t */\n\tpublic static List<ScmFile> addAllFiles(Git git, ScmFileSet fileSet) throws GitAPIException, NoFilepatternException {\n\t\tURI baseUri = fileSet.getBasedir().toURI();\n\t\tAddCommand add = git.add();\n\t\tfor (File file : fileSet.getFileList()) {\n\t\t\tif (file.exists()) {\n\t\t\t\tString path = file.getPath();\n\t\t\t\tif (file.isAbsolute()) {\n\t\t\t\t\tpath = baseUri.relativize(new File(path).toURI()).getPath();\n\t\t\t\t}\n\t\t\t\tadd.addFilepattern(path);\n\t\t\t}\n\t\t}\n\t\tadd.call();\n\n\t\tStatus status = git.status().call();\n\t\tSet<String> changed = status.getChanged();\n\n\t\tList<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n\t\t// rewrite all detected files to now have status 'checked_in'\n\t\tfor (String entry : changed) {\n\t\t\tScmFile scmfile = new ScmFile(entry, ScmFileStatus.MODIFIED);\n\n\t\t\t// if a specific fileSet is given, we have to check if the file is\n\t\t\t// really tracked\n\t\t\tfor (Iterator<File> itfl = fileSet.getFileList().iterator(); itfl.hasNext();) {\n\t\t\t\tFile f = (File) itfl.next();\n\t\t\t\tif (f.toString().equals(scmfile.getPath())) {\n\t\t\t\t\tchangedFiles.add(scmfile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changedFiles;\n\t}\n}\n","lineNo":222}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n */\npublic class GitStatusConsumer\n    implements StreamConsumer\n{\n\n    /**\n     * The pattern used to match added file lines\n     */\n    private static final Pattern addedRegexp = Pattern.compile( \"^A[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match modified file lines\n     */\n    private static final Pattern modifiedRegexp = Pattern.compile( \"^ *M[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match deleted file lines\n     */\n    private Pattern deletedRegexp = Pattern.compile( \"^ *D * (.*)$\" );\n\n    /**\n     * The pattern used to match renamed file lines\n     */\n    private Pattern renamedRegexp = Pattern.compile( \"^R  (.*) -> (.*)$\" );\n\n    private ScmLogger logger;\n\n    private File workingDirectory;\n\n    /**\n     * Entries are relative to working directory, not to the repositoryroot\n     */\n    private List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n    private URI relativeRepositoryPath;\n    \n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Consumer when workingDirectory and repositoryRootDirectory are the same\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory )\n    {\n        this.logger = logger;\n        this.workingDirectory = workingDirectory;\n    }\n\n    /**\n     * Assuming that you have to discover the repositoryRoot, this is how you can get the <code>relativeRepositoryPath<\/code>\n     * <pre>\n     * URI.create( repositoryRoot ).relativize( fileSet.getBasedir().toURI() )\n     * <\/pre>\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     * @param relativeRepositoryPath the working directory relative to the repository root\n     * @since 1.9\n     * @see GitStatusCommand#createRevparseShowToplevelCommand(org.apache.maven.scm.ScmFileSet)\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory, URI relativeRepositoryPath )\n    {\n        this( logger, workingDirectory );\n        this.relativeRepositoryPath = relativeRepositoryPath;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( line );\n        }\n        if ( StringUtils.isEmpty( line ) )\n        {\n            return;\n        }\n\n        ScmFileStatus status = null;\n\n        List<String> files = new ArrayList<String>();\n        \n        Matcher matcher;\n        if ( ( matcher = addedRegexp.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.ADDED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = modifiedRegexp.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.MODIFIED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = deletedRegexp.matcher( line ) ) .find() )\n        {\n            status = ScmFileStatus.DELETED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = renamedRegexp.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.RENAMED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n            files.add( resolvePath( matcher.group( 2 ), relativeRepositoryPath ) );\n            logger.debug( \"RENAMED status for line '\" + line + \"' files added '\" + matcher.group( 1 ) + \"' '\"\n                              + matcher.group( 2 ) );\n        }\n        else\n        {\n        \tlogger.warn( \"Ignoring unrecognized line: \" +  line );\n        \treturn;\n        }\n\n        // If the file isn't a file; don't add it.\n        if ( !files.isEmpty() && status != null )\n        {\n            if ( workingDirectory != null )\n            {\n                if ( status == ScmFileStatus.RENAMED )\n                {\n                    String oldFilePath = files.get( 0 );\n                    String newFilePath = files.get( 1 );\n                    if ( isFile( oldFilePath ) )\n                    {\n                        logger.debug(\n                            \"file '\" + oldFilePath + \"' is a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug(\n                            \"file '\" + oldFilePath + \"' not a file\" );\n                    }\n                    if ( !isFile( newFilePath ) )\n                    {\n                        logger.debug(\n                            \"file '\" + newFilePath + \"' not a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug(\n                            \"file '\" + newFilePath + \"' is a file\" );\n                    }\n                }\n                else if ( status == ScmFileStatus.DELETED )\n                {\n                    if ( isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n                else\n                {\n                    if ( !isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n            }\n\n            for ( String file : files )\n            {\n                changedFiles.add( new ScmFile( file, status ) );\n            }\n        }\n    }\n\n    private boolean isFile( String file )\n    {\n        return new File( workingDirectory, file ).isFile();\n    }\n\n    protected static String resolvePath( String fileEntry, URI path )\n    {\n        if ( path != null )\n        {\n            \n            return path.relativize( URI.create( fileEntry ) ).getPath();\n        }\n        else\n        {\n            return fileEntry;\n        }\n    }\n\n    public List<ScmFile> getChangedFiles()\n    {\n        return changedFiles;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.ObjectStreamClass;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n */\npublic class GitStatusConsumer\n    implements StreamConsumer\n{\n\n    /**\n     * The pattern used to match added file lines\n     */\n    private static final Pattern addedRegexp = Pattern.compile( \"^A[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match modified file lines\n     */\n    private static final Pattern modifiedRegexp = Pattern.compile( \"^ *M[ M]* (.*)$\" );\n\n    /**\n     * The pattern used to match deleted file lines\n     */\n    private Pattern deletedRegexp = Pattern.compile( \"^ *D * (.*)$\" );\n\n    /**\n     * The pattern used to match renamed file lines\n     */\n    private Pattern renamedRegexp = Pattern.compile( \"^R  (.*) -> (.*)$\" );\n\n    private ScmLogger logger;\n\n    private File workingDirectory;\n\n    /**\n     * Entries are relative to working directory, not to the repositoryroot\n     */\n    private List<ScmFile> changedFiles = new ArrayList<ScmFile>();\n\n    private URI relativeRepositoryPath;\n    \n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Consumer when workingDirectory and repositoryRootDirectory are the same\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory )\n    {\n        this.logger = logger;\n        this.workingDirectory = workingDirectory;\n    }\n\n    /**\n     * Assuming that you have to discover the repositoryRoot, this is how you can get the <code>relativeRepositoryPath<\/code>\n     * <pre>\n     * URI.create( repositoryRoot ).relativize( fileSet.getBasedir().toURI() )\n     * <\/pre>\n     * \n     * @param logger the logger\n     * @param workingDirectory the working directory\n     * @param relativeRepositoryPath the working directory relative to the repository root\n     * @since 1.9\n     * @see GitStatusCommand#createRevparseShowToplevelCommand(org.apache.maven.scm.ScmFileSet)\n     */\n    public GitStatusConsumer( ScmLogger logger, File workingDirectory, URI relativeRepositoryPath )\n    {\n        this( logger, workingDirectory );\n        this.relativeRepositoryPath = relativeRepositoryPath;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( line );\n        }\n        if ( StringUtils.isEmpty( line ) )\n        {\n            return;\n        }\n\n        ScmFileStatus status = null;\n\n        List<String> files = new ArrayList<String>();\n        \n        Matcher matcher;\n        if ( ( matcher = addedRegexp.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.ADDED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = modifiedRegexp.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.MODIFIED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = deletedRegexp.matcher( line ) ) .find() )\n        {\n            status = ScmFileStatus.DELETED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n        }\n        else if ( ( matcher = renamedRegexp.matcher( line ) ).find() )\n        {\n            status = ScmFileStatus.RENAMED;\n            files.add( resolvePath( matcher.group( 1 ), relativeRepositoryPath ) );\n            files.add( resolvePath( matcher.group( 2 ), relativeRepositoryPath ) );\n            logger.debug( \"RENAMED status for line '\" + line + \"' files added '\" + matcher.group( 1 ) + \"' '\"\n                              + matcher.group( 2 ) );\n        }\n        else\n        {\n        \tlogger.warn( \"Ignoring unrecognized line: \" +  line );\n        \treturn;\n        }\n\n        // If the file isn't a file; don't add it.\n        if ( !files.isEmpty() && status != null )\n        {\n            if ( workingDirectory != null )\n            {\n                if ( status == ScmFileStatus.RENAMED )\n                {\n                    String oldFilePath = files.get( 0 );\n                    String newFilePath = files.get( 1 );\n                    if ( isFile( oldFilePath ) )\n                    {\n                        logger.debug(\n                            \"file '\" + oldFilePath + \"' is a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug(\n                            \"file '\" + oldFilePath + \"' not a file\" );\n                    }\n                    if ( !isFile( newFilePath ) )\n                    {\n                        logger.debug(\n                            \"file '\" + newFilePath + \"' not a file\" );\n                        return;\n                    }\n                    else\n                    {\n                        logger.debug(\n                            \"file '\" + newFilePath + \"' is a file\" );\n                    }\n                }\n                else if ( status == ScmFileStatus.DELETED )\n                {\n                    if ( isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n                else\n                {\n                    if ( !isFile( files.get( 0 ) ) )\n                    {\n                        return;\n                    }\n                }\n            }\n\n            for ( String file : files )\n            {\n                changedFiles.add( new ScmFile( file, status ) );\n            }\n        }\n    }\n\n    private boolean isFile( String file )\n    {\n        return new File( workingDirectory, file ).isFile();\n    }\n\n    protected static String resolvePath( String fileEntry, URI path )\n    {\n        if ( path != null )\n        {\n            // When using URI.create, spaces need to be escaped but not the slashes, so we can't use URLEncoder.encode( String, String )\n            // new File( String ).toURI() results in an absolute URI while path is relative, so that can't be used either.\n            URI fe = new File( fileEntry ).toURI();\n            String str = fileEntry.replace( \" \", \"%20\" );\n            return path.relativize( URI.create( str ) ).getPath();\n        }\n        else\n        {\n            return fileEntry;\n        }\n    }\n\n    public List<ScmFile> getChangedFiles()\n    {\n        return changedFiles;\n    }\n}\n","lineNo":230}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assume.assumeTrue;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith( JUnit4.class )\npublic class AccuRevCommandLineTest\n    extends ScmTestCase\n{\n\n    public class AccuRevCommandLineTester\n        extends AccuRevCommandLine\n    {\n\n        private BufferedReader stdinReader;\n\n        private String response;\n\n        public BufferedReader getStdinReader()\n        {\n\n            return stdinReader;\n        }\n\n        private ScmLogger initLog()\n            throws Exception\n        {\n\n            return AccuRevJUnitUtil.getLogger( getContainer() );\n        }\n\n        public AccuRevCommandLineTester()\n            throws Exception\n        {\n\n            setLogger( initLog() );\n        }\n\n        public AccuRevCommandLineTester( String host, int port )\n            throws Exception\n        {\n\n            super( host, port );\n            setLogger( initLog() );\n        }\n\n        @Override\n        protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                          StreamConsumer stderr )\n            throws CommandLineException\n        {\n\n            if ( stdin != null )\n            {\n                stdinReader = new BufferedReader( new InputStreamReader( stdin ) );\n            }\n            else\n            {\n                stdinReader = null;\n            }\n            try\n            {\n                if ( response != null )\n                {\n                    BufferedReader reader = new BufferedReader( new StringReader( response ) );\n                    String line = reader.readLine();\n                    while ( line != null )\n                    {\n                        stdout.consumeLine( line );\n                        line = reader.readLine();\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new CommandLineException( \"Unexpected error\", e );\n            }\n            return 0;\n        }\n\n        public void setResponse( String response )\n        {\n\n            this.response = response;\n\n        }\n\n    }\n\n    @Before\n    @Override\n    public void setUp()\n        throws Exception\n    {\n\n        super.setUp();\n    }\n\n    @After\n    @Override\n    public void tearDown()\n        throws Exception\n    {\n\n        super.tearDown();\n    }\n\n    @Override\n    protected InputStream getCustomConfiguration()\n        throws Exception\n    {\n\n        return AccuRevJUnitUtil.getPlexusConfiguration();\n    }\n\n    @Test\n    public void testPromoteAll()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        assertThat( accuRevCL.promoteAll( new File( \"/my/workspace\" ), \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-p\", \"-K\", \"-c\", \"cmt msg\" } ) );\n\n    }\n\n    @Test\n    public void testPromote()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testfile = new File( \"my/test/file\" );\n        files.add( testfile );\n\n        assertThat( accuRevCL.promote( new File( \"/my/workspace\" ), files, \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-K\", \"-c\", \"cmt msg\", testfile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testLogin()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setResponse( \"Password: a124235bacc3ff\" );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        accuRevCL.login( \"aUser\", \"topSecret\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\", \"topSecret\" } ) );\n            assertThat( accuRevCL.getStdinReader(), is( nullValue() ) );\n        }\n        else\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\" } ) );\n            assertThat( accuRevCL.getStdinReader().readLine(), is( \"topSecret\" ) );\n        }\n\n        accuRevCL.info( null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\", \"-A\", \"a124235bacc3ff\" } ) );\n\n        assumeTrue( !Os.isFamily( Os.FAMILY_WINDOWS ) );\n\n        accuRevCL.login( \"anOther\", \"opensaysme\" );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"anOther\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"opensaysme\" ) );\n\n        accuRevCL.login( \"AUser\", null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"AUser\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"\" ) );\n\n    }\n\n    @Test\n    public void testPopExternal()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"12\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-t\", \"12\", \"-R\", projectDir.getPath() } ) );\n\n    }\n\n    @Test\n    public void testPopExternalWithTransactionNow()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"now\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(),  \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopExternalWithTransactionNull()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", null, Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopWorkSpace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev.exe\" );\n\n        File testFile = new File( \"project/dir\" );\n        accuRevCL.pop( new File( \"/home/workspace\" ), Collections.singleton( testFile ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        // take care of symlink\n        if (lastCL.getWorkingDirectory().getCanonicalFile().equals( lastCL.getWorkingDirectory().getAbsoluteFile() ))\n        {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getCanonicalFile() ) );\n        } else {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getAbsoluteFile() ));// .getCanonicalFile() ) );\n        }\n        \n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-R\", testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testMkws()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev2.exe\" );\n        File workspaceFile = new File( \"/my/workspace/location\" );\n        accuRevCL.mkws( \"myStream\", \"myWorkSpaceName\", workspaceFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev2.exe\" ) );\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"mkws\", \"-b\", \"myStream\", \"-w\", \"myWorkSpaceName\", \"-l\",\n            workspaceFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File workspaceFile = new File( \"/my/ws/loc\" );\n        accuRevCL.update( workspaceFile, \"highest\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"update\", \"-t\", \"highest\" } ) );\n\n    }\n\n    @Test\n    public void testInfo()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.info( new File( \"/my/base/dir\" ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/base/dir\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\" } ) );\n\n    }\n\n    @Test\n    public void testRemoveWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.rmws( \"myWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"rmws\", \"-s\", \"myWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testStatIgnored()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File testFile = new File( \"/my/base/dir\" );\n        accuRevCL.stat( testFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-fx\", testFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testReactivate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.reactivate( \"ArANdomWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"reactivate\", \"wspace\", \"ArANdomWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testReset()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        Commandline cl = accuRevCL.getCommandline();\n        String[] shellCmds = cl.getShellCommandline();\n        accuRevCL.reset();\n        assertThat( accuRevCL.getCommandline().getShellCommandline(), is( shellCmds ) );\n        assertThat( accuRevCL.getCommandline().getShell().getExecutable(), is( \"accurev\" ) );\n    }\n\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", AccuRev.DEFAULT_ADD_MESSAGE,\n            testFile.getPath() } ) );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testRemove()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        File workspaceFile = new File( \"/workspace\" );\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(),\n                    is( new String[] { \"defunct\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE,\n            testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, Collections.EMPTY_LIST, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, null, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n    }\n\n    @Test\n    public void testChangeWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.chws( new File( \"/my/workspace\" ), \"the_workspace_name_me\", \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"chws\", \"-s\", \"the_workspace_name_me\", \"-b\",\n            \"a-snapshot\", \"-l\", \".\" } ) );\n\n    }\n\n    @Test\n    public void testMkSnap()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.mksnap( \"a-snapshot\", \"basisStream\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"mksnap\", \"-s\", \"a-snapshot\", \"-b\", \"basisStream\", \"-t\",\n            \"now\" } ) );\n\n    }\n\n    @Test\n    public void testStatTag()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.statTag( \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", \"a-snapshot\" } ) );\n\n    }\n\n    @Test\n    public void testStatBackingStream()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> elements = new ArrayList<File>( 1 );\n        File addedOrModifiedFile = new File( \"addedOrModified/file\" );\n        elements.add( addedOrModifiedFile );\n        accuRevCL.statBackingStream( basedir, elements );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-b\", \"-ffr\", addedOrModifiedFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testStatRecursive()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> noFiles = new ArrayList<File>();\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.KEPT );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-k\", \"-R\", \".\" } ) );\n\n        noFiles.add( new File( \".\" ) );\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.DEFUNCT );\n        lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-D\", \"-R\", \".\" } ) );\n    }\n\n    @Test\n    public void testStatSpecificFilesAndDirectories()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> files = new ArrayList<File>();\n        File testDir = new File( \"a/dir\" );\n        files.add( testDir );\n        File testFile = new File( \"a/dir/a.file\" );\n        files.add( testFile );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, files, AccuRevStat.MISSING );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-M\", testDir.getPath(),\n            testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testAnnotate()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        File file = new File( \"src/main/java/foo.java\" );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.annotate( basedir, file );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"annotate\", \"-ftud\", file.getPath() } ) );\n\n    }\n\n    @Test\n    public void testDiff()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        accuRevCL.diff( \"myStream\", \"fromSpec\", \"toSpec\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", \"myStream\", \"-V\",\n            \"myStream\", \"-t\", \"fromSpec-toSpec\" } ) );\n\n    }\n\n    @Test\n    public void testShowStream()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.showStream( \"mystream\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"show\", \"-s\", \"mystream\", \"-fx\", \"streams\" } ) );\n        ;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assume.assumeTrue;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith( JUnit4.class )\npublic class AccuRevCommandLineTest\n    extends ScmTestCase\n{\n\n    public class AccuRevCommandLineTester\n        extends AccuRevCommandLine\n    {\n\n        private BufferedReader stdinReader;\n\n        private String response;\n\n        public BufferedReader getStdinReader()\n        {\n\n            return stdinReader;\n        }\n\n        private ScmLogger initLog()\n            throws Exception\n        {\n\n            return AccuRevJUnitUtil.getLogger( getContainer() );\n        }\n\n        public AccuRevCommandLineTester()\n            throws Exception\n        {\n\n            setLogger( initLog() );\n        }\n\n        public AccuRevCommandLineTester( String host, int port )\n            throws Exception\n        {\n\n            super( host, port );\n            setLogger( initLog() );\n        }\n\n        @Override\n        protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                          StreamConsumer stderr )\n            throws CommandLineException\n        {\n\n            if ( stdin != null )\n            {\n                stdinReader = new BufferedReader( new InputStreamReader( stdin ) );\n            }\n            else\n            {\n                stdinReader = null;\n            }\n            try\n            {\n                if ( response != null )\n                {\n                    BufferedReader reader = new BufferedReader( new StringReader( response ) );\n                    String line = reader.readLine();\n                    while ( line != null )\n                    {\n                        stdout.consumeLine( line );\n                        line = reader.readLine();\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new CommandLineException( \"Unexpected error\", e );\n            }\n            return 0;\n        }\n\n        public void setResponse( String response )\n        {\n\n            this.response = response;\n\n        }\n\n    }\n\n    @Before\n    @Override\n    public void setUp()\n        throws Exception\n    {\n\n        super.setUp();\n    }\n\n    @After\n    @Override\n    public void tearDown()\n        throws Exception\n    {\n\n        super.tearDown();\n    }\n\n    @Override\n    protected InputStream getCustomConfiguration()\n        throws Exception\n    {\n\n        return AccuRevJUnitUtil.getPlexusConfiguration();\n    }\n\n    @Test\n    public void testPromoteAll()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        assertThat( accuRevCL.promoteAll( new File( \"/my/workspace\" ), \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-p\", \"-K\", \"-c\", \"cmt msg\" } ) );\n\n    }\n\n    @Test\n    public void testPromote()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testfile = new File( \"my/test/file\" );\n        files.add( testfile );\n\n        assertThat( accuRevCL.promote( new File( \"/my/workspace\" ), files, \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-K\", \"-c\", \"cmt msg\", testfile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testLogin()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setResponse( \"Password: a124235bacc3ff\" );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        accuRevCL.login( \"aUser\", \"topSecret\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\", \"topSecret\" } ) );\n            assertThat( accuRevCL.getStdinReader(), is( nullValue() ) );\n        }\n        else\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\" } ) );\n            assertThat( accuRevCL.getStdinReader().readLine(), is( \"topSecret\" ) );\n        }\n\n        accuRevCL.info( null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\", \"-A\", \"a124235bacc3ff\" } ) );\n\n        assumeTrue( !Os.isFamily( Os.FAMILY_WINDOWS ) );\n\n        accuRevCL.login( \"anOther\", \"opensaysme\" );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"anOther\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"opensaysme\" ) );\n\n        accuRevCL.login( \"AUser\", null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"AUser\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"\" ) );\n\n    }\n\n    @Test\n    public void testPopExternal()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"12\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-t\", \"12\", \"-R\", projectDir.getPath() } ) );\n\n    }\n\n    @Test\n    public void testPopExternalWithTransactionNow()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"now\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(),  \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopExternalWithTransactionNull()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", null, Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopWorkSpace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev.exe\" );\n\n        File testFile = new File( \"project/dir\" );\n        accuRevCL.pop( new File( \"/home/workspace\" ), Collections.singleton( testFile ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        // take care of symlink\n        if (lastCL.getWorkingDirectory().getCanonicalFile().equals( lastCL.getWorkingDirectory().getAbsoluteFile() ))\n        {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getCanonicalFile() ) );\n        } else {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getAbsoluteFile() ));// .getCanonicalFile() ) );\n        }\n        \n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-R\", testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testMkws()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev2.exe\" );\n        File workspaceFile = new File( \"/my/workspace/location\" );\n        accuRevCL.mkws( \"myStream\", \"myWorkSpaceName\", workspaceFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev2.exe\" ) );\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"mkws\", \"-b\", \"myStream\", \"-w\", \"myWorkSpaceName\", \"-l\",\n            workspaceFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File workspaceFile = new File( \"/my/ws/loc\" );\n        accuRevCL.update( workspaceFile, \"highest\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"update\", \"-t\", \"highest\" } ) );\n\n    }\n\n    @Test\n    public void testInfo()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.info( new File( \"/my/base/dir\" ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/base/dir\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\" } ) );\n\n    }\n\n    @Test\n    public void testRemoveWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.rmws( \"myWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"rmws\", \"-s\", \"myWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testStatIgnored()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File testFile = new File( \"/my/base/dir\" );\n        accuRevCL.stat( testFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-fx\", testFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testReactivate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.reactivate( \"ArANdomWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"reactivate\", \"wspace\", \"ArANdomWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testReset()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        Commandline commandline = accuRevCL.getCommandline();\n        Commandline cl = commandline;\n        List<String> shellCmds = cl.getShell().getShellCommandLine( cl.getArguments() );\n        accuRevCL.reset();\n        assertThat( cl.getShell().getShellCommandLine( cl.getArguments() ), is( shellCmds ) );\n        assertThat( commandline.getShell().getExecutable(), is( \"accurev\" ) );\n    }\n\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", AccuRev.DEFAULT_ADD_MESSAGE,\n            testFile.getPath() } ) );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testRemove()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        File workspaceFile = new File( \"/workspace\" );\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(),\n                    is( new String[] { \"defunct\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE,\n            testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, Collections.EMPTY_LIST, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, null, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n    }\n\n    @Test\n    public void testChangeWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.chws( new File( \"/my/workspace\" ), \"the_workspace_name_me\", \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"chws\", \"-s\", \"the_workspace_name_me\", \"-b\",\n            \"a-snapshot\", \"-l\", \".\" } ) );\n\n    }\n\n    @Test\n    public void testMkSnap()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.mksnap( \"a-snapshot\", \"basisStream\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"mksnap\", \"-s\", \"a-snapshot\", \"-b\", \"basisStream\", \"-t\",\n            \"now\" } ) );\n\n    }\n\n    @Test\n    public void testStatTag()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.statTag( \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", \"a-snapshot\" } ) );\n\n    }\n\n    @Test\n    public void testStatBackingStream()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> elements = new ArrayList<File>( 1 );\n        File addedOrModifiedFile = new File( \"addedOrModified/file\" );\n        elements.add( addedOrModifiedFile );\n        accuRevCL.statBackingStream( basedir, elements );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-b\", \"-ffr\", addedOrModifiedFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testStatRecursive()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> noFiles = new ArrayList<File>();\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.KEPT );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-k\", \"-R\", \".\" } ) );\n\n        noFiles.add( new File( \".\" ) );\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.DEFUNCT );\n        lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-D\", \"-R\", \".\" } ) );\n    }\n\n    @Test\n    public void testStatSpecificFilesAndDirectories()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> files = new ArrayList<File>();\n        File testDir = new File( \"a/dir\" );\n        files.add( testDir );\n        File testFile = new File( \"a/dir/a.file\" );\n        files.add( testFile );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, files, AccuRevStat.MISSING );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-M\", testDir.getPath(),\n            testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testAnnotate()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        File file = new File( \"src/main/java/foo.java\" );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.annotate( basedir, file );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"annotate\", \"-ftud\", file.getPath() } ) );\n\n    }\n\n    @Test\n    public void testDiff()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        accuRevCL.diff( \"myStream\", \"fromSpec\", \"toSpec\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", \"myStream\", \"-V\",\n            \"myStream\", \"-t\", \"fromSpec-toSpec\" } ) );\n\n    }\n\n    @Test\n    public void testShowStream()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.showStream( \"mystream\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"show\", \"-s\", \"mystream\", \"-fx\", \"streams\" } ) );\n        ;\n    }\n}\n","lineNo":398}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assume.assumeTrue;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith( JUnit4.class )\npublic class AccuRevCommandLineTest\n    extends ScmTestCase\n{\n\n    public class AccuRevCommandLineTester\n        extends AccuRevCommandLine\n    {\n\n        private BufferedReader stdinReader;\n\n        private String response;\n\n        public BufferedReader getStdinReader()\n        {\n\n            return stdinReader;\n        }\n\n        private ScmLogger initLog()\n            throws Exception\n        {\n\n            return AccuRevJUnitUtil.getLogger( getContainer() );\n        }\n\n        public AccuRevCommandLineTester()\n            throws Exception\n        {\n\n            setLogger( initLog() );\n        }\n\n        public AccuRevCommandLineTester( String host, int port )\n            throws Exception\n        {\n\n            super( host, port );\n            setLogger( initLog() );\n        }\n\n        @Override\n        protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                          StreamConsumer stderr )\n            throws CommandLineException\n        {\n\n            if ( stdin != null )\n            {\n                stdinReader = new BufferedReader( new InputStreamReader( stdin ) );\n            }\n            else\n            {\n                stdinReader = null;\n            }\n            try\n            {\n                if ( response != null )\n                {\n                    BufferedReader reader = new BufferedReader( new StringReader( response ) );\n                    String line = reader.readLine();\n                    while ( line != null )\n                    {\n                        stdout.consumeLine( line );\n                        line = reader.readLine();\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new CommandLineException( \"Unexpected error\", e );\n            }\n            return 0;\n        }\n\n        public void setResponse( String response )\n        {\n\n            this.response = response;\n\n        }\n\n    }\n\n    @Before\n    @Override\n    public void setUp()\n        throws Exception\n    {\n\n        super.setUp();\n    }\n\n    @After\n    @Override\n    public void tearDown()\n        throws Exception\n    {\n\n        super.tearDown();\n    }\n\n    @Override\n    protected InputStream getCustomConfiguration()\n        throws Exception\n    {\n\n        return AccuRevJUnitUtil.getPlexusConfiguration();\n    }\n\n    @Test\n    public void testPromoteAll()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        assertThat( accuRevCL.promoteAll( new File( \"/my/workspace\" ), \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-p\", \"-K\", \"-c\", \"cmt msg\" } ) );\n\n    }\n\n    @Test\n    public void testPromote()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testfile = new File( \"my/test/file\" );\n        files.add( testfile );\n\n        assertThat( accuRevCL.promote( new File( \"/my/workspace\" ), files, \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-K\", \"-c\", \"cmt msg\", testfile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testLogin()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setResponse( \"Password: a124235bacc3ff\" );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        accuRevCL.login( \"aUser\", \"topSecret\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\", \"topSecret\" } ) );\n            assertThat( accuRevCL.getStdinReader(), is( nullValue() ) );\n        }\n        else\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\" } ) );\n            assertThat( accuRevCL.getStdinReader().readLine(), is( \"topSecret\" ) );\n        }\n\n        accuRevCL.info( null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\", \"-A\", \"a124235bacc3ff\" } ) );\n\n        assumeTrue( !Os.isFamily( Os.FAMILY_WINDOWS ) );\n\n        accuRevCL.login( \"anOther\", \"opensaysme\" );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"anOther\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"opensaysme\" ) );\n\n        accuRevCL.login( \"AUser\", null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"AUser\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"\" ) );\n\n    }\n\n    @Test\n    public void testPopExternal()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"12\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-t\", \"12\", \"-R\", projectDir.getPath() } ) );\n\n    }\n\n    @Test\n    public void testPopExternalWithTransactionNow()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"now\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(),  \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopExternalWithTransactionNull()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", null, Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopWorkSpace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev.exe\" );\n\n        File testFile = new File( \"project/dir\" );\n        accuRevCL.pop( new File( \"/home/workspace\" ), Collections.singleton( testFile ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        // take care of symlink\n        if (lastCL.getWorkingDirectory().getCanonicalFile().equals( lastCL.getWorkingDirectory().getAbsoluteFile() ))\n        {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getCanonicalFile() ) );\n        } else {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getAbsoluteFile() ));// .getCanonicalFile() ) );\n        }\n        \n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-R\", testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testMkws()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev2.exe\" );\n        File workspaceFile = new File( \"/my/workspace/location\" );\n        accuRevCL.mkws( \"myStream\", \"myWorkSpaceName\", workspaceFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev2.exe\" ) );\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"mkws\", \"-b\", \"myStream\", \"-w\", \"myWorkSpaceName\", \"-l\",\n            workspaceFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File workspaceFile = new File( \"/my/ws/loc\" );\n        accuRevCL.update( workspaceFile, \"highest\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"update\", \"-t\", \"highest\" } ) );\n\n    }\n\n    @Test\n    public void testInfo()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.info( new File( \"/my/base/dir\" ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/base/dir\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\" } ) );\n\n    }\n\n    @Test\n    public void testRemoveWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.rmws( \"myWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"rmws\", \"-s\", \"myWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testStatIgnored()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File testFile = new File( \"/my/base/dir\" );\n        accuRevCL.stat( testFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-fx\", testFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testReactivate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.reactivate( \"ArANdomWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"reactivate\", \"wspace\", \"ArANdomWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testReset()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        Commandline cl = accuRevCL.getCommandline();\n        String[] shellCmds = cl.getShellCommandline();\n        accuRevCL.reset();\n        assertThat( accuRevCL.getCommandline().getShellCommandline(), is( shellCmds ) );\n        assertThat( accuRevCL.getCommandline().getShell().getExecutable(), is( \"accurev\" ) );\n    }\n\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", AccuRev.DEFAULT_ADD_MESSAGE,\n            testFile.getPath() } ) );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testRemove()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        File workspaceFile = new File( \"/workspace\" );\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(),\n                    is( new String[] { \"defunct\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE,\n            testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, Collections.EMPTY_LIST, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, null, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n    }\n\n    @Test\n    public void testChangeWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.chws( new File( \"/my/workspace\" ), \"the_workspace_name_me\", \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"chws\", \"-s\", \"the_workspace_name_me\", \"-b\",\n            \"a-snapshot\", \"-l\", \".\" } ) );\n\n    }\n\n    @Test\n    public void testMkSnap()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.mksnap( \"a-snapshot\", \"basisStream\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"mksnap\", \"-s\", \"a-snapshot\", \"-b\", \"basisStream\", \"-t\",\n            \"now\" } ) );\n\n    }\n\n    @Test\n    public void testStatTag()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.statTag( \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", \"a-snapshot\" } ) );\n\n    }\n\n    @Test\n    public void testStatBackingStream()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> elements = new ArrayList<File>( 1 );\n        File addedOrModifiedFile = new File( \"addedOrModified/file\" );\n        elements.add( addedOrModifiedFile );\n        accuRevCL.statBackingStream( basedir, elements );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-b\", \"-ffr\", addedOrModifiedFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testStatRecursive()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> noFiles = new ArrayList<File>();\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.KEPT );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-k\", \"-R\", \".\" } ) );\n\n        noFiles.add( new File( \".\" ) );\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.DEFUNCT );\n        lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-D\", \"-R\", \".\" } ) );\n    }\n\n    @Test\n    public void testStatSpecificFilesAndDirectories()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> files = new ArrayList<File>();\n        File testDir = new File( \"a/dir\" );\n        files.add( testDir );\n        File testFile = new File( \"a/dir/a.file\" );\n        files.add( testFile );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, files, AccuRevStat.MISSING );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-M\", testDir.getPath(),\n            testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testAnnotate()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        File file = new File( \"src/main/java/foo.java\" );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.annotate( basedir, file );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"annotate\", \"-ftud\", file.getPath() } ) );\n\n    }\n\n    @Test\n    public void testDiff()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        accuRevCL.diff( \"myStream\", \"fromSpec\", \"toSpec\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", \"myStream\", \"-V\",\n            \"myStream\", \"-t\", \"fromSpec-toSpec\" } ) );\n\n    }\n\n    @Test\n    public void testShowStream()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.showStream( \"mystream\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"show\", \"-s\", \"mystream\", \"-fx\", \"streams\" } ) );\n        ;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assume.assumeTrue;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith( JUnit4.class )\npublic class AccuRevCommandLineTest\n    extends ScmTestCase\n{\n\n    public class AccuRevCommandLineTester\n        extends AccuRevCommandLine\n    {\n\n        private BufferedReader stdinReader;\n\n        private String response;\n\n        public BufferedReader getStdinReader()\n        {\n\n            return stdinReader;\n        }\n\n        private ScmLogger initLog()\n            throws Exception\n        {\n\n            return AccuRevJUnitUtil.getLogger( getContainer() );\n        }\n\n        public AccuRevCommandLineTester()\n            throws Exception\n        {\n\n            setLogger( initLog() );\n        }\n\n        public AccuRevCommandLineTester( String host, int port )\n            throws Exception\n        {\n\n            super( host, port );\n            setLogger( initLog() );\n        }\n\n        @Override\n        protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                          StreamConsumer stderr )\n            throws CommandLineException\n        {\n\n            if ( stdin != null )\n            {\n                stdinReader = new BufferedReader( new InputStreamReader( stdin ) );\n            }\n            else\n            {\n                stdinReader = null;\n            }\n            try\n            {\n                if ( response != null )\n                {\n                    BufferedReader reader = new BufferedReader( new StringReader( response ) );\n                    String line = reader.readLine();\n                    while ( line != null )\n                    {\n                        stdout.consumeLine( line );\n                        line = reader.readLine();\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new CommandLineException( \"Unexpected error\", e );\n            }\n            return 0;\n        }\n\n        public void setResponse( String response )\n        {\n\n            this.response = response;\n\n        }\n\n    }\n\n    @Before\n    @Override\n    public void setUp()\n        throws Exception\n    {\n\n        super.setUp();\n    }\n\n    @After\n    @Override\n    public void tearDown()\n        throws Exception\n    {\n\n        super.tearDown();\n    }\n\n    @Override\n    protected InputStream getCustomConfiguration()\n        throws Exception\n    {\n\n        return AccuRevJUnitUtil.getPlexusConfiguration();\n    }\n\n    @Test\n    public void testPromoteAll()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        assertThat( accuRevCL.promoteAll( new File( \"/my/workspace\" ), \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-p\", \"-K\", \"-c\", \"cmt msg\" } ) );\n\n    }\n\n    @Test\n    public void testPromote()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testfile = new File( \"my/test/file\" );\n        files.add( testfile );\n\n        assertThat( accuRevCL.promote( new File( \"/my/workspace\" ), files, \"cmt msg\" ), not( nullValue() ) );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"promote\", \"-K\", \"-c\", \"cmt msg\", testfile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testLogin()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setResponse( \"Password: a124235bacc3ff\" );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        accuRevCL.login( \"aUser\", \"topSecret\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\", \"topSecret\" } ) );\n            assertThat( accuRevCL.getStdinReader(), is( nullValue() ) );\n        }\n        else\n        {\n            assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"aUser\" } ) );\n            assertThat( accuRevCL.getStdinReader().readLine(), is( \"topSecret\" ) );\n        }\n\n        accuRevCL.info( null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\", \"-A\", \"a124235bacc3ff\" } ) );\n\n        assumeTrue( !Os.isFamily( Os.FAMILY_WINDOWS ) );\n\n        accuRevCL.login( \"anOther\", \"opensaysme\" );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"anOther\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"opensaysme\" ) );\n\n        accuRevCL.login( \"AUser\", null );\n        assertThat( lastCL.getArguments(), is( new String[] { \"login\", \"-A\", \"AUser\" } ) );\n        assertThat( accuRevCL.getStdinReader().readLine(), is( \"\" ) );\n\n    }\n\n    @Test\n    public void testPopExternal()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"12\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-t\", \"12\", \"-R\", projectDir.getPath() } ) );\n\n    }\n\n    @Test\n    public void testPopExternalWithTransactionNow()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", \"now\", Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(),  \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopExternalWithTransactionNull()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester( \"aHost\", 5051 );\n        accuRevCL.setExecutable( \"accurev.exe\" );\n        File testfile = new File( \"/my/export\" );\n        File projectDir = new File( \"/./project/dir\" );\n        accuRevCL.popExternal( testfile, \"stream\", null, Collections.singleton( projectDir ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-H\", \"aHost:5051\", \"-v\", \"stream\", \"-L\",\n            testfile.getAbsolutePath(), \"-R\", projectDir.getPath() } ) );\n    }\n    \n    @Test\n    public void testPopWorkSpace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev.exe\" );\n\n        File testFile = new File( \"project/dir\" );\n        accuRevCL.pop( new File( \"/home/workspace\" ), Collections.singleton( testFile ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev.exe\" ) );\n        // take care of symlink\n        if (lastCL.getWorkingDirectory().getCanonicalFile().equals( lastCL.getWorkingDirectory().getAbsoluteFile() ))\n        {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getCanonicalFile() ) );\n        } else {\n            assertThat( lastCL.getWorkingDirectory(), is( new File( \"/home/workspace\" ).getAbsoluteFile() ));// .getCanonicalFile() ) );\n        }\n        \n        assertThat( lastCL.getArguments(), is( new String[] { \"pop\", \"-R\", testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testMkws()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.setExecutable( \"accurev2.exe\" );\n        File workspaceFile = new File( \"/my/workspace/location\" );\n        accuRevCL.mkws( \"myStream\", \"myWorkSpaceName\", workspaceFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getExecutable(), is( \"accurev2.exe\" ) );\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"mkws\", \"-b\", \"myStream\", \"-w\", \"myWorkSpaceName\", \"-l\",\n            workspaceFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File workspaceFile = new File( \"/my/ws/loc\" );\n        accuRevCL.update( workspaceFile, \"highest\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"update\", \"-t\", \"highest\" } ) );\n\n    }\n\n    @Test\n    public void testInfo()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.info( new File( \"/my/base/dir\" ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/base/dir\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"info\" } ) );\n\n    }\n\n    @Test\n    public void testRemoveWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.rmws( \"myWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"rmws\", \"-s\", \"myWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testStatIgnored()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        File testFile = new File( \"/my/base/dir\" );\n        accuRevCL.stat( testFile );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-fx\", testFile.getAbsolutePath() } ) );\n\n    }\n\n    @Test\n    public void testReactivate()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.reactivate( \"ArANdomWorkspaceName\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"reactivate\", \"wspace\", \"ArANdomWorkspaceName\" } ) );\n\n    }\n\n    @Test\n    public void testReset()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        Commandline commandline = accuRevCL.getCommandline();\n        Commandline cl = commandline;\n        List<String> shellCmds = cl.getShell().getShellCommandLine( cl.getArguments() );\n        accuRevCL.reset();\n        assertThat( cl.getShell().getShellCommandLine( cl.getArguments() ), is( shellCmds ) );\n        assertThat( commandline.getShell().getExecutable(), is( \"accurev\" ) );\n    }\n\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.add( new File( \"/workspace\" ), files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"add\", \"-c\", AccuRev.DEFAULT_ADD_MESSAGE,\n            testFile.getPath() } ) );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testRemove()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        List<File> files = new ArrayList<File>();\n        File testFile = new File( \"my/test/file\" );\n        files.add( testFile );\n        File workspaceFile = new File( \"/workspace\" );\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"my commit message\" ), not( nullValue() ) );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( workspaceFile.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(),\n                    is( new String[] { \"defunct\", \"-c\", \"my commit message\", testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, files, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE,\n            testFile.getPath() } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, Collections.EMPTY_LIST, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n        assertThat( accuRevCL.defunct( workspaceFile, null, \"\" ), not( nullValue() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"defunct\", \"-c\", AccuRev.DEFAULT_REMOVE_MESSAGE, \".\" } ) );\n\n    }\n\n    @Test\n    public void testChangeWorkspace()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.chws( new File( \"/my/workspace\" ), \"the_workspace_name_me\", \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( new File( \"/my/workspace\" ).getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"chws\", \"-s\", \"the_workspace_name_me\", \"-b\",\n            \"a-snapshot\", \"-l\", \".\" } ) );\n\n    }\n\n    @Test\n    public void testMkSnap()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.mksnap( \"a-snapshot\", \"basisStream\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"mksnap\", \"-s\", \"a-snapshot\", \"-b\", \"basisStream\", \"-t\",\n            \"now\" } ) );\n\n    }\n\n    @Test\n    public void testStatTag()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.statTag( \"a-snapshot\" );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", \"a-snapshot\" } ) );\n\n    }\n\n    @Test\n    public void testStatBackingStream()\n        throws Exception\n    {\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> elements = new ArrayList<File>( 1 );\n        File addedOrModifiedFile = new File( \"addedOrModified/file\" );\n        elements.add( addedOrModifiedFile );\n        accuRevCL.statBackingStream( basedir, elements );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-b\", \"-ffr\", addedOrModifiedFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testStatRecursive()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> noFiles = new ArrayList<File>();\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.KEPT );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-k\", \"-R\", \".\" } ) );\n\n        noFiles.add( new File( \".\" ) );\n        accuRevCL.stat( basedir, noFiles, AccuRevStat.DEFUNCT );\n        lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-D\", \"-R\", \".\" } ) );\n    }\n\n    @Test\n    public void testStatSpecificFilesAndDirectories()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        List<File> files = new ArrayList<File>();\n        File testDir = new File( \"a/dir\" );\n        files.add( testDir );\n        File testFile = new File( \"a/dir/a.file\" );\n        files.add( testFile );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.stat( basedir, files, AccuRevStat.MISSING );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"stat\", \"-ffr\", \"-M\", testDir.getPath(),\n            testFile.getPath() } ) );\n\n    }\n\n    @Test\n    public void testAnnotate()\n        throws Exception\n    {\n\n        File basedir = new File( \"/my/workspace\" );\n        File file = new File( \"src/main/java/foo.java\" );\n\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.annotate( basedir, file );\n\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getWorkingDirectory(), is( basedir.getCanonicalFile() ) );\n        assertThat( lastCL.getArguments(), is( new String[] { \"annotate\", \"-ftud\", file.getPath() } ) );\n\n    }\n\n    @Test\n    public void testDiff()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n\n        accuRevCL.diff( \"myStream\", \"fromSpec\", \"toSpec\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", \"myStream\", \"-V\",\n            \"myStream\", \"-t\", \"fromSpec-toSpec\" } ) );\n\n    }\n\n    @Test\n    public void testShowStream()\n        throws Exception\n    {\n        AccuRevCommandLineTester accuRevCL = new AccuRevCommandLineTester();\n        accuRevCL.showStream( \"mystream\" );\n        Commandline lastCL = accuRevCL.getCommandline();\n        assertThat( lastCL.getArguments(), is( new String[] { \"show\", \"-s\", \"mystream\", \"-fx\", \"streams\" } ) );\n        ;\n    }\n}\n","lineNo":399}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.codehaus.plexus.PlexusTestCase;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n */\npublic class GitStatusConsumerTest\n    extends PlexusTestCase\n{\n\n    public void testConsumerUntrackedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"?? project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n    }\n\n    public void testConsumerAddedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"A  project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n    }\n\n    public void testConsumerAddedAndModifiedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"AM project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.ADDED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerAddedFileWithDirectoryAndNoFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"A  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerAddedFileWithDirectoryAndFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n        FileUtils.write( new File( dir, \"project.xml\" ), \"data\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"A  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerModifiedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"M  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n    }\n\n    public void testConsumerModifiedFileUnstaged()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \" M project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.MODIFIED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerModifiedFileBothStagedAndUnstaged()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"MM project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.MODIFIED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerModifiedFileWithDirectoryAndNoFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"M  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerModifiedFileWithDirectoryAndFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n        FileUtils.write( new File( dir, \"project.xml\" ), \"data\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"M  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerRemovedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"D  Capfile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n    }\n\n    public void testConsumerRemovedFileUnstaged()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \" D Capfile\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.DELETED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerRemovedFileWithDirectoryAndNoFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"D  Capfile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerRemovedFileWithDirectoryAndFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n        FileUtils.write( new File( dir, \"Capfile\" ), \"data\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"D  Capfile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n        FileUtils.deleteDirectory( dir );\n    }\n\n    // Test reproducing SCM-694\n    public void testConsumeRenamedFile()\n        throws Exception\n    {\n        File dir = createTempDirectory();\n\n        FileUtils.write( new File( dir, \"NewCapfile\" ), \"data\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog( true ), dir.getCanonicalFile() );\n\n        consumer.consumeLine( \"R  OldCapfile -> NewCapFile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 2, changedFiles.size() );\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testLog1Consumer()\n        throws Exception\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        File f = getTestFile( \"/src/test/resources/git/status/gitstatus1.gitlog\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertEquals( 2, changedFiles.size() );\n\n        testScmFile( (ScmFile) changedFiles.get( 0 ), \"project.xml\", ScmFileStatus.ADDED );\n        testScmFile( (ScmFile) changedFiles.get( 1 ), \"readme.txt\", ScmFileStatus.MODIFIED );\n    }\n\n    public void testEmptyLogConsumer()\n        throws Exception\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        File f = getTestFile( \"/src/test/resources/git/status/gitstatus-empty.gitlog\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertEquals( 0, changedFiles.size() );\n    }\n\n\n    public void testLog2Consumer()\n        throws Exception\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        File f = getTestFile( \"/src/test/resources/git/status/gitstatus2.gitlog\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertEquals( 4, changedFiles.size() );\n\n        testScmFile( (ScmFile) changedFiles.get( 0 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/add/GitAddCommand.java\",\n                     ScmFileStatus.MODIFIED );\n        testScmFile( (ScmFile) changedFiles.get( 1 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/checkin/GitCheckInCommand.java\",\n                     ScmFileStatus.MODIFIED );\n        testScmFile( (ScmFile) changedFiles.get( 2 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/checkin/GitCheckInConsumer.java\",\n                     ScmFileStatus.DELETED );\n        testScmFile( (ScmFile) changedFiles.get( 3 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/status/GitStatusConsumer.java\",\n                     ScmFileStatus.MODIFIED );\n    }\n\n\n    private void testScmFile( ScmFile fileToTest, String expectedFilePath, ScmFileStatus expectedStatus )\n    {\n        assertEquals( expectedFilePath, fileToTest.getPath() );\n        assertEquals( expectedStatus, fileToTest.getStatus() );\n    }\n\n    private File createTempDirectory()\n        throws IOException\n    {\n        File dir = File.createTempFile( \"gitexe\", \"test\" );\n        dir.delete();\n        dir.mkdir();\n        return dir;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.codehaus.plexus.PlexusTestCase;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n */\npublic class GitStatusConsumerTest\n    extends PlexusTestCase\n{\n\n    public void testConsumerUntrackedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"?? project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n    }\n\n    public void testConsumerAddedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"A  project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n    }\n\n    public void testConsumerAddedAndModifiedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"AM project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.ADDED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerAddedFileWithDirectoryAndNoFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"A  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerAddedFileWithDirectoryAndFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n        FileUtils.write( new File( dir, \"project.xml\" ), \"data\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"A  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerModifiedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"M  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n    }\n\n    public void testConsumerModifiedFileUnstaged()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \" M project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.MODIFIED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerModifiedFileBothStagedAndUnstaged()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"MM project.xml\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.MODIFIED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerModifiedFileWithDirectoryAndNoFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"M  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerModifiedFileWithDirectoryAndFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n        FileUtils.write( new File( dir, \"project.xml\" ), \"data\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"M  project.xml\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerRemovedFile()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \"D  Capfile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n    }\n\n    public void testConsumerRemovedFileUnstaged()\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        consumer.consumeLine( \" D Capfile\" );\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        assertEquals( ScmFileStatus.DELETED, changedFiles.get( 0 ).getStatus() );\n    }\n\n    public void testConsumerRemovedFileWithDirectoryAndNoFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"D  Capfile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 1, changedFiles.size() );\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testConsumerRemovedFileWithDirectoryAndFile()\n        throws IOException\n    {\n        File dir = createTempDirectory();\n        FileUtils.write( new File( dir, \"Capfile\" ), \"data\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), dir );\n\n        consumer.consumeLine( \"D  Capfile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 0, changedFiles.size() );\n        FileUtils.deleteDirectory( dir );\n    }\n\n    // Test reproducing SCM-694\n    public void testConsumeRenamedFile()\n        throws Exception\n    {\n        File dir = createTempDirectory();\n\n        File tmpFile = new File( dir, \"NewCapfile\" );\n\n        FileUtils.write( tmpFile, \"data\" );\n\n        System.out.println( \"write tmp file '\" + tmpFile.getAbsolutePath() + \"'\" );\n\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog( true ), dir.getCanonicalFile() );\n\n        consumer.consumeLine( \"R  OldCapfile -> NewCapFile\" );\n\n        List changedFiles = consumer.getChangedFiles();\n\n        assertNotNull( changedFiles );\n        assertEquals( 2, changedFiles.size() );\n        FileUtils.deleteDirectory( dir );\n    }\n\n    public void testLog1Consumer()\n        throws Exception\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        File f = getTestFile( \"/src/test/resources/git/status/gitstatus1.gitlog\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertEquals( 2, changedFiles.size() );\n\n        testScmFile( (ScmFile) changedFiles.get( 0 ), \"project.xml\", ScmFileStatus.ADDED );\n        testScmFile( (ScmFile) changedFiles.get( 1 ), \"readme.txt\", ScmFileStatus.MODIFIED );\n    }\n\n    public void testEmptyLogConsumer()\n        throws Exception\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        File f = getTestFile( \"/src/test/resources/git/status/gitstatus-empty.gitlog\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertEquals( 0, changedFiles.size() );\n    }\n\n\n    public void testLog2Consumer()\n        throws Exception\n    {\n        GitStatusConsumer consumer = new GitStatusConsumer( new DefaultLog(), null );\n\n        File f = getTestFile( \"/src/test/resources/git/status/gitstatus2.gitlog\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List<ScmFile> changedFiles = consumer.getChangedFiles();\n\n        assertEquals( 4, changedFiles.size() );\n\n        testScmFile( (ScmFile) changedFiles.get( 0 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/add/GitAddCommand.java\",\n                     ScmFileStatus.MODIFIED );\n        testScmFile( (ScmFile) changedFiles.get( 1 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/checkin/GitCheckInCommand.java\",\n                     ScmFileStatus.MODIFIED );\n        testScmFile( (ScmFile) changedFiles.get( 2 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/checkin/GitCheckInConsumer.java\",\n                     ScmFileStatus.DELETED );\n        testScmFile( (ScmFile) changedFiles.get( 3 ),\n                     \"maven-scm-provider-gitexe/src/main/java/org/apache/maven/scm/provider/git/gitexe/command/status/GitStatusConsumer.java\",\n                     ScmFileStatus.MODIFIED );\n    }\n\n\n    private void testScmFile( ScmFile fileToTest, String expectedFilePath, ScmFileStatus expectedStatus )\n    {\n        assertEquals( expectedFilePath, fileToTest.getPath() );\n        assertEquals( expectedStatus, fileToTest.getStatus() );\n    }\n\n    private File createTempDirectory()\n        throws IOException\n    {\n        File dir = File.createTempFile( \"gitexe\", \"test\" );\n        dir.delete();\n        dir.mkdir();\n        return dir;\n    }\n\n}\n","lineNo":250}
{"Smelly Sample":"package org.apache.maven.scm.provider.git;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport junit.framework.Assert;\nimport org.codehaus.plexus.PlexusTestCase;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic final class GitScmTestUtils\n{\n    private GitScmTestUtils()\n    {\n    }\n\n    public static void initRepo( File repository, File workingDirectory, File assertionDirectory )\n        throws IOException\n    {\n        initRepo( \"src/test/repository/\", repository, workingDirectory );\n\n        FileUtils.deleteDirectory( assertionDirectory );\n\n        Assert.assertTrue( assertionDirectory.mkdirs() );\n    }\n\n    public static void initRepo( String source, File repository, File workingDirectory )\n        throws IOException\n    {\n        // Copy the repository to target\n        File src = PlexusTestCase.getTestFile( source );\n\n        FileUtils.deleteDirectory( repository );\n\n        Assert.assertTrue( repository.mkdirs() );\n\n        FileUtils.copyDirectoryStructure( src, repository );\n\n        FileUtils.copyDirectoryStructure( new File( src, \"dotgit\" ), new File( repository, \".git\" ) );\n\n        FileUtils.deleteDirectory( workingDirectory );\n\n        Assert.assertTrue( workingDirectory.mkdirs() );\n    }\n\n    public static String getScmUrl( File repositoryRootFile, String provider )\n        throws CommandLineException\n    {\n        String repositoryRoot = repositoryRootFile.getAbsolutePath();\n\n        // TODO: it'd be great to build this into CommandLineUtils somehow\n        // TODO: some way without a custom cygwin sys property?\n        if ( \"true\".equals( System.getProperty( \"cygwin\" ) ) )\n        {\n            Commandline cl = new Commandline();\n\n            cl.setExecutable( \"cygpath\" );\n\n            cl.createArg().setValue( \"--unix\" );\n\n            cl.createArg().setValue( repositoryRoot );\n\n            CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n            int exitValue = CommandLineUtils.executeCommandLine( cl, stdout, null );\n\n            if ( exitValue != 0 )\n            {\n                throw new CommandLineException( \"Unable to convert cygwin path, exit code = \" + exitValue );\n            }\n\n            repositoryRoot = stdout.getOutput().trim();\n        }\n        else if ( Os.isFamily( \"windows\" ) )\n        {\n            repositoryRoot = \"/\" + StringUtils.replace( repositoryRoot, \"\\\\\", \"/\" );\n        }\n\n        return \"scm:\" + provider + \":file://\" + repositoryRoot;\n    }\n    \n    \n    public static void deleteAllDirectories( File startDirectory, String pattern ) \n    throws IOException\n    {\n        if ( startDirectory.isDirectory() ) \n        {\n            File[] childs = startDirectory.listFiles();\n            for ( int i = 0; i < childs.length; i++ )\n            {\n                File child = childs[ i ];\n                if ( child.isDirectory() )\n                {\n                    if ( child.getName().equals( pattern ) )\n                    {\n                        FileUtils.deleteDirectory( child );\n                    }\n                    else\n                    {\n                        deleteAllDirectories( child, pattern );\n                    }\n                }\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport junit.framework.Assert;\nimport org.codehaus.plexus.PlexusTestCase;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic final class GitScmTestUtils\n{\n    private GitScmTestUtils()\n    {\n    }\n\n    public static void initRepo( File repository, File workingDirectory, File assertionDirectory )\n        throws IOException\n    {\n        initRepo( \"src/test/repository/\", repository, workingDirectory );\n\n        FileUtils.deleteDirectory( assertionDirectory );\n\n        Assert.assertTrue( assertionDirectory.mkdirs() );\n    }\n\n    public static void initRepo( String source, File repository, File workingDirectory )\n        throws IOException\n    {\n        // Copy the repository to target\n        File src = PlexusTestCase.getTestFile( source );\n\n        FileUtils.deleteDirectory( repository );\n\n        Assert.assertTrue( repository.mkdirs() );\n\n        FileUtils.copyDirectoryStructure( src, repository );\n\n        File dotGitDirectory = new File( src, \"dotgit\" );\n\n        if ( dotGitDirectory.exists() )\n        {\n            FileUtils.copyDirectoryStructure( dotGitDirectory, new File( repository, \".git\" ) );\n        }\n\n        FileUtils.deleteDirectory( workingDirectory );\n\n        Assert.assertTrue( workingDirectory.mkdirs() );\n    }\n\n    public static String getScmUrl( File repositoryRootFile, String provider )\n        throws CommandLineException\n    {\n        String repositoryRoot = repositoryRootFile.getAbsolutePath();\n\n        // TODO: it'd be great to build this into CommandLineUtils somehow\n        // TODO: some way without a custom cygwin sys property?\n        if ( \"true\".equals( System.getProperty( \"cygwin\" ) ) )\n        {\n            Commandline cl = new Commandline();\n\n            cl.setExecutable( \"cygpath\" );\n\n            cl.createArg().setValue( \"--unix\" );\n\n            cl.createArg().setValue( repositoryRoot );\n\n            CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n            int exitValue = CommandLineUtils.executeCommandLine( cl, stdout, null );\n\n            if ( exitValue != 0 )\n            {\n                throw new CommandLineException( \"Unable to convert cygwin path, exit code = \" + exitValue );\n            }\n\n            repositoryRoot = stdout.getOutput().trim();\n        }\n        else if ( Os.isFamily( \"windows\" ) )\n        {\n            repositoryRoot = \"/\" + StringUtils.replace( repositoryRoot, \"\\\\\", \"/\" );\n        }\n\n        return \"scm:\" + provider + \":file://\" + repositoryRoot;\n    }\n\n\n    public static void deleteAllDirectories( File startDirectory, String pattern )\n        throws IOException\n    {\n        if ( startDirectory.isDirectory() )\n        {\n            File[] childs = startDirectory.listFiles();\n            for ( int i = 0; i < childs.length; i++ )\n            {\n                File child = childs[i];\n                if ( child.isDirectory() )\n                {\n                    if ( child.getName().equals( pattern ) )\n                    {\n                        FileUtils.deleteDirectory( child );\n                    }\n                    else\n                    {\n                        deleteAllDirectories( child, pattern );\n                    }\n                }\n            }\n        }\n    }\n\n}\n","lineNo":66}
{"Smelly Sample":"package org.apache.maven.scm.provider.jazz.command.edit;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.provider.jazz.JazzScmTestCase;\nimport org.apache.maven.scm.provider.jazz.repository.JazzScmProviderRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:ChrisGWarp@gmail.com\">Chris Graham<\/a>\n */\npublic class JazzEditCommandTest\n    extends JazzScmTestCase\n{\n    private JazzScmProviderRepository repo;\n\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n        repo = getScmProviderRepository();\n    }\n\n    public void testCreateEditCommandWithSpecificFiles()\n        throws Exception\n    {\n        Commandline cmd = new JazzEditCommand().createEditCommand( repo, getScmFileSet() ).getCommandline();\n        String expected =\n            \"scm lock acquire --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword file1 file2\";\n        assertCommandLine( expected, getWorkingDirectory(), cmd );\n    }\n\n    public void testCreateEditCommandWithEmptyFileSet()\n        throws Exception\n    {\n        // An empty file set will be all files, which jazz will take as a \".\"\n        Commandline cmd =\n            new JazzEditCommand().createEditCommand( repo, new ScmFileSet( new File( \".\" ) ) ).getCommandline();\n        String expected =\n            \"scm lock acquire --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword .\";\n        assertCommandLine( expected, getWorkingDirectory(), cmd );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.jazz.command.edit;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.provider.jazz.JazzScmTestCase;\nimport org.apache.maven.scm.provider.jazz.repository.JazzScmProviderRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:ChrisGWarp@gmail.com\">Chris Graham<\/a>\n */\npublic class JazzEditCommandTest\n    extends JazzScmTestCase\n{\n    private JazzScmProviderRepository repo;\n\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n        repo = getScmProviderRepository();\n    }\n\n    public void testCreateEditCommandWithSpecificFiles()\n        throws Exception\n    {\n        Commandline cmd = new JazzEditCommand().createEditCommand( repo, getScmFileSet() ).getCommandline();\n        String expected =\n            \"scm lock acquire --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword file1 file2\";\n        assertCommandLine( expected, getWorkingDirectory(), cmd );\n    }\n\n    public void testCreateEditCommandWithEmptyFileSet()\n        throws Exception\n    {\n        ScmFileSet scmFileSet = new ScmFileSet( new File( \".\" ) );\n        // An empty file set will be all files, which jazz will take as a \".\"\n        Commandline cmd = new JazzEditCommand().createEditCommand( repo, scmFileSet ).getCommandline();\n        String expected =\n            \"scm lock acquire --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword .\";\n\n        assertCommandLine( expected, scmFileSet.getBasedir(), cmd );\n    }\n}\n","lineNo":56}
{"Smelly Sample":"package org.apache.maven.scm.provider.jazz.command.unedit;\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.provider.jazz.JazzScmTestCase;\nimport org.apache.maven.scm.provider.jazz.repository.JazzScmProviderRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * @author <a href=\"mailto:ChrisGWarp@gmail.com\">Chris Graham<\/a>\n */\npublic class JazzUnEditCommandTest\n    extends JazzScmTestCase\n{\n    private JazzScmProviderRepository repo;\n\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n        repo = getScmProviderRepository();\n    }\n\n    public void testCreateUneditCommandWithSpecificFiles()\n        throws Exception\n    {\n        Commandline cmd = new JazzUnEditCommand().createUneditCommand( repo, getScmFileSet() ).getCommandline();\n        String expected =\n            \"scm lock release --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword file1 file2\";\n        assertCommandLine( expected, getWorkingDirectory(), cmd );\n    }\n\n    public void testCreateUneditCommandWithEmptyFileSet()\n        throws Exception\n    {\n        // An empty file set will be all files, which jazz will take as a \".\"\n        Commandline cmd =\n            new JazzUnEditCommand().createUneditCommand( repo, new ScmFileSet( new File( \".\" ) ) ).getCommandline();\n        String expected =\n            \"scm lock release --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword .\";\n        assertCommandLine( expected, getWorkingDirectory(), cmd );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.jazz.command.unedit;\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.provider.jazz.JazzScmTestCase;\nimport org.apache.maven.scm.provider.jazz.repository.JazzScmProviderRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * @author <a href=\"mailto:ChrisGWarp@gmail.com\">Chris Graham<\/a>\n */\npublic class JazzUnEditCommandTest\n    extends JazzScmTestCase\n{\n    private JazzScmProviderRepository repo;\n\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n        repo = getScmProviderRepository();\n    }\n\n    public void testCreateUneditCommandWithSpecificFiles()\n        throws Exception\n    {\n        Commandline cmd = new JazzUnEditCommand().createUneditCommand( repo, getScmFileSet() ).getCommandline();\n        String expected =\n            \"scm lock release --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword file1 file2\";\n        assertCommandLine( expected, getWorkingDirectory(), cmd );\n    }\n\n    public void testCreateUneditCommandWithEmptyFileSet()\n        throws Exception\n    {\n        ScmFileSet scmFileSet = new ScmFileSet( new File( \".\" ) );\n        // An empty file set will be all files, which jazz will take as a \".\"\n        Commandline cmd =\n            new JazzUnEditCommand().createUneditCommand( repo, scmFileSet ).getCommandline();\n        String expected =\n            \"scm lock release --repository-uri https://localhost:9443/jazz --username myUserName --password myPassword .\";\n        assertCommandLine( expected, scmFileSet.getBasedir(), cmd );\n    }\n}\n","lineNo":56}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Encapsulates the 'p4 info' command which can be very useful in determining\n * the runtime environment.  Use <code>getEntry(String key)<\/code> to query\n * the info set for a particular property.  The data from p4 info looks like this:\n * <p/>\n * <pre>\n * User name: mperham\n * Client name: mikeperham-dt\n * Client host: mikeperham-dt\n * Client root: d:\\perforce\n * <\/pre>\n * <p/>\n * where the key is the content before the first colon and the value is the data after\n * the first colon, trimmed.  For example:\n * <code>PerforceInfoCommand.getInfo( this, repo ).getEntry( \"User name\" )<\/code>\n * <p/>\n * Note that this is not a traditional SCM command.  This uses the Command class\n * simply because it needs a logger for error handling and the current repository data for\n * command line creation.\n *\n * @author mperham\n * @version $Id: $\n */\npublic class PerforceInfoCommand\n    extends AbstractCommand\n    implements PerforceCommand\n{\n    private static PerforceInfoCommand singleton = null;\n\n    private Map<String,String> entries = null;\n\n    public static PerforceInfoCommand getInfo( ScmLogger logger, PerforceScmProviderRepository repo )\n    {\n        return getSingleton( logger, repo );\n    }\n\n    public String getEntry( String key )\n    {\n        return (String) entries.get( key );\n    }\n\n    private static synchronized PerforceInfoCommand getSingleton( ScmLogger logger,\n                                                                  PerforceScmProviderRepository repo )\n    {\n        if ( singleton == null )\n        {\n            PerforceInfoCommand pic = new PerforceInfoCommand();\n            if ( logger != null )\n            {\n                pic.setLogger( logger );\n            }\n            try\n            {\n                pic.executeCommand( repo, null, null );\n                singleton = pic;\n            }\n            catch ( ScmException e )\n            {\n                if ( pic.getLogger().isErrorEnabled() )\n                {\n                    pic.getLogger().error( \"ScmException \" + e.getMessage(), e );\n                }\n            }\n        }\n\n        return singleton;\n    }\n\n    /** {@inheritDoc} */\n    protected ScmResult executeCommand( ScmProviderRepository repo, ScmFileSet scmFileSet,\n                                        CommandParameters commandParameters )\n        throws ScmException\n    {\n        if ( !PerforceScmProvider.isLive() )\n        {\n            return null;\n        }\n\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( (PerforceScmProviderRepository) repo, null );\n            command.createArg().setValue( \"info\" );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + command.toString() ) );\n            }\n            Process proc = command.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n            entries = new HashMap<String,String>();\n            while ( ( line = br.readLine() ) != null )\n            {\n                int idx = line.indexOf( ':' );\n                if ( idx == -1 )\n                {\n                    if ( line.indexOf( \"Client unknown.\" ) == -1 )\n                    {\n                        throw new IllegalStateException( \"Unexpected results from 'p4 info' command: \" + line );\n                    }\n\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Cannot find client.\" );\n                    }\n                    entries.put( \"Client root\", \"\" );\n                }\n                else\n                {\n                    String key = line.substring( 0, idx );\n                    String value = line.substring( idx + 1 ).trim();\n                    entries.put( key, value );\n                }\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new ScmException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( e.getLocalizedMessage() );\n        }\n        return null;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Encapsulates the 'p4 info' command which can be very useful in determining\n * the runtime environment.  Use <code>getEntry(String key)<\/code> to query\n * the info set for a particular property.  The data from p4 info looks like this:\n * <p/>\n * <pre>\n * User name: mperham\n * Client name: mikeperham-dt\n * Client host: mikeperham-dt\n * Client root: d:\\perforce\n * <\/pre>\n * <p/>\n * where the key is the content before the first colon and the value is the data after\n * the first colon, trimmed.  For example:\n * <code>PerforceInfoCommand.getInfo( this, repo ).getEntry( \"User name\" )<\/code>\n * <p/>\n * Note that this is not a traditional SCM command.  This uses the Command class\n * simply because it needs a logger for error handling and the current repository data for\n * command line creation.\n *\n * @author mperham\n * @version $Id: $\n */\npublic class PerforceInfoCommand\n    extends AbstractCommand\n    implements PerforceCommand\n{\n    private static PerforceInfoCommand singleton = null;\n\n    private Map<String, String> entries = null;\n\n    public static PerforceInfoCommand getInfo( ScmLogger logger, PerforceScmProviderRepository repo )\n    {\n        return getSingleton( logger, repo );\n    }\n\n    public String getEntry( String key )\n    {\n        return (String) entries.get( key );\n    }\n\n    private static synchronized PerforceInfoCommand getSingleton( ScmLogger logger, PerforceScmProviderRepository repo )\n    {\n        if ( singleton == null )\n        {\n            PerforceInfoCommand pic = new PerforceInfoCommand();\n            if ( logger != null )\n            {\n                pic.setLogger( logger );\n            }\n            try\n            {\n                pic.executeCommand( repo, null, null );\n                singleton = pic;\n            }\n            catch ( ScmException e )\n            {\n                if ( pic.getLogger().isErrorEnabled() )\n                {\n                    pic.getLogger().error( \"ScmException \" + e.getMessage(), e );\n                }\n            }\n        }\n\n        return singleton;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected ScmResult executeCommand( ScmProviderRepository repo, ScmFileSet scmFileSet,\n                                        CommandParameters commandParameters )\n        throws ScmException\n    {\n        if ( !PerforceScmProvider.isLive() )\n        {\n            return null;\n        }\n        InputStreamReader isReader = null;\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( (PerforceScmProviderRepository) repo, null );\n            command.createArg().setValue( \"info\" );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + command.toString() ) );\n            }\n            Process proc = command.execute();\n            isReader = new InputStreamReader( proc.getInputStream() );\n            BufferedReader br = new BufferedReader( isReader );\n            String line;\n            entries = new HashMap<String, String>();\n            while ( ( line = br.readLine() ) != null )\n            {\n                int idx = line.indexOf( ':' );\n                if ( idx == -1 )\n                {\n                    if ( line.indexOf( \"Client unknown.\" ) == -1 )\n                    {\n                        throw new IllegalStateException( \"Unexpected results from 'p4 info' command: \" + line );\n                    }\n\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Cannot find client.\" );\n                    }\n                    entries.put( \"Client root\", \"\" );\n                }\n                else\n                {\n                    String key = line.substring( 0, idx );\n                    String value = line.substring( idx + 1 ).trim();\n                    entries.put( key, value );\n                }\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new ScmException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( e.getLocalizedMessage() );\n        }\n        finally\n        {\n            IOUtil.close( isReader );\n        }\n        return null;\n    }\n}\n","lineNo":119}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Encapsulates the 'p4 where' command which can be very useful in determining\n * a file's location within the depot.  Use <code>getDepotLocation(String path)<\/code> to query\n * the depot location for a particular file.  The data from p4 where looks like this:\n * <p/>\n * <pre>\n * p4 where pom.xml\n * //depot/modules/fabric/trunk/pom.xml //mikeperham-dt/depot/modules/fabric/trunk/pom.xml\n * d:\\perforce\\depot\\modules\\fabric\\trunk\\pom.xml\n * <\/pre>\n *\n * @author mperham\n * @version $Id: $\n */\npublic class PerforceWhereCommand\n{\n    private ScmLogger logger = null;\n\n    private PerforceScmProviderRepository repo = null;\n\n    public PerforceWhereCommand( ScmLogger log, PerforceScmProviderRepository repos )\n    {\n        logger = log;\n        repo = repos;\n    }\n\n    public String getDepotLocation( File file )\n    {\n        return getDepotLocation( file.getAbsolutePath() );\n    }\n\n    /**\n     * @param filepath an absolute file path\n     * @return the absolute location of the given file within the Perforce repository or null if the file\n     *         does not exist in a mapping within the current clientspec.\n     */\n    public String getDepotLocation( String filepath )\n    {\n        if ( !PerforceScmProvider.isLive() )\n        {\n            return null;\n        }\n\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, null );\n            command.createArg().setValue( \"where\" );\n            command.createArg().setValue( filepath );\n            if ( logger.isDebugEnabled() )\n            {\n                logger.debug( PerforceScmProvider.clean( \"Executing: \" + command.toString() ) );\n            }\n            Process proc = command.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            BufferedReader brErr = new BufferedReader( new InputStreamReader( proc.getErrorStream() ) );\n            String line;\n            String path = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n                // verify that \"//\" appears twice in the line\n                path = line.substring( 0, line.lastIndexOf( \"//\" ) - 1 );\n            }\n            // Check for errors\n            while ( ( line = brErr.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n            }\n\n            return path;\n        }\n        catch ( CommandLineException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Encapsulates the 'p4 where' command which can be very useful in determining\n * a file's location within the depot.  Use <code>getDepotLocation(String path)<\/code> to query\n * the depot location for a particular file.  The data from p4 where looks like this:\n * <p/>\n * <pre>\n * p4 where pom.xml\n * //depot/modules/fabric/trunk/pom.xml //mikeperham-dt/depot/modules/fabric/trunk/pom.xml\n * d:\\perforce\\depot\\modules\\fabric\\trunk\\pom.xml\n * <\/pre>\n *\n * @author mperham\n * @version $Id: $\n */\npublic class PerforceWhereCommand\n{\n    private ScmLogger logger = null;\n\n    private PerforceScmProviderRepository repo = null;\n\n    public PerforceWhereCommand( ScmLogger log, PerforceScmProviderRepository repos )\n    {\n        logger = log;\n        repo = repos;\n    }\n\n    public String getDepotLocation( File file )\n    {\n        return getDepotLocation( file.getAbsolutePath() );\n    }\n\n    /**\n     * @param filepath an absolute file path\n     * @return the absolute location of the given file within the Perforce repository or null if the file\n     *         does not exist in a mapping within the current clientspec.\n     */\n    public String getDepotLocation( String filepath )\n    {\n        if ( !PerforceScmProvider.isLive() )\n        {\n            return null;\n        }\n\n        InputStreamReader isReader = null;\n        InputStreamReader isReaderErr = null;\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, null );\n            command.createArg().setValue( \"where\" );\n            command.createArg().setValue( filepath );\n            if ( logger.isDebugEnabled() )\n            {\n                logger.debug( PerforceScmProvider.clean( \"Executing: \" + command.toString() ) );\n            }\n            Process proc = command.execute();\n            isReader = new InputStreamReader( proc.getInputStream() );\n            isReaderErr = new InputStreamReader( proc.getErrorStream() );\n            BufferedReader br = new BufferedReader( isReader );\n            BufferedReader brErr = new BufferedReader( isReaderErr );\n            String line;\n            String path = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n                // verify that \"//\" appears twice in the line\n                path = line.substring( 0, line.lastIndexOf( \"//\" ) - 1 );\n            }\n            // Check for errors\n            while ( ( line = brErr.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n            }\n\n            return path;\n        }\n        catch ( CommandLineException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n        finally\n        {\n            IOUtil.close( isReader );\n            IOUtil.close( isReaderErr );\n        }\n    }\n}\n","lineNo":77}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Encapsulates the 'p4 where' command which can be very useful in determining\n * a file's location within the depot.  Use <code>getDepotLocation(String path)<\/code> to query\n * the depot location for a particular file.  The data from p4 where looks like this:\n * <p/>\n * <pre>\n * p4 where pom.xml\n * //depot/modules/fabric/trunk/pom.xml //mikeperham-dt/depot/modules/fabric/trunk/pom.xml\n * d:\\perforce\\depot\\modules\\fabric\\trunk\\pom.xml\n * <\/pre>\n *\n * @author mperham\n * @version $Id: $\n */\npublic class PerforceWhereCommand\n{\n    private ScmLogger logger = null;\n\n    private PerforceScmProviderRepository repo = null;\n\n    public PerforceWhereCommand( ScmLogger log, PerforceScmProviderRepository repos )\n    {\n        logger = log;\n        repo = repos;\n    }\n\n    public String getDepotLocation( File file )\n    {\n        return getDepotLocation( file.getAbsolutePath() );\n    }\n\n    /**\n     * @param filepath an absolute file path\n     * @return the absolute location of the given file within the Perforce repository or null if the file\n     *         does not exist in a mapping within the current clientspec.\n     */\n    public String getDepotLocation( String filepath )\n    {\n        if ( !PerforceScmProvider.isLive() )\n        {\n            return null;\n        }\n\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, null );\n            command.createArg().setValue( \"where\" );\n            command.createArg().setValue( filepath );\n            if ( logger.isDebugEnabled() )\n            {\n                logger.debug( PerforceScmProvider.clean( \"Executing: \" + command.toString() ) );\n            }\n            Process proc = command.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            BufferedReader brErr = new BufferedReader( new InputStreamReader( proc.getErrorStream() ) );\n            String line;\n            String path = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n                // verify that \"//\" appears twice in the line\n                path = line.substring( 0, line.lastIndexOf( \"//\" ) - 1 );\n            }\n            // Check for errors\n            while ( ( line = brErr.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n            }\n\n            return path;\n        }\n        catch ( CommandLineException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Encapsulates the 'p4 where' command which can be very useful in determining\n * a file's location within the depot.  Use <code>getDepotLocation(String path)<\/code> to query\n * the depot location for a particular file.  The data from p4 where looks like this:\n * <p/>\n * <pre>\n * p4 where pom.xml\n * //depot/modules/fabric/trunk/pom.xml //mikeperham-dt/depot/modules/fabric/trunk/pom.xml\n * d:\\perforce\\depot\\modules\\fabric\\trunk\\pom.xml\n * <\/pre>\n *\n * @author mperham\n * @version $Id: $\n */\npublic class PerforceWhereCommand\n{\n    private ScmLogger logger = null;\n\n    private PerforceScmProviderRepository repo = null;\n\n    public PerforceWhereCommand( ScmLogger log, PerforceScmProviderRepository repos )\n    {\n        logger = log;\n        repo = repos;\n    }\n\n    public String getDepotLocation( File file )\n    {\n        return getDepotLocation( file.getAbsolutePath() );\n    }\n\n    /**\n     * @param filepath an absolute file path\n     * @return the absolute location of the given file within the Perforce repository or null if the file\n     *         does not exist in a mapping within the current clientspec.\n     */\n    public String getDepotLocation( String filepath )\n    {\n        if ( !PerforceScmProvider.isLive() )\n        {\n            return null;\n        }\n\n        InputStreamReader isReader = null;\n        InputStreamReader isReaderErr = null;\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, null );\n            command.createArg().setValue( \"where\" );\n            command.createArg().setValue( filepath );\n            if ( logger.isDebugEnabled() )\n            {\n                logger.debug( PerforceScmProvider.clean( \"Executing: \" + command.toString() ) );\n            }\n            Process proc = command.execute();\n            isReader = new InputStreamReader( proc.getInputStream() );\n            isReaderErr = new InputStreamReader( proc.getErrorStream() );\n            BufferedReader br = new BufferedReader( isReader );\n            BufferedReader brErr = new BufferedReader( isReaderErr );\n            String line;\n            String path = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n                // verify that \"//\" appears twice in the line\n                path = line.substring( 0, line.lastIndexOf( \"//\" ) - 1 );\n            }\n            // Check for errors\n            while ( ( line = brErr.readLine() ) != null )\n            {\n                if ( line.indexOf( \"not in client view\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n                if ( line.indexOf( \"is not under\" ) != -1 )\n                {\n                    // uh oh, something bad is happening\n                    if ( logger.isErrorEnabled() )\n                    {\n                        logger.error( line );\n                    }\n                    return null;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( line );\n                }\n            }\n\n            return path;\n        }\n        catch ( CommandLineException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            if ( logger.isErrorEnabled() )\n            {\n                logger.error( e );\n            }\n            throw new RuntimeException( e.getLocalizedMessage() );\n        }\n        finally\n        {\n            IOUtil.close( isReader );\n            IOUtil.close( isReaderErr );\n        }\n    }\n}\n","lineNo":78}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.apache.regexp.RE;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n    private String actualLocation;\n\n    /**\n     * Check out the depot code at <code>repo.getPath()<\/code> into the target\n     * directory at <code>files.getBasedir<\/code>. Perforce does not support\n     * arbitrary checkout of versioned source so we need to set up a well-known\n     * clientspec which will hold the required info.\n     * <p/>\n     * 1) A clientspec will be created or updated which holds a temporary\n     * mapping from the repo path to the target directory.\n     * 2) This clientspec is sync'd to pull all the files onto the client\n     *\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files,\n                                                        ScmVersion version, boolean recursive )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        File workingDirectory = new File( files.getBasedir().getAbsolutePath() );\n\n        actualLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        String specname = PerforceScmProvider.getClientspecName( getLogger(), prepo, workingDirectory );\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer( specname, actualLocation );\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Checkout working directory: \" + workingDirectory );\n        }\n        Commandline cl = null;\n\n        // Create or update a clientspec so we can checkout the code to a particular location\n        try\n        {\n            // Ahhh, glorious Perforce.  Create and update of clientspecs is the exact\n            // same operation so we don't need to distinguish between the two modes.\n            cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n            cl.createArg().setValue( \"client\" );\n            cl.createArg().setValue( \"-i\" );\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n            }\n\n            String client = PerforceScmProvider.createClientspec( getLogger(), prepo, workingDirectory, actualLocation );\n\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Updating clientspec:\\n\" + client );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, new ByteArrayInputStream(client.getBytes()), consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        boolean clientspecExists = consumer.isSuccess();\n\n        // Perform the actual checkout using that clientspec\n        try\n        {\n            if ( clientspecExists )\n            {\n                try\n                {\n                    getLastChangelist( prepo, workingDirectory, specname );\n                    cl = createCommandLine( prepo, workingDirectory, version, specname );\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n                    int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n                    if ( exitCode != 0 )\n                    {\n                        String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                        StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                        msg.append( '\\n' );\n                        msg.append( \"Command line was:\" + cmdLine );\n\n                        throw new CommandLineException( msg.toString() );\n                    }\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Perforce sync complete.\" );\n                    }\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n            }\n\n            if ( consumer.isSuccess() )\n            {\n                return new CheckOutScmResult( cl.toString(), consumer.getCheckedout() );\n            }\n            else\n            {\n                return new CheckOutScmResult( cl.toString(), \"Unable to sync.  Are you logged in?\", consumer\n                    .getOutput(), consumer.isSuccess() );\n            }\n        }\n        finally\n        {\n            // See SCM-113\n            // Support transient clientspecs as we don't want to create 1000s of permanent clientspecs\n            if ( clientspecExists && !prepo.isPersistCheckout() )\n            {\n                // Delete the clientspec\n                try\n                {\n                    cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n                    cl.createArg().setValue( \"client\" );\n                    cl.createArg().setValue( \"-d\" );\n                    cl.createArg().setValue( specname );\n                    if ( getLogger().isInfoEnabled() )\n                    {\n                        getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    br.close();\n                    // Read errors from STDERR\n                    BufferedReader brErr = new BufferedReader( new InputStreamReader( proc.getErrorStream() ) );\n                    while ( ( line = brErr.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming stderr: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    brErr.close();\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n            }\n            else if ( clientspecExists )\n            {\n                // SCM-165 Save clientspec in memory so we can reuse it with further commands in this VM.\n                System.setProperty( PerforceScmProvider.DEFAULT_CLIENTSPEC_PROPERTY, specname );\n            }\n        }\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 ScmVersion version, String specname )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"-c\" + specname );\n        command.createArg().setValue( \"sync\" );\n\n        // Use a simple heuristic to determine if we should use the Force flag\n        // on sync.  Forcing sync is a HUGE performance hit but is required in\n        // rare instances where source is somehow deleted.  If the target\n        // directory is completely empty, assume a force is required.  If\n        // not empty, we assume a previous checkout was already done and a normal\n        // sync will suffice.\n        // SCM-110\n        String[] files = workingDirectory.list();\n        if ( files == null || files.length == 0 )\n        {\n            // We need to force so checkout to an empty directory will work.\n            command.createArg().setValue( \"-f\" );\n        }\n\n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            command.createArg().setValue( \"@\" + version.getName() );\n        }\n        return command;\n    }\n\n    private int getLastChangelist( PerforceScmProviderRepository repo, File workingDirectory,\n                                   String specname )\n    {\n        int lastChangelist = 0;\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n            command.createArg().setValue( \"-c\" + specname );\n            command.createArg().setValue( \"changes\" );\n            command.createArg().setValue( \"-m1\" );\n            command.createArg().setValue( \"-ssubmitted\" );\n            command.createArg().setValue( \"//\" + specname + \"/...\" );\n            getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( command.toString() ) );\n            Process proc = command.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n\n            String lastChangelistStr = \"\";\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                RE changeRegexp = new RE( \"Change (\\\\d+)\" );\n                if ( changeRegexp.match( line ) )\n                {\n                    lastChangelistStr = changeRegexp.getParen( 1 );\n                }\n            }\n            br.close();\n            // TODO: Read errors from STDERR?\n\n            try\n            {\n                lastChangelist = Integer.parseInt(lastChangelistStr);\n            }\n            catch( NumberFormatException nfe ) {\n                getLogger().debug(\"Could not parse changelist from line \" + line);\n            }\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n\n        return lastChangelist;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.apache.regexp.RE;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n    private String actualLocation;\n\n    /**\n     * Check out the depot code at <code>repo.getPath()<\/code> into the target\n     * directory at <code>files.getBasedir<\/code>. Perforce does not support\n     * arbitrary checkout of versioned source so we need to set up a well-known\n     * clientspec which will hold the required info.\n     * <p/>\n     * 1) A clientspec will be created or updated which holds a temporary\n     * mapping from the repo path to the target directory.\n     * 2) This clientspec is sync'd to pull all the files onto the client\n     * <p/>\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files,\n                                                        ScmVersion version, boolean recursive )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        File workingDirectory = new File( files.getBasedir().getAbsolutePath() );\n\n        actualLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        String specname = PerforceScmProvider.getClientspecName( getLogger(), prepo, workingDirectory );\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer( specname, actualLocation );\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Checkout working directory: \" + workingDirectory );\n        }\n        Commandline cl = null;\n\n        // Create or update a clientspec so we can checkout the code to a particular location\n        try\n        {\n            // Ahhh, glorious Perforce.  Create and update of clientspecs is the exact\n            // same operation so we don't need to distinguish between the two modes.\n            cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n            cl.createArg().setValue( \"client\" );\n            cl.createArg().setValue( \"-i\" );\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n            }\n\n            String client =\n                PerforceScmProvider.createClientspec( getLogger(), prepo, workingDirectory, actualLocation );\n\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Updating clientspec:\\n\" + client );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode =\n                CommandLineUtils.executeCommandLine( cl, new ByteArrayInputStream( client.getBytes() ), consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        boolean clientspecExists = consumer.isSuccess();\n\n        // Perform the actual checkout using that clientspec\n        try\n        {\n            if ( clientspecExists )\n            {\n                try\n                {\n                    getLastChangelist( prepo, workingDirectory, specname );\n                    cl = createCommandLine( prepo, workingDirectory, version, specname );\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n                    int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n                    if ( exitCode != 0 )\n                    {\n                        String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                        StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                        msg.append( '\\n' );\n                        msg.append( \"Command line was:\" + cmdLine );\n\n                        throw new CommandLineException( msg.toString() );\n                    }\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Perforce sync complete.\" );\n                    }\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n            }\n\n            if ( consumer.isSuccess() )\n            {\n                return new CheckOutScmResult( cl.toString(), consumer.getCheckedout() );\n            }\n            else\n            {\n                return new CheckOutScmResult( cl.toString(), \"Unable to sync.  Are you logged in?\",\n                                              consumer.getOutput(), consumer.isSuccess() );\n            }\n        }\n        finally\n        {\n            // See SCM-113\n            // Support transient clientspecs as we don't want to create 1000s of permanent clientspecs\n            if ( clientspecExists && !prepo.isPersistCheckout() )\n            {\n                // Delete the clientspec\n                InputStreamReader isReader = null;\n                InputStreamReader isReaderErr = null;\n                try\n                {\n                    cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n                    cl.createArg().setValue( \"client\" );\n                    cl.createArg().setValue( \"-d\" );\n                    cl.createArg().setValue( specname );\n                    if ( getLogger().isInfoEnabled() )\n                    {\n                        getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n                    isReader = new InputStreamReader( proc.getInputStream() );\n                    BufferedReader br = new BufferedReader( isReader );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    br.close();\n                    // Read errors from STDERR\n                    isReaderErr = new InputStreamReader( proc.getErrorStream() );\n                    BufferedReader brErr = new BufferedReader( isReaderErr );\n                    while ( ( line = brErr.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming stderr: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    brErr.close();\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n                finally\n                {\n                    IOUtil.close( isReader );\n                    IOUtil.close( isReaderErr );\n                }\n            }\n            else if ( clientspecExists )\n            {\n                // SCM-165 Save clientspec in memory so we can reuse it with further commands in this VM.\n                System.setProperty( PerforceScmProvider.DEFAULT_CLIENTSPEC_PROPERTY, specname );\n            }\n        }\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 ScmVersion version, String specname )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"-c\" + specname );\n        command.createArg().setValue( \"sync\" );\n\n        // Use a simple heuristic to determine if we should use the Force flag\n        // on sync.  Forcing sync is a HUGE performance hit but is required in\n        // rare instances where source is somehow deleted.  If the target\n        // directory is completely empty, assume a force is required.  If\n        // not empty, we assume a previous checkout was already done and a normal\n        // sync will suffice.\n        // SCM-110\n        String[] files = workingDirectory.list();\n        if ( files == null || files.length == 0 )\n        {\n            // We need to force so checkout to an empty directory will work.\n            command.createArg().setValue( \"-f\" );\n        }\n\n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            command.createArg().setValue( \"@\" + version.getName() );\n        }\n        return command;\n    }\n\n    private int getLastChangelist( PerforceScmProviderRepository repo, File workingDirectory, String specname )\n    {\n        int lastChangelist = 0;\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n            command.createArg().setValue( \"-c\" + specname );\n            command.createArg().setValue( \"changes\" );\n            command.createArg().setValue( \"-m1\" );\n            command.createArg().setValue( \"-ssubmitted\" );\n            command.createArg().setValue( \"//\" + specname + \"/...\" );\n            getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( command.toString() ) );\n            Process proc = command.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n\n            String lastChangelistStr = \"\";\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                RE changeRegexp = new RE( \"Change (\\\\d+)\" );\n                if ( changeRegexp.match( line ) )\n                {\n                    lastChangelistStr = changeRegexp.getParen( 1 );\n                }\n            }\n            br.close();\n            // TODO: Read errors from STDERR?\n\n            try\n            {\n                lastChangelist = Integer.parseInt( lastChangelistStr );\n            }\n            catch ( NumberFormatException nfe )\n            {\n                getLogger().debug( \"Could not parse changelist from line \" + line );\n            }\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n\n        return lastChangelist;\n    }\n}\n","lineNo":204}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.apache.regexp.RE;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n    private String actualLocation;\n\n    /**\n     * Check out the depot code at <code>repo.getPath()<\/code> into the target\n     * directory at <code>files.getBasedir<\/code>. Perforce does not support\n     * arbitrary checkout of versioned source so we need to set up a well-known\n     * clientspec which will hold the required info.\n     * <p/>\n     * 1) A clientspec will be created or updated which holds a temporary\n     * mapping from the repo path to the target directory.\n     * 2) This clientspec is sync'd to pull all the files onto the client\n     *\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files,\n                                                        ScmVersion version, boolean recursive )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        File workingDirectory = new File( files.getBasedir().getAbsolutePath() );\n\n        actualLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        String specname = PerforceScmProvider.getClientspecName( getLogger(), prepo, workingDirectory );\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer( specname, actualLocation );\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Checkout working directory: \" + workingDirectory );\n        }\n        Commandline cl = null;\n\n        // Create or update a clientspec so we can checkout the code to a particular location\n        try\n        {\n            // Ahhh, glorious Perforce.  Create and update of clientspecs is the exact\n            // same operation so we don't need to distinguish between the two modes.\n            cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n            cl.createArg().setValue( \"client\" );\n            cl.createArg().setValue( \"-i\" );\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n            }\n\n            String client = PerforceScmProvider.createClientspec( getLogger(), prepo, workingDirectory, actualLocation );\n\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Updating clientspec:\\n\" + client );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, new ByteArrayInputStream(client.getBytes()), consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        boolean clientspecExists = consumer.isSuccess();\n\n        // Perform the actual checkout using that clientspec\n        try\n        {\n            if ( clientspecExists )\n            {\n                try\n                {\n                    getLastChangelist( prepo, workingDirectory, specname );\n                    cl = createCommandLine( prepo, workingDirectory, version, specname );\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n                    int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n                    if ( exitCode != 0 )\n                    {\n                        String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                        StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                        msg.append( '\\n' );\n                        msg.append( \"Command line was:\" + cmdLine );\n\n                        throw new CommandLineException( msg.toString() );\n                    }\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Perforce sync complete.\" );\n                    }\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n            }\n\n            if ( consumer.isSuccess() )\n            {\n                return new CheckOutScmResult( cl.toString(), consumer.getCheckedout() );\n            }\n            else\n            {\n                return new CheckOutScmResult( cl.toString(), \"Unable to sync.  Are you logged in?\", consumer\n                    .getOutput(), consumer.isSuccess() );\n            }\n        }\n        finally\n        {\n            // See SCM-113\n            // Support transient clientspecs as we don't want to create 1000s of permanent clientspecs\n            if ( clientspecExists && !prepo.isPersistCheckout() )\n            {\n                // Delete the clientspec\n                try\n                {\n                    cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n                    cl.createArg().setValue( \"client\" );\n                    cl.createArg().setValue( \"-d\" );\n                    cl.createArg().setValue( specname );\n                    if ( getLogger().isInfoEnabled() )\n                    {\n                        getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    br.close();\n                    // Read errors from STDERR\n                    BufferedReader brErr = new BufferedReader( new InputStreamReader( proc.getErrorStream() ) );\n                    while ( ( line = brErr.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming stderr: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    brErr.close();\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n            }\n            else if ( clientspecExists )\n            {\n                // SCM-165 Save clientspec in memory so we can reuse it with further commands in this VM.\n                System.setProperty( PerforceScmProvider.DEFAULT_CLIENTSPEC_PROPERTY, specname );\n            }\n        }\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 ScmVersion version, String specname )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"-c\" + specname );\n        command.createArg().setValue( \"sync\" );\n\n        // Use a simple heuristic to determine if we should use the Force flag\n        // on sync.  Forcing sync is a HUGE performance hit but is required in\n        // rare instances where source is somehow deleted.  If the target\n        // directory is completely empty, assume a force is required.  If\n        // not empty, we assume a previous checkout was already done and a normal\n        // sync will suffice.\n        // SCM-110\n        String[] files = workingDirectory.list();\n        if ( files == null || files.length == 0 )\n        {\n            // We need to force so checkout to an empty directory will work.\n            command.createArg().setValue( \"-f\" );\n        }\n\n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            command.createArg().setValue( \"@\" + version.getName() );\n        }\n        return command;\n    }\n\n    private int getLastChangelist( PerforceScmProviderRepository repo, File workingDirectory,\n                                   String specname )\n    {\n        int lastChangelist = 0;\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n            command.createArg().setValue( \"-c\" + specname );\n            command.createArg().setValue( \"changes\" );\n            command.createArg().setValue( \"-m1\" );\n            command.createArg().setValue( \"-ssubmitted\" );\n            command.createArg().setValue( \"//\" + specname + \"/...\" );\n            getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( command.toString() ) );\n            Process proc = command.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n\n            String lastChangelistStr = \"\";\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                RE changeRegexp = new RE( \"Change (\\\\d+)\" );\n                if ( changeRegexp.match( line ) )\n                {\n                    lastChangelistStr = changeRegexp.getParen( 1 );\n                }\n            }\n            br.close();\n            // TODO: Read errors from STDERR?\n\n            try\n            {\n                lastChangelist = Integer.parseInt(lastChangelistStr);\n            }\n            catch( NumberFormatException nfe ) {\n                getLogger().debug(\"Could not parse changelist from line \" + line);\n            }\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n\n        return lastChangelist;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.apache.regexp.RE;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n    private String actualLocation;\n\n    /**\n     * Check out the depot code at <code>repo.getPath()<\/code> into the target\n     * directory at <code>files.getBasedir<\/code>. Perforce does not support\n     * arbitrary checkout of versioned source so we need to set up a well-known\n     * clientspec which will hold the required info.\n     * <p/>\n     * 1) A clientspec will be created or updated which holds a temporary\n     * mapping from the repo path to the target directory.\n     * 2) This clientspec is sync'd to pull all the files onto the client\n     * <p/>\n     * {@inheritDoc}\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files,\n                                                        ScmVersion version, boolean recursive )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        File workingDirectory = new File( files.getBasedir().getAbsolutePath() );\n\n        actualLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        String specname = PerforceScmProvider.getClientspecName( getLogger(), prepo, workingDirectory );\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer( specname, actualLocation );\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Checkout working directory: \" + workingDirectory );\n        }\n        Commandline cl = null;\n\n        // Create or update a clientspec so we can checkout the code to a particular location\n        try\n        {\n            // Ahhh, glorious Perforce.  Create and update of clientspecs is the exact\n            // same operation so we don't need to distinguish between the two modes.\n            cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n            cl.createArg().setValue( \"client\" );\n            cl.createArg().setValue( \"-i\" );\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n            }\n\n            String client =\n                PerforceScmProvider.createClientspec( getLogger(), prepo, workingDirectory, actualLocation );\n\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"Updating clientspec:\\n\" + client );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode =\n                CommandLineUtils.executeCommandLine( cl, new ByteArrayInputStream( client.getBytes() ), consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        boolean clientspecExists = consumer.isSuccess();\n\n        // Perform the actual checkout using that clientspec\n        try\n        {\n            if ( clientspecExists )\n            {\n                try\n                {\n                    getLastChangelist( prepo, workingDirectory, specname );\n                    cl = createCommandLine( prepo, workingDirectory, version, specname );\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n                    int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n                    if ( exitCode != 0 )\n                    {\n                        String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                        StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                        msg.append( '\\n' );\n                        msg.append( \"Command line was:\" + cmdLine );\n\n                        throw new CommandLineException( msg.toString() );\n                    }\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Perforce sync complete.\" );\n                    }\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n            }\n\n            if ( consumer.isSuccess() )\n            {\n                return new CheckOutScmResult( cl.toString(), consumer.getCheckedout() );\n            }\n            else\n            {\n                return new CheckOutScmResult( cl.toString(), \"Unable to sync.  Are you logged in?\",\n                                              consumer.getOutput(), consumer.isSuccess() );\n            }\n        }\n        finally\n        {\n            // See SCM-113\n            // Support transient clientspecs as we don't want to create 1000s of permanent clientspecs\n            if ( clientspecExists && !prepo.isPersistCheckout() )\n            {\n                // Delete the clientspec\n                InputStreamReader isReader = null;\n                InputStreamReader isReaderErr = null;\n                try\n                {\n                    cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n                    cl.createArg().setValue( \"client\" );\n                    cl.createArg().setValue( \"-d\" );\n                    cl.createArg().setValue( specname );\n                    if ( getLogger().isInfoEnabled() )\n                    {\n                        getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    }\n                    Process proc = cl.execute();\n                    isReader = new InputStreamReader( proc.getInputStream() );\n                    BufferedReader br = new BufferedReader( isReader );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    br.close();\n                    // Read errors from STDERR\n                    isReaderErr = new InputStreamReader( proc.getErrorStream() );\n                    BufferedReader brErr = new BufferedReader( isReaderErr );\n                    while ( ( line = brErr.readLine() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Consuming stderr: \" + line );\n                        }\n                        consumer.consumeLine( line );\n                    }\n                    brErr.close();\n                }\n                catch ( CommandLineException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( \"IOException \" + e.getMessage(), e );\n                    }\n                }\n                finally\n                {\n                    IOUtil.close( isReader );\n                    IOUtil.close( isReaderErr );\n                }\n            }\n            else if ( clientspecExists )\n            {\n                // SCM-165 Save clientspec in memory so we can reuse it with further commands in this VM.\n                System.setProperty( PerforceScmProvider.DEFAULT_CLIENTSPEC_PROPERTY, specname );\n            }\n        }\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 ScmVersion version, String specname )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"-c\" + specname );\n        command.createArg().setValue( \"sync\" );\n\n        // Use a simple heuristic to determine if we should use the Force flag\n        // on sync.  Forcing sync is a HUGE performance hit but is required in\n        // rare instances where source is somehow deleted.  If the target\n        // directory is completely empty, assume a force is required.  If\n        // not empty, we assume a previous checkout was already done and a normal\n        // sync will suffice.\n        // SCM-110\n        String[] files = workingDirectory.list();\n        if ( files == null || files.length == 0 )\n        {\n            // We need to force so checkout to an empty directory will work.\n            command.createArg().setValue( \"-f\" );\n        }\n\n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            command.createArg().setValue( \"@\" + version.getName() );\n        }\n        return command;\n    }\n\n    private int getLastChangelist( PerforceScmProviderRepository repo, File workingDirectory, String specname )\n    {\n        int lastChangelist = 0;\n        try\n        {\n            Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n            command.createArg().setValue( \"-c\" + specname );\n            command.createArg().setValue( \"changes\" );\n            command.createArg().setValue( \"-m1\" );\n            command.createArg().setValue( \"-ssubmitted\" );\n            command.createArg().setValue( \"//\" + specname + \"/...\" );\n            getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( command.toString() ) );\n            Process proc = command.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n\n            String lastChangelistStr = \"\";\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                RE changeRegexp = new RE( \"Change (\\\\d+)\" );\n                if ( changeRegexp.match( line ) )\n                {\n                    lastChangelistStr = changeRegexp.getParen( 1 );\n                }\n            }\n            br.close();\n            // TODO: Read errors from STDERR?\n\n            try\n            {\n                lastChangelist = Integer.parseInt( lastChangelistStr );\n            }\n            catch ( NumberFormatException nfe )\n            {\n                getLogger().debug( \"Could not parse changelist from line \" + line );\n            }\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n\n        return lastChangelist;\n    }\n}\n","lineNo":205}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.util.List;\n\n/**\n * @author Mike Perham\n * @author Olivier Lamy\n * @version $Id$\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n    private String actualRepoLocation = null;\n\n    \n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, files, tag, new ScmTagParameters( message ) );\n    }\n    \n    /** {@inheritDoc} */\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag,\n                                           ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualRepoLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        createLabel( repo, files, tag, consumer, false );\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n        if ( consumer.isSuccess() )\n        {\n            // Now update the label if we need to lock it\n            if ( shouldLock() )\n            {\n                consumer = new PerforceTagConsumer();\n                createLabel( repo, files, tag, consumer, true );\n            }\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n\n        // Unclear what to pass as the first arg\n        return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n    }\n\n    private boolean shouldLock()\n    {\n        return Boolean.valueOf( System.getProperty( \"maven.scm.locktag\", \"true\" ) ).booleanValue();\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl =\n            createLabelsyncCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer,\n                              boolean lock )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            Process proc = cl.execute();\n            OutputStream out = proc.getOutputStream();\n            DataOutputStream dos = new DataOutputStream( out );\n            String label = createLabelSpecification( (PerforceScmProviderRepository) repo, tag, lock );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"LabelSpec: \" + NEWLINE + label );\n            }\n            dos.write( label.getBytes() );\n            dos.close();\n            out.close();\n            // TODO find & use a less naive InputStream multiplexer\n            BufferedReader stdout = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            BufferedReader stderr = new BufferedReader( new InputStreamReader( proc.getErrorStream() ) );\n            String line;\n            while ( ( line = stdout.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stdout: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            while ( ( line = stderr.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stderr: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            stderr.close();\n            stdout.close();\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"IOException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"label\" );\n        command.createArg().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                          ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"labelsync\" );\n        command.createArg().setValue( \"-l\" );\n        command.createArg().setValue( tag );\n\n        List<File> fs = files.getFileList();\n        for ( File file : fs )\n        {\n            command.createArg().setValue( file.getPath() );\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label\n     * View: //depot/path/to/repos/...\n     * Owner: mperham\n     */\n    public String createLabelSpecification( PerforceScmProviderRepository repo, String tag, boolean lock )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( PerforceScmProvider.getCanonicalRepoPath( actualRepoLocation ) ).append(\n            NEWLINE );\n        String username = repo.getUser();\n        if ( username == null )\n        {\n            // I have no idea why but Perforce doesn't default the owner to the current user.\n            // Since the user is not explicitly set, we use 'p4 info' to query for the current user.\n            username = PerforceInfoCommand.getInfo( getLogger(), repo ).getEntry( \"User name\" );\n        }\n        buf.append( \"Owner: \" ).append( username ).append( NEWLINE );\n        buf.append( \"Options: \" ).append( lock ? \"\" : \"un\" ).append( \"locked\" ).append( NEWLINE );\n        return buf.toString();\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.util.List;\n\n/**\n * @author Mike Perham\n * @author Olivier Lamy\n * @version $Id$\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n    private String actualRepoLocation = null;\n\n\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, files, tag, new ScmTagParameters( message ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag,\n                                           ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualRepoLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        createLabel( repo, files, tag, consumer, false );\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n        if ( consumer.isSuccess() )\n        {\n            // Now update the label if we need to lock it\n            if ( shouldLock() )\n            {\n                consumer = new PerforceTagConsumer();\n                createLabel( repo, files, tag, consumer, true );\n            }\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n\n        // Unclear what to pass as the first arg\n        return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n    }\n\n    private boolean shouldLock()\n    {\n        return Boolean.valueOf( System.getProperty( \"maven.scm.locktag\", \"true\" ) ).booleanValue();\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl =\n            createLabelsyncCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer,\n                              boolean lock )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        DataOutputStream dos = null;\n        InputStreamReader isReader = null;\n        InputStreamReader isReaderErr = null;\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            Process proc = cl.execute();\n            OutputStream out = proc.getOutputStream();\n            dos = new DataOutputStream( out );\n            String label = createLabelSpecification( (PerforceScmProviderRepository) repo, tag, lock );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"LabelSpec: \" + NEWLINE + label );\n            }\n            dos.write( label.getBytes() );\n            dos.close();\n            out.close();\n            // TODO find & use a less naive InputStream multiplexer\n            isReader = new InputStreamReader( proc.getInputStream() );\n            isReaderErr = new InputStreamReader( proc.getErrorStream() );\n            BufferedReader stdout = new BufferedReader( isReader );\n            BufferedReader stderr = new BufferedReader( isReaderErr );\n            String line;\n            while ( ( line = stdout.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stdout: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            while ( ( line = stderr.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stderr: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            stderr.close();\n            stdout.close();\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"IOException \" + e.getMessage(), e );\n            }\n        }\n        finally\n        {\n            IOUtil.close( dos );\n            IOUtil.close( isReader );\n            IOUtil.close( isReaderErr );\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"label\" );\n        command.createArg().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                          ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"labelsync\" );\n        command.createArg().setValue( \"-l\" );\n        command.createArg().setValue( tag );\n\n        List<File> fs = files.getFileList();\n        for ( File file : fs )\n        {\n            command.createArg().setValue( file.getPath() );\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label\n     * View: //depot/path/to/repos/...\n     * Owner: mperham\n     */\n    public String createLabelSpecification( PerforceScmProviderRepository repo, String tag, boolean lock )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( PerforceScmProvider.getCanonicalRepoPath( actualRepoLocation ) ).append(\n            NEWLINE );\n        String username = repo.getUser();\n        if ( username == null )\n        {\n            // I have no idea why but Perforce doesn't default the owner to the current user.\n            // Since the user is not explicitly set, we use 'p4 info' to query for the current user.\n            username = PerforceInfoCommand.getInfo( getLogger(), repo ).getEntry( \"User name\" );\n        }\n        buf.append( \"Owner: \" ).append( username ).append( NEWLINE );\n        buf.append( \"Options: \" ).append( lock ? \"\" : \"un\" ).append( \"locked\" ).append( NEWLINE );\n        return buf.toString();\n    }\n}\n","lineNo":143}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.util.List;\n\n/**\n * @author Mike Perham\n * @author Olivier Lamy\n * @version $Id$\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n    private String actualRepoLocation = null;\n\n    \n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, files, tag, new ScmTagParameters( message ) );\n    }\n    \n    /** {@inheritDoc} */\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag,\n                                           ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualRepoLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        createLabel( repo, files, tag, consumer, false );\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n        if ( consumer.isSuccess() )\n        {\n            // Now update the label if we need to lock it\n            if ( shouldLock() )\n            {\n                consumer = new PerforceTagConsumer();\n                createLabel( repo, files, tag, consumer, true );\n            }\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n\n        // Unclear what to pass as the first arg\n        return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n    }\n\n    private boolean shouldLock()\n    {\n        return Boolean.valueOf( System.getProperty( \"maven.scm.locktag\", \"true\" ) ).booleanValue();\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl =\n            createLabelsyncCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer,\n                              boolean lock )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            Process proc = cl.execute();\n            OutputStream out = proc.getOutputStream();\n            DataOutputStream dos = new DataOutputStream( out );\n            String label = createLabelSpecification( (PerforceScmProviderRepository) repo, tag, lock );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"LabelSpec: \" + NEWLINE + label );\n            }\n            dos.write( label.getBytes() );\n            dos.close();\n            out.close();\n            // TODO find & use a less naive InputStream multiplexer\n            BufferedReader stdout = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            BufferedReader stderr = new BufferedReader( new InputStreamReader( proc.getErrorStream() ) );\n            String line;\n            while ( ( line = stdout.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stdout: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            while ( ( line = stderr.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stderr: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            stderr.close();\n            stdout.close();\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"IOException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"label\" );\n        command.createArg().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                          ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"labelsync\" );\n        command.createArg().setValue( \"-l\" );\n        command.createArg().setValue( tag );\n\n        List<File> fs = files.getFileList();\n        for ( File file : fs )\n        {\n            command.createArg().setValue( file.getPath() );\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label\n     * View: //depot/path/to/repos/...\n     * Owner: mperham\n     */\n    public String createLabelSpecification( PerforceScmProviderRepository repo, String tag, boolean lock )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( PerforceScmProvider.getCanonicalRepoPath( actualRepoLocation ) ).append(\n            NEWLINE );\n        String username = repo.getUser();\n        if ( username == null )\n        {\n            // I have no idea why but Perforce doesn't default the owner to the current user.\n            // Since the user is not explicitly set, we use 'p4 info' to query for the current user.\n            username = PerforceInfoCommand.getInfo( getLogger(), repo ).getEntry( \"User name\" );\n        }\n        buf.append( \"Owner: \" ).append( username ).append( NEWLINE );\n        buf.append( \"Options: \" ).append( lock ? \"\" : \"un\" ).append( \"locked\" ).append( NEWLINE );\n        return buf.toString();\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.util.List;\n\n/**\n * @author Mike Perham\n * @author Olivier Lamy\n * @version $Id$\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n    private String actualRepoLocation = null;\n\n\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag, String message )\n        throws ScmException\n    {\n        return executeTagCommand( repo, files, tag, new ScmTagParameters( message ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag,\n                                           ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        actualRepoLocation = PerforceScmProvider.getRepoPath( getLogger(), prepo, files.getBasedir() );\n\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        createLabel( repo, files, tag, consumer, false );\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n        if ( consumer.isSuccess() )\n        {\n            // Now update the label if we need to lock it\n            if ( shouldLock() )\n            {\n                consumer = new PerforceTagConsumer();\n                createLabel( repo, files, tag, consumer, true );\n            }\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n\n        // Unclear what to pass as the first arg\n        return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n    }\n\n    private boolean shouldLock()\n    {\n        return Boolean.valueOf( System.getProperty( \"maven.scm.locktag\", \"true\" ) ).booleanValue();\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl =\n            createLabelsyncCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer,\n                              boolean lock )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        DataOutputStream dos = null;\n        InputStreamReader isReader = null;\n        InputStreamReader isReaderErr = null;\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing: \" + cl.toString() ) );\n            }\n            Process proc = cl.execute();\n            OutputStream out = proc.getOutputStream();\n            dos = new DataOutputStream( out );\n            String label = createLabelSpecification( (PerforceScmProviderRepository) repo, tag, lock );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"LabelSpec: \" + NEWLINE + label );\n            }\n            dos.write( label.getBytes() );\n            dos.close();\n            out.close();\n            // TODO find & use a less naive InputStream multiplexer\n            isReader = new InputStreamReader( proc.getInputStream() );\n            isReaderErr = new InputStreamReader( proc.getErrorStream() );\n            BufferedReader stdout = new BufferedReader( isReader );\n            BufferedReader stderr = new BufferedReader( isReaderErr );\n            String line;\n            while ( ( line = stdout.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stdout: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            while ( ( line = stderr.readLine() ) != null )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Consuming stderr: \" + line );\n                }\n                consumer.consumeLine( line );\n            }\n            stderr.close();\n            stdout.close();\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"IOException \" + e.getMessage(), e );\n            }\n        }\n        finally\n        {\n            IOUtil.close( dos );\n            IOUtil.close( isReader );\n            IOUtil.close( isReaderErr );\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"label\" );\n        command.createArg().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                          ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArg().setValue( \"labelsync\" );\n        command.createArg().setValue( \"-l\" );\n        command.createArg().setValue( tag );\n\n        List<File> fs = files.getFileList();\n        for ( File file : fs )\n        {\n            command.createArg().setValue( file.getPath() );\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label\n     * View: //depot/path/to/repos/...\n     * Owner: mperham\n     */\n    public String createLabelSpecification( PerforceScmProviderRepository repo, String tag, boolean lock )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( PerforceScmProvider.getCanonicalRepoPath( actualRepoLocation ) ).append(\n            NEWLINE );\n        String username = repo.getUser();\n        if ( username == null )\n        {\n            // I have no idea why but Perforce doesn't default the owner to the current user.\n            // Since the user is not explicitly set, we use 'p4 info' to query for the current user.\n            username = PerforceInfoCommand.getInfo( getLogger(), repo ).getEntry( \"User name\" );\n        }\n        buf.append( \"Owner: \" ).append( username ).append( NEWLINE );\n        buf.append( \"Options: \" ).append( lock ? \"\" : \"un\" ).append( \"locked\" ).append( NEWLINE );\n        return buf.toString();\n    }\n}\n","lineNo":144}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.io.File;\nimport java.util.List;\n\n/**\n * Command line construction utility.\n *\n * @author Brett Porter\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @version $Id$\n */\npublic final class GitCommandLineUtils\n{\n\n    private GitCommandLineUtils()\n    {\n    }\n\n    public static void addTarget( Commandline cl, List<File> files )\n    {\n        if ( files == null || files.isEmpty() )\n        {\n            return;\n        }\n\n        for ( File f : files )\n        {\n            String relativeFile = f.getPath();\n\n            if ( f.getAbsolutePath().startsWith( cl.getWorkingDirectory().getAbsolutePath() ) )\n            {\n                // so we can omit the starting characters\n                relativeFile = f.getAbsolutePath().substring( cl.getWorkingDirectory().getAbsolutePath().length() );\n\n                if ( relativeFile.startsWith( File.separator ) )\n                {\n                    relativeFile = relativeFile.substring( File.separator.length() );\n                }\n            }\n\n            // no setFile() since this screws up the working directory!\n            cl.createArg().setValue( relativeFile );\n        }\n\n    }\n\n    public static Commandline getBaseGitCommandLine( File workingDirectory, String command )\n    {\n        if ( command == null || command.length() == 0 )\n        {\n            return null;\n        }\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"git\" );\n\n        cl.createArg().setValue( command );\n\n        if ( workingDirectory != null )\n        {\n        \tcl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n        }\n\n        return cl;\n    }\n\n    public static int execute( Commandline cl, StreamConsumer consumer, CommandLineUtils.StringStreamConsumer stderr,\n                               ScmLogger logger )\n        throws ScmException\n    {\n        if ( logger.isInfoEnabled() )\n        {\n            logger.info( \"Executing: \" + cl );\n            logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        return exitCode;\n    }\n\n    public static int execute( Commandline cl, CommandLineUtils.StringStreamConsumer stdout,\n                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n    throws ScmException\n    {\n        if ( logger.isInfoEnabled() )\n        {\n            logger.info( \"Executing: \" + cl );\n            logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        return exitCode;\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Command line construction utility.\n * \n * @author Brett Porter\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @version $Id$\n */\npublic final class GitCommandLineUtils\n{\n\n    private GitCommandLineUtils()\n    {\n    }\n\n    public static void addTarget( Commandline cl, List<File> files )\n    {\n        if ( files == null || files.isEmpty() )\n        {\n            return;\n        }\n        final File workingDirectory = cl.getWorkingDirectory();\n        try\n        {\n            final String canonicalWorkingDirectory = workingDirectory.getCanonicalPath();\n            for ( File file : files )\n            {\n                String relativeFile = file.getPath();\n                \n                final String canonicalFile = file.getCanonicalPath();\n                if ( canonicalFile.startsWith( canonicalWorkingDirectory ) )\n                {\n                    // so we can omit the starting characters\n                    relativeFile = canonicalFile.substring( canonicalWorkingDirectory.length() );\n\n                    if ( relativeFile.startsWith( File.separator ) )\n                    {\n                        relativeFile = relativeFile.substring( File.separator.length() );\n                    }\n                }\n\n                // no setFile() since this screws up the working directory!\n                cl.createArg().setValue( relativeFile );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new IllegalArgumentException( \"Could not get canonical paths for workingDirectory = \"\n                + workingDirectory + \" or files=\" + files, ex );\n        }\n    }\n\n    public static Commandline getBaseGitCommandLine( File workingDirectory, String command )\n    {\n        if ( command == null || command.length() == 0 )\n        {\n            return null;\n        }\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"git\" );\n\n        cl.createArg().setValue( command );\n\n        if ( workingDirectory != null )\n        {\n            cl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n        }\n\n        return cl;\n    }\n\n    public static int execute( Commandline cl, StreamConsumer consumer, CommandLineUtils.StringStreamConsumer stderr,\n                               ScmLogger logger )\n        throws ScmException\n    {\n        if ( logger.isInfoEnabled() )\n        {\n            logger.info( \"Executing: \" + cl );\n            logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        return exitCode;\n    }\n\n    public static int execute( Commandline cl, CommandLineUtils.StringStreamConsumer stdout,\n                               CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws ScmException\n    {\n        if ( logger.isInfoEnabled() )\n        {\n            logger.info( \"Executing: \" + cl );\n            logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, stdout, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        return exitCode;\n    }\n\n}\n","lineNo":53}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.util.AbstractConsumer;\nimport org.apache.regexp.RE;\nimport org.apache.regexp.RESyntaxException;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Olivier Lamy\n * @version $Id$\n */\npublic class GitChangeLogConsumer\n    extends AbstractConsumer\n{\n    /**\n     * Date formatter for git timestamp\n     * we use iso format cli git log --date=iso sample : 2008-08-06 01:37:18 +0200\n     */\n    private static final String GIT_TIMESTAMP_PATTERN = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /**\n     * State machine constant: expecting header\n     */\n    private static final int STATUS_GET_HEADER = 1;\n\n    /**\n     * State machine constant: expecting author information\n     */\n    private static final int STATUS_GET_AUTHOR = 2;\n\n    /**\n     * State machine constant: expecting date information\n     */\n    private static final int STATUS_GET_DATE = 3;\n\n    /**\n     * State machine constant: expecting file information\n     */\n    private static final int STATUS_GET_FILE = 4;\n\n    /**\n     * State machine constant: expecting comments\n     */\n    private static final int STATUS_GET_COMMENT = 5;\n\n    /**\n     * The pattern used to match git header lines\n     */\n    private static final String HEADER_PATTERN = \"^commit (.*)\";\n\n    /**\n     * The pattern used to match git author lines\n     */\n    private static final String AUTHOR_PATTERN = \"^Author: (.*)\";\n\n    /**\n     * The pattern used to match git date lines\n     */\n    private static final String DATE_PATTERN = \"^Date:\\\\s*(.*)\";\n\n    /**\n     * The pattern used to match git file lines\n     */\n    private static final String FILE_PATTERN = \"^:\\\\d* \\\\d* [:xdigit:]*\\\\.* [:xdigit:]*\\\\.* ([:upper:])\\\\t(.*)\";\n\n    /**\n     * Current status of the parser\n     */\n    private int status = STATUS_GET_HEADER;\n\n    /**\n     * List of change log entries\n     */\n    private List<ChangeSet> entries = new ArrayList<ChangeSet>();\n\n    /**\n     * The current log entry being processed by the parser\n     */\n    private ChangeSet currentChange;\n\n    /**\n     * The current revision of the entry being processed by the parser\n     */\n    private String currentRevision;\n\n    /**\n     * The current comment of the entry being processed by the parser\n     */\n    private StringBuffer currentComment;\n\n    /**\n     * The regular expression used to match header lines\n     */\n    private RE headerRegexp;\n\n    /**\n     * The regular expression used to match author lines\n     */\n    private RE authorRegexp;\n\n    /**\n     * The regular expression used to match date lines\n     */\n    private RE dateRegexp;\n\n    /**\n     * The regular expression used to match file lines\n     */\n    private RE fileRegexp;\n\n    private String userDateFormat;\n\n    /**\n     * Default constructor.\n     */\n    public GitChangeLogConsumer( ScmLogger logger, String userDateFormat )\n    {\n        super( logger );\n\n        this.userDateFormat = userDateFormat;\n\n        try\n        {\n            headerRegexp = new RE( HEADER_PATTERN );\n            authorRegexp = new RE( AUTHOR_PATTERN );\n            dateRegexp = new RE( DATE_PATTERN );\n            fileRegexp = new RE( FILE_PATTERN );\n        }\n        catch ( RESyntaxException ex )\n        {\n            throw new RuntimeException(\n                                        \"INTERNAL ERROR: Could not create regexp to parse git log file. This shouldn't happen. Something is probably wrong with the oro installation.\",\n                                        ex );\n        }\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        // this is needed since the processFile does not always get a the end-sequence correctly.\n        processGetFile( \"\" );\n\n        return entries;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void consumeLine( String line )\n    {\n        switch ( status )\n        {\n            case STATUS_GET_HEADER:\n                processGetHeader( line );\n                break;\n            case STATUS_GET_AUTHOR:\n                processGetAuthor( line );\n                break;\n            case STATUS_GET_DATE:\n                processGetDate( line, null );\n                break;\n            case STATUS_GET_COMMENT:\n                processGetComment( line );\n                break;\n            case STATUS_GET_FILE:\n                processGetFile( line );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown state: \" + status );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Process the current input line in the GET_HEADER state.  The\n     * author, date, and the revision of the entry are gathered.  Note,\n     * Git does not have per-file revisions, instead, the entire\n     * branch is given a single revision number, which is also used for\n     * the revision number of each file.\n     *\n     * @param line A line of text from the git log output\n     */\n    private void processGetHeader( String line )\n    {\n        if ( !headerRegexp.match( line ) )\n        {\n            return;\n        }\n\n        currentRevision = headerRegexp.getParen( 1 );\n\n        currentChange = new ChangeSet();\n\n        currentChange.setRevision( currentRevision );\n\n        status = STATUS_GET_AUTHOR;\n    }\n\n    /**\n     * Process the current input line in the STATUS_GET_AUTHOR state.  This\n     * state gathers all of the author information that are part of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetAuthor( String line )\n    {\n        if ( !authorRegexp.match( line ) )\n        {\n            return;\n        }\n        String author = authorRegexp.getParen( 1 );\n\n        currentChange.setAuthor( author );\n\n        status = STATUS_GET_DATE;\n    }\n\n    /**\n     * Process the current input line in the STATUS_GET_DATE state.  This\n     * state gathers all of the date information that are part of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetDate( String line, Locale locale )\n    {\n        if ( !dateRegexp.match( line ) )\n        {\n            return;\n        }\n\n        String datestring = dateRegexp.getParen( 1 );\n\n        Date date = parseDate( datestring.trim(), userDateFormat, GIT_TIMESTAMP_PATTERN, locale );\n\n        currentChange.setDate( date );\n\n        status = STATUS_GET_COMMENT;\n    }\n\n    /**\n     * Process the current input line in the GET_COMMENT state.  This\n     * state gathers all of the comments that are part of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetComment( String line )\n    {\n        if ( line.length() < 4 )\n        {\n            if ( currentComment == null )\n            {\n                currentComment = new StringBuffer();\n            }\n            else\n            {\n                currentChange.setComment( currentComment.toString() );\n                status = STATUS_GET_FILE;\n            }\n        }\n        else\n        {\n            if ( currentComment.length() > 0 )\n            {\n                currentComment.append( '\\n' );\n            }\n\n            currentComment.append( line.substring( 4 ) );\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_FILE state.  This state\n     * adds each file entry line to the current change log entry.  Note,\n     * the revision number for the entire entry is used for the revision\n     * number of each file.\n     *\n     * @param line A line of text from the git log output\n     */\n    private void processGetFile( String line )\n    {\n        if ( line.length() == 0 )\n        {\n            if ( currentChange != null )\n            {\n                entries.add( currentChange );\n            }\n\n            resetChangeLog();\n\n            status = STATUS_GET_HEADER;\n        }\n        else\n        {\n            if ( !fileRegexp.match( line ) )\n            {\n                return;\n            }\n            // String action = fileRegexp.getParen( 1 );\n            // action is currently not used\n\n            String name = fileRegexp.getParen( 2 );\n\n            currentChange.addFile( new ChangeFile( name, currentRevision ) );\n        }\n    }\n\n    private void resetChangeLog()\n    {\n        currentComment = null;\n        currentChange = null;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.util.AbstractConsumer;\nimport org.apache.regexp.RE;\nimport org.apache.regexp.RESyntaxException;\n\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:struberg@yahoo.de\">Mark Struberg<\/a>\n * @author Olivier Lamy\n * @version $Id$\n */\npublic class GitChangeLogConsumer\n    extends AbstractConsumer\n{\n    /**\n     * Date formatter for git timestamp\n     * we use iso format cli git log --date=iso sample : 2008-08-06 01:37:18 +0200\n     */\n    private static final String GIT_TIMESTAMP_PATTERN = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    /**\n     * State machine constant: expecting header\n     */\n    private static final int STATUS_GET_HEADER = 1;\n\n    /**\n     * State machine constant: expecting author information\n     */\n    private static final int STATUS_GET_AUTHOR = 2;\n\n    /**\n     * State machine constant: expecting parent hash information\n     */\n    private static final int STATUS_RAW_TREE = 21;\n\n    /**\n     * State machine constant: expecting parent hash information\n     */\n    private static final int STATUS_RAW_PARENT = 22;\n\n    /**\n     * State machine constant: expecting author name, email and timestamp information\n     */\n    private static final int STATUS_RAW_AUTHOR = 23;\n\n    /**\n     * State machine constant: expecting committer name, email and timestamp information\n     */\n    private static final int STATUS_RAW_COMMITTER = 24;\n\n    /**\n     * State machine constant: expecting date information\n     */\n    private static final int STATUS_GET_DATE = 3;\n\n    /**\n     * State machine constant: expecting file information\n     */\n    private static final int STATUS_GET_FILE = 4;\n\n    /**\n     * State machine constant: expecting comments\n     */\n    private static final int STATUS_GET_COMMENT = 5;\n\n    /**\n     * The pattern used to match git header lines\n     */\n    private static final String HEADER_PATTERN = \"^commit (.*)\";\n\n    /**\n     * The pattern used to match git author lines\n     */\n    private static final String AUTHOR_PATTERN = \"^Author: (.*)\";\n\n    /**\n     * The pattern used to match git tree hash lines (raw mode)\n     */\n    private static final String RAW_TREE_PATTERN = \"^tree ([:xdigit:]+)\";\n\n    /**\n     * The pattern used to match git parent hash lines (raw mode)\n     */\n    private static final String RAW_PARENT_PATTERN = \"^parent ([:xdigit:]+)\";\n\n    /**\n     * The pattern used to match git author lines (raw mode)\n     */\n    private static final String RAW_AUTHOR_PATTERN = \"^author (.+ <.+>) ([:digit:]+) (.*)\";\n\n    /**\n     * The pattern used to match git author lines (raw mode)\n     */\n    private static final String RAW_COMMITTER_PATTERN = \"^committer (.+ <.+>) ([:digit:]+) (.*)\";\n\n    /**\n     * The pattern used to match git date lines\n     */\n    private static final String DATE_PATTERN = \"^Date:\\\\s*(.*)\";\n\n    /**\n     * The pattern used to match git file lines\n     */\n    private static final String FILE_PATTERN =\n        \"^:\\\\d* \\\\d* [:xdigit:]*\\\\.* [:xdigit:]*\\\\.* ([:upper:])[:digit:]*\\\\t([^\\\\t]*)(\\\\t(.*))?\";\n\n    /**\n     * Current status of the parser\n     */\n    private int status = STATUS_GET_HEADER;\n\n    /**\n     * List of change log entries\n     */\n    private List<ChangeSet> entries = new ArrayList<ChangeSet>();\n\n    /**\n     * The current log entry being processed by the parser\n     */\n    private ChangeSet currentChange;\n\n    /**\n     * The current revision of the entry being processed by the parser\n     */\n    private String currentRevision;\n\n    /**\n     * The current comment of the entry being processed by the parser\n     */\n    private StringBuffer currentComment;\n\n    /**\n     * The regular expression used to match header lines\n     */\n    private RE headerRegexp;\n\n    /**\n     * The regular expression used to match author lines\n     */\n    private RE authorRegexp;\n\n    /**\n     * The regular expression used to match tree hash lines in raw mode\n     */\n    private RE rawTreeRegexp;\n\n    /**\n     * The regular expression used to match parent hash lines in raw mode\n     */\n    private RE rawParentRegexp;\n\n    /**\n     * The regular expression used to match author lines in raw mode\n     */\n    private RE rawAuthorRegexp;\n\n    /**\n     * The regular expression used to match committer lines in raw mode\n     */\n    private RE rawCommitterRegexp;\n\n    /**\n     * The regular expression used to match date lines\n     */\n    private RE dateRegexp;\n\n    /**\n     * The regular expression used to match file lines\n     */\n    private RE fileRegexp;\n\n    private String userDateFormat;\n\n    /**\n     * Default constructor.\n     */\n    public GitChangeLogConsumer( ScmLogger logger, String userDateFormat )\n    {\n        super( logger );\n\n        this.userDateFormat = userDateFormat;\n\n        try\n        {\n            headerRegexp = new RE( HEADER_PATTERN );\n            authorRegexp = new RE( AUTHOR_PATTERN );\n            dateRegexp = new RE( DATE_PATTERN );\n            fileRegexp = new RE( FILE_PATTERN );\n            rawTreeRegexp = new RE( RAW_TREE_PATTERN );\n            rawParentRegexp = new RE( RAW_PARENT_PATTERN );\n            rawAuthorRegexp = new RE( RAW_AUTHOR_PATTERN );\n            rawCommitterRegexp = new RE( RAW_COMMITTER_PATTERN );\n        }\n        catch ( RESyntaxException ex )\n        {\n            throw new RuntimeException(\n                \"INTERNAL ERROR: Could not create regexp to parse git log file. This shouldn't happen. Something is probably wrong with the oro installation.\",\n                ex );\n        }\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        // this is needed since the processFile does not always get a the end-sequence correctly.\n        processGetFile( \"\" );\n\n        return entries;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        switch ( status )\n        {\n            case STATUS_GET_HEADER:\n                processGetHeader( line );\n                break;\n            case STATUS_GET_AUTHOR:\n                processGetAuthor( line );\n                break;\n            case STATUS_GET_DATE:\n                processGetDate( line, null );\n                break;\n            case STATUS_GET_COMMENT:\n                processGetComment( line );\n                break;\n            case STATUS_GET_FILE:\n                processGetFile( line );\n                break;\n            case STATUS_RAW_TREE:\n                processGetRawTree( line );\n                break;\n            case STATUS_RAW_PARENT:\n                processGetRawParent( line );\n                break;\n            case STATUS_RAW_AUTHOR:\n                processGetRawAuthor( line );\n                break;\n            case STATUS_RAW_COMMITTER:\n                processGetRawCommitter( line );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown state: \" + status );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Process the current input line in the GET_HEADER state.  The\n     * author, date, and the revision of the entry are gathered.  Note,\n     * Git does not have per-file revisions, instead, the entire\n     * branch is given a single revision number, which is also used for\n     * the revision number of each file.\n     *\n     * @param line A line of text from the git log output\n     */\n    private void processGetHeader( String line )\n    {\n        if ( !headerRegexp.match( line ) )\n        {\n            return;\n        }\n\n        currentRevision = headerRegexp.getParen( 1 );\n\n        currentChange = new ChangeSet();\n\n        currentChange.setRevision( currentRevision );\n\n        status = STATUS_GET_AUTHOR;\n    }\n\n    /**\n     * Process the current input line in the STATUS_GET_AUTHOR state.  This\n     * state gathers all of the author information that are part of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetAuthor( String line )\n    {\n        // this autodetects 'raw' format\n        if ( rawTreeRegexp.match( line ) )\n        {\n            status = STATUS_RAW_TREE;\n            processGetRawTree( line );\n            return;\n        }\n\n        if ( !authorRegexp.match( line ) )\n        {\n            return;\n        }\n        String author = authorRegexp.getParen( 1 );\n\n        currentChange.setAuthor( author );\n\n        status = STATUS_GET_DATE;\n    }\n\n    /**\n     * Process the current input line in the STATUS_RAW_TREE state.  This\n     * state gathers tree hash part of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetRawTree( String line )\n    {\n        if ( !rawTreeRegexp.match( line ) )\n        {\n            return;\n        }\n        //here we could set treeHash if it appears in the model: currentChange.setTreeHash( rawTreeRegexp.getParen( 1 ) );\n        status = STATUS_RAW_PARENT;\n    }\n\n    /**\n     * Process the current input line in the STATUS_RAW_PARENT state.  This\n     * state gathers parent revisions of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetRawParent( String line )\n    {\n        if ( !rawParentRegexp.match( line ) )\n        {\n            status = STATUS_RAW_AUTHOR;\n            processGetRawAuthor( line );\n            return;\n        }\n        String parentHash = rawParentRegexp.getParen( 1 );\n\n        addParentRevision( parentHash );\n    }\n\n    /**\n     * In git log, both parent and merged revisions are called parent. Fortunately, the real parent comes first in the log.\n     * This method takes care of the difference.\n     *\n     * @param hash -\n     */\n    private void addParentRevision( String hash )\n    {\n        if ( currentChange.getParentRevision() == null )\n        {\n            currentChange.setParentRevision( hash );\n        }\n        else\n        {\n            currentChange.addMergedRevision( hash );\n        }\n    }\n\n    /**\n     * Process the current input line in the STATUS_RAW_AUTHOR state.  This\n     * state gathers all the author information of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetRawAuthor( String line )\n    {\n        if ( !rawAuthorRegexp.match( line ) )\n        {\n            return;\n        }\n        String author = rawAuthorRegexp.getParen( 1 );\n        currentChange.setAuthor( author );\n\n        String datestring = rawAuthorRegexp.getParen( 2 );\n        String tz = rawAuthorRegexp.getParen( 3 );\n\n        // with --format=raw option (which gets us to this methods), date is always in seconds since beginning of time\n        // even explicit --date=iso is ignored, so we ignore both userDateFormat and GIT_TIMESTAMP_PATTERN here\n        Calendar c = Calendar.getInstance( TimeZone.getTimeZone( tz ) );\n        c.setTimeInMillis( Long.parseLong( datestring ) * 1000 );\n        currentChange.setDate( c.getTime() );\n\n        status = STATUS_RAW_COMMITTER;\n    }\n\n    /**\n     * Process the current input line in the STATUS_RAW_AUTHOR state.  This\n     * state gathers all the committer information of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetRawCommitter( String line )\n    {\n        if ( !rawCommitterRegexp.match( line ) )\n        {\n            return;\n        }\n        // here we could set committer and committerDate, the same way as in processGetRawAuthor\n        status = STATUS_GET_COMMENT;\n    }\n\n    /**\n     * Process the current input line in the STATUS_GET_DATE state.  This\n     * state gathers all of the date information that are part of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetDate( String line, Locale locale )\n    {\n        if ( !dateRegexp.match( line ) )\n        {\n            return;\n        }\n\n        String datestring = dateRegexp.getParen( 1 );\n\n        Date date = parseDate( datestring.trim(), userDateFormat, GIT_TIMESTAMP_PATTERN, locale );\n\n        currentChange.setDate( date );\n\n        status = STATUS_GET_COMMENT;\n    }\n\n    /**\n     * Process the current input line in the GET_COMMENT state.  This\n     * state gathers all of the comments that are part of a log entry.\n     *\n     * @param line a line of text from the git log output\n     */\n    private void processGetComment( String line )\n    {\n        if ( line.length() < 4 )\n        {\n            if ( currentComment == null )\n            {\n                currentComment = new StringBuffer();\n            }\n            else\n            {\n                currentChange.setComment( currentComment.toString() );\n                status = STATUS_GET_FILE;\n            }\n        }\n        else\n        {\n            if ( currentComment.length() > 0 )\n            {\n                currentComment.append( '\\n' );\n            }\n\n            currentComment.append( line.substring( 4 ) );\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_FILE state.  This state\n     * adds each file entry line to the current change log entry.  Note,\n     * the revision number for the entire entry is used for the revision\n     * number of each file.\n     *\n     * @param line A line of text from the git log output\n     */\n    private void processGetFile( String line )\n    {\n        if ( line.length() == 0 )\n        {\n            if ( currentChange != null )\n            {\n                entries.add( currentChange );\n            }\n\n            resetChangeLog();\n\n            status = STATUS_GET_HEADER;\n        }\n        else\n        {\n            if ( !fileRegexp.match( line ) )\n            {\n                return;\n            }\n            final String actionChar = fileRegexp.getParen( 1 );\n            // action is currently not used\n            final ScmFileStatus action;\n            String name = fileRegexp.getParen( 2 );\n            String originalName = null;\n            String originalRevision = null;\n            if ( \"A\".equals( actionChar ) )\n            {\n                action = ScmFileStatus.ADDED;\n            }\n            else if ( \"M\".equals( actionChar ) )\n            {\n                action = ScmFileStatus.MODIFIED;\n            }\n            else if ( \"D\".equals( actionChar ) )\n            {\n                action = ScmFileStatus.DELETED;\n            }\n            else if ( \"R\".equals( actionChar ) )\n            {\n                action = ScmFileStatus.RENAMED;\n                originalName = name;\n                name = fileRegexp.getParen( 4 );\n                originalRevision = currentChange.getParentRevision();\n            }\n            else if ( \"C\".equals( actionChar ) )\n            {\n                action = ScmFileStatus.COPIED;\n                originalName = name;\n                name = fileRegexp.getParen( 4 );\n                originalRevision = currentChange.getParentRevision();\n            }\n            else\n            {\n                action = ScmFileStatus.UNKNOWN;\n            }\n\n            final ChangeFile changeFile = new ChangeFile( name, currentRevision );\n            changeFile.setAction( action );\n            changeFile.setOriginalName( originalName );\n            changeFile.setOriginalRevision( originalRevision );\n            currentChange.addFile( changeFile );\n        }\n    }\n\n    private void resetChangeLog()\n    {\n        currentComment = null;\n        currentChange = null;\n    }\n}\n","lineNo":552}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.SvnChangeSet;\nimport org.apache.maven.scm.util.AbstractConsumer;\nimport org.apache.regexp.RE;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnChangeLogConsumer\n    extends AbstractConsumer\n{\n    /**\n     * Date formatter for svn timestamp (after a little massaging)\n     */\n    private static final String SVN_TIMESTAMP_PATTERN = \"yyyy-MM-dd HH:mm:ss zzzzzzzzz\";\n\n    /**\n     * State machine constant: expecting header\n     */\n    private static final int GET_HEADER = 1;\n\n    /**\n     * State machine constant: expecting file information\n     */\n    private static final int GET_FILE = 2;\n\n    /**\n     * State machine constant: expecting comments\n     */\n    private static final int GET_COMMENT = 3;\n\n    /**\n     * There is always action and affected path; when copying/moving, recognize also original path and revision\n     */\n    private static final RE FILE_PATTERN = new RE( \"^\\\\s\\\\s\\\\s([:upper:])\\\\s(.+)$\" );\n\n    /**\n     * This matches the 'original file info' part of the complete file line.\n     * Note the use of [:alpha:] instead of literal 'from' - this is meant to allow non-English localizations.\n     */\n    private static final RE ORIG_FILE_PATTERN = new RE( \"\\\\([:alpha:]+ (.+):(\\\\d+)\\\\)\" );\n\n    /**\n     * The file section ends with a blank line\n     */\n    private static final String FILE_END_TOKEN = \"\";\n\n    /**\n     * The comment section ends with a dashed line\n     */\n    private static final String COMMENT_END_TOKEN =\n        \"------------------------------------\" + \"------------------------------------\";\n\n    /**\n     * Current status of the parser\n     */\n    private int status = GET_HEADER;\n\n    /**\n     * List of change log entries\n     */\n    private List<ChangeSet> entries = new ArrayList<ChangeSet>();\n\n    /**\n     * The current log entry being processed by the parser\n     */\n    private SvnChangeSet currentChange;\n\n    /**\n     * The current revision of the entry being processed by the parser\n     */\n    private String currentRevision;\n\n    /**\n     * The current comment of the entry being processed by the parser\n     */\n    private StringBuffer currentComment;\n\n    /**\n     * The regular expression used to match header lines\n     */\n    private static final RE HEADER_REG_EXP = new RE( \"^(.+) \\\\| (.+) \\\\| (.+) \\\\|.*$\" );\n\n    private static final int REVISION_GROUP = 1;\n\n    private static final int AUTHOR_GROUP = 2;\n\n    private static final int DATE_GROUP = 3;\n\n    private static final RE REVISION_REG_EXP1 = new RE( \"rev (\\\\d+):\" );\n\n    private static final RE REVISION_REG_EXP2 = new RE( \"r(\\\\d+)\" );\n\n    private static final RE DATE_REG_EXP = new RE( \"(\\\\d+-\\\\d+-\\\\d+ \" +             // date 2002-08-24\n                                                       \"\\\\d+:\\\\d+:\\\\d+) \" +             // time 16:01:00\n                                                       \"([\\\\-+])(\\\\d\\\\d)(\\\\d\\\\d)\" );     // gmt offset -0400);)\n\n    private final String userDateFormat;\n\n    /**\n     * Default constructor.\n     */\n    public SvnChangeLogConsumer( ScmLogger logger, String userDateFormat )\n    {\n        super( logger );\n\n        this.userDateFormat = userDateFormat;\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        return entries;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( line );\n        }\n        switch ( status )\n        {\n            case GET_HEADER:\n                processGetHeader( line );\n                break;\n            case GET_FILE:\n                processGetFile( line );\n                break;\n            case GET_COMMENT:\n                processGetComment( line );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown state: \" + status );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Process the current input line in the GET_HEADER state.  The\n     * author, date, and the revision of the entry are gathered.  Note,\n     * Subversion does not have per-file revisions, instead, the entire\n     * repository is given a single revision number, which is used for\n     * the revision number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetHeader( String line )\n    {\n        if ( !HEADER_REG_EXP.match( line ) )\n        {\n            // The header line is not found. Intentionally do nothing.\n            return;\n        }\n\n        currentRevision = getRevision( HEADER_REG_EXP.getParen( REVISION_GROUP ) );\n\n        currentChange = new SvnChangeSet();\n\n        currentChange.setAuthor( HEADER_REG_EXP.getParen( AUTHOR_GROUP ) );\n\n        currentChange.setDate( getDate( HEADER_REG_EXP.getParen( DATE_GROUP ) ) );\n\n        currentChange.setRevision( currentRevision );\n\n        status = GET_FILE;\n    }\n\n    /**\n     * Gets the svn revision, from the svn log revision output.\n     *\n     * @param revisionOutput\n     * @return the svn revision\n     */\n    private String getRevision( final String revisionOutput )\n    {\n        if ( REVISION_REG_EXP1.match( revisionOutput ) )\n        {\n            return REVISION_REG_EXP1.getParen( 1 );\n        }\n        else if ( REVISION_REG_EXP2.match( revisionOutput ) )\n        {\n            return REVISION_REG_EXP2.getParen( 1 );\n        }\n        else\n        {\n            throw new IllegalOutputException( revisionOutput );\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_FILE state.  This state\n     * adds each file entry line to the current change log entry.  Note,\n     * the revision number for the entire entry is used for the revision\n     * number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetFile( String line )\n    {\n        if ( FILE_PATTERN.match( line ) )\n        {\n            final String fileinfo = FILE_PATTERN.getParen( 2 );\n            String name = fileinfo;\n            final int n = fileinfo.indexOf( \" (\" );\n            if ( n > 1 && fileinfo.endsWith( \")\" ) )\n            {\n                final String origFileInfo = fileinfo.substring( n );\n                if ( ORIG_FILE_PATTERN.match( origFileInfo ) )\n                {\n                    // if original file is present, we must extract only the affected one at the beginning\n                    name = fileinfo.substring( 0, n );\n                }\n            }\n            currentChange.addFile( new ChangeFile( name, currentRevision ) );\n\n            status = GET_FILE;\n        }\n        else if ( line.equals( FILE_END_TOKEN ) )\n        {\n            // Create a buffer for the collection of the comment now\n            // that we are leaving the GET_FILE state.\n            currentComment = new StringBuffer();\n\n            status = GET_COMMENT;\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_COMMENT state.  This\n     * state gathers all of the comments that are part of a log entry.\n     *\n     * @param line a line of text from the svn log output\n     */\n    private void processGetComment( String line )\n    {\n        if ( line.equals( COMMENT_END_TOKEN ) )\n        {\n            currentChange.setComment( currentComment.toString() );\n\n            entries.add( currentChange );\n\n            status = GET_HEADER;\n        }\n        else\n        {\n            currentComment.append( line ).append( '\\n' );\n        }\n    }\n\n    /**\n     * Converts the date time stamp from the svn output into a date\n     * object.\n     *\n     * @param dateOutput The date output from an svn log command.\n     * @return A date representing the time stamp of the log entry.\n     */\n    private Date getDate( final String dateOutput )\n    {\n        if ( !DATE_REG_EXP.match( dateOutput ) )\n        {\n            throw new IllegalOutputException( dateOutput );\n        }\n\n        final StringBuffer date = new StringBuffer();\n        date.append( DATE_REG_EXP.getParen( 1 ) );\n        date.append( \" GMT\" );\n        date.append( DATE_REG_EXP.getParen( 2 ) );\n        date.append( DATE_REG_EXP.getParen( 3 ) );\n        date.append( ':' );\n        date.append( DATE_REG_EXP.getParen( 4 ) );\n\n        return parseDate( date.toString(), userDateFormat, SVN_TIMESTAMP_PATTERN );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.svn.SvnChangeSet;\nimport org.apache.maven.scm.util.AbstractConsumer;\nimport org.apache.regexp.RE;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnChangeLogConsumer\n    extends AbstractConsumer\n{\n    /**\n     * Date formatter for svn timestamp (after a little massaging)\n     */\n    private static final String SVN_TIMESTAMP_PATTERN = \"yyyy-MM-dd HH:mm:ss zzzzzzzzz\";\n\n    /**\n     * State machine constant: expecting header\n     */\n    private static final int GET_HEADER = 1;\n\n    /**\n     * State machine constant: expecting file information\n     */\n    private static final int GET_FILE = 2;\n\n    /**\n     * State machine constant: expecting comments\n     */\n    private static final int GET_COMMENT = 3;\n\n    /**\n     * There is always action and affected path; when copying/moving, recognize also original path and revision\n     */\n    private static final RE FILE_PATTERN = new RE( \"^\\\\s\\\\s\\\\s([:upper:])\\\\s(.+)$\" );\n\n    /**\n     * This matches the 'original file info' part of the complete file line.\n     * Note the use of [:alpha:] instead of literal 'from' - this is meant to allow non-English localizations.\n     */\n    private static final RE ORIG_FILE_PATTERN = new RE( \"\\\\([:alpha:]+ (.+):(\\\\d+)\\\\)\" );\n\n    /**\n     * The file section ends with a blank line\n     */\n    private static final String FILE_END_TOKEN = \"\";\n\n    /**\n     * The comment section ends with a dashed line\n     */\n    private static final String COMMENT_END_TOKEN =\n        \"------------------------------------\" + \"------------------------------------\";\n\n    /**\n     * Current status of the parser\n     */\n    private int status = GET_HEADER;\n\n    /**\n     * List of change log entries\n     */\n    private List<ChangeSet> entries = new ArrayList<ChangeSet>();\n\n    /**\n     * The current log entry being processed by the parser\n     */\n    private SvnChangeSet currentChange;\n\n    /**\n     * The current revision of the entry being processed by the parser\n     */\n    private String currentRevision;\n\n    /**\n     * The current comment of the entry being processed by the parser\n     */\n    private StringBuffer currentComment;\n\n    /**\n     * The regular expression used to match header lines\n     */\n    private static final RE HEADER_REG_EXP = new RE( \"^(.+) \\\\| (.+) \\\\| (.+) \\\\|.*$\" );\n\n    private static final int REVISION_GROUP = 1;\n\n    private static final int AUTHOR_GROUP = 2;\n\n    private static final int DATE_GROUP = 3;\n\n    private static final RE REVISION_REG_EXP1 = new RE( \"rev (\\\\d+):\" );\n\n    private static final RE REVISION_REG_EXP2 = new RE( \"r(\\\\d+)\" );\n\n    private static final RE DATE_REG_EXP = new RE( \"(\\\\d+-\\\\d+-\\\\d+ \" +             // date 2002-08-24\n                                                       \"\\\\d+:\\\\d+:\\\\d+) \" +             // time 16:01:00\n                                                       \"([\\\\-+])(\\\\d\\\\d)(\\\\d\\\\d)\" );     // gmt offset -0400);)\n\n    private final String userDateFormat;\n\n    /**\n     * Default constructor.\n     */\n    public SvnChangeLogConsumer( ScmLogger logger, String userDateFormat )\n    {\n        super( logger );\n\n        this.userDateFormat = userDateFormat;\n    }\n\n    public List<ChangeSet> getModifications()\n    {\n        return entries;\n    }\n\n    // ----------------------------------------------------------------------\n    // StreamConsumer Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void consumeLine( String line )\n    {\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( line );\n        }\n        switch ( status )\n        {\n            case GET_HEADER:\n                processGetHeader( line );\n                break;\n            case GET_FILE:\n                processGetFile( line );\n                break;\n            case GET_COMMENT:\n                processGetComment( line );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown state: \" + status );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * Process the current input line in the GET_HEADER state.  The\n     * author, date, and the revision of the entry are gathered.  Note,\n     * Subversion does not have per-file revisions, instead, the entire\n     * repository is given a single revision number, which is used for\n     * the revision number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetHeader( String line )\n    {\n        if ( !HEADER_REG_EXP.match( line ) )\n        {\n            // The header line is not found. Intentionally do nothing.\n            return;\n        }\n\n        currentRevision = getRevision( HEADER_REG_EXP.getParen( REVISION_GROUP ) );\n\n        currentChange = new SvnChangeSet();\n\n        currentChange.setAuthor( HEADER_REG_EXP.getParen( AUTHOR_GROUP ) );\n\n        currentChange.setDate( getDate( HEADER_REG_EXP.getParen( DATE_GROUP ) ) );\n\n        currentChange.setRevision( currentRevision );\n\n        status = GET_FILE;\n    }\n\n    /**\n     * Gets the svn revision, from the svn log revision output.\n     *\n     * @param revisionOutput\n     * @return the svn revision\n     */\n    private String getRevision( final String revisionOutput )\n    {\n        if ( REVISION_REG_EXP1.match( revisionOutput ) )\n        {\n            return REVISION_REG_EXP1.getParen( 1 );\n        }\n        else if ( REVISION_REG_EXP2.match( revisionOutput ) )\n        {\n            return REVISION_REG_EXP2.getParen( 1 );\n        }\n        else\n        {\n            throw new IllegalOutputException( revisionOutput );\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_FILE state.  This state\n     * adds each file entry line to the current change log entry.  Note,\n     * the revision number for the entire entry is used for the revision\n     * number of each file.\n     *\n     * @param line A line of text from the svn log output\n     */\n    private void processGetFile( String line )\n    {\n        if ( FILE_PATTERN.match( line ) )\n        {\n            final String fileinfo = FILE_PATTERN.getParen( 2 );\n            String name = fileinfo;\n            String originalName = null;\n            String originalRev = null;\n            final int n = fileinfo.indexOf( \" (\" );\n            if ( n > 1 && fileinfo.endsWith( \")\" ) )\n            {\n                final String origFileInfo = fileinfo.substring( n );\n                if ( ORIG_FILE_PATTERN.match( origFileInfo ) )\n                {\n                    // if original file is present, we must extract the affected one from the beginning\n                    name = fileinfo.substring( 0, n );\n                    originalName = ORIG_FILE_PATTERN.getParen( 1 );\n                    originalRev = ORIG_FILE_PATTERN.getParen( 2 );\n                }\n            }\n            final String actionStr = FILE_PATTERN.getParen( 1 );\n            final ScmFileStatus action;\n            if ( \"A\".equals( actionStr ) )\n            {\n                //TODO: this may even change to MOVED if we later explore whole changeset and find matching DELETED\n                action = originalRev == null ? ScmFileStatus.ADDED : ScmFileStatus.COPIED;\n            }\n            else if ( \"D\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.DELETED;\n            }\n            else if ( \"M\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.MODIFIED;\n            }\n            else if ( \"R\".equals( actionStr ) )\n            {\n                action = ScmFileStatus.UPDATED; //== REPLACED in svn terms\n            }\n            else\n            {\n                action = ScmFileStatus.UNKNOWN;\n            }\n            System.out.println( actionStr + \" : \" + name );\n            final ChangeFile changeFile = new ChangeFile( name, currentRevision );\n            changeFile.setAction( action );\n            changeFile.setOriginalName( originalName );\n            changeFile.setOriginalRevision( originalRev );\n            currentChange.addFile( changeFile );\n\n            status = GET_FILE;\n        }\n        else if ( line.equals( FILE_END_TOKEN ) )\n        {\n            // Create a buffer for the collection of the comment now\n            // that we are leaving the GET_FILE state.\n            currentComment = new StringBuffer();\n\n            status = GET_COMMENT;\n        }\n    }\n\n    /**\n     * Process the current input line in the GET_COMMENT state.  This\n     * state gathers all of the comments that are part of a log entry.\n     *\n     * @param line a line of text from the svn log output\n     */\n    private void processGetComment( String line )\n    {\n        if ( line.equals( COMMENT_END_TOKEN ) )\n        {\n            currentChange.setComment( currentComment.toString() );\n\n            entries.add( currentChange );\n\n            status = GET_HEADER;\n        }\n        else\n        {\n            currentComment.append( line ).append( '\\n' );\n        }\n    }\n\n    /**\n     * Converts the date time stamp from the svn output into a date\n     * object.\n     *\n     * @param dateOutput The date output from an svn log command.\n     * @return A date representing the time stamp of the log entry.\n     */\n    private Date getDate( final String dateOutput )\n    {\n        if ( !DATE_REG_EXP.match( dateOutput ) )\n        {\n            throw new IllegalOutputException( dateOutput );\n        }\n\n        final StringBuffer date = new StringBuffer();\n        date.append( DATE_REG_EXP.getParen( 1 ) );\n        date.append( \" GMT\" );\n        date.append( DATE_REG_EXP.getParen( 2 ) );\n        date.append( DATE_REG_EXP.getParen( 3 ) );\n        date.append( ':' );\n        date.append( DATE_REG_EXP.getParen( 4 ) );\n\n        return parseDate( date.toString(), userDateFormat, SVN_TIMESTAMP_PATTERN );\n    }\n}\n","lineNo":281}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.codehaus.plexus.PlexusTestCase;\nimport org.codehaus.plexus.logging.Logger;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnChangeLogConsumerTest\n    extends PlexusTestCase\n{\n    Logger logger;\n    SvnChangeLogConsumer consumer;\n    \n\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        logger = getContainer().getLogger();\n        consumer = new SvnChangeLogConsumer( new DefaultLog(), null );\n    }\n    \n    /**\n     * Initial modifications should be empty.\n     */\n    public void testGetModifications_Initial()\n    {\n        assertTrue(\"Initial modifications should be empty\", consumer.getModifications().isEmpty());\n    }\n    \n    /**\n     * Valid svn log output should have expected values.\n     * \n     * @throws Exception if any problem occurs.\n     */\n    public void testConsumeLine_ValidOutput()\n        throws Exception\n    {\n        final File svnLog = getTestFile( \"/src/test/resources/svn/changelog/svnLogValidOutput.txt\" );\n\n        consumeLog( svnLog );\n\n        final ChangeSet entry = (ChangeSet) consumer.getModifications().get( 0 );\n\n        final List changedFiles = entry.getFiles();\n        final String revision = ( (ChangeFile) changedFiles.get( 0 ) ).getRevision();\n\n        assertEquals( \"Valid revision expected\", \"15\", revision );\n        assertEquals( \"Valid num changed files expected\", 2, changedFiles.size() );\n        assertEquals( \"Valid name expected\", \"unconventional author output (somedata)\", entry.getAuthor() );\n        String expectedDate = getLocalizedDate( \"2002-08-26 14:33:26\", TimeZone.getTimeZone( \"GMT-4\" ) );\n        assertEquals( \"Valid date expected\", expectedDate, entry.getDateFormatted() );\n        assertEquals( \"Valid comment expected\", \"Minor formatting changes.\\n\", entry.getComment() );\n    }\n\n    private static String getLocalizedDate( String date, TimeZone timeZone )\n        throws Exception\n    {\n        DateFormat fmt = new SimpleDateFormat( \"yyyy-MM-dd HH:mm:ss\" );\n        fmt.setTimeZone( timeZone );\n        Date parsed = fmt.parse( date );\n        fmt = new SimpleDateFormat( \"yyyy-MM-dd\" );\n        return fmt.format( parsed );\n    }\n    \n    /**\n     * Svn log output with an invalid reason should throw an IllegalOutputException.\n     * \n     * @throws Exception\n     */\n    public void testConsumeLine_InvalidReason()\n        throws Exception\n    {\n        final File svnLog = getTestFile( \"/src/test/resources/svn/changelog/svnLogInvalidReason.txt\" );\n\n        try\n        {\n            consumeLog( svnLog );\n            fail( \"Svn log output with an invalid reason should throw IllegalOutputException\" );\n        }\n        catch ( final IllegalOutputException e )\n        {\n            assertTrue( true );\n        }\n    }\n    \n    /**\n     * Svn log output with an invalid date should throw an IllegalOutputException.\n     * \n     * @throws Exception\n     */\n    public void testConsumeLine_InvalidDate()\n        throws Exception\n    {\n        final File svnLog = getTestFile( \"/src/test/resources/svn/changelog/svnLogInvalidDate.txt\" );\n        try\n        {\n            consumeLog( svnLog );\n            fail( \"Svn log output with an invalid date should throw IllegalOutputException\" );\n        }\n        catch ( final IllegalOutputException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    /**\n     * Consumes change log information stored in a file.\n     * \n     * @param logFile the file.\n     * @throws IOException if a problem occurs.\n     */\n    private void consumeLog( final File logFile )\n        throws IOException\n    {\n        final BufferedReader reader = new BufferedReader( new FileReader( logFile ) );\n        String line = reader.readLine();\n\n        while ( line != null )\n        {\n            consumer.consumeLine( line );\n            line = reader.readLine();\n        }\n    }\n\n    public void testConsumerWithPattern1()\n        throws Exception\n    {\n        StringBuffer out = new StringBuffer();\n\n        File f = getTestFile( \"/src/test/resources/svn/changelog/svnlog.txt\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List modifications = consumer.getModifications();\n\n        out.append( \"Text format:\" );\n\n        out.append( \"nb modifications : \" + modifications.size() );\n\n        for ( Iterator i = modifications.iterator(); i.hasNext(); )\n        {\n            ChangeSet entry = (ChangeSet) i.next();\n\n            out.append( \"Author:\" + entry.getAuthor() );\n\n            out.append( \"Date:\" + entry.getDate() );\n\n            out.append( \"Comment:\" + entry.getComment() );\n\n            List files = entry.getFiles();\n\n            for ( Iterator it = files.iterator(); it.hasNext(); )\n            {\n                ChangeFile file = (ChangeFile) it.next();\n\n                out.append( \"File:\" + file.getName() );\n            }\n\n            out.append( \"==============================\" );\n        }\n\n        out.append( \"XML format:\" );\n\n        out.append( \"nb modifications : \" + modifications.size() );\n\n        for ( Iterator i = modifications.iterator(); i.hasNext(); )\n        {\n            ChangeSet entry = (ChangeSet) i.next();\n\n            out.append( entry.toXML() );\n\n            out.append( \"==============================\" );\n        }\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( out.toString() );\n        }\n    }\n\n    public void testConsumerWithPattern2()\n        throws Exception\n    {\n        StringBuffer out = new StringBuffer();\n\n        File f = getTestFile( \"/src/test/resources/svn/changelog/svnlog2.txt\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List modifications = consumer.getModifications();\n\n        out.append( \"nb modifications : \" + modifications.size() );\n\n        for ( Iterator i = modifications.iterator(); i.hasNext(); )\n        {\n            ChangeSet entry = (ChangeSet) i.next();\n\n            out.append( \"Author:\" + entry.getAuthor() );\n\n            out.append( \"Date:\" + entry.getDate() );\n\n            out.append( \"Comment:\" + entry.getComment() );\n\n            List files = entry.getFiles();\n\n            for ( Iterator it = files.iterator(); it.hasNext(); )\n            {\n                ChangeFile file = (ChangeFile) it.next();\n\n                out.append( \"File:\" + file.getName() );\n            }\n\n            out.append( \"==============================\" );\n        }\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( out.toString() );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.apache.maven.scm.ChangeFile;\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.codehaus.plexus.PlexusTestCase;\nimport org.codehaus.plexus.logging.Logger;\nimport org.junit.Assert;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnChangeLogConsumerTest\n    extends PlexusTestCase\n{\n    Logger logger;\n    SvnChangeLogConsumer consumer;\n    \n\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        logger = getContainer().getLogger();\n        consumer = new SvnChangeLogConsumer( new DefaultLog(), null );\n    }\n    \n    /**\n     * Initial modifications should be empty.\n     */\n    public void testGetModifications_Initial()\n    {\n        assertTrue(\"Initial modifications should be empty\", consumer.getModifications().isEmpty());\n    }\n    \n    /**\n     * Valid svn log output should have expected values.\n     * \n     * @throws Exception if any problem occurs.\n     */\n    public void testConsumeLine_ValidOutput()\n        throws Exception\n    {\n        final File svnLog = getTestFile( \"/src/test/resources/svn/changelog/svnLogValidOutput.txt\" );\n\n        consumeLog( svnLog );\n\n        final ChangeSet entry = (ChangeSet) consumer.getModifications().get( 0 );\n\n        final List changedFiles = entry.getFiles();\n        final String revision = ( (ChangeFile) changedFiles.get( 0 ) ).getRevision();\n\n        assertEquals( \"Valid revision expected\", \"15\", revision );\n        assertEquals( \"Valid num changed files expected\", 2, changedFiles.size() );\n        assertEquals( \"Valid name expected\", \"unconventional author output (somedata)\", entry.getAuthor() );\n        String expectedDate = getLocalizedDate( \"2002-08-26 14:33:26\", TimeZone.getTimeZone( \"GMT-4\" ) );\n        assertEquals( \"Valid date expected\", expectedDate, entry.getDateFormatted() );\n        assertEquals( \"Valid comment expected\", \"Minor formatting changes.\\n\", entry.getComment() );\n    }\n\n    private static String getLocalizedDate( String date, TimeZone timeZone )\n        throws Exception\n    {\n        DateFormat fmt = new SimpleDateFormat( \"yyyy-MM-dd HH:mm:ss\" );\n        fmt.setTimeZone( timeZone );\n        Date parsed = fmt.parse( date );\n        fmt = new SimpleDateFormat( \"yyyy-MM-dd\" );\n        return fmt.format( parsed );\n    }\n    \n    /**\n     * Svn log output with an invalid reason should throw an IllegalOutputException.\n     * \n     * @throws Exception\n     */\n    public void testConsumeLine_InvalidReason()\n        throws Exception\n    {\n        final File svnLog = getTestFile( \"/src/test/resources/svn/changelog/svnLogInvalidReason.txt\" );\n\n        try\n        {\n            consumeLog( svnLog );\n            fail( \"Svn log output with an invalid reason should throw IllegalOutputException\" );\n        }\n        catch ( final IllegalOutputException e )\n        {\n            assertTrue( true );\n        }\n    }\n    \n    /**\n     * Svn log output with an invalid date should throw an IllegalOutputException.\n     * \n     * @throws Exception\n     */\n    public void testConsumeLine_InvalidDate()\n        throws Exception\n    {\n        final File svnLog = getTestFile( \"/src/test/resources/svn/changelog/svnLogInvalidDate.txt\" );\n        try\n        {\n            consumeLog( svnLog );\n            fail( \"Svn log output with an invalid date should throw IllegalOutputException\" );\n        }\n        catch ( final IllegalOutputException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    /**\n     * Consumes change log information stored in a file.\n     * \n     * @param logFile the file.\n     * @throws IOException if a problem occurs.\n     */\n    private void consumeLog( final File logFile )\n        throws IOException\n    {\n        final BufferedReader reader = new BufferedReader( new FileReader( logFile ) );\n        String line = reader.readLine();\n\n        while ( line != null )\n        {\n            consumer.consumeLine( line );\n            line = reader.readLine();\n        }\n    }\n\n    public void testConsumerWithPattern1()\n        throws Exception\n    {\n        StringBuffer out = new StringBuffer();\n\n        File f = getTestFile( \"/src/test/resources/svn/changelog/svnlog.txt\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List modifications = consumer.getModifications();\n\n        out.append( \"Text format:\" );\n\n        out.append( \"nb modifications : \" + modifications.size() );\n\n        for ( Iterator i = modifications.iterator(); i.hasNext(); )\n        {\n            ChangeSet entry = (ChangeSet) i.next();\n\n            out.append( \"Author:\" + entry.getAuthor() );\n\n            out.append( \"Date:\" + entry.getDate() );\n\n            out.append( \"Comment:\" + entry.getComment() );\n\n            List files = entry.getFiles();\n\n            for ( Iterator it = files.iterator(); it.hasNext(); )\n            {\n                ChangeFile file = (ChangeFile) it.next();\n\n                out.append( \"File:\" + file.getName() );\n            }\n\n            out.append( \"==============================\" );\n        }\n\n        out.append( \"XML format:\" );\n\n        out.append( \"nb modifications : \" + modifications.size() );\n\n        for ( Iterator i = modifications.iterator(); i.hasNext(); )\n        {\n            ChangeSet entry = (ChangeSet) i.next();\n\n            out.append( entry.toXML() );\n\n            out.append( \"==============================\" );\n        }\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( out.toString() );\n        }\n    }\n\n    public void testConsumerWithPattern2()\n        throws Exception\n    {\n        StringBuffer out = new StringBuffer();\n\n        File f = getTestFile( \"/src/test/resources/svn/changelog/svnlog2.txt\" );\n\n        BufferedReader r = new BufferedReader( new FileReader( f ) );\n\n        String line;\n\n        while ( ( line = r.readLine() ) != null )\n        {\n            consumer.consumeLine( line );\n        }\n\n        List modifications = consumer.getModifications();\n\n        out.append( \"nb modifications : \" + modifications.size() );\n\n        for ( Iterator i = modifications.iterator(); i.hasNext(); )\n        {\n            ChangeSet entry = (ChangeSet) i.next();\n\n            out.append( \"Author:\" + entry.getAuthor() );\n\n            out.append( \"Date:\" + entry.getDate() );\n\n            out.append( \"Comment:\" + entry.getComment() );\n\n            List files = entry.getFiles();\n\n            for ( Iterator it = files.iterator(); it.hasNext(); )\n            {\n                ChangeFile file = (ChangeFile) it.next();\n\n                final String fileName = file.getName();\n                out.append( \"File:\" + fileName );\n\n                // files in this log are known to be from one subtree\n                Assert.assertTrue( \"Unexpected file name: \" + fileName, fileName.startsWith( \"/maven/scm/trunk\" ) );\n\n                // files in this log are known not to contain space\n                Assert.assertEquals( \"Unexpected space found in filename: \" + fileName, -1, fileName.indexOf( \" \" ) );\n            }\n\n            out.append( \"==============================\" );\n        }\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( out.toString() );\n        }\n    }\n}\n","lineNo":262}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamScmProviderTest\n    extends ScmTestCase\n{\n\n    public void testGoodGetRelativeFile()\n        throws Exception\n    {\n        File basedir = new File( getBasedir() );\n\n        File testDir = new File( basedir.getPath() + \"/target/../target/testdir\" );\n\n        testDir.mkdirs();\n\n        File testFile = new File( testDir, \"testfile.txt\" );\n\n        testFile.createNewFile();\n\n        String relativePath = StarteamScmProvider.getRelativePath( basedir, testFile );\n\n        assertEquals( \"target/testdir/testfile.txt\", relativePath.replace( '\\\\', '/' ) );\n\n    }\n\n    public void testBadGetRelativeFile()\n        throws Exception\n    {\n        File basedir = new File( getBasedir() );\n\n        File testDir1 = new File( basedir.getPath() + \"/target/testdir1\" );\n        testDir1.mkdirs();\n\n        File testDir2 = new File( basedir.getPath() + \"/target/testdir2\" );\n        testDir2.mkdirs();\n\n        File testFile = new File( testDir1, \"testfile.txt\" );\n\n        testFile.createNewFile();\n\n        try\n        {\n            StarteamScmProvider.getRelativePath( testDir2, testFile );\n            fail( \"Bad relative path found!\" );\n        }\n        catch ( ScmException e )\n        {\n\n        }\n\n    }\n\n    /**\n     * To specify multiple views url, we must use '|'( pipe ) as separator,\n     * must separate host and port using |\n     *\n     * @throws Exception\n     */\n    public void testMultipleViewsUrl()\n        throws Exception\n    {\n        String scmSpecificUrl = \"user:password@host|1234|/project/rootview:subview/folder\";\n        //String scmSpecificUrl = \"user:password@host|1234/project/rootview:subview/folder\"; //should work as well\n        StarteamScmProvider provider = new StarteamScmProvider();\n        StarteamScmProviderRepository starteamProvider =\n            (StarteamScmProviderRepository) provider.makeProviderScmRepository( scmSpecificUrl, '|' );\n        assertEquals( \"user\", starteamProvider.getUser() );\n        assertEquals( \"password\", starteamProvider.getPassword() );\n        assertEquals( 1234, starteamProvider.getPort() );\n        assertEquals( \"host\", starteamProvider.getHost() );\n        assertEquals( \"/project/rootview:subview/folder\", starteamProvider.getPath() );\n        assertEquals( \"user:password@host:1234/project/rootview:subview/folder\", starteamProvider.getFullUrl() );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamScmProviderTest\n    extends ScmTestCase\n{\n\n    public void testGoodGetRelativeFile()\n        throws Exception\n    {\n        File basedir = new File( getBasedir() );\n\n        File testDir = new File( basedir.getPath() + \"/target/../target/testdir\" );\n\n        testDir.mkdirs();\n\n        File testFile = new File( testDir, \"testfile.txt\" );\n\n        testFile.createNewFile();\n\n        String relativePath = StarteamScmProvider.getRelativePath( basedir, testFile );\n        relativePath = relativePath.replace( '\\\\', '/' ) ;\n        assertEquals(\"not expected relativePath, found \" + relativePath , \"target/testdir/testfile.txt\", relativePath);\n\n    }\n\n    public void testBadGetRelativeFile()\n        throws Exception\n    {\n        File basedir = new File( getBasedir() );\n\n        File testDir1 = new File( basedir.getPath() + \"/target/testdir1\" );\n        testDir1.mkdirs();\n\n        File testDir2 = new File( basedir.getPath() + \"/target/testdir2\" );\n        testDir2.mkdirs();\n\n        File testFile = new File( testDir1, \"testfile.txt\" );\n\n        testFile.createNewFile();\n\n        try\n        {\n            StarteamScmProvider.getRelativePath( testDir2, testFile );\n            fail( \"Bad relative path found!\" );\n        }\n        catch ( ScmException e )\n        {\n\n        }\n\n    }\n\n    /**\n     * To specify multiple views url, we must use '|'( pipe ) as separator,\n     * must separate host and port using |\n     *\n     * @throws Exception\n     */\n    public void testMultipleViewsUrl()\n        throws Exception\n    {\n        String scmSpecificUrl = \"user:password@host|1234|/project/rootview:subview/folder\";\n        //String scmSpecificUrl = \"user:password@host|1234/project/rootview:subview/folder\"; //should work as well\n        StarteamScmProvider provider = new StarteamScmProvider();\n        StarteamScmProviderRepository starteamProvider =\n            (StarteamScmProviderRepository) provider.makeProviderScmRepository( scmSpecificUrl, '|' );\n        assertEquals( \"user\", starteamProvider.getUser() );\n        assertEquals( \"password\", starteamProvider.getPassword() );\n        assertEquals( 1234, starteamProvider.getPort() );\n        assertEquals( \"host\", starteamProvider.getHost() );\n        assertEquals( \"/project/rootview:subview/folder\", starteamProvider.getPath() );\n        assertEquals( \"user:password@host:1234/project/rootview:subview/folder\", starteamProvider.getFullUrl() );\n    }\n\n}\n","lineNo":48}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.gitexe.command.blame;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.util.AbstractConsumer;\n\nimport java.util.*;\n\n/**\n * Parses the --porcelain format of git-blame\n *\n * For more information about the porcelain format, please read the official\n * <a href=\"http://www.kernel.org/pub/software/scm/git/docs/git-blame.html#_the_porcelain_format\">\n * GIT blame porcelain format<\/a> description.\n *\n * @author Evgeny Mandrikov\n * @author Olivier Lamy\n * @author Mark Struberg\n * @since 1.4\n */\npublic class GitBlameConsumer\n    extends AbstractConsumer\n{\n    private final static String GIT_COMMITTER_PREFIX = \"committer\";\n    private final static String GIT_COMMITTER      = GIT_COMMITTER_PREFIX + \" \";\n    private final static String GIT_COMMITTER_TIME = GIT_COMMITTER_PREFIX + \"-time \";\n    private final static String GIT_AUTHOR         = \"author \";\n\n\n    private List<BlameLine> lines = new ArrayList<BlameLine>();\n\n    private String revision  = null;\n    private String author    = null;\n    private String committer = null;\n    private Date   time      = null;\n\n    private boolean expectRevisionLine = true;\n\n    public GitBlameConsumer( ScmLogger logger )\n    {\n        super( logger );\n    }\n\n    public void consumeLine( String line )\n    {\n        if ( line == null )\n        {\n            return;\n        }\n\n        if (expectRevisionLine)\n        {\n            // this is the revision line\n            String parts[] = line.split( \"\\\\s\", 4 );\n\n            if ( parts.length >= 1)\n            {\n                revision = parts[0];\n            }\n\n            expectRevisionLine = false;\n        }\n        else\n        {\n            if ( line.startsWith( GIT_AUTHOR ) )\n            {\n                author = line.substring( GIT_AUTHOR.length() );\n                return;\n            }\n\n            if ( line.startsWith( GIT_COMMITTER ) )\n            {\n                committer = line.substring( GIT_COMMITTER.length() );\n                return;\n            }\n\n            if ( line.startsWith( GIT_COMMITTER_TIME ) )\n            {\n                String timeStr = line.substring( GIT_COMMITTER_TIME.length() );\n                time = new Date( Long.parseLong( timeStr ) * 1000L );\n                return;\n            }\n\n\n            if ( line.startsWith( \"\\t\" ) )\n            {\n                // this is the content line.\n                // we actually don't need the content, but this is the right time to add the blame line\n                getLines().add( new BlameLine( time, revision, author, committer ) );\n\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( author + \" \" + time.toGMTString() );\n                }\n\n                expectRevisionLine = true;\n            }\n\n        }\n    }\n\n    public List<BlameLine> getLines()\n    {\n        return lines;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.gitexe.command.blame;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.util.AbstractConsumer;\n\nimport java.util.*;\n\n/**\n * Parses the --porcelain format of git-blame\n *\n * For more information about the porcelain format, please read the official\n * <a href=\"http://www.kernel.org/pub/software/scm/git/docs/git-blame.html#_the_porcelain_format\">\n * GIT blame porcelain format<\/a> description.\n *\n * @author Evgeny Mandrikov\n * @author Olivier Lamy\n * @author Mark Struberg\n * @since 1.4\n */\npublic class GitBlameConsumer\n    extends AbstractConsumer\n{\n    private final static String GIT_COMMITTER_PREFIX = \"committer\";\n    private final static String GIT_COMMITTER      = GIT_COMMITTER_PREFIX + \" \";\n    private final static String GIT_COMMITTER_TIME = GIT_COMMITTER_PREFIX + \"-time \";\n    private final static String GIT_AUTHOR         = \"author \";\n\n\n    private List<BlameLine> lines = new ArrayList<BlameLine>();\n\n    /**\n     * Since the porcelain format only contains the commit information\n     * the first time a specific sha-1 commit appears, we need to store\n     * this information somwehere.\n     *\n     * key: the sha-1 of the commit\n     * value: the {@link BlameLine} containing the full committer/author info\n     */\n    private Map<String, BlameLine> commitInfo = new HashMap<String, BlameLine>();\n\n    private boolean expectRevisionLine = true;\n\n    private String revision  = null;\n    private String author    = null;\n    private String committer = null;\n    private Date   time      = null;\n\n    public GitBlameConsumer( ScmLogger logger )\n    {\n        super( logger );\n    }\n\n    public void consumeLine( String line )\n    {\n        if ( line == null )\n        {\n            return;\n        }\n\n        if (expectRevisionLine)\n        {\n            // this is the revision line\n            String parts[] = line.split( \"\\\\s\", 4 );\n\n            if ( parts.length >= 1)\n            {\n                revision = parts[0];\n\n                BlameLine oldLine = commitInfo.get( revision );\n\n                if ( oldLine != null )\n                {\n                    // restore the commit info\n                    author    = oldLine.getAuthor();\n                    committer = oldLine.getCommitter();\n                    time      = oldLine.getDate();\n                }\n\n                expectRevisionLine = false;\n            }\n        }\n        else\n        {\n            if ( line.startsWith( GIT_AUTHOR ) )\n            {\n                author = line.substring( GIT_AUTHOR.length() );\n                return;\n            }\n\n            if ( line.startsWith( GIT_COMMITTER ) )\n            {\n                committer = line.substring( GIT_COMMITTER.length() );\n                return;\n            }\n\n            if ( line.startsWith( GIT_COMMITTER_TIME ) )\n            {\n                String timeStr = line.substring( GIT_COMMITTER_TIME.length() );\n                time = new Date( Long.parseLong( timeStr ) * 1000L );\n                return;\n            }\n\n\n            if ( line.startsWith( \"\\t\" ) )\n            {\n                // this is the content line.\n                // we actually don't need the content, but this is the right time to add the blame line\n                BlameLine blameLine = new BlameLine( time, revision, author, committer );\n                getLines().add( blameLine );\n\n                // keep commitinfo for this sha-1\n                commitInfo.put( revision, blameLine );\n\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( author + \" \" + time.toGMTString() );\n                }\n\n                expectRevisionLine = true;\n            }\n\n        }\n    }\n\n    public List<BlameLine> getLines()\n    {\n        return lines;\n    }\n}\n","lineNo":128}
{"Smelly Sample":"package org.apache.maven.scm.provider.local.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.command.changelog.LocalChangeLogCommand;\nimport org.apache.maven.scm.provider.local.metadata.LocalScmMetadata;\nimport org.apache.maven.scm.provider.local.metadata.LocalScmMetadataUtils;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalUpdateCommand\n    extends AbstractUpdateCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !baseDestination.exists() )\n        {\n            throw new ScmException(\n                \"The working directory doesn't exist (\" + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        if ( !baseDestination.exists() && !baseDestination.isDirectory() )\n        {\n            throw new ScmException( \"The destination directory isn't a directory or doesn't exist (\"\n                + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        List updatedFiles;\n\n        try\n        {\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info(\n                                  \"Updating '\" + baseDestination.getAbsolutePath() + \"' from '\"\n                                      + source.getAbsolutePath() + \"'.\" );\n            }\n\n            List fileList = FileUtils.getFiles( source.getAbsoluteFile(), \"**\", null );\n\n            updatedFiles = update( source, baseDestination, fileList );\n\n            // process deletions in repository\n            LocalScmMetadataUtils metadataUtils = new LocalScmMetadataUtils( getLogger() );\n            LocalScmMetadata originalMetadata = metadataUtils.readMetadata( baseDestination );\n            if ( originalMetadata != null )\n            {\n                LocalScmMetadata newMetadata = metadataUtils.buildMetadata( source );\n                for ( Iterator it = originalMetadata.getRepositoryFileNames().iterator(); it.hasNext(); )\n                {\n                    String filename = (String) it.next();\n                    if ( !newMetadata.getRepositoryFileNames().contains( filename ) )\n                    {\n                        File localFile = new File( baseDestination, filename );\n                        if ( localFile.exists() )\n                        {\n                            localFile.delete();\n                            updatedFiles.add( new ScmFile( \"/\" + filename, ScmFileStatus.UPDATED ) );\n                        }\n                    }\n                }\n            }\n\n            // rewrite metadata file\n            metadataUtils.writeMetadata( baseDestination, metadataUtils.buildMetadata( source ) );\n\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking out the files.\", ex );\n        }\n\n        return new LocalUpdateScmResult( null, updatedFiles );\n    }\n\n    private List update( File source, File baseDestination, List files )\n        throws ScmException, IOException\n    {\n        String sourcePath = source.getAbsolutePath();\n\n        List updatedFiles = new ArrayList();\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File repositoryFile = (File) i.next();\n\n            File repositoryDirectory = repositoryFile.getParentFile();\n\n            // TODO: Add more excludes here\n            if ( repositoryDirectory != null && repositoryDirectory.getName().equals( \"CVS\" ) )\n            {\n                continue;\n            }\n\n            String dest = repositoryFile.getAbsolutePath().substring( sourcePath.length() + 1 );\n\n            File destinationFile = new File( baseDestination, dest );\n\n            String repositoryFileContents = FileUtils.fileRead( repositoryFile );\n\n            if ( destinationFile.exists() )\n            {\n                String destionationFileContents = FileUtils.fileRead( destinationFile );\n\n                if ( repositoryFileContents.equals( destionationFileContents ) )\n                {\n                    continue;\n                }\n            }\n\n            File destinationDirectory = destinationFile.getParentFile();\n\n            if ( !destinationDirectory.exists() && !destinationDirectory.mkdirs() )\n            {\n                throw new ScmException(\n                    \"Could not create destination directory '\" + destinationDirectory.getAbsolutePath() + \"'.\" );\n            }\n\n            ScmFileStatus status;\n\n            if ( destinationFile.exists() )\n            {\n                status = ScmFileStatus.UPDATED;\n            }\n            else\n            {\n                status = ScmFileStatus.ADDED;\n            }\n\n            FileUtils.copyFileToDirectory( repositoryFile, destinationDirectory );\n\n            int chop = baseDestination.getAbsolutePath().length();\n\n            String fileName = \"/\" + destinationFile.getAbsolutePath().substring( chop + 1 );\n\n            updatedFiles.add( new ScmFile( fileName, status ) );\n        }\n\n        return updatedFiles;\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        return new LocalChangeLogCommand();\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.local.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.command.changelog.LocalChangeLogCommand;\nimport org.apache.maven.scm.provider.local.metadata.LocalScmMetadata;\nimport org.apache.maven.scm.provider.local.metadata.LocalScmMetadataUtils;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @author Olivier Lamy\n * @version $Id$\n */\npublic class LocalUpdateCommand\n    extends AbstractUpdateCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !baseDestination.exists() )\n        {\n            throw new ScmException(\n                \"The working directory doesn't exist (\" + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        if ( !baseDestination.exists() && !baseDestination.isDirectory() )\n        {\n            throw new ScmException( \"The destination directory isn't a directory or doesn't exist (\"\n                + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        List<ScmFile> updatedFiles;\n\n        try\n        {\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info(\n                                  \"Updating '\" + baseDestination.getAbsolutePath() + \"' from '\"\n                                      + source.getAbsolutePath() + \"'.\" );\n            }\n\n            @SuppressWarnings( \"unchecked\" )\n            List<File> fileList = FileUtils.getFiles( source.getAbsoluteFile(), \"**\", null );\n            List<File> list = fileList;\n            updatedFiles = update( source, baseDestination, list );\n\n            // process deletions in repository\n            LocalScmMetadataUtils metadataUtils = new LocalScmMetadataUtils( getLogger() );\n            LocalScmMetadata originalMetadata = metadataUtils.readMetadata( baseDestination );\n            if ( originalMetadata != null )\n            {\n                LocalScmMetadata newMetadata = metadataUtils.buildMetadata( source );\n                for ( Iterator<String> it = originalMetadata.getRepositoryFileNames().iterator(); it.hasNext(); )\n                {\n                    String filename = it.next();\n                    if ( !newMetadata.getRepositoryFileNames().contains( filename ) )\n                    {\n                        File localFile = new File( baseDestination, filename );\n                        if ( localFile.exists() )\n                        {\n                            localFile.delete();\n                            updatedFiles.add( new ScmFile( \"/\" + filename, ScmFileStatus.UPDATED ) );\n                        }\n                    }\n                }\n            }\n\n            // rewrite metadata file\n            metadataUtils.writeMetadata( baseDestination, metadataUtils.buildMetadata( source ) );\n\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking out the files.\", ex );\n        }\n\n        return new LocalUpdateScmResult( null, updatedFiles );\n    }\n\n    private List<ScmFile> update( File source, File baseDestination, List<File> files )\n        throws ScmException, IOException\n    {\n        String sourcePath = source.getAbsolutePath();\n\n        List<ScmFile> updatedFiles = new ArrayList<ScmFile>();\n\n        for ( Iterator<File> i = files.iterator(); i.hasNext(); )\n        {\n            File repositoryFile = i.next();\n\n            File repositoryDirectory = repositoryFile.getParentFile();\n\n            // TODO: Add more excludes here\n            if ( repositoryDirectory != null && repositoryDirectory.getName().equals( \"CVS\" ) )\n            {\n                continue;\n            }\n\n            String dest = repositoryFile.getAbsolutePath().substring( sourcePath.length() + 1 );\n\n            File destinationFile = new File( baseDestination, dest );\n\n            String repositoryFileContents = FileUtils.fileRead( repositoryFile );\n\n            if ( destinationFile.exists() )\n            {\n                String destionationFileContents = FileUtils.fileRead( destinationFile );\n\n                if ( repositoryFileContents.equals( destionationFileContents ) )\n                {\n                    continue;\n                }\n            }\n\n            File destinationDirectory = destinationFile.getParentFile();\n\n            if ( !destinationDirectory.exists() && !destinationDirectory.mkdirs() )\n            {\n                throw new ScmException(\n                    \"Could not create destination directory '\" + destinationDirectory.getAbsolutePath() + \"'.\" );\n            }\n\n            ScmFileStatus status;\n\n            if ( destinationFile.exists() )\n            {\n                status = ScmFileStatus.UPDATED;\n            }\n            else\n            {\n                status = ScmFileStatus.ADDED;\n            }\n\n            FileUtils.copyFileToDirectory( repositoryFile, destinationDirectory );\n\n            int chop = baseDestination.getAbsolutePath().length();\n\n            String fileName = \"/\" + destinationFile.getAbsolutePath().substring( chop + 1 );\n\n            updatedFiles.add( new ScmFile( fileName, status ) );\n        }\n\n        return updatedFiles;\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        return new LocalChangeLogCommand();\n    }\n}\n","lineNo":107}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnCommandUtils;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @version $Id$\n * @todo since this is just a copy, use that instead.\n */\npublic class SvnTagCommand\n    extends AbstractTagCommand\n    implements SvnCommand\n{\n    \n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag, String message )\n        throws ScmException\n    {\n        ScmTagParameters scmTagParameters = new ScmTagParameters( message );\n        // force false to preserve backward comp\n        scmTagParameters.setRemoteTagging( false );\n        return executeTagCommand( repo, fileSet, tag, scmTagParameters );\n    }\n    \n    /** {@inheritDoc} */\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag,\n                                        ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        // NPE free\n        if (scmTagParameters == null)\n        {\n            getLogger().debug( \"SvnTagCommand :: scmTagParameters is null create an empty one\" );\n            scmTagParameters = new ScmTagParameters();\n            scmTagParameters.setRemoteTagging( false );\n          \n        }\n        else\n        {\n            getLogger().debug(\n                               \"SvnTagCommand :: scmTagParameters.remoteTagging : \"\n                                   + scmTagParameters.isRemoteTagging() );\n        }\n        if ( tag == null || StringUtils.isEmpty( tag.trim() ) )\n        {\n            throw new ScmException( \"tag must be specified\" );\n        }\n\n        if ( fileSet.getFiles().length != 0 )\n        {\n            throw new ScmException( \"This provider doesn't support tagging subsets of a directory\" );\n        }\n\n        SvnScmProviderRepository repository = (SvnScmProviderRepository) repo;\n\n        File messageFile = FileUtils.createTempFile( \"maven-scm-\", \".commit\", null );\n\n        try\n        {\n            FileUtils.fileWrite( messageFile.getAbsolutePath(), scmTagParameters == null ? \"\" : scmTagParameters\n                .getMessage() );\n        }\n        catch ( IOException ex )\n        {\n            return new TagScmResult( null, \"Error while making a temporary file for the commit message: \"\n                + ex.getMessage(), null, false );\n        }\n       \n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), tag, messageFile, scmTagParameters );\n        \n        CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n            getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, stdout, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n        finally\n        {\n            try\n            {\n                FileUtils.forceDelete( messageFile );\n            }\n            catch ( IOException ex )\n            {\n                // ignore\n            }\n        }\n\n        if ( exitCode != 0 )\n        {\n            // TODO: Improve this error message\n            return new TagScmResult( cl.toString(), \"The svn tag command failed.\", stderr.getOutput(), false );\n        }\n\n        List fileList = new ArrayList();\n\n        List files = null;\n\n        try\n        {\n            if ( StringUtils.isNotEmpty( fileSet.getExcludes() ) )\n            {\n                files =\n                    FileUtils.getFiles( fileSet.getBasedir(),\n                                        ( StringUtils.isEmpty( fileSet.getIncludes() ) ? \"**\"\n                                                        : fileSet.getIncludes() ), fileSet.getExcludes()\n                                            + \",**/.svn/**\", false );\n            }\n            else\n            {\n                files =\n                    FileUtils.getFiles( fileSet.getBasedir(),\n                                        ( StringUtils.isEmpty( fileSet.getIncludes() ) ? \"**\"\n                                                        : fileSet.getIncludes() ), \"**/.svn/**\", false );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( \"Error while executing command.\", e );\n        }\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File f = (File) i.next();\n\n            fileList.add( new ScmFile( f.getPath(), ScmFileStatus.TAGGED ) );\n        }\n\n        return new TagScmResult( cl.toString(), fileList );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * @deprecated\n     * @param repository\n     * @param workingDirectory\n     * @param tag\n     * @param messageFile\n     * @return\n     */\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory, String tag,\n                                                 File messageFile )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArg().setValue( \"copy\" );\n\n        cl.createArg().setValue( \"--file\" );\n\n        cl.createArg().setValue( messageFile.getAbsolutePath() );\n\n        cl.createArg().setValue( \".\" );\n\n        // Note: this currently assumes you have the tag base checked out too\n        String tagUrl = SvnTagBranchUtils.resolveTagUrl( repository, new ScmTag( tag ) );\n        cl.createArg().setValue( SvnCommandUtils.fixUrl( tagUrl, repository.getUser() ) );\n\n        return cl;\n    }\n\n    \n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 String tag, File messageFile, ScmTagParameters scmTagParameters )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArg().setValue( \"copy\" );\n\n        cl.createArg().setValue( \"--file\" );\n\n        cl.createArg().setValue( messageFile.getAbsolutePath() );\n\n        // SCM-487 olamy : this need a svn 1.5 cli \n        //cl.createArg().setValue( \"--parents\" );\n        \n        if ( scmTagParameters != null && scmTagParameters.getScmRevision() != null )\n        {\n            cl.createArg().setValue( \"--revision\" );\n            \n            cl.createArg().setValue( scmTagParameters.getScmRevision() );\n            \n        }\n        \n\n        if ( scmTagParameters != null && scmTagParameters.isRemoteTagging() )\n        {\n            cl.createArg().setValue( repository.getUrl() );\n        }\n        else\n        {\n            cl.createArg().setValue( \".\" );\n        }\n\n        // Note: this currently assumes you have the tag base checked out too\n        String tagUrl = SvnTagBranchUtils.resolveTagUrl( repository, new ScmTag( tag ) );\n        cl.createArg().setValue( SvnCommandUtils.fixUrl( tagUrl, repository.getUser() ) );\n\n        return cl;\n    }    \n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.tag;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnCommandUtils;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author Olivier Lamy\n * @version $Id$\n * @todo since this is just a copy, use that instead.\n */\npublic class SvnTagCommand\n    extends AbstractTagCommand\n    implements SvnCommand\n{\n    \n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag, String message )\n        throws ScmException\n    {\n        ScmTagParameters scmTagParameters = new ScmTagParameters( message );\n        // force false to preserve backward comp\n        scmTagParameters.setRemoteTagging( false );\n        return executeTagCommand( repo, fileSet, tag, scmTagParameters );\n    }\n    \n    /** {@inheritDoc} */\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag,\n                                        ScmTagParameters scmTagParameters )\n        throws ScmException\n    {\n        // NPE free\n        if (scmTagParameters == null)\n        {\n            getLogger().debug( \"SvnTagCommand :: scmTagParameters is null create an empty one\" );\n            scmTagParameters = new ScmTagParameters();\n            scmTagParameters.setRemoteTagging( false );\n          \n        }\n        else\n        {\n            getLogger().debug(\n                               \"SvnTagCommand :: scmTagParameters.remoteTagging : \"\n                                   + scmTagParameters.isRemoteTagging() );\n        }\n        if ( tag == null || StringUtils.isEmpty( tag.trim() ) )\n        {\n            throw new ScmException( \"tag must be specified\" );\n        }\n\n        if ( fileSet.getFileList().isEmpty() )\n        {\n            throw new ScmException( \"This provider doesn't support tagging subsets of a directory\" );\n        }\n\n        SvnScmProviderRepository repository = (SvnScmProviderRepository) repo;\n\n        File messageFile = FileUtils.createTempFile( \"maven-scm-\", \".commit\", null );\n\n        try\n        {\n            FileUtils.fileWrite( messageFile.getAbsolutePath(), scmTagParameters == null ? \"\" : scmTagParameters\n                .getMessage() );\n        }\n        catch ( IOException ex )\n        {\n            return new TagScmResult( null, \"Error while making a temporary file for the commit message: \"\n                + ex.getMessage(), null, false );\n        }\n       \n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), tag, messageFile, scmTagParameters );\n        \n        CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n            getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, stdout, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n        finally\n        {\n            try\n            {\n                FileUtils.forceDelete( messageFile );\n            }\n            catch ( IOException ex )\n            {\n                // ignore\n            }\n        }\n\n        if ( exitCode != 0 )\n        {\n            // TODO: Improve this error message\n            return new TagScmResult( cl.toString(), \"The svn tag command failed.\", stderr.getOutput(), false );\n        }\n\n        List<ScmFile> fileList = new ArrayList<ScmFile>();\n\n        List<File> files = null;\n\n        try\n        {\n            if ( StringUtils.isNotEmpty( fileSet.getExcludes() ) )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<File> list =\n                    FileUtils.getFiles( fileSet.getBasedir(),\n                                        ( StringUtils.isEmpty( fileSet.getIncludes() ) ? \"**\"\n                                                        : fileSet.getIncludes() ), fileSet.getExcludes()\n                                            + \",**/.svn/**\", false );\n                files = list;\n            }\n            else\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<File> list =\n                    FileUtils.getFiles( fileSet.getBasedir(),\n                                        ( StringUtils.isEmpty( fileSet.getIncludes() ) ? \"**\"\n                                                        : fileSet.getIncludes() ), \"**/.svn/**\", false );\n                files = list;\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( \"Error while executing command.\", e );\n        }\n\n        for ( Iterator<File> i = files.iterator(); i.hasNext(); )\n        {\n            File f = i.next();\n\n            fileList.add( new ScmFile( f.getPath(), ScmFileStatus.TAGGED ) );\n        }\n\n        return new TagScmResult( cl.toString(), fileList );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * @deprecated\n     * @param repository\n     * @param workingDirectory\n     * @param tag\n     * @param messageFile\n     * @return\n     */\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory, String tag,\n                                                 File messageFile )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArg().setValue( \"copy\" );\n\n        cl.createArg().setValue( \"--file\" );\n\n        cl.createArg().setValue( messageFile.getAbsolutePath() );\n\n        cl.createArg().setValue( \".\" );\n\n        // Note: this currently assumes you have the tag base checked out too\n        String tagUrl = SvnTagBranchUtils.resolveTagUrl( repository, new ScmTag( tag ) );\n        cl.createArg().setValue( SvnCommandUtils.fixUrl( tagUrl, repository.getUser() ) );\n\n        return cl;\n    }\n\n    \n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 String tag, File messageFile, ScmTagParameters scmTagParameters )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArg().setValue( \"copy\" );\n\n        cl.createArg().setValue( \"--file\" );\n\n        cl.createArg().setValue( messageFile.getAbsolutePath() );\n\n        // SCM-487 olamy : this need a svn 1.5 cli \n        //cl.createArg().setValue( \"--parents\" );\n        \n        if ( scmTagParameters != null && scmTagParameters.getScmRevision() != null )\n        {\n            cl.createArg().setValue( \"--revision\" );\n            \n            cl.createArg().setValue( scmTagParameters.getScmRevision() );\n            \n        }\n        \n\n        if ( scmTagParameters != null && scmTagParameters.isRemoteTagging() )\n        {\n            cl.createArg().setValue( repository.getUrl() );\n        }\n        else\n        {\n            cl.createArg().setValue( \".\" );\n        }\n\n        // Note: this currently assumes you have the tag base checked out too\n        String tagUrl = SvnTagBranchUtils.resolveTagUrl( repository, new ScmTag( tag ) );\n        cl.createArg().setValue( SvnCommandUtils.fixUrl( tagUrl, repository.getUser() ) );\n\n        return cl;\n    }    \n}\n","lineNo":162}
{"Smelly Sample":"package org.apache.maven.scm.provider.local.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.metadata.LocalScmMetadataUtils;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                        ScmVersion version, boolean recursive )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        List checkedOutFiles;\n\n        try\n        {\n            if ( baseDestination.exists() )\n            {\n                FileUtils.deleteDirectory( baseDestination );\n            }\n\n            if ( !baseDestination.mkdirs() )\n            {\n                throw new ScmException(\n                    \"Could not create destination directory '\" + baseDestination.getAbsolutePath() + \"'.\" );\n            }\n\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info(\n                                  \"Checking out '\" + source.getAbsolutePath() + \"' to '\"\n                                      + baseDestination.getAbsolutePath() + \"'.\" );\n            }\n\n            List fileList;\n\n            if ( fileSet.getFiles().length == 0 )\n            {\n                fileList = FileUtils.getFiles( source.getAbsoluteFile(), \"**\", null );\n            }\n            else\n            {\n                fileList = Arrays.asList( fileSet.getFiles() );\n            }\n\n            checkedOutFiles = checkOut( source, baseDestination, fileList, repository.getModule() );\n\n            // write metadata file\n            LocalScmMetadataUtils metadataUtils = new LocalScmMetadataUtils( getLogger() );\n            metadataUtils.writeMetadata( baseDestination, metadataUtils.buildMetadata( source ) );\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking out the files.\", ex );\n        }\n\n        return new LocalCheckOutScmResult( null, checkedOutFiles );\n    }\n\n    private List checkOut( File source, File baseDestination, List files, String module )\n        throws ScmException, IOException\n    {\n        String sourcePath = source.getAbsolutePath();\n\n        List checkedOutFiles = new ArrayList();\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File file = (File) i.next();\n\n            String dest = file.getAbsolutePath();\n\n            dest = dest.substring( sourcePath.length() + 1 );\n\n            File destination = new File( baseDestination, dest );\n\n            destination = destination.getParentFile();\n\n            if ( !destination.exists() && !destination.mkdirs() )\n            {\n                throw new ScmException(\n                    \"Could not create destination directory '\" + destination.getAbsolutePath() + \"'.\" );\n            }\n\n            FileUtils.copyFileToDirectory( file, destination );\n\n            File parent = file.getParentFile();\n\n            // TODO: Add more excludes here\n            if ( parent != null && parent.getName().equals( \"CVS\" ) )\n            {\n                continue;\n            }\n\n            String fileName = \"/\" + module + \"/\" + dest;\n\n            checkedOutFiles.add( new ScmFile( fileName, ScmFileStatus.CHECKED_OUT ) );\n        }\n\n        return checkedOutFiles;\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.local.command.checkout;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.metadata.LocalScmMetadataUtils;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                        ScmVersion version, boolean recursive )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        List<ScmFile> checkedOutFiles;\n\n        try\n        {\n            if ( baseDestination.exists() )\n            {\n                FileUtils.deleteDirectory( baseDestination );\n            }\n\n            if ( !baseDestination.mkdirs() )\n            {\n                throw new ScmException(\n                    \"Could not create destination directory '\" + baseDestination.getAbsolutePath() + \"'.\" );\n            }\n\n            if ( getLogger().isInfoEnabled() )\n            {\n                getLogger().info(\n                                  \"Checking out '\" + source.getAbsolutePath() + \"' to '\"\n                                      + baseDestination.getAbsolutePath() + \"'.\" );\n            }\n\n            List<File> fileList;\n\n            if ( fileSet.getFileList().isEmpty() )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<File> files = FileUtils.getFiles( source.getAbsoluteFile(), \"**\", null ); \n                fileList = files;\n            }\n            else\n            {\n                fileList = fileSet.getFileList();\n            }\n\n            checkedOutFiles = checkOut( source, baseDestination, fileList, repository.getModule() );\n\n            // write metadata file\n            LocalScmMetadataUtils metadataUtils = new LocalScmMetadataUtils( getLogger() );\n            metadataUtils.writeMetadata( baseDestination, metadataUtils.buildMetadata( source ) );\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking out the files.\", ex );\n        }\n\n        return new LocalCheckOutScmResult( null, checkedOutFiles );\n    }\n\n    private List<ScmFile> checkOut( File source, File baseDestination, List<File> files, String module )\n        throws ScmException, IOException\n    {\n        String sourcePath = source.getAbsolutePath();\n\n        List<ScmFile> checkedOutFiles = new ArrayList<ScmFile>();\n\n        for ( File file : files )\n        {\n            String dest = file.getAbsolutePath();\n\n            dest = dest.substring( sourcePath.length() + 1 );\n\n            File destination = new File( baseDestination, dest );\n\n            destination = destination.getParentFile();\n\n            if ( !destination.exists() && !destination.mkdirs() )\n            {\n                throw new ScmException(\n                    \"Could not create destination directory '\" + destination.getAbsolutePath() + \"'.\" );\n            }\n\n            FileUtils.copyFileToDirectory( file, destination );\n\n            File parent = file.getParentFile();\n\n            // TODO: Add more excludes here\n            if ( parent != null && parent.getName().equals( \"CVS\" ) )\n            {\n                continue;\n            }\n\n            String fileName = \"/\" + module + \"/\" + dest;\n\n            checkedOutFiles.add( new ScmFile( fileName, ScmFileStatus.CHECKED_OUT ) );\n        }\n\n        return checkedOutFiles;\n    }\n\n\n}\n","lineNo":105}
{"Smelly Sample":"package org.apache.maven.scm.provider.local.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckInCommand\n    extends AbstractCheckInCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      ScmVersion version )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !baseDestination.exists() )\n        {\n            throw new ScmException(\n                \"The working directory doesn't exist (\" + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        List checkedInFiles = new ArrayList();\n\n        try\n        {\n            // Only copy files newer than in the repo\n            File repoRoot = new File( repository.getRoot(), repository.getModule() );\n\n            List files = Arrays.asList( fileSet.getFiles() );\n\n            if ( files.isEmpty() )\n            {\n                files = FileUtils.getFiles( baseDestination, \"**\", null, false );\n            }\n\n            Iterator it = files.iterator();\n\n            while ( it.hasNext() )\n            {\n                File file = (File) it.next();\n\n                String path = file.getPath().replace( '\\\\', '/' );\n                File repoFile = new File( repoRoot, path );\n                file = new File( baseDestination, path );\n\n                ScmFileStatus status;\n\n                if ( repoFile.exists() )\n                {\n                    String repoFileContents = FileUtils.fileRead( repoFile );\n\n                    String fileContents = FileUtils.fileRead( file );\n\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"fileContents:\" + fileContents );\n                        getLogger().debug( \"repoFileContents:\" + repoFileContents );\n                    }\n                    if ( fileContents.equals( repoFileContents ) )\n                    {\n                        continue;\n                    }\n\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else if ( repository.isFileAdded( path ) )\n                {\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"skipped unknown file in checkin:\" + path );\n                    }\n                    // unknown file, skip\n                    continue;\n                }\n\n                FileUtils.copyFile( file, repoFile );\n\n                System.err.println( new ScmFile( path, status ) );\n                checkedInFiles.add( new ScmFile( path, status ) );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking in the files.\", ex );\n        }\n\n        return new CheckInScmResult( null, checkedInFiles );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.local.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckInCommand\n    extends AbstractCheckInCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      ScmVersion version )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !baseDestination.exists() )\n        {\n            throw new ScmException(\n                \"The working directory doesn't exist (\" + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        List<ScmFile> checkedInFiles = new ArrayList<ScmFile>();\n\n        try\n        {\n            // Only copy files newer than in the repo\n            File repoRoot = new File( repository.getRoot(), repository.getModule() );\n\n            List<File> files = fileSet.getFileList();\n\n            if ( files.isEmpty() )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<File> listFiles = FileUtils.getFiles( baseDestination, \"**\", null, false ); \n               \n                files = listFiles;\n            }\n\n            for ( File file : files )\n            {\n                String path = file.getPath().replace( '\\\\', '/' );\n                File repoFile = new File( repoRoot, path );\n                file = new File( baseDestination, path );\n\n                ScmFileStatus status;\n\n                if ( repoFile.exists() )\n                {\n                    String repoFileContents = FileUtils.fileRead( repoFile );\n\n                    String fileContents = FileUtils.fileRead( file );\n\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"fileContents:\" + fileContents );\n                        getLogger().debug( \"repoFileContents:\" + repoFileContents );\n                    }\n                    if ( fileContents.equals( repoFileContents ) )\n                    {\n                        continue;\n                    }\n\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else if ( repository.isFileAdded( path ) )\n                {\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"skipped unknown file in checkin:\" + path );\n                    }\n                    // unknown file, skip\n                    continue;\n                }\n\n                FileUtils.copyFile( file, repoFile );\n                ScmFile scmFile = new ScmFile( path, status);\n                getLogger().info( scmFile.toString() );\n                checkedInFiles.add( scmFile );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking in the files.\", ex );\n        }\n\n        return new CheckInScmResult( null, checkedInFiles );\n    }\n}\n","lineNo":96}
{"Smelly Sample":"package org.apache.maven.scm.provider.local.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckInCommand\n    extends AbstractCheckInCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      ScmVersion version )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !baseDestination.exists() )\n        {\n            throw new ScmException(\n                \"The working directory doesn't exist (\" + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        List checkedInFiles = new ArrayList();\n\n        try\n        {\n            // Only copy files newer than in the repo\n            File repoRoot = new File( repository.getRoot(), repository.getModule() );\n\n            List files = Arrays.asList( fileSet.getFiles() );\n\n            if ( files.isEmpty() )\n            {\n                files = FileUtils.getFiles( baseDestination, \"**\", null, false );\n            }\n\n            Iterator it = files.iterator();\n\n            while ( it.hasNext() )\n            {\n                File file = (File) it.next();\n\n                String path = file.getPath().replace( '\\\\', '/' );\n                File repoFile = new File( repoRoot, path );\n                file = new File( baseDestination, path );\n\n                ScmFileStatus status;\n\n                if ( repoFile.exists() )\n                {\n                    String repoFileContents = FileUtils.fileRead( repoFile );\n\n                    String fileContents = FileUtils.fileRead( file );\n\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"fileContents:\" + fileContents );\n                        getLogger().debug( \"repoFileContents:\" + repoFileContents );\n                    }\n                    if ( fileContents.equals( repoFileContents ) )\n                    {\n                        continue;\n                    }\n\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else if ( repository.isFileAdded( path ) )\n                {\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"skipped unknown file in checkin:\" + path );\n                    }\n                    // unknown file, skip\n                    continue;\n                }\n\n                FileUtils.copyFile( file, repoFile );\n\n                System.err.println( new ScmFile( path, status ) );\n                checkedInFiles.add( new ScmFile( path, status ) );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking in the files.\", ex );\n        }\n\n        return new CheckInScmResult( null, checkedInFiles );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.local.command.checkin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.local.command.LocalCommand;\nimport org.apache.maven.scm.provider.local.repository.LocalScmProviderRepository;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckInCommand\n    extends AbstractCheckInCommand\n    implements LocalCommand\n{\n    /** {@inheritDoc} */\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      ScmVersion version )\n        throws ScmException\n    {\n        LocalScmProviderRepository repository = (LocalScmProviderRepository) repo;\n\n        if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n        {\n            throw new ScmException( \"The local scm doesn't support tags.\" );\n        }\n\n        File root = new File( repository.getRoot() );\n\n        String module = repository.getModule();\n\n        File source = new File( root, module );\n\n        File baseDestination = fileSet.getBasedir();\n\n        if ( !baseDestination.exists() )\n        {\n            throw new ScmException(\n                \"The working directory doesn't exist (\" + baseDestination.getAbsolutePath() + \").\" );\n        }\n\n        if ( !root.exists() )\n        {\n            throw new ScmException( \"The base directory doesn't exist (\" + root.getAbsolutePath() + \").\" );\n        }\n\n        if ( !source.exists() )\n        {\n            throw new ScmException( \"The module directory doesn't exist (\" + source.getAbsolutePath() + \").\" );\n        }\n\n        List<ScmFile> checkedInFiles = new ArrayList<ScmFile>();\n\n        try\n        {\n            // Only copy files newer than in the repo\n            File repoRoot = new File( repository.getRoot(), repository.getModule() );\n\n            List<File> files = fileSet.getFileList();\n\n            if ( files.isEmpty() )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<File> listFiles = FileUtils.getFiles( baseDestination, \"**\", null, false ); \n               \n                files = listFiles;\n            }\n\n            for ( File file : files )\n            {\n                String path = file.getPath().replace( '\\\\', '/' );\n                File repoFile = new File( repoRoot, path );\n                file = new File( baseDestination, path );\n\n                ScmFileStatus status;\n\n                if ( repoFile.exists() )\n                {\n                    String repoFileContents = FileUtils.fileRead( repoFile );\n\n                    String fileContents = FileUtils.fileRead( file );\n\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"fileContents:\" + fileContents );\n                        getLogger().debug( \"repoFileContents:\" + repoFileContents );\n                    }\n                    if ( fileContents.equals( repoFileContents ) )\n                    {\n                        continue;\n                    }\n\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else if ( repository.isFileAdded( path ) )\n                {\n                    status = ScmFileStatus.CHECKED_IN;\n                }\n                else\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"skipped unknown file in checkin:\" + path );\n                    }\n                    // unknown file, skip\n                    continue;\n                }\n\n                FileUtils.copyFile( file, repoFile );\n                ScmFile scmFile = new ScmFile( path, status);\n                getLogger().info( scmFile.toString() );\n                checkedInFiles.add( scmFile );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while checking in the files.\", ex );\n        }\n\n        return new CheckInScmResult( null, checkedInFiles );\n    }\n}\n","lineNo":142}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.branch;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmBranchParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.branch.AbstractBranchCommand;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnCommandUtils;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @todo since this is just a copy, use that instead.\n */\npublic class SvnBranchCommand\n    extends AbstractBranchCommand\n    implements SvnCommand\n{\n    \n    public ScmResult executeBranchCommand( ScmProviderRepository repo, ScmFileSet fileSet, String branch, ScmBranchParameters scmBranchParameters )\n    throws ScmException\n    {\n        if ( branch == null || StringUtils.isEmpty( branch.trim() ) )\n        {\n            throw new ScmException( \"branch name must be specified\" );\n        }\n\n        if ( fileSet.getFiles().length != 0 )\n        {\n            throw new ScmException( \"This provider doesn't support branching subsets of a directory\" );\n        }\n\n        SvnScmProviderRepository repository = (SvnScmProviderRepository) repo;\n\n        File messageFile = FileUtils.createTempFile( \"maven-scm-\", \".commit\", null );\n\n        try\n        {\n            FileUtils.fileWrite( messageFile.getAbsolutePath(), scmBranchParameters.getMessage() );\n        }\n        catch ( IOException ex )\n        {\n            return new BranchScmResult( null, \"Error while making a temporary file for the commit message: \"\n                + ex.getMessage(), null, false );\n        }\n\n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), branch, messageFile, scmBranchParameters );\n\n        CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n            getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, stdout, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n        finally\n        {\n            try\n            {\n                FileUtils.forceDelete( messageFile );\n            }\n            catch ( IOException ex )\n            {\n                // ignore\n            }\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new BranchScmResult( cl.toString(), \"The svn branch command failed.\", stderr.getOutput(), false );\n        }\n\n        List fileList = new ArrayList();\n\n        List files = null;\n\n        try\n        {\n            files = FileUtils.getFiles( fileSet.getBasedir(), \"**\", \"**/.svn/**\", false );\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( \"Error while executing command.\", e );\n        }\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File f = (File) i.next();\n\n            fileList.add( new ScmFile( f.getPath(), ScmFileStatus.TAGGED ) );\n        }\n\n        return new BranchScmResult( cl.toString(), fileList );\n    }\n    \n    /** {@inheritDoc} */\n    public ScmResult executeBranchCommand( ScmProviderRepository repo, ScmFileSet fileSet, String branch,\n                                           String message )\n        throws ScmException\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters( message );\n        return executeBranchCommand( repo, fileSet, branch, scmBranchParameters );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 String branch, File messageFile )\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters();\n        scmBranchParameters.setRemoteBranching( false );\n        return createCommandLine( repository, workingDirectory, branch, messageFile, scmBranchParameters );\n    }\n    \n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 String branch, File messageFile, ScmBranchParameters scmBranchParameters )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArg().setValue( \"copy\" );\n\n        cl.createArg().setValue( \"--file\" );\n\n        cl.createArg().setValue( messageFile.getAbsolutePath() );\n\n        if ( scmBranchParameters != null && scmBranchParameters.isRemoteBranching() )\n        {\n            if (StringUtils.isNotBlank( scmBranchParameters.getScmRevision() ) )\n            {\n                cl.createArg().setValue( \"--revision\" );\n                cl.createArg().setValue( scmBranchParameters.getScmRevision() );\n            }\n            cl.createArg().setValue( repository.getUrl() );\n        }\n        else\n        {\n            cl.createArg().setValue( \".\" );\n        }\n        // Note: this currently assumes you have the branch base checked out too\n        String branchUrl = SvnTagBranchUtils.resolveBranchUrl( repository, new ScmBranch( branch ) );\n        cl.createArg().setValue( SvnCommandUtils.fixUrl( branchUrl, repository.getUser() ) );\n\n        return cl;\n    }    \n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.branch;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmBranchParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.branch.AbstractBranchCommand;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnCommandUtils;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author Olivier Lamy\n * @version $Id$\n * @todo since this is just a copy, use that instead.\n */\npublic class SvnBranchCommand\n    extends AbstractBranchCommand\n    implements SvnCommand\n{\n    \n    public ScmResult executeBranchCommand( ScmProviderRepository repo, ScmFileSet fileSet, String branch, ScmBranchParameters scmBranchParameters )\n    throws ScmException\n    {\n        if ( branch == null || StringUtils.isEmpty( branch.trim() ) )\n        {\n            throw new ScmException( \"branch name must be specified\" );\n        }\n\n        if ( fileSet.getFileList().isEmpty() )\n        {\n            throw new ScmException( \"This provider doesn't support branching subsets of a directory\" );\n        }\n\n        SvnScmProviderRepository repository = (SvnScmProviderRepository) repo;\n\n        File messageFile = FileUtils.createTempFile( \"maven-scm-\", \".commit\", null );\n\n        try\n        {\n            FileUtils.fileWrite( messageFile.getAbsolutePath(), scmBranchParameters.getMessage() );\n        }\n        catch ( IOException ex )\n        {\n            return new BranchScmResult( null, \"Error while making a temporary file for the commit message: \"\n                + ex.getMessage(), null, false );\n        }\n\n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), branch, messageFile, scmBranchParameters );\n\n        CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        if ( getLogger().isInfoEnabled() )\n        {\n            getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n            getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n        }\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, stdout, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n        finally\n        {\n            try\n            {\n                FileUtils.forceDelete( messageFile );\n            }\n            catch ( IOException ex )\n            {\n                // ignore\n            }\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new BranchScmResult( cl.toString(), \"The svn branch command failed.\", stderr.getOutput(), false );\n        }\n\n        List<ScmFile> fileList = new ArrayList<ScmFile>();\n\n        List<File> files = null;\n\n        try\n        {\n            @SuppressWarnings( \"unchecked\" )\n            List<File> listFiles = FileUtils.getFiles( fileSet.getBasedir(), \"**\", \"**/.svn/**\", false );\n            files = listFiles;\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( \"Error while executing command.\", e );\n        }\n\n        for ( File f : files )\n        {\n            fileList.add( new ScmFile( f.getPath(), ScmFileStatus.TAGGED ) );\n        }\n\n        return new BranchScmResult( cl.toString(), fileList );\n    }\n    \n    /** {@inheritDoc} */\n    public ScmResult executeBranchCommand( ScmProviderRepository repo, ScmFileSet fileSet, String branch,\n                                           String message )\n        throws ScmException\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters( message );\n        return executeBranchCommand( repo, fileSet, branch, scmBranchParameters );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 String branch, File messageFile )\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters();\n        scmBranchParameters.setRemoteBranching( false );\n        return createCommandLine( repository, workingDirectory, branch, messageFile, scmBranchParameters );\n    }\n    \n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 String branch, File messageFile, ScmBranchParameters scmBranchParameters )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArg().setValue( \"copy\" );\n\n        cl.createArg().setValue( \"--file\" );\n\n        cl.createArg().setValue( messageFile.getAbsolutePath() );\n\n        if ( scmBranchParameters != null && scmBranchParameters.isRemoteBranching() )\n        {\n            if (StringUtils.isNotBlank( scmBranchParameters.getScmRevision() ) )\n            {\n                cl.createArg().setValue( \"--revision\" );\n                cl.createArg().setValue( scmBranchParameters.getScmRevision() );\n            }\n            cl.createArg().setValue( repository.getUrl() );\n        }\n        else\n        {\n            cl.createArg().setValue( \".\" );\n        }\n        // Note: this currently assumes you have the branch base checked out too\n        String branchUrl = SvnTagBranchUtils.resolveBranchUrl( repository, new ScmBranch( branch ) );\n        cl.createArg().setValue( SvnCommandUtils.fixUrl( branchUrl, repository.getUser() ) );\n\n        return cl;\n    }    \n}\n","lineNo":132}
{"Smelly Sample":"package org.apache.maven.scm.manager;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.list.ListScmResult;\nimport org.apache.maven.scm.command.mkdir.MkdirScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmUrlUtils;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmManager\n    implements ScmManager\n{\n    private Map scmProviders = new HashMap();\n\n    private ScmLogger logger;\n\n    private Map userProviderTypes = new HashMap();\n\n    protected void setScmProviders( Map/*<String,ScmProvider>*/ providers )\n    {\n        this.scmProviders = providers;\n    }\n\n    /**\n     * @deprecated use {@link #setScmProvider(String,ScmProvider)} instead\n     */\n    protected void addScmProvider( String providerType, ScmProvider provider )\n    {\n        setScmProvider( providerType, provider );\n    }\n\n    /**\n     * Set a provider to be used for a type of SCM.\n     * If there was already a designed provider for that type it will be replaced.\n     *\n     * @param providerType the type of SCM, eg. <code>svn<\/code>, <code>cvs<\/code>\n     * @param provider     the provider that will be used for that SCM type\n     */\n    public void setScmProvider( String providerType, ScmProvider provider )\n    {\n        scmProviders.put( providerType, provider );\n    }\n\n    protected abstract ScmLogger getScmLogger();\n\n    // ----------------------------------------------------------------------\n    // ScmManager Implementation\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByUrl( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        return getProviderByType( providerType );\n    }\n\n    /** {@inheritDoc} */\n    public void setScmProviderImplementation( String providerType, String providerImplementation )\n    {\n        userProviderTypes.put( providerType, providerImplementation );\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByType( String providerType )\n        throws NoSuchScmProviderException\n    {\n        if ( logger == null )\n        {\n            logger = getScmLogger();\n\n            for ( Iterator i = scmProviders.keySet().iterator(); i.hasNext(); )\n            {\n                String key = (String) i.next();\n\n                ScmProvider p = (ScmProvider) scmProviders.get( key );\n\n                p.addListener( logger );\n            }\n        }\n\n        String usedProviderType = System.getProperty( \"maven.scm.provider.\" + providerType + \".implementation\" );\n\n        if ( usedProviderType == null )\n        {\n            if ( userProviderTypes.containsKey( providerType ) )\n            {\n                usedProviderType = (String) userProviderTypes.get( providerType );\n            }\n            else\n            {\n                usedProviderType = providerType;\n            }\n        }\n\n        ScmProvider scmProvider = (ScmProvider) scmProviders.get( usedProviderType );\n\n        if ( scmProvider == null )\n        {\n            throw new NoSuchScmProviderException( usedProviderType );\n        }\n\n        return scmProvider;\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByRepository( ScmRepository repository )\n        throws NoSuchScmProviderException\n    {\n        return getProviderByType( repository.getProvider() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Repository\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmRepository makeScmRepository( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        char delimiter = ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n        \n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( scmSpecificUrl, delimiter );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /**\n     * Clean the SCM url by removing all ../ in path\n     *\n     * @param scmUrl the SCM url\n     * @return the cleaned SCM url\n     */\n    protected String cleanScmUrl( String scmUrl )\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String pathSeparator = \"\";\n\n        int indexOfDoubleDot = -1;\n\n        // Clean Unix path\n        if ( scmUrl.indexOf( \"../\" ) > 1 )\n        {\n            pathSeparator = \"/\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"../\" );\n        }\n\n        // Clean windows path\n        if ( scmUrl.indexOf( \"..\\\\\" ) > 1 )\n        {\n            pathSeparator = \"\\\\\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"..\\\\\" );\n        }\n\n        if ( indexOfDoubleDot > 1 )\n        {\n            int startOfTextToRemove = scmUrl.substring( 0, indexOfDoubleDot - 1 ).lastIndexOf( pathSeparator );\n\n            String beginUrl = \"\";\n            if ( startOfTextToRemove >= 0 )\n            {\n                beginUrl = scmUrl.substring( 0, startOfTextToRemove );\n            }\n\n            String endUrl = scmUrl.substring( indexOfDoubleDot + 3 );\n\n            scmUrl = beginUrl + pathSeparator + endUrl;\n\n            // Check if we have other double dot\n            if ( scmUrl.indexOf( \"../\" ) > 1 || scmUrl.indexOf( \"..\\\\\" ) > 1 )\n            {\n                scmUrl = cleanScmUrl( scmUrl );\n            }\n        }\n\n        return scmUrl;\n    }\n\n    /** {@inheritDoc} */\n    public ScmRepository makeProviderScmRepository( String providerType, File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure, NoSuchScmProviderException\n    {\n        if ( providerType == null )\n        {\n            throw new NullPointerException( \"The provider type cannot be null.\" );\n        }\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( path );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /** {@inheritDoc} */\n    public List validateScmRepository( String scmUrl )\n    {\n        List messages = new ArrayList();\n\n        messages.addAll( ScmUrlUtils.validate( scmUrl ) );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider;\n\n        try\n        {\n            provider = getProviderByType( providerType );\n        }\n        catch ( NoSuchScmProviderException e )\n        {\n            messages.add( \"No such provider installed '\" + providerType + \"'.\" );\n\n            return messages;\n        }\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        List providerMessages =\n            provider.validateScmUrl( scmSpecificUrl, ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 ) );\n\n        if ( providerMessages == null )\n        {\n            throw new RuntimeException( \"The SCM provider cannot return null from validateScmUrl().\" );\n        }\n\n        messages.addAll( providerMessages );\n\n        return messages;\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName, message );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                                         ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startRevision,\n                                         ScmVersion endRevision, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startRevision, endRevision,\n                                                                     datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, ScmVersion revision, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, revision, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                       boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public DiffScmResult diff( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                               ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).diff( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public EditScmResult edit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).edit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, (ScmVersion) null,\n                                                                  outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version, outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ListScmResult list( ScmRepository repository, ScmFileSet fileSet, boolean recursive, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).list( repository, fileSet, recursive, version );\n    }\n\n    /** {@inheritDoc} */\n    public MkdirScmResult mkdir( ScmRepository repository, ScmFileSet fileSet, String message, boolean createInLocal )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).mkdir( repository, fileSet, message, createInLocal );\n    }\n    \n    /** {@inheritDoc} */\n    public RemoveScmResult remove( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).remove( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public StatusScmResult status( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).status( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).tag( repository, fileSet, tagName );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).tag( repository, fileSet, tagName, message );\n    }\n\n    /** {@inheritDoc} */\n    public UnEditScmResult unedit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).unedit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate,\n                                                                  datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate,\n                                                                  datePattern );\n    }\n\n     /** {@inheritDoc} */\n    public BlameScmResult blame( ScmRepository repository, ScmFileSet fileSet, String filename )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).blame( repository, fileSet, filename );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.manager;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmBranchParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.list.ListScmResult;\nimport org.apache.maven.scm.command.mkdir.MkdirScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmUrlUtils;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmManager\n    implements ScmManager\n{\n    private Map<String,ScmProvider> scmProviders = new HashMap<String,ScmProvider>();\n\n    private ScmLogger logger;\n\n    private Map<String,String> userProviderTypes = new HashMap<String,String>();\n\n    protected void setScmProviders( Map<String,ScmProvider> providers )\n    {\n        this.scmProviders = providers;\n    }\n\n    /**\n     * @deprecated use {@link #setScmProvider(String,ScmProvider)} instead\n     */\n    protected void addScmProvider( String providerType, ScmProvider provider )\n    {\n        setScmProvider( providerType, provider );\n    }\n\n    /**\n     * Set a provider to be used for a type of SCM.\n     * If there was already a designed provider for that type it will be replaced.\n     *\n     * @param providerType the type of SCM, eg. <code>svn<\/code>, <code>cvs<\/code>\n     * @param provider     the provider that will be used for that SCM type\n     */\n    public void setScmProvider( String providerType, ScmProvider provider )\n    {\n        scmProviders.put( providerType, provider );\n    }\n\n    protected abstract ScmLogger getScmLogger();\n\n    // ----------------------------------------------------------------------\n    // ScmManager Implementation\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByUrl( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        return getProviderByType( providerType );\n    }\n\n    /** {@inheritDoc} */\n    public void setScmProviderImplementation( String providerType, String providerImplementation )\n    {\n        userProviderTypes.put( providerType, providerImplementation );\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByType( String providerType )\n        throws NoSuchScmProviderException\n    {\n        if ( logger == null )\n        {\n            logger = getScmLogger();\n\n            for ( Entry<String,ScmProvider> entry : scmProviders.entrySet() )\n            {\n                ScmProvider p = scmProviders.get( entry.getKey() );\n\n                p.addListener( logger );\n            }\n        }\n\n        String usedProviderType = System.getProperty( \"maven.scm.provider.\" + providerType + \".implementation\" );\n\n        if ( usedProviderType == null )\n        {\n            if ( userProviderTypes.containsKey( providerType ) )\n            {\n                usedProviderType = (String) userProviderTypes.get( providerType );\n            }\n            else\n            {\n                usedProviderType = providerType;\n            }\n        }\n\n        ScmProvider scmProvider = (ScmProvider) scmProviders.get( usedProviderType );\n\n        if ( scmProvider == null )\n        {\n            throw new NoSuchScmProviderException( usedProviderType );\n        }\n\n        return scmProvider;\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByRepository( ScmRepository repository )\n        throws NoSuchScmProviderException\n    {\n        return getProviderByType( repository.getProvider() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Repository\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmRepository makeScmRepository( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        char delimiter = ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n        \n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( scmSpecificUrl, delimiter );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /**\n     * Clean the SCM url by removing all ../ in path\n     *\n     * @param scmUrl the SCM url\n     * @return the cleaned SCM url\n     */\n    protected String cleanScmUrl( String scmUrl )\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String pathSeparator = \"\";\n\n        int indexOfDoubleDot = -1;\n\n        // Clean Unix path\n        if ( scmUrl.indexOf( \"../\" ) > 1 )\n        {\n            pathSeparator = \"/\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"../\" );\n        }\n\n        // Clean windows path\n        if ( scmUrl.indexOf( \"..\\\\\" ) > 1 )\n        {\n            pathSeparator = \"\\\\\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"..\\\\\" );\n        }\n\n        if ( indexOfDoubleDot > 1 )\n        {\n            int startOfTextToRemove = scmUrl.substring( 0, indexOfDoubleDot - 1 ).lastIndexOf( pathSeparator );\n\n            String beginUrl = \"\";\n            if ( startOfTextToRemove >= 0 )\n            {\n                beginUrl = scmUrl.substring( 0, startOfTextToRemove );\n            }\n\n            String endUrl = scmUrl.substring( indexOfDoubleDot + 3 );\n\n            scmUrl = beginUrl + pathSeparator + endUrl;\n\n            // Check if we have other double dot\n            if ( scmUrl.indexOf( \"../\" ) > 1 || scmUrl.indexOf( \"..\\\\\" ) > 1 )\n            {\n                scmUrl = cleanScmUrl( scmUrl );\n            }\n        }\n\n        return scmUrl;\n    }\n\n    /** {@inheritDoc} */\n    public ScmRepository makeProviderScmRepository( String providerType, File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure, NoSuchScmProviderException\n    {\n        if ( providerType == null )\n        {\n            throw new NullPointerException( \"The provider type cannot be null.\" );\n        }\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( path );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /** {@inheritDoc} */\n    public List<String> validateScmRepository( String scmUrl )\n    {\n        List<String> messages = new ArrayList<String>();\n\n        messages.addAll( ScmUrlUtils.validate( scmUrl ) );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider;\n\n        try\n        {\n            provider = getProviderByType( providerType );\n        }\n        catch ( NoSuchScmProviderException e )\n        {\n            messages.add( \"No such provider installed '\" + providerType + \"'.\" );\n\n            return messages;\n        }\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        List<String> providerMessages =\n            provider.validateScmUrl( scmSpecificUrl, ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 ) );\n\n        if ( providerMessages == null )\n        {\n            throw new RuntimeException( \"The SCM provider cannot return null from validateScmUrl().\" );\n        }\n\n        messages.addAll( providerMessages );\n\n        return messages;\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName )\n        throws ScmException\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters( \"\" );\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName, scmBranchParameters );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName, String message )\n        throws ScmException\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters( message );\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName, scmBranchParameters );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                                         ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startRevision,\n                                         ScmVersion endRevision, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startRevision, endRevision,\n                                                                     datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, ScmVersion revision, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, revision, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                       boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public DiffScmResult diff( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                               ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).diff( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public EditScmResult edit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).edit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, (ScmVersion) null,\n                                                                  outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version, outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ListScmResult list( ScmRepository repository, ScmFileSet fileSet, boolean recursive, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).list( repository, fileSet, recursive, version );\n    }\n\n    /** {@inheritDoc} */\n    public MkdirScmResult mkdir( ScmRepository repository, ScmFileSet fileSet, String message, boolean createInLocal )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).mkdir( repository, fileSet, message, createInLocal );\n    }\n    \n    /** {@inheritDoc} */\n    public RemoveScmResult remove( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).remove( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public StatusScmResult status( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).status( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName )\n        throws ScmException\n    {\n        return this.tag( repository, fileSet, tagName, \"\" );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName, String message )\n        throws ScmException\n    {\n        ScmTagParameters scmTagParameters = new ScmTagParameters( message );\n        return this.getProviderByRepository( repository ).tag( repository, fileSet, tagName, scmTagParameters );\n    }\n\n    /** {@inheritDoc} */\n    public UnEditScmResult unedit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).unedit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate,\n                                                                  datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate,\n                                                                  datePattern );\n    }\n\n     /** {@inheritDoc} */\n    public BlameScmResult blame( ScmRepository repository, ScmFileSet fileSet, String filename )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).blame( repository, fileSet, filename );\n    }\n}\n","lineNo":335}
{"Smelly Sample":"package org.apache.maven.scm.manager;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.list.ListScmResult;\nimport org.apache.maven.scm.command.mkdir.MkdirScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmUrlUtils;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmManager\n    implements ScmManager\n{\n    private Map scmProviders = new HashMap();\n\n    private ScmLogger logger;\n\n    private Map userProviderTypes = new HashMap();\n\n    protected void setScmProviders( Map/*<String,ScmProvider>*/ providers )\n    {\n        this.scmProviders = providers;\n    }\n\n    /**\n     * @deprecated use {@link #setScmProvider(String,ScmProvider)} instead\n     */\n    protected void addScmProvider( String providerType, ScmProvider provider )\n    {\n        setScmProvider( providerType, provider );\n    }\n\n    /**\n     * Set a provider to be used for a type of SCM.\n     * If there was already a designed provider for that type it will be replaced.\n     *\n     * @param providerType the type of SCM, eg. <code>svn<\/code>, <code>cvs<\/code>\n     * @param provider     the provider that will be used for that SCM type\n     */\n    public void setScmProvider( String providerType, ScmProvider provider )\n    {\n        scmProviders.put( providerType, provider );\n    }\n\n    protected abstract ScmLogger getScmLogger();\n\n    // ----------------------------------------------------------------------\n    // ScmManager Implementation\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByUrl( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        return getProviderByType( providerType );\n    }\n\n    /** {@inheritDoc} */\n    public void setScmProviderImplementation( String providerType, String providerImplementation )\n    {\n        userProviderTypes.put( providerType, providerImplementation );\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByType( String providerType )\n        throws NoSuchScmProviderException\n    {\n        if ( logger == null )\n        {\n            logger = getScmLogger();\n\n            for ( Iterator i = scmProviders.keySet().iterator(); i.hasNext(); )\n            {\n                String key = (String) i.next();\n\n                ScmProvider p = (ScmProvider) scmProviders.get( key );\n\n                p.addListener( logger );\n            }\n        }\n\n        String usedProviderType = System.getProperty( \"maven.scm.provider.\" + providerType + \".implementation\" );\n\n        if ( usedProviderType == null )\n        {\n            if ( userProviderTypes.containsKey( providerType ) )\n            {\n                usedProviderType = (String) userProviderTypes.get( providerType );\n            }\n            else\n            {\n                usedProviderType = providerType;\n            }\n        }\n\n        ScmProvider scmProvider = (ScmProvider) scmProviders.get( usedProviderType );\n\n        if ( scmProvider == null )\n        {\n            throw new NoSuchScmProviderException( usedProviderType );\n        }\n\n        return scmProvider;\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByRepository( ScmRepository repository )\n        throws NoSuchScmProviderException\n    {\n        return getProviderByType( repository.getProvider() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Repository\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmRepository makeScmRepository( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        char delimiter = ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n        \n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( scmSpecificUrl, delimiter );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /**\n     * Clean the SCM url by removing all ../ in path\n     *\n     * @param scmUrl the SCM url\n     * @return the cleaned SCM url\n     */\n    protected String cleanScmUrl( String scmUrl )\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String pathSeparator = \"\";\n\n        int indexOfDoubleDot = -1;\n\n        // Clean Unix path\n        if ( scmUrl.indexOf( \"../\" ) > 1 )\n        {\n            pathSeparator = \"/\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"../\" );\n        }\n\n        // Clean windows path\n        if ( scmUrl.indexOf( \"..\\\\\" ) > 1 )\n        {\n            pathSeparator = \"\\\\\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"..\\\\\" );\n        }\n\n        if ( indexOfDoubleDot > 1 )\n        {\n            int startOfTextToRemove = scmUrl.substring( 0, indexOfDoubleDot - 1 ).lastIndexOf( pathSeparator );\n\n            String beginUrl = \"\";\n            if ( startOfTextToRemove >= 0 )\n            {\n                beginUrl = scmUrl.substring( 0, startOfTextToRemove );\n            }\n\n            String endUrl = scmUrl.substring( indexOfDoubleDot + 3 );\n\n            scmUrl = beginUrl + pathSeparator + endUrl;\n\n            // Check if we have other double dot\n            if ( scmUrl.indexOf( \"../\" ) > 1 || scmUrl.indexOf( \"..\\\\\" ) > 1 )\n            {\n                scmUrl = cleanScmUrl( scmUrl );\n            }\n        }\n\n        return scmUrl;\n    }\n\n    /** {@inheritDoc} */\n    public ScmRepository makeProviderScmRepository( String providerType, File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure, NoSuchScmProviderException\n    {\n        if ( providerType == null )\n        {\n            throw new NullPointerException( \"The provider type cannot be null.\" );\n        }\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( path );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /** {@inheritDoc} */\n    public List validateScmRepository( String scmUrl )\n    {\n        List messages = new ArrayList();\n\n        messages.addAll( ScmUrlUtils.validate( scmUrl ) );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider;\n\n        try\n        {\n            provider = getProviderByType( providerType );\n        }\n        catch ( NoSuchScmProviderException e )\n        {\n            messages.add( \"No such provider installed '\" + providerType + \"'.\" );\n\n            return messages;\n        }\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        List providerMessages =\n            provider.validateScmUrl( scmSpecificUrl, ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 ) );\n\n        if ( providerMessages == null )\n        {\n            throw new RuntimeException( \"The SCM provider cannot return null from validateScmUrl().\" );\n        }\n\n        messages.addAll( providerMessages );\n\n        return messages;\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName, message );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                                         ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startRevision,\n                                         ScmVersion endRevision, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startRevision, endRevision,\n                                                                     datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, ScmVersion revision, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, revision, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                       boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public DiffScmResult diff( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                               ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).diff( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public EditScmResult edit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).edit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, (ScmVersion) null,\n                                                                  outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version, outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ListScmResult list( ScmRepository repository, ScmFileSet fileSet, boolean recursive, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).list( repository, fileSet, recursive, version );\n    }\n\n    /** {@inheritDoc} */\n    public MkdirScmResult mkdir( ScmRepository repository, ScmFileSet fileSet, String message, boolean createInLocal )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).mkdir( repository, fileSet, message, createInLocal );\n    }\n    \n    /** {@inheritDoc} */\n    public RemoveScmResult remove( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).remove( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public StatusScmResult status( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).status( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).tag( repository, fileSet, tagName );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).tag( repository, fileSet, tagName, message );\n    }\n\n    /** {@inheritDoc} */\n    public UnEditScmResult unedit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).unedit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate,\n                                                                  datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate,\n                                                                  datePattern );\n    }\n\n     /** {@inheritDoc} */\n    public BlameScmResult blame( ScmRepository repository, ScmFileSet fileSet, String filename )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).blame( repository, fileSet, filename );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.manager;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmBranchParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.list.ListScmResult;\nimport org.apache.maven.scm.command.mkdir.MkdirScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmUrlUtils;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmManager\n    implements ScmManager\n{\n    private Map<String,ScmProvider> scmProviders = new HashMap<String,ScmProvider>();\n\n    private ScmLogger logger;\n\n    private Map<String,String> userProviderTypes = new HashMap<String,String>();\n\n    protected void setScmProviders( Map<String,ScmProvider> providers )\n    {\n        this.scmProviders = providers;\n    }\n\n    /**\n     * @deprecated use {@link #setScmProvider(String,ScmProvider)} instead\n     */\n    protected void addScmProvider( String providerType, ScmProvider provider )\n    {\n        setScmProvider( providerType, provider );\n    }\n\n    /**\n     * Set a provider to be used for a type of SCM.\n     * If there was already a designed provider for that type it will be replaced.\n     *\n     * @param providerType the type of SCM, eg. <code>svn<\/code>, <code>cvs<\/code>\n     * @param provider     the provider that will be used for that SCM type\n     */\n    public void setScmProvider( String providerType, ScmProvider provider )\n    {\n        scmProviders.put( providerType, provider );\n    }\n\n    protected abstract ScmLogger getScmLogger();\n\n    // ----------------------------------------------------------------------\n    // ScmManager Implementation\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByUrl( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        return getProviderByType( providerType );\n    }\n\n    /** {@inheritDoc} */\n    public void setScmProviderImplementation( String providerType, String providerImplementation )\n    {\n        userProviderTypes.put( providerType, providerImplementation );\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByType( String providerType )\n        throws NoSuchScmProviderException\n    {\n        if ( logger == null )\n        {\n            logger = getScmLogger();\n\n            for ( Entry<String,ScmProvider> entry : scmProviders.entrySet() )\n            {\n                ScmProvider p = scmProviders.get( entry.getKey() );\n\n                p.addListener( logger );\n            }\n        }\n\n        String usedProviderType = System.getProperty( \"maven.scm.provider.\" + providerType + \".implementation\" );\n\n        if ( usedProviderType == null )\n        {\n            if ( userProviderTypes.containsKey( providerType ) )\n            {\n                usedProviderType = (String) userProviderTypes.get( providerType );\n            }\n            else\n            {\n                usedProviderType = providerType;\n            }\n        }\n\n        ScmProvider scmProvider = (ScmProvider) scmProviders.get( usedProviderType );\n\n        if ( scmProvider == null )\n        {\n            throw new NoSuchScmProviderException( usedProviderType );\n        }\n\n        return scmProvider;\n    }\n\n    /** {@inheritDoc} */\n    public ScmProvider getProviderByRepository( ScmRepository repository )\n        throws NoSuchScmProviderException\n    {\n        return getProviderByType( repository.getProvider() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Repository\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public ScmRepository makeScmRepository( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        char delimiter = ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n        \n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( scmSpecificUrl, delimiter );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /**\n     * Clean the SCM url by removing all ../ in path\n     *\n     * @param scmUrl the SCM url\n     * @return the cleaned SCM url\n     */\n    protected String cleanScmUrl( String scmUrl )\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String pathSeparator = \"\";\n\n        int indexOfDoubleDot = -1;\n\n        // Clean Unix path\n        if ( scmUrl.indexOf( \"../\" ) > 1 )\n        {\n            pathSeparator = \"/\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"../\" );\n        }\n\n        // Clean windows path\n        if ( scmUrl.indexOf( \"..\\\\\" ) > 1 )\n        {\n            pathSeparator = \"\\\\\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"..\\\\\" );\n        }\n\n        if ( indexOfDoubleDot > 1 )\n        {\n            int startOfTextToRemove = scmUrl.substring( 0, indexOfDoubleDot - 1 ).lastIndexOf( pathSeparator );\n\n            String beginUrl = \"\";\n            if ( startOfTextToRemove >= 0 )\n            {\n                beginUrl = scmUrl.substring( 0, startOfTextToRemove );\n            }\n\n            String endUrl = scmUrl.substring( indexOfDoubleDot + 3 );\n\n            scmUrl = beginUrl + pathSeparator + endUrl;\n\n            // Check if we have other double dot\n            if ( scmUrl.indexOf( \"../\" ) > 1 || scmUrl.indexOf( \"..\\\\\" ) > 1 )\n            {\n                scmUrl = cleanScmUrl( scmUrl );\n            }\n        }\n\n        return scmUrl;\n    }\n\n    /** {@inheritDoc} */\n    public ScmRepository makeProviderScmRepository( String providerType, File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure, NoSuchScmProviderException\n    {\n        if ( providerType == null )\n        {\n            throw new NullPointerException( \"The provider type cannot be null.\" );\n        }\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( path );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    /** {@inheritDoc} */\n    public List<String> validateScmRepository( String scmUrl )\n    {\n        List<String> messages = new ArrayList<String>();\n\n        messages.addAll( ScmUrlUtils.validate( scmUrl ) );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider;\n\n        try\n        {\n            provider = getProviderByType( providerType );\n        }\n        catch ( NoSuchScmProviderException e )\n        {\n            messages.add( \"No such provider installed '\" + providerType + \"'.\" );\n\n            return messages;\n        }\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        List<String> providerMessages =\n            provider.validateScmUrl( scmSpecificUrl, ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 ) );\n\n        if ( providerMessages == null )\n        {\n            throw new RuntimeException( \"The SCM provider cannot return null from validateScmUrl().\" );\n        }\n\n        messages.addAll( providerMessages );\n\n        return messages;\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public AddScmResult add( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).add( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName )\n        throws ScmException\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters( \"\" );\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName, scmBranchParameters );\n    }\n\n    /** {@inheritDoc} */\n    public BranchScmResult branch( ScmRepository repository, ScmFileSet fileSet, String branchName, String message )\n        throws ScmException\n    {\n        ScmBranchParameters scmBranchParameters = new ScmBranchParameters( message );\n        return this.getProviderByRepository( repository ).branch( repository, fileSet, branchName, scmBranchParameters );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, Date startDate, Date endDate,\n                                         int numDays, ScmBranch branch, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startDate, endDate, numDays,\n                                                                     branch, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                                         ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changeLog( ScmRepository repository, ScmFileSet fileSet, ScmVersion startRevision,\n                                         ScmVersion endRevision, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).changeLog( repository, fileSet, startRevision, endRevision,\n                                                                     datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkIn( ScmRepository repository, ScmFileSet fileSet, ScmVersion revision, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkIn( repository, fileSet, revision, message );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkOut( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                       boolean recursive )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).checkOut( repository, fileSet, version, recursive );\n    }\n\n    /** {@inheritDoc} */\n    public DiffScmResult diff( ScmRepository repository, ScmFileSet fileSet, ScmVersion startVersion,\n                               ScmVersion endVersion )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).diff( repository, fileSet, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    public EditScmResult edit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).edit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, (ScmVersion) null,\n                                                                  outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ExportScmResult export( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String outputDirectory )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).export( repository, fileSet, version, outputDirectory );\n    }\n\n    /** {@inheritDoc} */\n    public ListScmResult list( ScmRepository repository, ScmFileSet fileSet, boolean recursive, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).list( repository, fileSet, recursive, version );\n    }\n\n    /** {@inheritDoc} */\n    public MkdirScmResult mkdir( ScmRepository repository, ScmFileSet fileSet, String message, boolean createInLocal )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).mkdir( repository, fileSet, message, createInLocal );\n    }\n    \n    /** {@inheritDoc} */\n    public RemoveScmResult remove( ScmRepository repository, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).remove( repository, fileSet, message );\n    }\n\n    /** {@inheritDoc} */\n    public StatusScmResult status( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).status( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName )\n        throws ScmException\n    {\n        return this.tag( repository, fileSet, tagName, \"\" );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmRepository repository, ScmFileSet fileSet, String tagName, String message )\n        throws ScmException\n    {\n        ScmTagParameters scmTagParameters = new ScmTagParameters( message );\n        return this.getProviderByRepository( repository ).tag( repository, fileSet, tagName, scmTagParameters );\n    }\n\n    /** {@inheritDoc} */\n    public UnEditScmResult unedit( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).unedit( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   boolean runChangelog )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, runChangelog );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, Date lastUpdate, String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, (ScmVersion) null, lastUpdate,\n                                                                  datePattern );\n    }\n\n    /** {@inheritDoc} */\n    public UpdateScmResult update( ScmRepository repository, ScmFileSet fileSet, ScmVersion version, Date lastUpdate,\n                                   String datePattern )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).update( repository, fileSet, version, lastUpdate,\n                                                                  datePattern );\n    }\n\n     /** {@inheritDoc} */\n    public BlameScmResult blame( ScmRepository repository, ScmFileSet fileSet, String filename )\n        throws ScmException\n    {\n        return this.getProviderByRepository( repository ).blame( repository, fileSet, filename );\n    }\n}\n","lineNo":501}
{"Smelly Sample":"package org.apache.maven.scm;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Set of files used for SCM operations.\n * Consists of the base directory of the files and a list of files relative to that directory.\n *\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @version $Id$\n */\npublic class ScmFileSet\n    implements Serializable\n{\n    private static final long serialVersionUID = -5978597349974797556L;\n\n    private static final String DELIMITER = \",\";\n    \n    /** @see DirectoryScanner#DEFAULTEXCLUDES */\n    private static final String DEFAULT_EXCLUDES = StringUtils.join( DirectoryScanner.DEFAULTEXCLUDES, DELIMITER );\n\n    private final File basedir;\n\n    private String includes;\n\n    private String excludes;\n\n    /**\n     * List of File objects, all relative to the basedir.\n     */\n    private final List files;\n\n    /**\n     * Create a file set with no files, only the base directory.\n     *\n     * @param basedir directory files in the set are relative to\n     */\n    public ScmFileSet( File basedir )\n    {\n        this( basedir, new ArrayList( 0 ) );\n    }\n\n    /**\n     * Create a file set with only the file provided, relative to basedir.\n     *\n     * @param basedir directory file is relative to\n     * @param file    file that the set will contain, has to be relative to basedir\n     */\n    public ScmFileSet( File basedir, File file )\n    {\n        this( basedir, new File[]{file} );\n    }\n\n    /**\n     * Create a file set with only files (not directories) from basefile,\n     * using includes and excludes provided.\n     *\n     * @param basedir  directory files are relative to\n     * @param includes Ant pattern for files to include\n     * @param excludes Ant pattern for files to exclude,\n     *                 if null DEFAULT_EXCLUDES is used, else DEFAULT_EXCLUDES is added.\n     * @throws IOException if any\n     */\n    public ScmFileSet( File basedir, String includes, String excludes )\n        throws IOException\n    {\n        this.basedir = basedir;\n\n        if ( excludes != null && excludes.length() > 0 )\n        {\n            excludes += DELIMITER + DEFAULT_EXCLUDES;\n        }\n        else\n        {\n            excludes = DEFAULT_EXCLUDES;\n        }\n\n        this.files = FileUtils.getFiles( basedir, includes, excludes, false );\n        this.includes = includes;\n        this.excludes = excludes;\n    }\n\n    /**\n     * Create a file set with files from basefile, using includes provided and default excludes.\n     *\n     * @param basedir  directory files are relative to\n     * @param includes Ant pattern for files to include\n     * @throws IOException if any\n     * @since 1.0\n     */\n    public ScmFileSet( File basedir, String includes )\n        throws IOException\n    {\n        this( basedir, includes, null );\n    }\n\n    /**\n     * Create a file set with the files provided, relative to basedir.\n     *\n     * @param basedir directory files are relative to\n     * @param files   files that the set will contain, have to be relative to basedir\n     * @deprecated use ScmFileSet( File, List )\n     */\n    public ScmFileSet( File basedir, File[] files )\n    {\n        this( basedir, Arrays.asList( files ) );\n    }\n\n    /**\n     * Create a file set with the files provided, relative to basedir.\n     *\n     * @param basedir directory files are relative to\n     * @param files   list of File objects, files that the set will contain, have to be relative to basedir\n     */\n    public ScmFileSet( File basedir, List files )\n    {\n        if ( basedir == null )\n        {\n            throw new NullPointerException( \"basedir must not be null\" );\n        }\n\n        if ( files == null )\n        {\n            throw new NullPointerException( \"files must not be null\" );\n        }\n\n        this.basedir = basedir;\n        this.files = files;\n    }\n\n    /**\n     * Get the base directory of the file set. It's the directory files in the set are relative to.\n     *\n     * @return base directory\n     */\n    public File getBasedir()\n    {\n        return basedir;\n    }\n\n    /**\n     * Get the list of files in the set, relative to basedir\n     *\n     * @return files in this set\n     * @deprecated use getFileList() instead\n     */\n    public File[] getFiles()\n    {\n        return (File[]) this.files.toArray( new File[0] );\n    }\n\n    /**\n     * Get the list of files in the set, relative to basedir\n     *\n     * @return List of File objects\n     */\n    public List getFileList()\n    {\n        return this.files;\n    }\n\n\n    /**\n     * @return the includes files as a comma separated string\n     */\n    public String getIncludes()\n    {\n        return this.includes;\n    }\n\n\n    /**\n     * @return the excludes files as a comma separated string\n     */\n    public String getExcludes()\n    {\n        return this.excludes;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        return \"basedir = \" + basedir + \"; files = \" + files;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Set of files used for SCM operations.\n * Consists of the base directory of the files and a list of files relative to that directory.\n *\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @version $Id$\n */\npublic class ScmFileSet\n    implements Serializable\n{\n    private static final long serialVersionUID = -5978597349974797556L;\n\n    private static final String DELIMITER = \",\";\n    \n    /** @see DirectoryScanner#DEFAULTEXCLUDES */\n    private static final String DEFAULT_EXCLUDES = StringUtils.join( DirectoryScanner.DEFAULTEXCLUDES, DELIMITER );\n\n    private final File basedir;\n\n    private String includes;\n\n    private String excludes;\n\n    /**\n     * List of File objects, all relative to the basedir.\n     */\n    private final List<File> files;\n\n    /**\n     * Create a file set with no files, only the base directory.\n     *\n     * @param basedir directory files in the set are relative to\n     */\n    public ScmFileSet( File basedir )\n    {\n        this( basedir, new ArrayList<File>( 0 ) );\n    }\n\n    /**\n     * Create a file set with only the file provided, relative to basedir.\n     *\n     * @param basedir directory file is relative to\n     * @param file    file that the set will contain, has to be relative to basedir\n     */\n    public ScmFileSet( File basedir, File file )\n    {\n        this( basedir, new File[]{file} );\n    }\n\n    /**\n     * Create a file set with only files (not directories) from basefile,\n     * using includes and excludes provided.\n     *\n     * @param basedir  directory files are relative to\n     * @param includes Ant pattern for files to include\n     * @param excludes Ant pattern for files to exclude,\n     *                 if null DEFAULT_EXCLUDES is used, else DEFAULT_EXCLUDES is added.\n     * @throws IOException if any\n     */\n    public ScmFileSet( File basedir, String includes, String excludes )\n        throws IOException\n    {\n        this.basedir = basedir;\n\n        if ( excludes != null && excludes.length() > 0 )\n        {\n            excludes += DELIMITER + DEFAULT_EXCLUDES;\n        }\n        else\n        {\n            excludes = DEFAULT_EXCLUDES;\n        }\n        @SuppressWarnings( \"unchecked\" )\n        List<File> fileList = (List<File>) FileUtils.getFiles( basedir, includes, excludes, false ); \n        this.files = fileList;\n        this.includes = includes;\n        this.excludes = excludes;\n    }\n\n    /**\n     * Create a file set with files from basefile, using includes provided and default excludes.\n     *\n     * @param basedir  directory files are relative to\n     * @param includes Ant pattern for files to include\n     * @throws IOException if any\n     * @since 1.0\n     */\n    public ScmFileSet( File basedir, String includes )\n        throws IOException\n    {\n        this( basedir, includes, null );\n    }\n\n    /**\n     * Create a file set with the files provided, relative to basedir.\n     *\n     * @param basedir directory files are relative to\n     * @param files   files that the set will contain, have to be relative to basedir\n     * @deprecated use ScmFileSet( File, List )\n     */\n    public ScmFileSet( File basedir, File[] files )\n    {\n        this( basedir, Arrays.asList( files ) );\n    }\n\n    /**\n     * Create a file set with the files provided, relative to basedir.\n     *\n     * @param basedir directory files are relative to\n     * @param files   list of File objects, files that the set will contain, have to be relative to basedir\n     */\n    public ScmFileSet( File basedir, List<File> files )\n    {\n        if ( basedir == null )\n        {\n            throw new NullPointerException( \"basedir must not be null\" );\n        }\n\n        if ( files == null )\n        {\n            throw new NullPointerException( \"files must not be null\" );\n        }\n\n        this.basedir = basedir;\n        this.files = files;\n    }\n\n    /**\n     * Get the base directory of the file set. It's the directory files in the set are relative to.\n     *\n     * @return base directory\n     */\n    public File getBasedir()\n    {\n        return basedir;\n    }\n\n    /**\n     * Get the list of files in the set, relative to basedir\n     *\n     * @return files in this set\n     * @deprecated use getFileList() instead\n     */\n    public File[] getFiles()\n    {\n        return (File[]) this.files.toArray( new File[0] );\n    }\n\n    /**\n     * Get the list of files in the set, relative to basedir\n     *\n     * @return List of File objects\n     */\n    public List<File> getFileList()\n    {\n        return this.files;\n    }\n\n\n    /**\n     * @return the includes files as a comma separated string\n     */\n    public String getIncludes()\n    {\n        return this.includes;\n    }\n\n\n    /**\n     * @return the excludes files as a comma separated string\n     */\n    public String getExcludes()\n    {\n        return this.excludes;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        return \"basedir = \" + basedir + \"; files = \" + files;\n    }\n}\n","lineNo":106}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmRevision;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.cli.AccuRevCommandLine;\nimport org.apache.maven.scm.provider.accurev.command.add.AccuRevAddCommand;\nimport org.apache.maven.scm.provider.accurev.command.blame.AccuRevBlameCommand;\nimport org.apache.maven.scm.provider.accurev.command.changelog.AccuRevChangeLogCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkin.AccuRevCheckInCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkout.AccuRevCheckOutCommand;\nimport org.apache.maven.scm.provider.accurev.command.export.AccuRevExportCommand;\nimport org.apache.maven.scm.provider.accurev.command.login.AccuRevLoginCommand;\nimport org.apache.maven.scm.provider.accurev.command.remove.AccuRevRemoveCommand;\nimport org.apache.maven.scm.provider.accurev.command.status.AccuRevStatusCommand;\nimport org.apache.maven.scm.provider.accurev.command.tag.AccuRevTagCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateScmResult;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * AccuRev integration with Maven SCM\n * \n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"accurev\"\n */\npublic class AccuRevScmProvider\n    extends AbstractScmProvider\n{\n\n    public String getScmType()\n    {\n        return \"accurev\";\n    }\n\n    /**\n     * The basic url parsing approach is to be as loose as possible. If you specify as per the docs\n     * you'll get what you expect. If you do something else the result is undefined. Don't use \"/\"\n     * \"\\\" or \"@\" as the delimiter,\n     */\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n\n        List<String> validationMessages = new ArrayList<String>();\n\n        String[] tokens = StringUtils.split( scmSpecificUrl, Character.toString( delimiter ) );\n\n        //[[user][/pass]@host[:port]][:stream][:\\project\\dir]\n\n        String basisStream = null;\n        String projectPath = null;\n        int port = AccuRevScmProviderRepository.DEFAULT_PORT;\n        String host = null;\n        String user = null;\n        String password = null;\n\n        int i = 0;\n        while ( i < tokens.length )\n        {\n            int at = tokens[i].indexOf( '@' );\n            // prefer \"/\", better not have a \"/\" or a \"\\\\\" in your password.\n            int slash = tokens[i].indexOf( '/' );\n            slash = slash < 0 ? tokens[i].indexOf( '\\\\' ) : slash;\n\n            if ( slash == 0 )\n            {\n                // this is the project path\n                projectPath = tokens[i].substring( 1 );\n                break;\n            }\n            else if ( ( slash > 0 || ( at >= 0 ) ) && host == null && user == null )\n            {\n                // user/pass@host\n                int len = tokens[i].length();\n                if ( at >= 0 && len > at )\n                {\n                    // everything after the \"@\"\n                    host = tokens[i].substring( at + 1 );\n                }\n\n                if ( slash > 0 )\n                {\n                    // user up to /\n                    user = tokens[i].substring( 0, slash );\n                    // pass between / and @\n                    password = tokens[i].substring( slash + 1, at < 0 ? len : at );\n                }\n                else\n                {\n                    // no /, user from beginning to @\n                    user = tokens[i].substring( 0, at < 0 ? len : at );\n                }\n\n            }\n            else if ( host != null && tokens[i].matches( \"^[0-9]+$\" ) )\n            {\n                // only valid entry with all digits is the port specification.\n                port = Integer.parseInt( tokens[i] );\n            }\n            else\n            {\n                basisStream = tokens[i];\n            }\n\n            i++;\n        }\n\n        if ( i < tokens.length )\n        {\n            validationMessages.add( \"Unknown tokens in URL \" + scmSpecificUrl );\n        }\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        if ( !StringUtils.isEmpty( user ) )\n        {\n            repo.setUser( user );\n        }\n        if ( !StringUtils.isEmpty( password ) )\n        {\n            repo.setPassword( password );\n        }\n        if ( !StringUtils.isEmpty( basisStream ) )\n        {\n            repo.setStreamName( basisStream );\n        }\n        if ( !StringUtils.isEmpty( projectPath ) )\n        {\n            repo.setProjectPath( projectPath );\n        }\n        if ( !StringUtils.isEmpty( host ) )\n        {\n            repo.setHost( host );\n        }\n        repo.setPort( port );\n        AccuRevCommandLine accuRev = new AccuRevCommandLine( host, port );\n        accuRev.setLogger( getLogger() );\n        repo.setAccuRev( accuRev );\n\n        return repo;\n\n    }\n\n    @Override\n    protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( repository.toString() );\n        }\n\n        AccuRevLoginCommand command = new AccuRevLoginCommand( getLogger() );\n        return command.login( repository, fileSet, parameters );\n    }\n\n    protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                          CommandParameters parameters )\n        throws ScmException\n    {\n\n        // workaround deprecated behaviour\n        // TODO pull up to AbstractScmProvider\n        AccuRevScmProviderRepository accuRevRepo = (AccuRevScmProviderRepository) repository;\n        if ( !repository.isPersistCheckout() && accuRevRepo.shouldUseExportForNonPersistentCheckout() )\n        {\n\n            ExportScmResult result = export( repository, fileSet, parameters );\n            if ( result.isSuccess() )\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getExportedFiles(), accuRevRepo\n                    .getExportRelativePath() );\n            }\n            else\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getProviderMessage(), result\n                    .getCommandOutput(), false );\n            }\n        }\n\n        AccuRevCheckOutCommand command = new AccuRevCheckOutCommand( getLogger() );\n\n        return command.checkout( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,\n                                        CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevCheckInCommand command = new AccuRevCheckInCommand( getLogger() );\n\n        return command.checkIn( repository, fileSet, parameters );\n    }\n\n    public ScmProviderRepository makeProviderScmRepository( File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure\n    {\n        // TODO: accurev info with current dir = \"path\", find workspace. Find use-case for this.\n        return super.makeProviderScmRepository( path );\n    }\n\n    @Override\n    protected AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n        return command.add( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevTagCommand command = new AccuRevTagCommand( getLogger() );\n        return command.tag( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n        return command.status( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        Date now = new Date(); // better to store this before we run the update...\n\n        UpdateScmResult result = command.update( repository, fileSet, parameters );\n\n        if ( result.isSuccess() && parameters.getBoolean( CommandParameter.RUN_CHANGELOG_WITH_UPDATE ) )\n        {\n            AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n            AccuRevVersion startVersion = accuRevResult.getFromVersion();\n            AccuRevVersion endVersion = accuRevResult.getToVersion();\n\n            if ( endVersion.isNow() )\n            {\n                endVersion = new AccuRevVersion( endVersion.getBasisStream(), now );\n            }\n\n            parameters.setScmVersion( CommandParameter.START_SCM_VERSION, new ScmRevision( startVersion.toString() ) );\n            parameters.setScmVersion( CommandParameter.END_SCM_VERSION, new ScmRevision( endVersion.toString() ) );\n\n            if ( startVersion.getBasisStream().equals( endVersion.getBasisStream() ) )\n            {\n                ChangeLogScmResult changeLogResult = changelog( repository, fileSet, parameters );\n\n                if ( changeLogResult.isSuccess() )\n                {\n                    result.setChanges( changeLogResult.getChangeLog().getChangeSets() );\n                }\n            }\n            else\n            {\n                String comment = \"Cross stream update result from \" + startVersion + \" to \" + endVersion;\n                String author = \"\";\n                @SuppressWarnings(\"unchecked\")\n                List<ScmFile> files = result.getUpdatedFiles();\n                ChangeSet dummyChangeSet = new ChangeSet( now, comment, author, files );\n                // different streams invalidates the change log, insert a dummy change instead.\n                List<ChangeSet> changeSets = Collections.singletonList( dummyChangeSet );\n                result.setChanges( changeSets );\n            }\n\n        }\n        return result;\n    }\n\n    @Override\n    protected ExportScmResult export( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevExportCommand command = new AccuRevExportCommand( getLogger() );\n        return command.export( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                            CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevChangeLogCommand command = new AccuRevChangeLogCommand( getLogger() );\n        return command.changelog( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevRemoveCommand command = new AccuRevRemoveCommand( getLogger() );\n        return command.remove( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevBlameCommand blameCommand = new AccuRevBlameCommand( getLogger() );\n        return blameCommand.blame( repository, fileSet, parameters );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmRevision;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.cli.AccuRevCommandLine;\nimport org.apache.maven.scm.provider.accurev.command.add.AccuRevAddCommand;\nimport org.apache.maven.scm.provider.accurev.command.blame.AccuRevBlameCommand;\nimport org.apache.maven.scm.provider.accurev.command.changelog.AccuRevChangeLogCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkin.AccuRevCheckInCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkout.AccuRevCheckOutCommand;\nimport org.apache.maven.scm.provider.accurev.command.export.AccuRevExportCommand;\nimport org.apache.maven.scm.provider.accurev.command.login.AccuRevLoginCommand;\nimport org.apache.maven.scm.provider.accurev.command.remove.AccuRevRemoveCommand;\nimport org.apache.maven.scm.provider.accurev.command.status.AccuRevStatusCommand;\nimport org.apache.maven.scm.provider.accurev.command.tag.AccuRevTagCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.util.QuotedPropertyParser;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * AccuRev integration with Maven SCM\n * \n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"accurev\"\n */\npublic class AccuRevScmProvider\n    extends AbstractScmProvider\n{\n\n    public static final String ACCUREV_EXECUTABLE_PROPERTY = \"accurevExe\";\n\n    public static final String TAG_FORMAT_PROPERTY = \"tagFormat\";\n\n    public static final String SYSTEM_PROPERTY_PREFIX = \"maven.scm.accurev.\";\n\n    public String getScmType()\n    {\n\n        return \"accurev\";\n    }\n\n    /**\n     * The basic url parsing approach is to be as loose as possible. If you specify as per the docs you'll get what you\n     * expect. If you do something else the result is undefined. Don't use \"/\" \"\\\" or \"@\" as the delimiter,\n     */\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n\n        List<String> validationMessages = new ArrayList<String>();\n\n        String[] tokens = StringUtils.split( scmSpecificUrl, Character.toString( delimiter ) );\n\n        // [[user][/pass]@host[:port]][:stream][:\\project\\dir]\n\n        String basisStream = null;\n        String projectPath = null;\n        int port = AccuRev.DEFAULT_PORT;\n        String host = null;\n        String user = null;\n        String password = null;\n        Map<String, String> properties = new HashMap<String, String>();\n        properties.put( TAG_FORMAT_PROPERTY, AccuRevScmProviderRepository.DEFAULT_TAG_FORMAT );\n        properties.put( ACCUREV_EXECUTABLE_PROPERTY, AccuRev.DEFAULT_ACCUREV_EXECUTABLE );\n\n        fillSystemProperties( properties );\n\n        int i = 0;\n        while ( i < tokens.length )\n        {\n            int at = tokens[i].indexOf( '@' );\n            // prefer \"/\", better not have a \"/\" or a \"\\\\\" in your password.\n            int slash = tokens[i].indexOf( '/' );\n            slash = slash < 0 ? tokens[i].indexOf( '\\\\' ) : slash;\n\n            int qMark = tokens[i].indexOf( '?' );\n\n            if ( qMark == 0 )\n            {\n                QuotedPropertyParser.parse( tokens[i].substring( 1 ), properties );\n            }\n            else if ( slash == 0 )\n            {\n                // this is the project path\n                projectPath = tokens[i].substring( 1 );\n                break;\n            }\n            else if ( ( slash > 0 || ( at >= 0 ) ) && host == null && user == null )\n            {\n                // user/pass@host\n                int len = tokens[i].length();\n                if ( at >= 0 && len > at )\n                {\n                    // everything after the \"@\"\n                    host = tokens[i].substring( at + 1 );\n                }\n\n                if ( slash > 0 )\n                {\n                    // user up to /\n                    user = tokens[i].substring( 0, slash );\n                    // pass between / and @\n                    password = tokens[i].substring( slash + 1, at < 0 ? len : at );\n                }\n                else\n                {\n                    // no /, user from beginning to @\n                    user = tokens[i].substring( 0, at < 0 ? len : at );\n                }\n\n            }\n            else if ( host != null && tokens[i].matches( \"^[0-9]+$\" ) )\n            {\n                // only valid entry with all digits is the port specification.\n                port = Integer.parseInt( tokens[i] );\n            }\n            else\n            {\n                basisStream = tokens[i];\n            }\n\n            i++;\n        }\n\n        if ( i < tokens.length )\n        {\n            validationMessages.add( \"Unknown tokens in URL \" + scmSpecificUrl );\n        }\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setLogger( getLogger() );\n        if ( !StringUtils.isEmpty( user ) )\n        {\n            repo.setUser( user );\n        }\n        if ( !StringUtils.isEmpty( password ) )\n        {\n            repo.setPassword( password );\n        }\n        if ( !StringUtils.isEmpty( basisStream ) )\n        {\n            repo.setStreamName( basisStream );\n        }\n        if ( !StringUtils.isEmpty( projectPath ) )\n        {\n            repo.setProjectPath( projectPath );\n        }\n        if ( !StringUtils.isEmpty( host ) )\n        {\n            repo.setHost( host );\n        }\n        repo.setPort( port );\n        repo.setTagFormat( properties.get( TAG_FORMAT_PROPERTY ) );\n\n        AccuRevCommandLine accuRev = new AccuRevCommandLine( host, port );\n        accuRev.setLogger( getLogger() );\n        accuRev.setExecutable( properties.get( ACCUREV_EXECUTABLE_PROPERTY ) );\n        repo.setAccuRev( accuRev );\n\n        return repo;\n\n    }\n\n    private void fillSystemProperties( Map<String, String> properties )\n    {\n\n        Set<String> propertyKeys = properties.keySet();\n        for ( String key : propertyKeys )\n        {\n            String systemPropertyKey = SYSTEM_PROPERTY_PREFIX + key;\n            String systemProperty = System.getProperty( systemPropertyKey );\n            if ( systemProperty != null )\n            {\n                properties.put( key, systemProperty );\n            }\n        }\n\n    }\n\n    @Override\n    protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( repository.toString() );\n        }\n\n        AccuRevLoginCommand command = new AccuRevLoginCommand( getLogger() );\n        return command.login( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                          CommandParameters parameters )\n        throws ScmException\n    {\n\n        // workaround deprecated behaviour\n        // TODO pull up to AbstractScmProvider\n        AccuRevScmProviderRepository accuRevRepo = (AccuRevScmProviderRepository) repository;\n        if ( !repository.isPersistCheckout() && accuRevRepo.shouldUseExportForNonPersistentCheckout() )\n        {\n\n            ExportScmResult result = export( repository, fileSet, parameters );\n            if ( result.isSuccess() )\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getExportedFiles(),\n                                              accuRevRepo.getExportRelativePath() );\n            }\n            else\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getProviderMessage(),\n                                              result.getCommandOutput(), false );\n            }\n        }\n\n        AccuRevCheckOutCommand command = new AccuRevCheckOutCommand( getLogger() );\n\n        return command.checkout( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,\n                                        CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevCheckInCommand command = new AccuRevCheckInCommand( getLogger() );\n\n        return command.checkIn( repository, fileSet, parameters );\n    }\n\n    @Override\n    public ScmProviderRepository makeProviderScmRepository( File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure\n    {\n\n        // TODO: accurev info with current dir = \"path\", find workspace. Find use-case for this.\n        return super.makeProviderScmRepository( path );\n    }\n\n    @Override\n    protected AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n        return command.add( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevTagCommand command = new AccuRevTagCommand( getLogger() );\n        return command.tag( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n        return command.status( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevScmProviderRepository accurevRepo = (AccuRevScmProviderRepository) repository;\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        UpdateScmResult result = command.update( repository, fileSet, parameters );\n\n        if ( result.isSuccess() && parameters.getBoolean( CommandParameter.RUN_CHANGELOG_WITH_UPDATE ) )\n        {\n            AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n\n            ScmRevision fromRevision = new ScmRevision( accuRevResult.getFromRevision() );\n            ScmRevision toRevision = new ScmRevision( accuRevResult.getToRevision() );\n\n            parameters.setScmVersion( CommandParameter.START_SCM_VERSION, fromRevision );\n            parameters.setScmVersion( CommandParameter.END_SCM_VERSION, toRevision );\n\n            AccuRevVersion startVersion = accurevRepo.getAccuRevVersion( fromRevision );\n            AccuRevVersion endVersion = accurevRepo.getAccuRevVersion( toRevision );\n            if ( startVersion.getBasisStream().equals( endVersion.getBasisStream() ) )\n            {\n                ChangeLogScmResult changeLogResult = changelog( repository, fileSet, parameters );\n\n                if ( changeLogResult.isSuccess() )\n                {\n                    result.setChanges( changeLogResult.getChangeLog().getChangeSets() );\n                }\n                else\n                {\n                    getLogger().warn( \"Changelog from \" + fromRevision + \" to \" + toRevision + \" failed\" );\n                }\n            }\n            else\n            {\n                String comment = \"Cross stream update result from \" + startVersion + \" to \" + endVersion;\n                String author = \"\";\n                @SuppressWarnings( \"unchecked\" )\n                List<ScmFile> files = result.getUpdatedFiles();\n                ChangeSet dummyChangeSet = new ChangeSet( new Date(), comment, author, files );\n                // different streams invalidates the change log, insert a dummy change instead.\n                List<ChangeSet> changeSets = Collections.singletonList( dummyChangeSet );\n                result.setChanges( changeSets );\n            }\n\n        }\n        return result;\n    }\n\n    @Override\n    protected ExportScmResult export( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevExportCommand command = new AccuRevExportCommand( getLogger() );\n        return command.export( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                            CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevChangeLogCommand command = new AccuRevChangeLogCommand( getLogger() );\n        return command.changelog( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevRemoveCommand command = new AccuRevRemoveCommand( getLogger() );\n        return command.remove( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevBlameCommand blameCommand = new AccuRevBlameCommand( getLogger() );\n        return blameCommand.blame( repository, fileSet, parameters );\n    }\n}\n","lineNo":337}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmRevision;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.cli.AccuRevCommandLine;\nimport org.apache.maven.scm.provider.accurev.command.add.AccuRevAddCommand;\nimport org.apache.maven.scm.provider.accurev.command.blame.AccuRevBlameCommand;\nimport org.apache.maven.scm.provider.accurev.command.changelog.AccuRevChangeLogCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkin.AccuRevCheckInCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkout.AccuRevCheckOutCommand;\nimport org.apache.maven.scm.provider.accurev.command.export.AccuRevExportCommand;\nimport org.apache.maven.scm.provider.accurev.command.login.AccuRevLoginCommand;\nimport org.apache.maven.scm.provider.accurev.command.remove.AccuRevRemoveCommand;\nimport org.apache.maven.scm.provider.accurev.command.status.AccuRevStatusCommand;\nimport org.apache.maven.scm.provider.accurev.command.tag.AccuRevTagCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateScmResult;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * AccuRev integration with Maven SCM\n * \n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"accurev\"\n */\npublic class AccuRevScmProvider\n    extends AbstractScmProvider\n{\n\n    public String getScmType()\n    {\n        return \"accurev\";\n    }\n\n    /**\n     * The basic url parsing approach is to be as loose as possible. If you specify as per the docs\n     * you'll get what you expect. If you do something else the result is undefined. Don't use \"/\"\n     * \"\\\" or \"@\" as the delimiter,\n     */\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n\n        List<String> validationMessages = new ArrayList<String>();\n\n        String[] tokens = StringUtils.split( scmSpecificUrl, Character.toString( delimiter ) );\n\n        //[[user][/pass]@host[:port]][:stream][:\\project\\dir]\n\n        String basisStream = null;\n        String projectPath = null;\n        int port = AccuRevScmProviderRepository.DEFAULT_PORT;\n        String host = null;\n        String user = null;\n        String password = null;\n\n        int i = 0;\n        while ( i < tokens.length )\n        {\n            int at = tokens[i].indexOf( '@' );\n            // prefer \"/\", better not have a \"/\" or a \"\\\\\" in your password.\n            int slash = tokens[i].indexOf( '/' );\n            slash = slash < 0 ? tokens[i].indexOf( '\\\\' ) : slash;\n\n            if ( slash == 0 )\n            {\n                // this is the project path\n                projectPath = tokens[i].substring( 1 );\n                break;\n            }\n            else if ( ( slash > 0 || ( at >= 0 ) ) && host == null && user == null )\n            {\n                // user/pass@host\n                int len = tokens[i].length();\n                if ( at >= 0 && len > at )\n                {\n                    // everything after the \"@\"\n                    host = tokens[i].substring( at + 1 );\n                }\n\n                if ( slash > 0 )\n                {\n                    // user up to /\n                    user = tokens[i].substring( 0, slash );\n                    // pass between / and @\n                    password = tokens[i].substring( slash + 1, at < 0 ? len : at );\n                }\n                else\n                {\n                    // no /, user from beginning to @\n                    user = tokens[i].substring( 0, at < 0 ? len : at );\n                }\n\n            }\n            else if ( host != null && tokens[i].matches( \"^[0-9]+$\" ) )\n            {\n                // only valid entry with all digits is the port specification.\n                port = Integer.parseInt( tokens[i] );\n            }\n            else\n            {\n                basisStream = tokens[i];\n            }\n\n            i++;\n        }\n\n        if ( i < tokens.length )\n        {\n            validationMessages.add( \"Unknown tokens in URL \" + scmSpecificUrl );\n        }\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        if ( !StringUtils.isEmpty( user ) )\n        {\n            repo.setUser( user );\n        }\n        if ( !StringUtils.isEmpty( password ) )\n        {\n            repo.setPassword( password );\n        }\n        if ( !StringUtils.isEmpty( basisStream ) )\n        {\n            repo.setStreamName( basisStream );\n        }\n        if ( !StringUtils.isEmpty( projectPath ) )\n        {\n            repo.setProjectPath( projectPath );\n        }\n        if ( !StringUtils.isEmpty( host ) )\n        {\n            repo.setHost( host );\n        }\n        repo.setPort( port );\n        AccuRevCommandLine accuRev = new AccuRevCommandLine( host, port );\n        accuRev.setLogger( getLogger() );\n        repo.setAccuRev( accuRev );\n\n        return repo;\n\n    }\n\n    @Override\n    protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( repository.toString() );\n        }\n\n        AccuRevLoginCommand command = new AccuRevLoginCommand( getLogger() );\n        return command.login( repository, fileSet, parameters );\n    }\n\n    protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                          CommandParameters parameters )\n        throws ScmException\n    {\n\n        // workaround deprecated behaviour\n        // TODO pull up to AbstractScmProvider\n        AccuRevScmProviderRepository accuRevRepo = (AccuRevScmProviderRepository) repository;\n        if ( !repository.isPersistCheckout() && accuRevRepo.shouldUseExportForNonPersistentCheckout() )\n        {\n\n            ExportScmResult result = export( repository, fileSet, parameters );\n            if ( result.isSuccess() )\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getExportedFiles(), accuRevRepo\n                    .getExportRelativePath() );\n            }\n            else\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getProviderMessage(), result\n                    .getCommandOutput(), false );\n            }\n        }\n\n        AccuRevCheckOutCommand command = new AccuRevCheckOutCommand( getLogger() );\n\n        return command.checkout( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,\n                                        CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevCheckInCommand command = new AccuRevCheckInCommand( getLogger() );\n\n        return command.checkIn( repository, fileSet, parameters );\n    }\n\n    public ScmProviderRepository makeProviderScmRepository( File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure\n    {\n        // TODO: accurev info with current dir = \"path\", find workspace. Find use-case for this.\n        return super.makeProviderScmRepository( path );\n    }\n\n    @Override\n    protected AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n        return command.add( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevTagCommand command = new AccuRevTagCommand( getLogger() );\n        return command.tag( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n        return command.status( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        Date now = new Date(); // better to store this before we run the update...\n\n        UpdateScmResult result = command.update( repository, fileSet, parameters );\n\n        if ( result.isSuccess() && parameters.getBoolean( CommandParameter.RUN_CHANGELOG_WITH_UPDATE ) )\n        {\n            AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n            AccuRevVersion startVersion = accuRevResult.getFromVersion();\n            AccuRevVersion endVersion = accuRevResult.getToVersion();\n\n            if ( endVersion.isNow() )\n            {\n                endVersion = new AccuRevVersion( endVersion.getBasisStream(), now );\n            }\n\n            parameters.setScmVersion( CommandParameter.START_SCM_VERSION, new ScmRevision( startVersion.toString() ) );\n            parameters.setScmVersion( CommandParameter.END_SCM_VERSION, new ScmRevision( endVersion.toString() ) );\n\n            if ( startVersion.getBasisStream().equals( endVersion.getBasisStream() ) )\n            {\n                ChangeLogScmResult changeLogResult = changelog( repository, fileSet, parameters );\n\n                if ( changeLogResult.isSuccess() )\n                {\n                    result.setChanges( changeLogResult.getChangeLog().getChangeSets() );\n                }\n            }\n            else\n            {\n                String comment = \"Cross stream update result from \" + startVersion + \" to \" + endVersion;\n                String author = \"\";\n                @SuppressWarnings(\"unchecked\")\n                List<ScmFile> files = result.getUpdatedFiles();\n                ChangeSet dummyChangeSet = new ChangeSet( now, comment, author, files );\n                // different streams invalidates the change log, insert a dummy change instead.\n                List<ChangeSet> changeSets = Collections.singletonList( dummyChangeSet );\n                result.setChanges( changeSets );\n            }\n\n        }\n        return result;\n    }\n\n    @Override\n    protected ExportScmResult export( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevExportCommand command = new AccuRevExportCommand( getLogger() );\n        return command.export( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                            CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevChangeLogCommand command = new AccuRevChangeLogCommand( getLogger() );\n        return command.changelog( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        AccuRevRemoveCommand command = new AccuRevRemoveCommand( getLogger() );\n        return command.remove( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevBlameCommand blameCommand = new AccuRevBlameCommand( getLogger() );\n        return blameCommand.blame( repository, fileSet, parameters );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmRevision;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.blame.BlameScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.export.ExportScmResult;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.cli.AccuRevCommandLine;\nimport org.apache.maven.scm.provider.accurev.command.add.AccuRevAddCommand;\nimport org.apache.maven.scm.provider.accurev.command.blame.AccuRevBlameCommand;\nimport org.apache.maven.scm.provider.accurev.command.changelog.AccuRevChangeLogCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkin.AccuRevCheckInCommand;\nimport org.apache.maven.scm.provider.accurev.command.checkout.AccuRevCheckOutCommand;\nimport org.apache.maven.scm.provider.accurev.command.export.AccuRevExportCommand;\nimport org.apache.maven.scm.provider.accurev.command.login.AccuRevLoginCommand;\nimport org.apache.maven.scm.provider.accurev.command.remove.AccuRevRemoveCommand;\nimport org.apache.maven.scm.provider.accurev.command.status.AccuRevStatusCommand;\nimport org.apache.maven.scm.provider.accurev.command.tag.AccuRevTagCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateCommand;\nimport org.apache.maven.scm.provider.accurev.command.update.AccuRevUpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.util.QuotedPropertyParser;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * AccuRev integration with Maven SCM\n * \n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"accurev\"\n */\npublic class AccuRevScmProvider\n    extends AbstractScmProvider\n{\n\n    public static final String ACCUREV_EXECUTABLE_PROPERTY = \"accurevExe\";\n\n    public static final String TAG_FORMAT_PROPERTY = \"tagFormat\";\n\n    public static final String SYSTEM_PROPERTY_PREFIX = \"maven.scm.accurev.\";\n\n    public String getScmType()\n    {\n\n        return \"accurev\";\n    }\n\n    /**\n     * The basic url parsing approach is to be as loose as possible. If you specify as per the docs you'll get what you\n     * expect. If you do something else the result is undefined. Don't use \"/\" \"\\\" or \"@\" as the delimiter,\n     */\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n\n        List<String> validationMessages = new ArrayList<String>();\n\n        String[] tokens = StringUtils.split( scmSpecificUrl, Character.toString( delimiter ) );\n\n        // [[user][/pass]@host[:port]][:stream][:\\project\\dir]\n\n        String basisStream = null;\n        String projectPath = null;\n        int port = AccuRev.DEFAULT_PORT;\n        String host = null;\n        String user = null;\n        String password = null;\n        Map<String, String> properties = new HashMap<String, String>();\n        properties.put( TAG_FORMAT_PROPERTY, AccuRevScmProviderRepository.DEFAULT_TAG_FORMAT );\n        properties.put( ACCUREV_EXECUTABLE_PROPERTY, AccuRev.DEFAULT_ACCUREV_EXECUTABLE );\n\n        fillSystemProperties( properties );\n\n        int i = 0;\n        while ( i < tokens.length )\n        {\n            int at = tokens[i].indexOf( '@' );\n            // prefer \"/\", better not have a \"/\" or a \"\\\\\" in your password.\n            int slash = tokens[i].indexOf( '/' );\n            slash = slash < 0 ? tokens[i].indexOf( '\\\\' ) : slash;\n\n            int qMark = tokens[i].indexOf( '?' );\n\n            if ( qMark == 0 )\n            {\n                QuotedPropertyParser.parse( tokens[i].substring( 1 ), properties );\n            }\n            else if ( slash == 0 )\n            {\n                // this is the project path\n                projectPath = tokens[i].substring( 1 );\n                break;\n            }\n            else if ( ( slash > 0 || ( at >= 0 ) ) && host == null && user == null )\n            {\n                // user/pass@host\n                int len = tokens[i].length();\n                if ( at >= 0 && len > at )\n                {\n                    // everything after the \"@\"\n                    host = tokens[i].substring( at + 1 );\n                }\n\n                if ( slash > 0 )\n                {\n                    // user up to /\n                    user = tokens[i].substring( 0, slash );\n                    // pass between / and @\n                    password = tokens[i].substring( slash + 1, at < 0 ? len : at );\n                }\n                else\n                {\n                    // no /, user from beginning to @\n                    user = tokens[i].substring( 0, at < 0 ? len : at );\n                }\n\n            }\n            else if ( host != null && tokens[i].matches( \"^[0-9]+$\" ) )\n            {\n                // only valid entry with all digits is the port specification.\n                port = Integer.parseInt( tokens[i] );\n            }\n            else\n            {\n                basisStream = tokens[i];\n            }\n\n            i++;\n        }\n\n        if ( i < tokens.length )\n        {\n            validationMessages.add( \"Unknown tokens in URL \" + scmSpecificUrl );\n        }\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setLogger( getLogger() );\n        if ( !StringUtils.isEmpty( user ) )\n        {\n            repo.setUser( user );\n        }\n        if ( !StringUtils.isEmpty( password ) )\n        {\n            repo.setPassword( password );\n        }\n        if ( !StringUtils.isEmpty( basisStream ) )\n        {\n            repo.setStreamName( basisStream );\n        }\n        if ( !StringUtils.isEmpty( projectPath ) )\n        {\n            repo.setProjectPath( projectPath );\n        }\n        if ( !StringUtils.isEmpty( host ) )\n        {\n            repo.setHost( host );\n        }\n        repo.setPort( port );\n        repo.setTagFormat( properties.get( TAG_FORMAT_PROPERTY ) );\n\n        AccuRevCommandLine accuRev = new AccuRevCommandLine( host, port );\n        accuRev.setLogger( getLogger() );\n        accuRev.setExecutable( properties.get( ACCUREV_EXECUTABLE_PROPERTY ) );\n        repo.setAccuRev( accuRev );\n\n        return repo;\n\n    }\n\n    private void fillSystemProperties( Map<String, String> properties )\n    {\n\n        Set<String> propertyKeys = properties.keySet();\n        for ( String key : propertyKeys )\n        {\n            String systemPropertyKey = SYSTEM_PROPERTY_PREFIX + key;\n            String systemProperty = System.getProperty( systemPropertyKey );\n            if ( systemProperty != null )\n            {\n                properties.put( key, systemProperty );\n            }\n        }\n\n    }\n\n    @Override\n    protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( repository.toString() );\n        }\n\n        AccuRevLoginCommand command = new AccuRevLoginCommand( getLogger() );\n        return command.login( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                          CommandParameters parameters )\n        throws ScmException\n    {\n\n        // workaround deprecated behaviour\n        // TODO pull up to AbstractScmProvider\n        AccuRevScmProviderRepository accuRevRepo = (AccuRevScmProviderRepository) repository;\n        if ( !repository.isPersistCheckout() && accuRevRepo.shouldUseExportForNonPersistentCheckout() )\n        {\n\n            ExportScmResult result = export( repository, fileSet, parameters );\n            if ( result.isSuccess() )\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getExportedFiles(),\n                                              accuRevRepo.getExportRelativePath() );\n            }\n            else\n            {\n                return new CheckOutScmResult( result.getCommandLine(), result.getProviderMessage(),\n                                              result.getCommandOutput(), false );\n            }\n        }\n\n        AccuRevCheckOutCommand command = new AccuRevCheckOutCommand( getLogger() );\n\n        return command.checkout( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,\n                                        CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevCheckInCommand command = new AccuRevCheckInCommand( getLogger() );\n\n        return command.checkIn( repository, fileSet, parameters );\n    }\n\n    @Override\n    public ScmProviderRepository makeProviderScmRepository( File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure\n    {\n\n        // TODO: accurev info with current dir = \"path\", find workspace. Find use-case for this.\n        return super.makeProviderScmRepository( path );\n    }\n\n    @Override\n    protected AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n        return command.add( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevTagCommand command = new AccuRevTagCommand( getLogger() );\n        return command.tag( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n        return command.status( repository, fileSet, parameters );\n\n    }\n\n    @Override\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevScmProviderRepository accurevRepo = (AccuRevScmProviderRepository) repository;\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        UpdateScmResult result = command.update( repository, fileSet, parameters );\n\n        if ( result.isSuccess() && parameters.getBoolean( CommandParameter.RUN_CHANGELOG_WITH_UPDATE ) )\n        {\n            AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n\n            ScmRevision fromRevision = new ScmRevision( accuRevResult.getFromRevision() );\n            ScmRevision toRevision = new ScmRevision( accuRevResult.getToRevision() );\n\n            parameters.setScmVersion( CommandParameter.START_SCM_VERSION, fromRevision );\n            parameters.setScmVersion( CommandParameter.END_SCM_VERSION, toRevision );\n\n            AccuRevVersion startVersion = accurevRepo.getAccuRevVersion( fromRevision );\n            AccuRevVersion endVersion = accurevRepo.getAccuRevVersion( toRevision );\n            if ( startVersion.getBasisStream().equals( endVersion.getBasisStream() ) )\n            {\n                ChangeLogScmResult changeLogResult = changelog( repository, fileSet, parameters );\n\n                if ( changeLogResult.isSuccess() )\n                {\n                    result.setChanges( changeLogResult.getChangeLog().getChangeSets() );\n                }\n                else\n                {\n                    getLogger().warn( \"Changelog from \" + fromRevision + \" to \" + toRevision + \" failed\" );\n                }\n            }\n            else\n            {\n                String comment = \"Cross stream update result from \" + startVersion + \" to \" + endVersion;\n                String author = \"\";\n                @SuppressWarnings( \"unchecked\" )\n                List<ScmFile> files = result.getUpdatedFiles();\n                ChangeSet dummyChangeSet = new ChangeSet( new Date(), comment, author, files );\n                // different streams invalidates the change log, insert a dummy change instead.\n                List<ChangeSet> changeSets = Collections.singletonList( dummyChangeSet );\n                result.setChanges( changeSets );\n            }\n\n        }\n        return result;\n    }\n\n    @Override\n    protected ExportScmResult export( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevExportCommand command = new AccuRevExportCommand( getLogger() );\n        return command.export( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                            CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevChangeLogCommand command = new AccuRevChangeLogCommand( getLogger() );\n        return command.changelog( repository, fileSet, parameters );\n    }\n\n    @Override\n    protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevRemoveCommand command = new AccuRevRemoveCommand( getLogger() );\n        return command.remove( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n\n        AccuRevBlameCommand blameCommand = new AccuRevBlameCommand( getLogger() );\n        return blameCommand.blame( repository, fileSet, parameters );\n    }\n}\n","lineNo":338}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StreamConsumer systemErr;\n\n    private StringBuffer commandLines = new StringBuffer();\n\n    private StringBuffer errorOutput = new StringBuffer();\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    public AccuRevCommandLine()\n    {\n        super();\n        reset();\n\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                //Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer );\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null );\n    }\n\n    private boolean executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private boolean executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result == 0;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n        return cl;\n    }\n\n    public void reset()\n    {\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuffer();\n        errorOutput = new StringBuffer();\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().warn( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean update( File baseDir, String transactionId, List<File> updatedFiles )\n        throws AccuRevException\n    {\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean add( File basedir, List<File> elements, String message, List<File> addedFiles )\n        throws AccuRevException\n    {\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles );\n\n    }\n\n    public boolean defunct( File basedir, List<File> files, String message, List<File> defunctedFiles )\n        throws AccuRevException\n    {\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctedFiles );\n    }\n\n    public boolean promote( File basedir, List<File> files, String message, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles );\n\n    }\n\n    public String getCommandLines()\n    {\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n        this.logger = logger;\n        this.systemErr = new ErrorConsumer( logger, errorOutput );\n    }\n\n    public ScmLogger getLogger()\n    {\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean promoteAll( File baseDir, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) );\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) );\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public boolean statTag( String streamName, List<File> taggedFiles )\n        throws AccuRevException\n    {\n        return executeCommandLine( null, new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName }, null,\n                                   FileConsumer.STAT_PATTERN, taggedFiles );\n    }\n\n    public boolean stat( File basedir, Collection<File> elements, AccuRevStat statType, List<File> matchingElements )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements );\n    }\n\n    public boolean pop( File basedir, Collection<File> elements, List<File> poppedFiles )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n    }\n\n    public boolean pop( File basedir, String versionSpec, Collection<File> elements, List<File> poppedFiles )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        String[] pop = { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n\n        return executeCommandLine( basedir, pop, elements, FileConsumer.POPULATE_PATTERN, poppedFiles );\n    }\n\n    public boolean statBackingStream( File basedir, Collection<File> elements, Collection<File> memberElements,\n                                      Collection<File> nonMemberElements )\n        throws AccuRevException\n    {\n        if ( elements.isEmpty() )\n        {\n            return true;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( memberElements, nonMemberElements ) );\n\n    }\n\n    public boolean history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                            List<Transaction> transactions )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist = { \"hist\", \"-fx\", \"-s\", baseStream, \"-t\", timeSpec };\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout );\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout );\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout );\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public boolean annotate( File basedir, File file, List<BlameLine> lines )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout );\n    }\n    \n    public boolean showRefTrees( Map<String, WorkSpace> workSpaces )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout );\n    }\n\n    public boolean showWorkSpaces( Map<String, WorkSpace> workSpaces )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout );\n    }\n\n    public static void main( String[] args )\n        throws AccuRevException\n    {\n        AccuRevCommandLine myCL = new AccuRevCommandLine( args[0], Integer.parseInt( args[1] ) );\n        myCL.setLogger( new DefaultLog()\n        {\n\n            @Override\n            public void debug( String content )\n            {\n                debug( content, null );\n            }\n\n            @Override\n            public void debug( Throwable error )\n            {\n                debug( null, error );\n            }\n\n            @Override\n            public void debug( String content, Throwable error )\n            {\n                if ( content != null )\n                {\n                    System.err.println( content );\n                }\n                if ( error != null )\n                {\n                    error.printStackTrace( System.err );\n                }\n            }\n\n            @Override\n            public boolean isDebugEnabled()\n            {\n                return true;\n            }\n        } );\n\n        myCL.login( args[2], args[3] );\n\n        System.out.println( Arrays.toString( myCL.authArgs ) );\n\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.cli;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.scm.command.blame.BlameLine;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.FileDifference;\nimport org.apache.maven.scm.provider.accurev.Stream;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\npublic class AccuRevCommandLine\n    implements AccuRev\n{\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[] {};\n\n    private static final File CURRENT_DIR = new File( \".\" );\n\n    private ScmLogger logger;\n\n    private Commandline cl = new Commandline();\n\n    private StreamConsumer systemErr;\n\n    private StringBuffer commandLines = new StringBuffer();\n\n    private StringBuffer errorOutput = new StringBuffer();\n\n    private String[] hostArgs = EMPTY_STRING_ARRAY;\n\n    private String[] authArgs = EMPTY_STRING_ARRAY;\n\n    private String executable = \"accurev\";\n\n    private long executableModTime;\n\n    private String clientVersion;\n\n    public AccuRevCommandLine()\n    {\n\n        super();\n        reset();\n\n    }\n\n    public AccuRevCommandLine( String host, int port )\n    {\n\n        this();\n        setServer( host, port );\n    }\n\n    public void setServer( String host, int port )\n    {\n\n        if ( host != null )\n        {\n            hostArgs = new String[] { \"-H\", host + \":\" + port };\n        }\n        else\n        {\n            hostArgs = EMPTY_STRING_ARRAY;\n        }\n\n    }\n\n    public void setExecutable( String accuRevExe )\n    {\n\n        executable = accuRevExe;\n        reset();\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements, Pattern matchPattern,\n                                        List<File> matchedFiles )\n        throws AccuRevException\n    {\n\n        FileConsumer stdoutConsumer = new FileConsumer( matchedFiles, matchPattern );\n\n        return executeCommandLine( basedir, args, elements, stdoutConsumer );\n    }\n\n    private boolean executeCommandLine( File basedir, String[] args, Iterable<File> elements,\n                                        StreamConsumer stdoutConsumer )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        setCommandLineArgs( args );\n\n        if ( elements != null )\n        {\n            for ( File file : elements )\n            {\n                String path = file.getPath();\n                // Hack for Windows \"/./\". TODO find a nicer way to handle this.\n                if ( \"\\\\.\".equals( path ) )\n                {\n                    path = \"\\\\.\\\\\";\n                }\n                cl.createArg().setValue( path );\n            }\n        }\n        return executeCommandLine( null, stdoutConsumer ) == 0;\n    }\n\n    private void setCommandLineArgs( String[] args )\n    {\n\n        cl.clearArgs();\n\n        if ( args.length > 0 )\n        {\n            // First arg is the accurev command\n            cl.createArg().setValue( args[0] );\n\n            // Inject -H <host:port> and -A <token> here\n            cl.addArguments( hostArgs );\n            cl.addArguments( authArgs );\n        }\n\n        for ( int i = 1; i < args.length; i++ )\n        {\n            cl.createArg().setValue( args[i] );\n        }\n\n    }\n\n    private boolean executeCommandLine( String[] args )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( args, null, null ) == 0;\n    }\n\n    private int executeCommandLine( String[] args, InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        setCommandLineArgs( args );\n\n        return executeCommandLine( stdin, stdout );\n\n    }\n\n    private int executeCommandLine( InputStream stdin, StreamConsumer stdout )\n        throws AccuRevException\n    {\n\n        commandLines.append( cl.toString() );\n        commandLines.append( ';' );\n\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( cl.toString() );\n        }\n        try\n        {\n\n            int result = executeCommandLine( cl, stdin, new CommandOutputConsumer( getLogger(), stdout ), systemErr );\n            if ( result != 0 )\n            {\n                getLogger().debug( \"Non zero result - \" + result );\n            }\n            return result;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new AccuRevException( \"Error executing command \" + cl.toString(), ex );\n        }\n\n    }\n\n    /**\n     * Extracted so test class can override\n     * \n     * @param stdin\n     * @param stdout\n     * @param stderr\n     * @return\n     * @throws CommandLineException\n     */\n    protected int executeCommandLine( Commandline cl, InputStream stdin, CommandOutputConsumer stdout,\n                                      StreamConsumer stderr )\n        throws CommandLineException\n    {\n\n        int result = CommandLineUtils.executeCommandLine( cl, stdin, stdout, stderr );\n        stdout.waitComplete();\n\n        return result;\n    }\n\n    protected Commandline getCommandline()\n    {\n\n        return cl;\n    }\n\n    public void reset()\n    {\n\n        // TODO find out why Commandline allows executable, args etc to be initialised to\n        // null, but not allowing them to be reset to null. This results is weird \"clear\"\n        // behaviour. It is just safer to start again.\n\n        cl = new Commandline();\n        commandLines = new StringBuffer();\n        errorOutput = new StringBuffer();\n        cl.getShell().setQuotedArgumentsEnabled( true );\n        cl.setExecutable( executable );\n        try\n        {\n            cl.addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().warn( \"Unable to obtain system environment\", e );\n            }\n            else\n            {\n                getLogger().warn( \"Unable to obtain system environment\" );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean mkws( String basisStream, String workspaceName, File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] mkws = { \"mkws\", \"-b\", basisStream, \"-w\", workspaceName, \"-l\", basedir.getAbsolutePath() };\n\n        return executeCommandLine( mkws );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> update( File baseDir, String transactionId )\n        throws AccuRevException\n    {\n\n        if ( transactionId == null )\n        {\n            transactionId = \"highest\";\n        }\n        String[] update = { \"update\", \"-t\", transactionId };\n        setWorkingDirectory( baseDir );\n\n        List<File> updatedFiles = new ArrayList<File>();\n        return executeCommandLine( update, null, new FileConsumer( updatedFiles, FileConsumer.UPDATE_PATTERN ) ) == 0 ? updatedFiles\n                        : null;\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> add( File basedir, List<File> elements, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_ADD_MESSAGE;\n        }\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        List<File> addedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"add\", \"-c\", message, recursive ? \"-R\" : null }, elements,\n                                   FileConsumer.ADD_PATTERN, addedFiles ) ? addedFiles : null;\n\n    }\n\n    public List<File> defunct( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_REMOVE_MESSAGE;\n        }\n\n        if ( files == null || files.isEmpty() )\n        {\n            files = Collections.singletonList( CURRENT_DIR );\n        }\n\n        ArrayList<File> defunctFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"defunct\", \"-c\", message }, files,\n                                   FileConsumer.DEFUNCT_PATTERN, defunctFiles ) ? defunctFiles : null;\n    }\n\n    public List<File> promote( File basedir, List<File> files, String message )\n        throws AccuRevException\n    {\n\n        if ( StringUtils.isBlank( message ) )\n        {\n            message = AccuRev.DEFAULT_PROMOTE_MESSAGE;\n        }\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, new String[] { \"promote\", \"-K\", \"-c\", message }, files,\n                                   FileConsumer.PROMOTE_PATTERN, promotedFiles ) ? promotedFiles : null;\n\n    }\n\n    public String getCommandLines()\n    {\n\n        return commandLines.toString();\n    }\n\n    public String getErrorOutput()\n    {\n\n        return errorOutput.toString();\n    }\n\n    public void setLogger( ScmLogger logger )\n    {\n\n        this.logger = logger;\n        this.systemErr = new ErrorConsumer( logger, errorOutput );\n    }\n\n    public ScmLogger getLogger()\n    {\n\n        return logger;\n    }\n\n    public boolean mkdepot( String depotName )\n        throws AccuRevException\n    {\n\n        String[] mkdepot = { \"mkdepot\", \"-p\", depotName };\n\n        return executeCommandLine( mkdepot );\n\n    }\n\n    public boolean mkstream( String backingStream, String newStreamName )\n        throws AccuRevException\n    {\n        String[] mkstream = { \"mkstream\", \"-b\", backingStream, \"-s\", newStreamName };\n        return executeCommandLine( mkstream );\n\n    }\n\n    public boolean promoteStream( String subStream, String commitMessage, List<File> promotedFiles )\n        throws AccuRevException\n    {\n        String[] promote = { \"promote\", \"-s\", subStream, \"-d\" };\n        return executeCommandLine( promote );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List<File> promoteAll( File baseDir, String commitMessage )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( baseDir );\n        String[] promote = { \"promote\", \"-p\", \"-K\", \"-c\", commitMessage };\n\n        List<File> promotedFiles = new ArrayList<File>();\n        return executeCommandLine( promote, null, new FileConsumer( promotedFiles, FileConsumer.PROMOTE_PATTERN ) ) == 0 ? promotedFiles\n                        : null;\n\n    }\n\n    public AccuRevInfo info( File basedir )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        String[] info = { \"info\" };\n        AccuRevInfo result = new AccuRevInfo( basedir );\n\n        executeCommandLine( info, null, new InfoConsumer( result ) );\n        return result;\n    }\n\n    private void setWorkingDirectory( File basedir )\n    {\n\n        // TODO raise bug against plexus. Null is OK for working directory\n        // but once set to not-null cannot be set back to null!\n        // this is a problem if the old workingdir has been deleted\n        // probably safer to use a new commandline\n\n        if ( basedir == null )\n        {\n            cl.setWorkingDirectory( \".\" );\n        }\n        cl.setWorkingDirectory( basedir );\n    }\n\n    public boolean reactivate( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] reactivate = { \"reactivate\", \"wspace\", workSpaceName };\n\n        return executeCommandLine( reactivate, null, new CommandOutputConsumer( getLogger(), null ) ) == 0;\n\n    }\n\n    public boolean rmws( String workSpaceName )\n        throws AccuRevException\n    {\n\n        String[] rmws = { \"rmws\", \"-s\", workSpaceName };\n\n        return executeCommandLine( rmws );\n\n    }\n\n    public String stat( File element )\n        throws AccuRevException\n    {\n\n        String[] stat = { \"stat\", \"-fx\", element.getAbsolutePath() };\n\n        StatConsumer statConsumer = new StatConsumer( getLogger() );\n        executeCommandLine( stat, null, statConsumer );\n        return statConsumer.getStatus();\n\n    }\n\n    public boolean chws( File basedir, String workSpaceName, String newBasisStream )\n        throws AccuRevException\n    {\n\n        setWorkingDirectory( basedir );\n        return executeCommandLine( new String[] { \"chws\", \"-s\", workSpaceName, \"-b\", newBasisStream, \"-l\", \".\" } );\n\n    }\n\n    public boolean mksnap( String snapShotName, String basisStream )\n        throws AccuRevException\n    {\n\n        return executeCommandLine( new String[] { \"mksnap\", \"-s\", snapShotName, \"-b\", basisStream, \"-t\", \"now\" } );\n    }\n\n    public List<File> statTag( String streamName )\n        throws AccuRevException\n    {\n\n        List<File> taggedFiles = new ArrayList<File>();\n        String[] stat = new String[] { \"stat\", \"-a\", \"-ffl\", \"-s\", streamName };\n        return executeCommandLine( null, stat, null, FileConsumer.STAT_PATTERN, taggedFiles ) ? taggedFiles : null;\n    }\n\n    public List<File> stat( File basedir, Collection<File> elements, AccuRevStat statType )\n        throws AccuRevException\n    {\n\n        boolean recursive = false;\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n            recursive = true;\n        }\n        else if ( elements.size() == 1 && elements.toArray()[0].equals( CURRENT_DIR ) )\n        {\n            recursive = true;\n        }\n\n        String[] args = { \"stat\", \"-ffr\", statType.getStatArg(), recursive ? \"-R\" : null };\n\n        List<File> matchingElements = new ArrayList<File>();\n        return executeCommandLine( basedir, args, elements, statType.getMatchPattern(), matchingElements ) ? matchingElements\n                        : null;\n    }\n\n    public List<File> pop( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( CURRENT_DIR );\n        }\n\n        String[] popws = { \"pop\", \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, popws, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public List<File> pop( File basedir, String versionSpec, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        if ( elements == null || elements.isEmpty() )\n        {\n            elements = Collections.singletonList( new File( \"/./\" ) );\n        }\n\n        String[] pop = { \"pop\", \"-v\", versionSpec, \"-L\", basedir.getAbsolutePath(), \"-R\" };\n\n        List<File> poppedFiles = new ArrayList<File>();\n        return executeCommandLine( basedir, pop, elements, FileConsumer.POPULATE_PATTERN, poppedFiles ) ? poppedFiles\n                        : null;\n    }\n\n    public CategorisedElements statBackingStream( File basedir, Collection<File> elements )\n        throws AccuRevException\n    {\n\n        CategorisedElements catElems = new CategorisedElements();\n\n        if ( elements.isEmpty() )\n        {\n            return catElems;\n        }\n        String[] args = { \"stat\", \"-b\", \"-ffr\" };\n\n        return executeCommandLine( basedir, args, elements, new StatBackingConsumer( catElems.getMemberElements(),\n                                                                                     catElems.getNonMemberElements() ) ) ? catElems\n                        : null;\n\n    }\n\n    public List<Transaction> history( String baseStream, String fromTimeSpec, String toTimeSpec, int count,\n                                      boolean depotHistory, boolean transactionsOnly )\n        throws AccuRevException\n    {\n\n        String timeSpec = fromTimeSpec;\n\n        if ( toTimeSpec != null )\n        {\n            timeSpec = timeSpec + \"-\" + toTimeSpec;\n        }\n\n        if ( count > 0 )\n        {\n            timeSpec = timeSpec + \".\" + count;\n        }\n\n        String[] hist =\n            { \"hist\", transactionsOnly ? \"-ftx\" : \"-fx\", depotHistory ? \"-p\" : \"-s\", baseStream, \"-t\", timeSpec };\n\n        ArrayList<Transaction> transactions = new ArrayList<Transaction>();\n        HistoryConsumer stdout = new HistoryConsumer( getLogger(), transactions );\n        return executeCommandLine( hist, null, stdout ) == 0 ? transactions : null;\n    }\n\n    public List<FileDifference> diff( String baseStream, String fromTimeSpec, String toTimeSpec )\n        throws AccuRevException\n    {\n        String timeSpec = fromTimeSpec + \"-\" + toTimeSpec;\n        String[] diff = { \"diff\", \"-fx\", \"-a\", \"-i\", \"-v\", baseStream, \"-V\", baseStream, \"-t\", timeSpec };\n\n        List<FileDifference> results = new ArrayList<FileDifference>();\n        DiffConsumer stdout = new DiffConsumer( getLogger(), results );\n        return executeCommandLine( diff, null, stdout ) < 2 ? results : null;\n    }\n\n    public boolean login( String user, String password )\n        throws AccuRevException\n    {\n\n        // TODO Raise bug against plexus commandline - can't set workingdir to null\n        // and will get an error if the working directory is deleted.\n        cl.setWorkingDirectory( \".\" );\n        authArgs = EMPTY_STRING_ARRAY;\n        AuthTokenConsumer stdout = new AuthTokenConsumer();\n\n        boolean result;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( StringUtils.isBlank( password ) )\n            {\n                // Ensure blank is passed in.\n                password = \"\\\"\\\"\";\n            }\n            String[] login = { \"login\", \"-A\", user, password };\n            result = executeCommandLine( login, null, stdout ) == 0;\n        }\n        else\n        {\n            String[] login = { \"login\", \"-A\", user };\n            password = StringUtils.clean( password ) + \"\\n\";\n            byte[] bytes = password.getBytes();\n            ByteArrayInputStream stdin = new ByteArrayInputStream( bytes );\n            result = executeCommandLine( login, stdin, stdout ) == 0;\n\n        }\n\n        authArgs = new String[] { \"-A\", stdout.getAuthToken() };\n        return result;\n    }\n\n    public boolean logout()\n        throws AccuRevException\n    {\n\n        String[] logout = { \"logout\" };\n        return executeCommandLine( logout );\n\n    }\n\n    public List<BlameLine> annotate( File basedir, File file )\n        throws AccuRevException\n    {\n\n        String[] annotate = { \"annotate\", \"-ftud\" };\n        List<BlameLine> lines = new ArrayList<BlameLine>();\n        AnnotateConsumer stdout = new AnnotateConsumer( lines, getLogger() );\n\n        return executeCommandLine( basedir, annotate, Collections.singletonList( file ), stdout ) ? lines : null;\n    }\n\n    public Map<String, WorkSpace> showRefTrees()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-fx\", \"refs\" };\n        Map<String, WorkSpace> refTrees = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), refTrees );\n        return executeCommandLine( show, null, stdout ) == 0 ? refTrees : null;\n    }\n\n    public Map<String, WorkSpace> showWorkSpaces()\n        throws AccuRevException\n    {\n\n        String[] show = { \"show\", \"-a\", \"-fx\", \"wspaces\" };\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n        WorkSpaceConsumer stdout = new WorkSpaceConsumer( getLogger(), workSpaces );\n        return executeCommandLine( show, null, stdout ) == 0 ? workSpaces : null;\n    }\n\n    public Stream showStream( String stream )\n        throws AccuRevException\n    {\n        String[] show = { \"show\", \"-s\", stream, \"-fx\", \"streams\" };\n        List<Stream> streams = new ArrayList<Stream>();\n        StreamsConsumer stdout = new StreamsConsumer( getLogger(), streams );\n\n        return executeCommandLine( show, null, stdout ) == 0 && streams.size() == 1 ? streams.get( 0 ) : null;\n    }\n\n    public String getExecutable()\n    {\n\n        return executable;\n    }\n\n    public String getClientVersion()\n        throws AccuRevException\n    {\n\n        long lastModified = new File( getExecutable() ).lastModified();\n        if ( clientVersion == null || executableModTime != lastModified )\n        {\n            executableModTime = lastModified;\n\n            ClientVersionConsumer stdout = new ClientVersionConsumer();\n            executeCommandLine( new String[] {}, null, stdout );\n            clientVersion = stdout.getClientVersion();\n        }\n        return clientVersion;\n\n    }\n\n}\n","lineNo":515}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommand;\nimport org.codehaus.plexus.util.StringUtils;\n\npublic class AccuRevUpdateCommand\n    extends AbstractAccuRevCommand\n{\n\n    public AccuRevUpdateCommand( ScmLogger logger )\n    {\n        super( logger );\n    }\n\n    @Override\n    protected ScmResult executeAccurevCommand( AccuRevScmProviderRepository repository, ScmFileSet fileSet,\n                                               CommandParameters parameters )\n        throws ScmException, AccuRevException\n    {\n\n        ArrayList<File> updatedFiles = new ArrayList<File>();\n\n        AccuRev accuRev = repository.getAccuRev();\n\n        File basedir = fileSet.getBasedir();\n\n        AccuRevInfo info = accuRev.info( basedir );\n\n        if ( !info.isWorkSpace() )\n        {\n            throw new AccuRevException( \"No workspace at \" + basedir.getAbsolutePath() );\n        }\n\n        boolean success = true;\n\n        AccuRevVersion startVersion = getStartVersion( repository, parameters, info );\n\n        AccuRevVersion endVersion = getEndVersion( repository, parameters, info );\n\n        String newBasisStream = endVersion.getBasisStream();\n        if ( newBasisStream != null && !newBasisStream.equals( info.getBasis() ) )\n        {\n            getLogger().info( \"Reparenting \" + info.getWorkSpace() + \" to \" + newBasisStream );\n            success = accuRev.chws( basedir, info.getWorkSpace(), newBasisStream );\n        }\n\n        success = success && accuRev.update( basedir, endVersion.getTimeSpec(), updatedFiles );\n\n        if ( success )\n        {\n            return new AccuRevUpdateScmResult( startVersion, endVersion, accuRev.getCommandLines(),\n                                               getScmFiles( updatedFiles, ScmFileStatus.UPDATED ) );\n        }\n        else\n        {\n            return new UpdateScmResult( accuRev.getCommandLines(), \"AccuRev error\", accuRev.getErrorOutput(), false );\n        }\n    }\n\n    /*\n     * If we are not capturing info for a changelog, return null. If start date is supplied then\n     * start version is the current workspace basis stream / start_date Otherwise get the current\n     * high water mark for the workspace as the start version.\n     */\n    private AccuRevVersion getStartVersion( AccuRevScmProviderRepository repository, CommandParameters parameters,\n                                            AccuRevInfo info )\n        throws ScmException, AccuRevException\n    {\n        AccuRevVersion startVersion = null;\n\n        AccuRev accuRev = repository.getAccuRev();\n\n        boolean runChangeLog = parameters.getBoolean( CommandParameter.RUN_CHANGELOG_WITH_UPDATE );\n        Date startDate = parameters.getDate( CommandParameter.START_DATE, null );\n\n        if ( runChangeLog )\n        {\n            if ( startDate == null )\n            {\n                // Get tran id before the update, and add one.\n                startVersion = new AccuRevVersion( info.getBasis(), 1 + getCurrentTransactionId( info.getWorkSpace(),\n                                                                                                 accuRev ) );\n            }\n            else\n            {\n                // Use the supplied date (assume same basis, TODO not strictly correct)\n                startVersion = new AccuRevVersion( info.getBasis(), startDate );\n            }\n        }\n        return startVersion;\n    }\n\n    /*\n     * End version timespec is used as the -t parameter to update. If a version is specified in\n     * parameters then we use that. If \"now\" or \"highest\" is specified as the timespec it is\n     * replaced with the \"now\" as a date, so that we can be 100% accurate in terms of the changelog.\n     * If no version is specified then we use the current workspace basis stream and \"now\" as a\n     * date.\n     */\n    private AccuRevVersion getEndVersion( AccuRevScmProviderRepository repository, CommandParameters parameters,\n                                          AccuRevInfo info )\n        throws ScmException\n    {\n        AccuRevVersion endVersion = null;\n        ScmVersion scmVersion = parameters.getScmVersion( CommandParameter.SCM_VERSION, null );\n\n        if ( scmVersion != null )\n        {\n            endVersion = repository.getAccuRevVersion( scmVersion );\n        }\n        else\n        {\n            endVersion = new AccuRevVersion( info.getBasis(), (String) null );\n        }\n        return endVersion;\n    }\n\n    private long getCurrentTransactionId( String workSpaceName, AccuRev accuRev )\n        throws AccuRevException\n    {\n        // AccuRev does not have a way to get at this workspace info by name.\n        // So we have to do it the hard way...\n\n        Map<String, WorkSpace> workSpaces = new HashMap<String, WorkSpace>();\n\n        accuRev.showWorkSpaces( workSpaces );\n\n        WorkSpace workspace = workSpaces.get( workSpaceName );\n\n        if ( workspace == null )\n        {\n            // Must be a reftree\n            accuRev.showRefTrees( workSpaces );\n            workspace = workSpaces.get( workSpaceName );\n        }\n\n        if ( workspace == null )\n        {\n            getLogger().warn( \"Can't find workspace \" + workSpaceName );\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().warn( StringUtils.join( workSpaces.values().iterator(), \"\\n\" ) );\n            }\n            return 0;\n        }\n        return workspace.getTransactionId();\n    }\n\n    public UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        return (UpdateScmResult) execute( repository, fileSet, parameters );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRev;\nimport org.apache.maven.scm.provider.accurev.AccuRevException;\nimport org.apache.maven.scm.provider.accurev.AccuRevInfo;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevVersion;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommand;\n\npublic class AccuRevUpdateCommand\n    extends AbstractAccuRevCommand\n{\n\n    public AccuRevUpdateCommand( ScmLogger logger )\n    {\n        super( logger );\n    }\n\n    @Override\n    protected ScmResult executeAccurevCommand( AccuRevScmProviderRepository repository, ScmFileSet fileSet,\n                                               CommandParameters parameters )\n        throws ScmException, AccuRevException\n    {\n\n        AccuRev accuRev = repository.getAccuRev();\n\n        File basedir = fileSet.getBasedir();\n\n        AccuRevInfo info = accuRev.info( basedir );\n\n        if ( !info.isWorkSpace() )\n        {\n            throw new AccuRevException( \"No workspace at \" + basedir.getAbsolutePath() );\n        }\n\n        String startRevision = getStartRevision( repository, parameters, info );\n\n        ScmVersion scmVersion = parameters.getScmVersion( CommandParameter.SCM_VERSION, null );\n\n        String updateTransactionId = null;\n\n        if ( scmVersion != null )\n        {\n            AccuRevVersion updateVersion = repository.getAccuRevVersion( scmVersion );\n\n            // Reparent if necessary\n            String newBasisStream = updateVersion.getBasisStream();\n            if ( newBasisStream != null\n                && ( !( newBasisStream.equals( info.getWorkSpace() ) || newBasisStream.equals( info.getBasis() ) ) ) )\n            {\n                getLogger().info( \"Reparenting \" + info.getWorkSpace() + \" to \" + newBasisStream );\n                accuRev.chws( basedir, info.getWorkSpace(), newBasisStream );\n            }\n\n            if ( !updateVersion.isNow() )\n            {\n                updateTransactionId = updateVersion.getTimeSpec();\n            }\n        }\n\n        if ( updateTransactionId == null )\n        {\n            updateTransactionId = repository.getDepotTransactionId( info.getWorkSpace(), \"now\" );\n        }\n\n        String endRevision = repository.getRevision( info.getWorkSpace(), updateTransactionId );\n\n        List<File> updatedFiles = accuRev.update( basedir, updateTransactionId );\n\n        if ( updatedFiles != null )\n        {\n            return new AccuRevUpdateScmResult( accuRev.getCommandLines(), getScmFiles( updatedFiles,\n                                                                                       ScmFileStatus.UPDATED ),\n                                               startRevision, endRevision );\n        }\n        else\n        {\n            return new AccuRevUpdateScmResult( accuRev.getCommandLines(), \"AccuRev error\", accuRev.getErrorOutput(),\n                                               null, null, false );\n        }\n    }\n\n    /*\n     * If we are not capturing info for a changelog then we don't need a start revision. Start date is used if supplied\n     * otherwise get the current high water mark for the workspace as the start version.\n     */\n    private String getStartRevision( AccuRevScmProviderRepository repository, CommandParameters parameters,\n                                     AccuRevInfo info )\n        throws ScmException, AccuRevException\n    {\n\n        boolean runChangeLog = parameters.getBoolean( CommandParameter.RUN_CHANGELOG_WITH_UPDATE );\n        Date startDate = parameters.getDate( CommandParameter.START_DATE, null );\n        String workspace = info.getWorkSpace();\n\n        if ( !runChangeLog )\n        {\n            return null;\n        }\n        else\n        {\n            return startDate == null ? repository.getWorkSpaceRevision( workspace )\n                            : repository.getRevision( workspace, startDate );\n        }\n\n    }\n\n    public UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        return (UpdateScmResult) execute( repository, fileSet, parameters );\n    }\n\n}\n","lineNo":127}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.add;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevAddCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).add( with( basedir ), with( testFileSet.getFileList() ), with( \"A new file\" ),\n                                    with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, new File( \"added/file\" ) ), returnValue( true ) ) );\n                inSequence( sequence );\n\n            }\n        } );\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getAddedFiles().size(), is( 1 ) );\n        assertHasScmFile( result.getAddedFiles(), \"added/file\", ScmFileStatus.ADDED );\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddFailed()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).add( with( basedir ), with( testFileSet.getFileList() ), with( \"A new file\" ),\n                                    with( any( List.class ) ) );\n                will( returnValue( false ) );\n                inSequence( sequence );\n\n            }\n        } );\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.add;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevAddCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n        final List<File> files = testFileSet.getFileList();\n\n        when( accurev.add( basedir, files, \"A new file\" ) ).thenReturn(\n                                                                        Collections.singletonList( new File(\n                                                                                                             \"added/file\" ) ) );\n        \n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getAddedFiles().size(), is( 1 ) );\n        assertHasScmFile( result.getAddedFiles(), \"added/file\", ScmFileStatus.ADDED );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testAddFailed()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n        final List<File> files = testFileSet.getFileList();\n\n        when( accurev.add( basedir, files, \"A new file\" ) ).thenReturn(null);\n                                                                       \n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n    }\n\n}\n","lineNo":50}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.add;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevAddCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).add( with( basedir ), with( testFileSet.getFileList() ), with( \"A new file\" ),\n                                    with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, new File( \"added/file\" ) ), returnValue( true ) ) );\n                inSequence( sequence );\n\n            }\n        } );\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getAddedFiles().size(), is( 1 ) );\n        assertHasScmFile( result.getAddedFiles(), \"added/file\", ScmFileStatus.ADDED );\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddFailed()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).add( with( basedir ), with( testFileSet.getFileList() ), with( \"A new file\" ),\n                                    with( any( List.class ) ) );\n                will( returnValue( false ) );\n                inSequence( sequence );\n\n            }\n        } );\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.add;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevAddCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testAdd()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n        final List<File> files = testFileSet.getFileList();\n\n        when( accurev.add( basedir, files, \"A new file\" ) ).thenReturn(\n                                                                        Collections.singletonList( new File(\n                                                                                                             \"added/file\" ) ) );\n        \n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getAddedFiles().size(), is( 1 ) );\n        assertHasScmFile( result.getAddedFiles(), \"added/file\", ScmFileStatus.ADDED );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testAddFailed()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( basedir, new File( \"src/main/java/Foo.java\" ) );\n        final List<File> files = testFileSet.getFileList();\n\n        when( accurev.add( basedir, files, \"A new file\" ) ).thenReturn(null);\n                                                                       \n        AccuRevAddCommand command = new AccuRevAddCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.MESSAGE, \"A new file\" );\n        AddScmResult result = command.add( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n    }\n\n}\n","lineNo":73}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"kept/file\" );\n                File keptAdded = new File( \"kept/added\" );\n                // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n                // needs to filter it out.\n                File keptDefunct = new File( \"kept/defunct\" );\n                File modifiedFile = new File( \"modified/file\" );\n                File modifiedAdded = new File( \"modified/added\" );\n                File missingFile = new File( \"missing/file\" );\n                File externalFile = new File( \"external/file\" );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.DEFUNCT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, modifiedFile, modifiedAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.KEPT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct, keptFile, keptAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MISSING ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, missingFile ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.EXTERNAL ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, externalFile ), returnValue( true ) ) );\n\n                one( accurev ).statBackingStream(\n                                                  with( basedir ),\n                                                  (Collection<File>) with( allOf( hasItems( modifiedFile,\n                                                                                            modifiedAdded, keptFile,\n                                                                                            keptAdded ),\n                                                                                  not( hasItem( keptDefunct ) ) ) ),\n                                                  with( any( List.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, modifiedFile, keptFile ), addElementsTo( 3, modifiedAdded, keptAdded ),\n                             returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n        // Note the case.. without compiles under Eclipse but not sun JDK\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( returnValue( false ) );\n\n                atMost( 4 ).of( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ),\n                                                with( any( AccuRevStat.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.anyListOf;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        File keptFile = new File( \"kept/file\" );\n        File keptAdded = new File( \"kept/added\" );\n        // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n        // needs to filter it out.\n        File keptDefunct = new File( \"kept/defunct\" );\n        File modifiedFile = new File( \"modified/file\" );\n        File modifiedAdded = new File( \"modified/added\" );\n        File missingFile = new File( \"missing/file\" );\n        File externalFile = new File( \"external/file\" );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.DEFUNCT ) ) ).thenReturn(\n                                                                                                              Arrays.asList( keptDefunct ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MODIFIED ) ) ).thenReturn(\n                                                                                                               Arrays.asList( modifiedFile,modifiedAdded ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.KEPT ) ) ).thenReturn(\n                                                                                                           Arrays.asList(\n                                                                                                                          keptDefunct,\n                                                                                                                          keptFile,\n                                                                                                                          keptAdded ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MISSING ) ) ).thenReturn(\n                                                                                                              Arrays.asList( missingFile ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.EXTERNAL ) ) ).thenReturn(\n                                                                                                               Arrays.asList( externalFile ) );\n\n        CategorisedElements catElems = new CategorisedElements();\n        catElems.getMemberElements().addAll( Arrays.asList( modifiedFile, keptFile ) );\n        catElems.getNonMemberElements().addAll( Arrays.asList( modifiedAdded, keptAdded ) );\n        when(\n              accurev.statBackingStream( eq( basedir ), (Collection<File>) argThat( hasItems( modifiedFile,\n                                                                                              modifiedAdded, keptFile,\n                                                                                              keptAdded ) ) ) ).thenReturn(\n                                                                                                                            catElems );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        when( accurev.stat( basedir, testFileSet.getFileList(), AccuRevStat.MODIFIED ) ).thenReturn( null );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","lineNo":62}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"kept/file\" );\n                File keptAdded = new File( \"kept/added\" );\n                // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n                // needs to filter it out.\n                File keptDefunct = new File( \"kept/defunct\" );\n                File modifiedFile = new File( \"modified/file\" );\n                File modifiedAdded = new File( \"modified/added\" );\n                File missingFile = new File( \"missing/file\" );\n                File externalFile = new File( \"external/file\" );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.DEFUNCT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, modifiedFile, modifiedAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.KEPT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct, keptFile, keptAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MISSING ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, missingFile ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.EXTERNAL ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, externalFile ), returnValue( true ) ) );\n\n                one( accurev ).statBackingStream(\n                                                  with( basedir ),\n                                                  (Collection<File>) with( allOf( hasItems( modifiedFile,\n                                                                                            modifiedAdded, keptFile,\n                                                                                            keptAdded ),\n                                                                                  not( hasItem( keptDefunct ) ) ) ),\n                                                  with( any( List.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, modifiedFile, keptFile ), addElementsTo( 3, modifiedAdded, keptAdded ),\n                             returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n        // Note the case.. without compiles under Eclipse but not sun JDK\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( returnValue( false ) );\n\n                atMost( 4 ).of( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ),\n                                                with( any( AccuRevStat.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.anyListOf;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        File keptFile = new File( \"kept/file\" );\n        File keptAdded = new File( \"kept/added\" );\n        // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n        // needs to filter it out.\n        File keptDefunct = new File( \"kept/defunct\" );\n        File modifiedFile = new File( \"modified/file\" );\n        File modifiedAdded = new File( \"modified/added\" );\n        File missingFile = new File( \"missing/file\" );\n        File externalFile = new File( \"external/file\" );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.DEFUNCT ) ) ).thenReturn(\n                                                                                                              Arrays.asList( keptDefunct ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MODIFIED ) ) ).thenReturn(\n                                                                                                               Arrays.asList( modifiedFile,modifiedAdded ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.KEPT ) ) ).thenReturn(\n                                                                                                           Arrays.asList(\n                                                                                                                          keptDefunct,\n                                                                                                                          keptFile,\n                                                                                                                          keptAdded ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MISSING ) ) ).thenReturn(\n                                                                                                              Arrays.asList( missingFile ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.EXTERNAL ) ) ).thenReturn(\n                                                                                                               Arrays.asList( externalFile ) );\n\n        CategorisedElements catElems = new CategorisedElements();\n        catElems.getMemberElements().addAll( Arrays.asList( modifiedFile, keptFile ) );\n        catElems.getNonMemberElements().addAll( Arrays.asList( modifiedAdded, keptAdded ) );\n        when(\n              accurev.statBackingStream( eq( basedir ), (Collection<File>) argThat( hasItems( modifiedFile,\n                                                                                              modifiedAdded, keptFile,\n                                                                                              keptAdded ) ) ) ).thenReturn(\n                                                                                                                            catElems );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        when( accurev.stat( basedir, testFileSet.getFileList(), AccuRevStat.MODIFIED ) ).thenReturn( null );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","lineNo":63}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"kept/file\" );\n                File keptAdded = new File( \"kept/added\" );\n                // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n                // needs to filter it out.\n                File keptDefunct = new File( \"kept/defunct\" );\n                File modifiedFile = new File( \"modified/file\" );\n                File modifiedAdded = new File( \"modified/added\" );\n                File missingFile = new File( \"missing/file\" );\n                File externalFile = new File( \"external/file\" );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.DEFUNCT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, modifiedFile, modifiedAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.KEPT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct, keptFile, keptAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MISSING ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, missingFile ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.EXTERNAL ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, externalFile ), returnValue( true ) ) );\n\n                one( accurev ).statBackingStream(\n                                                  with( basedir ),\n                                                  (Collection<File>) with( allOf( hasItems( modifiedFile,\n                                                                                            modifiedAdded, keptFile,\n                                                                                            keptAdded ),\n                                                                                  not( hasItem( keptDefunct ) ) ) ),\n                                                  with( any( List.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, modifiedFile, keptFile ), addElementsTo( 3, modifiedAdded, keptAdded ),\n                             returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n        // Note the case.. without compiles under Eclipse but not sun JDK\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( returnValue( false ) );\n\n                atMost( 4 ).of( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ),\n                                                with( any( AccuRevStat.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.anyListOf;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        File keptFile = new File( \"kept/file\" );\n        File keptAdded = new File( \"kept/added\" );\n        // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n        // needs to filter it out.\n        File keptDefunct = new File( \"kept/defunct\" );\n        File modifiedFile = new File( \"modified/file\" );\n        File modifiedAdded = new File( \"modified/added\" );\n        File missingFile = new File( \"missing/file\" );\n        File externalFile = new File( \"external/file\" );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.DEFUNCT ) ) ).thenReturn(\n                                                                                                              Arrays.asList( keptDefunct ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MODIFIED ) ) ).thenReturn(\n                                                                                                               Arrays.asList( modifiedFile,modifiedAdded ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.KEPT ) ) ).thenReturn(\n                                                                                                           Arrays.asList(\n                                                                                                                          keptDefunct,\n                                                                                                                          keptFile,\n                                                                                                                          keptAdded ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MISSING ) ) ).thenReturn(\n                                                                                                              Arrays.asList( missingFile ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.EXTERNAL ) ) ).thenReturn(\n                                                                                                               Arrays.asList( externalFile ) );\n\n        CategorisedElements catElems = new CategorisedElements();\n        catElems.getMemberElements().addAll( Arrays.asList( modifiedFile, keptFile ) );\n        catElems.getNonMemberElements().addAll( Arrays.asList( modifiedAdded, keptAdded ) );\n        when(\n              accurev.statBackingStream( eq( basedir ), (Collection<File>) argThat( hasItems( modifiedFile,\n                                                                                              modifiedAdded, keptFile,\n                                                                                              keptAdded ) ) ) ).thenReturn(\n                                                                                                                            catElems );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        when( accurev.stat( basedir, testFileSet.getFileList(), AccuRevStat.MODIFIED ) ).thenReturn( null );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","lineNo":66}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"kept/file\" );\n                File keptAdded = new File( \"kept/added\" );\n                // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n                // needs to filter it out.\n                File keptDefunct = new File( \"kept/defunct\" );\n                File modifiedFile = new File( \"modified/file\" );\n                File modifiedAdded = new File( \"modified/added\" );\n                File missingFile = new File( \"missing/file\" );\n                File externalFile = new File( \"external/file\" );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.DEFUNCT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, modifiedFile, modifiedAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.KEPT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct, keptFile, keptAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MISSING ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, missingFile ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.EXTERNAL ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, externalFile ), returnValue( true ) ) );\n\n                one( accurev ).statBackingStream(\n                                                  with( basedir ),\n                                                  (Collection<File>) with( allOf( hasItems( modifiedFile,\n                                                                                            modifiedAdded, keptFile,\n                                                                                            keptAdded ),\n                                                                                  not( hasItem( keptDefunct ) ) ) ),\n                                                  with( any( List.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, modifiedFile, keptFile ), addElementsTo( 3, modifiedAdded, keptAdded ),\n                             returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n        // Note the case.. without compiles under Eclipse but not sun JDK\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( returnValue( false ) );\n\n                atMost( 4 ).of( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ),\n                                                with( any( AccuRevStat.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.anyListOf;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        File keptFile = new File( \"kept/file\" );\n        File keptAdded = new File( \"kept/added\" );\n        // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n        // needs to filter it out.\n        File keptDefunct = new File( \"kept/defunct\" );\n        File modifiedFile = new File( \"modified/file\" );\n        File modifiedAdded = new File( \"modified/added\" );\n        File missingFile = new File( \"missing/file\" );\n        File externalFile = new File( \"external/file\" );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.DEFUNCT ) ) ).thenReturn(\n                                                                                                              Arrays.asList( keptDefunct ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MODIFIED ) ) ).thenReturn(\n                                                                                                               Arrays.asList( modifiedFile,modifiedAdded ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.KEPT ) ) ).thenReturn(\n                                                                                                           Arrays.asList(\n                                                                                                                          keptDefunct,\n                                                                                                                          keptFile,\n                                                                                                                          keptAdded ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MISSING ) ) ).thenReturn(\n                                                                                                              Arrays.asList( missingFile ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.EXTERNAL ) ) ).thenReturn(\n                                                                                                               Arrays.asList( externalFile ) );\n\n        CategorisedElements catElems = new CategorisedElements();\n        catElems.getMemberElements().addAll( Arrays.asList( modifiedFile, keptFile ) );\n        catElems.getNonMemberElements().addAll( Arrays.asList( modifiedAdded, keptAdded ) );\n        when(\n              accurev.statBackingStream( eq( basedir ), (Collection<File>) argThat( hasItems( modifiedFile,\n                                                                                              modifiedAdded, keptFile,\n                                                                                              keptAdded ) ) ) ).thenReturn(\n                                                                                                                            catElems );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        when( accurev.stat( basedir, testFileSet.getFileList(), AccuRevStat.MODIFIED ) ).thenReturn( null );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","lineNo":67}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"kept/file\" );\n                File keptAdded = new File( \"kept/added\" );\n                // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n                // needs to filter it out.\n                File keptDefunct = new File( \"kept/defunct\" );\n                File modifiedFile = new File( \"modified/file\" );\n                File modifiedAdded = new File( \"modified/added\" );\n                File missingFile = new File( \"missing/file\" );\n                File externalFile = new File( \"external/file\" );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.DEFUNCT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, modifiedFile, modifiedAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.KEPT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct, keptFile, keptAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MISSING ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, missingFile ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.EXTERNAL ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, externalFile ), returnValue( true ) ) );\n\n                one( accurev ).statBackingStream(\n                                                  with( basedir ),\n                                                  (Collection<File>) with( allOf( hasItems( modifiedFile,\n                                                                                            modifiedAdded, keptFile,\n                                                                                            keptAdded ),\n                                                                                  not( hasItem( keptDefunct ) ) ) ),\n                                                  with( any( List.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, modifiedFile, keptFile ), addElementsTo( 3, modifiedAdded, keptAdded ),\n                             returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n        // Note the case.. without compiles under Eclipse but not sun JDK\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( returnValue( false ) );\n\n                atMost( 4 ).of( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ),\n                                                with( any( AccuRevStat.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.anyListOf;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        File keptFile = new File( \"kept/file\" );\n        File keptAdded = new File( \"kept/added\" );\n        // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n        // needs to filter it out.\n        File keptDefunct = new File( \"kept/defunct\" );\n        File modifiedFile = new File( \"modified/file\" );\n        File modifiedAdded = new File( \"modified/added\" );\n        File missingFile = new File( \"missing/file\" );\n        File externalFile = new File( \"external/file\" );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.DEFUNCT ) ) ).thenReturn(\n                                                                                                              Arrays.asList( keptDefunct ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MODIFIED ) ) ).thenReturn(\n                                                                                                               Arrays.asList( modifiedFile,modifiedAdded ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.KEPT ) ) ).thenReturn(\n                                                                                                           Arrays.asList(\n                                                                                                                          keptDefunct,\n                                                                                                                          keptFile,\n                                                                                                                          keptAdded ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MISSING ) ) ).thenReturn(\n                                                                                                              Arrays.asList( missingFile ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.EXTERNAL ) ) ).thenReturn(\n                                                                                                               Arrays.asList( externalFile ) );\n\n        CategorisedElements catElems = new CategorisedElements();\n        catElems.getMemberElements().addAll( Arrays.asList( modifiedFile, keptFile ) );\n        catElems.getNonMemberElements().addAll( Arrays.asList( modifiedAdded, keptAdded ) );\n        when(\n              accurev.statBackingStream( eq( basedir ), (Collection<File>) argThat( hasItems( modifiedFile,\n                                                                                              modifiedAdded, keptFile,\n                                                                                              keptAdded ) ) ) ).thenReturn(\n                                                                                                                            catElems );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        when( accurev.stat( basedir, testFileSet.getFileList(), AccuRevStat.MODIFIED ) ).thenReturn( null );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","lineNo":68}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"kept/file\" );\n                File keptAdded = new File( \"kept/added\" );\n                // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n                // needs to filter it out.\n                File keptDefunct = new File( \"kept/defunct\" );\n                File modifiedFile = new File( \"modified/file\" );\n                File modifiedAdded = new File( \"modified/added\" );\n                File missingFile = new File( \"missing/file\" );\n                File externalFile = new File( \"external/file\" );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.DEFUNCT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, modifiedFile, modifiedAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.KEPT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct, keptFile, keptAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MISSING ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, missingFile ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.EXTERNAL ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, externalFile ), returnValue( true ) ) );\n\n                one( accurev ).statBackingStream(\n                                                  with( basedir ),\n                                                  (Collection<File>) with( allOf( hasItems( modifiedFile,\n                                                                                            modifiedAdded, keptFile,\n                                                                                            keptAdded ),\n                                                                                  not( hasItem( keptDefunct ) ) ) ),\n                                                  with( any( List.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, modifiedFile, keptFile ), addElementsTo( 3, modifiedAdded, keptAdded ),\n                             returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n        // Note the case.. without compiles under Eclipse but not sun JDK\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( returnValue( false ) );\n\n                atMost( 4 ).of( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ),\n                                                with( any( AccuRevStat.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.anyListOf;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        File keptFile = new File( \"kept/file\" );\n        File keptAdded = new File( \"kept/added\" );\n        // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n        // needs to filter it out.\n        File keptDefunct = new File( \"kept/defunct\" );\n        File modifiedFile = new File( \"modified/file\" );\n        File modifiedAdded = new File( \"modified/added\" );\n        File missingFile = new File( \"missing/file\" );\n        File externalFile = new File( \"external/file\" );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.DEFUNCT ) ) ).thenReturn(\n                                                                                                              Arrays.asList( keptDefunct ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MODIFIED ) ) ).thenReturn(\n                                                                                                               Arrays.asList( modifiedFile,modifiedAdded ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.KEPT ) ) ).thenReturn(\n                                                                                                           Arrays.asList(\n                                                                                                                          keptDefunct,\n                                                                                                                          keptFile,\n                                                                                                                          keptAdded ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MISSING ) ) ).thenReturn(\n                                                                                                              Arrays.asList( missingFile ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.EXTERNAL ) ) ).thenReturn(\n                                                                                                               Arrays.asList( externalFile ) );\n\n        CategorisedElements catElems = new CategorisedElements();\n        catElems.getMemberElements().addAll( Arrays.asList( modifiedFile, keptFile ) );\n        catElems.getNonMemberElements().addAll( Arrays.asList( modifiedAdded, keptAdded ) );\n        when(\n              accurev.statBackingStream( eq( basedir ), (Collection<File>) argThat( hasItems( modifiedFile,\n                                                                                              modifiedAdded, keptFile,\n                                                                                              keptAdded ) ) ) ).thenReturn(\n                                                                                                                            catElems );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        when( accurev.stat( basedir, testFileSet.getFileList(), AccuRevStat.MODIFIED ) ).thenReturn( null );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","lineNo":69}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"kept/file\" );\n                File keptAdded = new File( \"kept/added\" );\n                // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n                // needs to filter it out.\n                File keptDefunct = new File( \"kept/defunct\" );\n                File modifiedFile = new File( \"modified/file\" );\n                File modifiedAdded = new File( \"modified/added\" );\n                File missingFile = new File( \"missing/file\" );\n                File externalFile = new File( \"external/file\" );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.DEFUNCT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, modifiedFile, modifiedAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.KEPT ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, keptDefunct, keptFile, keptAdded ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MISSING ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, missingFile ), returnValue( true ) ) );\n\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.EXTERNAL ),\n                                     with( any( List.class ) ) );\n                will( doAll( addElementsTo( 3, externalFile ), returnValue( true ) ) );\n\n                one( accurev ).statBackingStream(\n                                                  with( basedir ),\n                                                  (Collection<File>) with( allOf( hasItems( modifiedFile,\n                                                                                            modifiedAdded, keptFile,\n                                                                                            keptAdded ),\n                                                                                  not( hasItem( keptDefunct ) ) ) ),\n                                                  with( any( List.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, modifiedFile, keptFile ), addElementsTo( 3, modifiedAdded, keptAdded ),\n                             returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n        // Note the case.. without compiles under Eclipse but not sun JDK\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                one( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ), with( AccuRevStat.MODIFIED ),\n                                     with( any( List.class ) ) );\n                will( returnValue( false ) );\n\n                atMost( 4 ).of( accurev ).stat( with( basedir ), with( testFileSet.getFileList() ),\n                                                with( any( AccuRevStat.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n            }\n        } );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.status;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.ScmFileMatcher.scmFile;\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.anyListOf;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevStat;\nimport org.apache.maven.scm.provider.accurev.CategorisedElements;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.junit.Test;\n\npublic class AccuRevStatusCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testStatus()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        File keptFile = new File( \"kept/file\" );\n        File keptAdded = new File( \"kept/added\" );\n        // this is the special one, it is returned by both the kept and defunct stat calls, so the command\n        // needs to filter it out.\n        File keptDefunct = new File( \"kept/defunct\" );\n        File modifiedFile = new File( \"modified/file\" );\n        File modifiedAdded = new File( \"modified/added\" );\n        File missingFile = new File( \"missing/file\" );\n        File externalFile = new File( \"external/file\" );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.DEFUNCT ) ) ).thenReturn(\n                                                                                                              Arrays.asList( keptDefunct ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MODIFIED ) ) ).thenReturn(\n                                                                                                               Arrays.asList( modifiedFile,modifiedAdded ) );\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.KEPT ) ) ).thenReturn(\n                                                                                                           Arrays.asList(\n                                                                                                                          keptDefunct,\n                                                                                                                          keptFile,\n                                                                                                                          keptAdded ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.MISSING ) ) ).thenReturn(\n                                                                                                              Arrays.asList( missingFile ) );\n\n        when( accurev.stat( eq( basedir ), anyListOf( File.class ), eq( AccuRevStat.EXTERNAL ) ) ).thenReturn(\n                                                                                                               Arrays.asList( externalFile ) );\n\n        CategorisedElements catElems = new CategorisedElements();\n        catElems.getMemberElements().addAll( Arrays.asList( modifiedFile, keptFile ) );\n        catElems.getNonMemberElements().addAll( Arrays.asList( modifiedAdded, keptAdded ) );\n        when(\n              accurev.statBackingStream( eq( basedir ), (Collection<File>) argThat( hasItems( modifiedFile,\n                                                                                              modifiedAdded, keptFile,\n                                                                                              keptAdded ) ) ) ).thenReturn(\n                                                                                                                            catElems );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getChangedFiles().size(), is( 7 ) );\n\n        assertThat( (List<ScmFile>) result.getChangedFiles(), not( hasItem( scmFile( \"kept/defunct\",\n                                                                                     ScmFileStatus.MODIFIED ) ) ) );\n        assertHasScmFile( result.getChangedFiles(), \"kept/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"kept/defunct\", ScmFileStatus.DELETED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/file\", ScmFileStatus.MODIFIED );\n        assertHasScmFile( result.getChangedFiles(), \"modified/added\", ScmFileStatus.ADDED );\n        assertHasScmFile( result.getChangedFiles(), \"missing/file\", ScmFileStatus.MISSING );\n        assertHasScmFile( result.getChangedFiles(), \"external/file\", ScmFileStatus.UNKNOWN );\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testFailure()\n        throws Exception\n    {\n\n        final ScmFileSet testFileSet = getScmFileSet();\n\n        when( accurev.stat( basedir, testFileSet.getFileList(), AccuRevStat.MODIFIED ) ).thenReturn( null );\n\n        AccuRevStatusCommand command = new AccuRevStatusCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        StatusScmResult result = command.status( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n\n}\n","lineNo":70}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.apache.maven.scm.provider.accurev.PutMapEntryAction.putEntryTo;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.hamcrest.Matchers.nullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.hamcrest.core.IsInstanceOf;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccurevUpdateCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"updated/file\" );\n                File keptAdded = new File( \"new/file\" );\n\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                // TODO Should test that the timeSpec parameter is a formatted date\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, keptFile, keptAdded ), returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getUpdatedFiles().size(), is( 2 ) );\n        assertHasScmFile( result.getUpdatedFiles(), \"updated/file\", ScmFileStatus.UPDATED );\n        assertHasScmFile( result.getUpdatedFiles(), \"new/file\", ScmFileStatus.UPDATED );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdateWithChangeLog()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n        info.setBasis( \"myStream\" );\n        context.checking( new Expectations()\n        {\n            {\n                WorkSpace wsBefore = new WorkSpace( \"theWorkSpace\", 123 );\n\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                one( accurev ).showWorkSpaces( with( any( Map.class ) ) );\n                will( doAll( putEntryTo( 0, \"theWorkSpace\", wsBefore ), returnValue( true ) ) );\n\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( true ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result, IsInstanceOf.instanceOf( AccuRevUpdateScmResult.class ) );\n        AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n        assertThat( accuRevResult.getFromVersion().getTimeSpec(), is( \"124\" ) );\n        assertThat( accuRevResult.getToVersion().getTimeSpec(), nullValue() );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAccuRevFailure()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"updated/file\" );\n                File keptAdded = new File( \"new/file\" );\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, keptFile, keptAdded ), returnValue( false ) ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.hamcrest.core.IsInstanceOf;\nimport org.junit.Test;\n\npublic class AccurevUpdateCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    private ScmFileSet testFileSet;\n\n    private File basedir;\n\n    @Override\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n        testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        basedir = testFileSet.getBasedir();\n\n        info.setWorkSpace( \"theWorkSpace\" );\n        when( accurev.info( basedir ) ).thenReturn( info );\n\n    }\n\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n\n        final File keptFile = new File( \"updated/file\" );\n        final File keptAdded = new File( \"new/file\" );\n\n        List<File> files = Arrays.asList( keptFile, keptAdded );\n\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( files );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getUpdatedFiles().size(), is( 2 ) );\n        assertHasScmFile( result.getUpdatedFiles(), \"updated/file\", ScmFileStatus.UPDATED );\n        assertHasScmFile( result.getUpdatedFiles(), \"new/file\", ScmFileStatus.UPDATED );\n\n    }\n\n    @Test\n    public void testUpdateWithChangeLog()\n        throws Exception\n    {\n\n        final WorkSpace wsBefore = new WorkSpace( \"theWorkSpace\", 123 );\n\n        Map<String, WorkSpace> workspaces = Collections.singletonMap( \"theWorkSpace\", wsBefore );\n\n        when( accurev.showWorkSpaces() ).thenReturn( workspaces );\n\n        List<File> emptyList = Collections.emptyList();\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( emptyList );\n\n        final Date currentDate = new Date();\n        List<Transaction> transactions =\n            Collections.singletonList( new Transaction( 197L, currentDate, \"type\", \"user\" ) );\n\n        when(\n              accurev.history( any( String.class ), any( String.class ), any( String.class ), eq( 1 ), eq( true ),\n                               eq( true ) ) ).thenReturn( transactions );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( true ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result, IsInstanceOf.instanceOf( AccuRevUpdateScmResult.class ) );\n        AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n        assertThat( accuRevResult.getFromRevision(), is( \"theWorkSpace/123\" ) );\n        assertThat( accuRevResult.getToRevision(), is( \"theWorkSpace/197\" ) );\n\n    }\n\n    @Test\n    public void testAccuRevFailure()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( null );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n}\n","lineNo":74}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.apache.maven.scm.provider.accurev.PutMapEntryAction.putEntryTo;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.hamcrest.Matchers.nullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.hamcrest.core.IsInstanceOf;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccurevUpdateCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"updated/file\" );\n                File keptAdded = new File( \"new/file\" );\n\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                // TODO Should test that the timeSpec parameter is a formatted date\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, keptFile, keptAdded ), returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getUpdatedFiles().size(), is( 2 ) );\n        assertHasScmFile( result.getUpdatedFiles(), \"updated/file\", ScmFileStatus.UPDATED );\n        assertHasScmFile( result.getUpdatedFiles(), \"new/file\", ScmFileStatus.UPDATED );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdateWithChangeLog()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n        info.setBasis( \"myStream\" );\n        context.checking( new Expectations()\n        {\n            {\n                WorkSpace wsBefore = new WorkSpace( \"theWorkSpace\", 123 );\n\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                one( accurev ).showWorkSpaces( with( any( Map.class ) ) );\n                will( doAll( putEntryTo( 0, \"theWorkSpace\", wsBefore ), returnValue( true ) ) );\n\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( true ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result, IsInstanceOf.instanceOf( AccuRevUpdateScmResult.class ) );\n        AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n        assertThat( accuRevResult.getFromVersion().getTimeSpec(), is( \"124\" ) );\n        assertThat( accuRevResult.getToVersion().getTimeSpec(), nullValue() );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAccuRevFailure()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"updated/file\" );\n                File keptAdded = new File( \"new/file\" );\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, keptFile, keptAdded ), returnValue( false ) ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.hamcrest.core.IsInstanceOf;\nimport org.junit.Test;\n\npublic class AccurevUpdateCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    private ScmFileSet testFileSet;\n\n    private File basedir;\n\n    @Override\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n        testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        basedir = testFileSet.getBasedir();\n\n        info.setWorkSpace( \"theWorkSpace\" );\n        when( accurev.info( basedir ) ).thenReturn( info );\n\n    }\n\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n\n        final File keptFile = new File( \"updated/file\" );\n        final File keptAdded = new File( \"new/file\" );\n\n        List<File> files = Arrays.asList( keptFile, keptAdded );\n\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( files );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getUpdatedFiles().size(), is( 2 ) );\n        assertHasScmFile( result.getUpdatedFiles(), \"updated/file\", ScmFileStatus.UPDATED );\n        assertHasScmFile( result.getUpdatedFiles(), \"new/file\", ScmFileStatus.UPDATED );\n\n    }\n\n    @Test\n    public void testUpdateWithChangeLog()\n        throws Exception\n    {\n\n        final WorkSpace wsBefore = new WorkSpace( \"theWorkSpace\", 123 );\n\n        Map<String, WorkSpace> workspaces = Collections.singletonMap( \"theWorkSpace\", wsBefore );\n\n        when( accurev.showWorkSpaces() ).thenReturn( workspaces );\n\n        List<File> emptyList = Collections.emptyList();\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( emptyList );\n\n        final Date currentDate = new Date();\n        List<Transaction> transactions =\n            Collections.singletonList( new Transaction( 197L, currentDate, \"type\", \"user\" ) );\n\n        when(\n              accurev.history( any( String.class ), any( String.class ), any( String.class ), eq( 1 ), eq( true ),\n                               eq( true ) ) ).thenReturn( transactions );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( true ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result, IsInstanceOf.instanceOf( AccuRevUpdateScmResult.class ) );\n        AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n        assertThat( accuRevResult.getFromRevision(), is( \"theWorkSpace/123\" ) );\n        assertThat( accuRevResult.getToRevision(), is( \"theWorkSpace/197\" ) );\n\n    }\n\n    @Test\n    public void testAccuRevFailure()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( null );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n}\n","lineNo":75}
{"Smelly Sample":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.apache.maven.scm.provider.accurev.AddElementsAction.addElementsTo;\nimport static org.apache.maven.scm.provider.accurev.PutMapEntryAction.putEntryTo;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.hamcrest.Matchers.nullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.AccuRevScmProviderRepository;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.hamcrest.core.IsInstanceOf;\nimport org.jmock.Expectations;\nimport org.junit.Test;\n\npublic class AccurevUpdateCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"updated/file\" );\n                File keptAdded = new File( \"new/file\" );\n\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                // TODO Should test that the timeSpec parameter is a formatted date\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, keptFile, keptAdded ), returnValue( true ) ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getUpdatedFiles().size(), is( 2 ) );\n        assertHasScmFile( result.getUpdatedFiles(), \"updated/file\", ScmFileStatus.UPDATED );\n        assertHasScmFile( result.getUpdatedFiles(), \"new/file\", ScmFileStatus.UPDATED );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdateWithChangeLog()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n        info.setBasis( \"myStream\" );\n        context.checking( new Expectations()\n        {\n            {\n                WorkSpace wsBefore = new WorkSpace( \"theWorkSpace\", 123 );\n\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                one( accurev ).showWorkSpaces( with( any( Map.class ) ) );\n                will( doAll( putEntryTo( 0, \"theWorkSpace\", wsBefore ), returnValue( true ) ) );\n\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( returnValue( true ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( true ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result, IsInstanceOf.instanceOf( AccuRevUpdateScmResult.class ) );\n        AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n        assertThat( accuRevResult.getFromVersion().getTimeSpec(), is( \"124\" ) );\n        assertThat( accuRevResult.getToVersion().getTimeSpec(), nullValue() );\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAccuRevFailure()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        AccuRevScmProviderRepository repo = new AccuRevScmProviderRepository();\n        repo.setStreamName( \"myStream\" );\n        repo.setAccuRev( accurev );\n        repo.setProjectPath( \"/project/dir\" );\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        context.checking( new Expectations()\n        {\n            {\n                File keptFile = new File( \"updated/file\" );\n                File keptAdded = new File( \"new/file\" );\n                one( accurev ).info( basedir );\n                will( returnValue( info ) );\n\n                one( accurev ).update( with( basedir ), with( any( String.class ) ), with( any( List.class ) ) );\n                will( doAll( addElementsTo( 2, keptFile, keptAdded ), returnValue( false ) ) );\n\n            }\n        } );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        context.assertIsSatisfied();\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.accurev.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.apache.maven.scm.ScmFileMatcher.assertHasScmFile;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.when;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.accurev.Transaction;\nimport org.apache.maven.scm.provider.accurev.WorkSpace;\nimport org.apache.maven.scm.provider.accurev.command.AbstractAccuRevCommandTest;\nimport org.hamcrest.core.IsInstanceOf;\nimport org.junit.Test;\n\npublic class AccurevUpdateCommandTest\n    extends AbstractAccuRevCommandTest\n{\n\n    private ScmFileSet testFileSet;\n\n    private File basedir;\n\n    @Override\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n        testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        basedir = testFileSet.getBasedir();\n\n        info.setWorkSpace( \"theWorkSpace\" );\n        when( accurev.info( basedir ) ).thenReturn( info );\n\n    }\n\n    @Test\n    public void testUpdate()\n        throws Exception\n    {\n\n        final File keptFile = new File( \"updated/file\" );\n        final File keptAdded = new File( \"new/file\" );\n\n        List<File> files = Arrays.asList( keptFile, keptAdded );\n\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( files );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result.getUpdatedFiles().size(), is( 2 ) );\n        assertHasScmFile( result.getUpdatedFiles(), \"updated/file\", ScmFileStatus.UPDATED );\n        assertHasScmFile( result.getUpdatedFiles(), \"new/file\", ScmFileStatus.UPDATED );\n\n    }\n\n    @Test\n    public void testUpdateWithChangeLog()\n        throws Exception\n    {\n\n        final WorkSpace wsBefore = new WorkSpace( \"theWorkSpace\", 123 );\n\n        Map<String, WorkSpace> workspaces = Collections.singletonMap( \"theWorkSpace\", wsBefore );\n\n        when( accurev.showWorkSpaces() ).thenReturn( workspaces );\n\n        List<File> emptyList = Collections.emptyList();\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( emptyList );\n\n        final Date currentDate = new Date();\n        List<Transaction> transactions =\n            Collections.singletonList( new Transaction( 197L, currentDate, \"type\", \"user\" ) );\n\n        when(\n              accurev.history( any( String.class ), any( String.class ), any( String.class ), eq( 1 ), eq( true ),\n                               eq( true ) ) ).thenReturn( transactions );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( true ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( true ) );\n        assertThat( result, IsInstanceOf.instanceOf( AccuRevUpdateScmResult.class ) );\n        AccuRevUpdateScmResult accuRevResult = (AccuRevUpdateScmResult) result;\n        assertThat( accuRevResult.getFromRevision(), is( \"theWorkSpace/123\" ) );\n        assertThat( accuRevResult.getToRevision(), is( \"theWorkSpace/197\" ) );\n\n    }\n\n    @Test\n    public void testAccuRevFailure()\n        throws Exception\n    {\n        final ScmFileSet testFileSet = new ScmFileSet( new File( \"/my/workspace/project/dir\" ) );\n        final File basedir = testFileSet.getBasedir();\n\n        info.setWorkSpace( \"theWorkSpace\" );\n\n        when( accurev.update( eq( basedir ), any( String.class ) ) ).thenReturn( null );\n\n        AccuRevUpdateCommand command = new AccuRevUpdateCommand( getLogger() );\n\n        CommandParameters commandParameters = new CommandParameters();\n        commandParameters.setString( CommandParameter.RUN_CHANGELOG_WITH_UPDATE, Boolean.toString( false ) );\n        UpdateScmResult result = command.update( repo, testFileSet, commandParameters );\n\n        assertThat( result.isSuccess(), is( false ) );\n        assertThat( result.getProviderMessage(), notNullValue() );\n\n    }\n}\n","lineNo":99}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\n\n/**\n * Branch the project.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @goal branch\n * @aggregator\n */\npublic class BranchMojo\n    extends AbstractScmMojo\n{\n    /**\n     * The branch name.\n     *\n     * @parameter expression=\"${branch}\"\n     * @required\n     */\n    private String branch;\n\n    /**\n     * The message applied to the tag creation.\n     *\n     * @parameter expression=\"${message}\"\n     */\n    private String message;\n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        try\n        {\n            ScmRepository repository = getScmRepository();\n            ScmProvider provider = getScmManager().getProviderByRepository( repository );\n\n            String finalBranch = provider.sanitizeTagName( branch );\n            getLog().info( \"Final Branch Name: '\" + finalBranch + \"'\" );\n\n            BranchScmResult result = provider.branch( repository, getFileSet(), finalBranch, message );\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run branch command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run branch command : \", e );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmBranchParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.branch.BranchScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\n\n/**\n * Branch the project.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @goal branch\n * @aggregator\n */\npublic class BranchMojo\n    extends AbstractScmMojo\n{\n    /**\n     * The branch name.\n     *\n     * @parameter expression=\"${branch}\"\n     * @required\n     */\n    private String branch;\n\n    /**\n     * The message applied to the tag creation.\n     *\n     * @parameter expression=\"${message}\"\n     */\n    private String message;\n    \n    /**\n     * currently only implemented with svn scm. Enable a workaround to prevent issue \n     * due to svn client > 1.5.0 (http://jira.codehaus.org/browse/SCM-406)\n     *      \n     * \n     * @parameter expression=\"${remoteTagging}\" default-value=\"true\"\n     * @since 1.3\n     */    \n    private boolean remoteBranching;     \n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        try\n        {\n            ScmRepository repository = getScmRepository();\n            ScmProvider provider = getScmManager().getProviderByRepository( repository );\n\n            String finalBranch = provider.sanitizeTagName( branch );\n            getLog().info( \"Final Branch Name: '\" + finalBranch + \"'\" );\n\n            ScmBranchParameters scmBranchParameters = new ScmBranchParameters( message );\n            scmBranchParameters.setRemoteBranching( remoteBranching );\n            \n            BranchScmResult result = provider.branch( repository, getFileSet(), finalBranch, scmBranchParameters );\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run branch command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run branch command : \", e );\n        }\n    }\n}\n","lineNo":81}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class GitScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String url;\n\n    /**\n     * the protocol to use\n     */\n    private String protocol;\n\n    /** use local file as transport*/\n    public static final String PROTOCOL_FILE = \"file\";\n\n    /** use gits internal protocol */\n    public static final String PROTOCOL_GIT = \"git\";\n\n    /** use secure shell protocol */\n    public static final String PROTOCOL_SSH = \"ssh\";\n\n    /** use the standard port 80 http protocol */\n    public static final String PROTOCOL_HTTP = \"http\";\n\n    /** use the standard port 443 https protocol */\n    public static final String PROTOCOL_HTTPS = \"https\";\n\n    /** use rsync for retrieving the data\n     * TODO implement! */\n    public static final String PROTOCOL_RSYNC = \"rsync\";\n\n\n    public GitScmProviderRepository( String url )\n    {\n        parseUrl( url );\n    }\n\n    public GitScmProviderRepository( String url, String user, String password )\n    {\n        this( url );\n\n        setUser( user );\n\n        setPassword( password );\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    private void setProtocol( String protocol )\n    {\n        this.protocol = protocol;\n    }\n\n    /**\n     * @return the protocol used in this repository (file, http, https, git, ...)\n     */\n    public String getProtocol()\n    {\n        return protocol;\n    }\n\n    private void parseUrl( String url )\n    {\n        if ( url.startsWith( PROTOCOL_FILE ) )\n        {\n            setProtocol( PROTOCOL_FILE );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTPS ) )\n        {\n            setProtocol( PROTOCOL_HTTPS );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTP ) )\n        {\n            setProtocol( PROTOCOL_HTTP );\n        }\n        else if ( url.startsWith( PROTOCOL_SSH ) )\n        {\n            setProtocol( PROTOCOL_SSH );\n        }\n        else if ( url.startsWith( PROTOCOL_GIT ) )\n        {\n            setProtocol( PROTOCOL_GIT );\n        }\n        else if ( url.startsWith( PROTOCOL_RSYNC ) )\n        {\n            setProtocol( PROTOCOL_RSYNC );\n        }\n\n        if ( getProtocol() == null )\n        {\n            return;\n        }\n\n        String urlPath = url.substring( getProtocol().length() );\n\n        if ( urlPath.startsWith( \"://\" ) )\n        {\n            urlPath = urlPath.substring( 3 );\n        }\n        int indexAt = urlPath.indexOf( \"@\" );\n\n        if ( indexAt > 0 )\n        {\n            String userPassword = urlPath.substring( 0, indexAt );\n            if ( userPassword.indexOf( \":\" ) < 0 )\n            {\n                setUser( userPassword );\n            }\n            else\n            {\n                setUser( userPassword.substring( 0, userPassword.indexOf( \":\" ) ) );\n                setPassword( userPassword.substring( userPassword.indexOf( \":\" ) + 1 ) );\n            }\n\n            urlPath = urlPath.substring( indexAt + 1 );\n\n            if ( PROTOCOL_SSH.equals( getProtocol() ) )\n            {\n                StringBuffer urlSb = new StringBuffer( getProtocol() );\n\n                urlSb.append( \"://\" );\n\n                if ( getUser() != null )\n                {\n                     urlSb.append( getUser() );\n\n                     if ( getPassword() != null )\n                     {\n                         urlSb.append( ':' ).append( getPassword() );\n                     }\n\n                     urlSb.append( '@' );\n                }\n\n                urlSb.append( urlPath );\n\n                this.url = urlSb.toString();\n            }\n            else\n            {\n                this.url = getProtocol() + \"://\" + urlPath;\n            }\n        }\n        else\n        {\n            this.url = getProtocol() + \"://\"  + urlPath;\n        }\n\n        if ( !PROTOCOL_FILE.equals( getProtocol() ) )\n        {\n            int indexSlash = urlPath.indexOf( \"/\" );\n\n            String hostPort = urlPath;\n\n            if ( indexSlash > 0 )\n            {\n                hostPort = urlPath.substring( 0, indexSlash );\n            }\n\n            int indexColon = hostPort.indexOf( \":\" );\n\n            if ( indexColon > 0 )\n            {\n                boolean sshGitDev = false;\n                // url = scm:git:git@github.com:22:olamy/scm-git-test-one-module.git\n                if ( hostPort.startsWith( \"@\" ) )\n                {\n                    setHost( hostPort.substring( 1, indexColon ) );\n                }\n                else\n                {\n                    setHost( hostPort.substring( 0, indexColon ) );\n                }\n                String port = hostPort.substring( indexColon + 1 );\n\n                if ( port.indexOf( \":\" ) > 0 )\n                {\n                    port = port.substring( 0, port.indexOf( \":\" ) );\n                    sshGitDev = true;\n                }\n                \n                // url = scm:git:git@github.com:olamy/scm-git-test-one-module.git -> Nan\n                try\n                {\n                    setPort( Integer.parseInt( port ) );\n                }\n                catch ( NumberFormatException e )\n                {\n                    if ( !PROTOCOL_GIT.equals( getProtocol() ) )\n                    {\n                        throw e;\n                    }\n                    sshGitDev = true;\n                }\n                if (sshGitDev)\n                {\n                    this.url = \"git\" + urlPath;\n                }\n            }\n            else\n            {\n                setHost( hostPort );\n            }\n\n        }\n    }\n\n    /** {@inheritDoc} */\n    public ScmProviderRepository getParent()\n    {\n        String newUrl = getUrl().substring( getProtocol().length() );\n\n        while ( newUrl.endsWith( \"/.\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() - 1 );\n        }\n\n        while ( newUrl.endsWith( \"/\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() );\n        }\n\n        int i = newUrl.lastIndexOf( \"/\" );\n\n        if ( i < 0 )\n        {\n            return null;\n        }\n        newUrl = newUrl.substring( 0, i );\n\n        return new GitScmProviderRepository( getProtocol() + newUrl, getUser(), getPassword() );\n    }\n\n    /** {@inheritDoc} */\n    public String getRelativePath( ScmProviderRepository ancestor )\n    {\n        if ( ancestor instanceof GitScmProviderRepository )\n        {\n            GitScmProviderRepository gitAncestor = (GitScmProviderRepository) ancestor;\n\n            String path = getUrl().replaceFirst( gitAncestor.getUrl() + \"/\", \"\" );\n\n            if ( !path.equals( getUrl() ) )\n            {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        return getUrl();\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:struberg@apache.org\">Mark Struberg<\/a>\n * @version $Id$\n */\npublic class GitScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    \n    /** sequence used to delimit the fetch URL */ \n    public static final String URL_DELIMITER_FETCH = \"[fetch=]\";\n    \n    /** sequence used to delimit the push URL */ \n    public static final String URL_DELIMITER_PUSH = \"[push=]\";\n\n    /** this trails every protocol */\n    public static final String PROTOCOL_SEPARATOR = \"://\";\n    \n    /** use local file as transport*/\n    public static final String PROTOCOL_FILE = \"file\";\n\n    /** use gits internal protocol */\n    public static final String PROTOCOL_GIT = \"git\";\n\n    /** use secure shell protocol */\n    public static final String PROTOCOL_SSH = \"ssh\";\n\n    /** use the standard port 80 http protocol */\n    public static final String PROTOCOL_HTTP = \"http\";\n\n    /** use the standard port 443 https protocol */\n    public static final String PROTOCOL_HTTPS = \"https\";\n\n    /** use rsync for retrieving the data\n     * TODO implement! */\n    public static final String PROTOCOL_RSYNC = \"rsync\";\n\n    /** \n     * No special protocol specified. Git will either use git://\n     * or ssh:// depending on whether we work locally or over the network \n     */\n    public static final String PROTOCOL_NONE = \"\";\n\n    /** this may either 'git' or 'jgit' depending on the underlying implementation being used */\n    private String provider;\n    \n    /** the URL used to fetch from the upstream repository */\n    private RepositoryUrl fetchInfo;\n\n    /** the URL used to push to the upstream repository */\n    private RepositoryUrl pushInfo;\n\n    public GitScmProviderRepository( String url )\n        throws ScmException\n    {\n        if ( url == null )\n        {\n            throw new ScmException( \"url must not be null\" );\n        }\n        \n        if ( url.startsWith( URL_DELIMITER_FETCH  ) )\n        {\n            String fetch = url.substring( URL_DELIMITER_FETCH.length() );\n\n            int indexPushDelimiter = fetch.indexOf( URL_DELIMITER_PUSH );\n            if ( indexPushDelimiter >= 0 )\n            {\n                String push = fetch.substring( indexPushDelimiter + URL_DELIMITER_PUSH.length() );\n                pushInfo = parseUrl( push );\n                \n                fetch = fetch.substring( 0, indexPushDelimiter );\n            }\n            \n            fetchInfo = parseUrl( fetch );\n\n            if ( pushInfo == null )\n            {\n                pushInfo = fetchInfo;\n            }\n        }\n        else  if ( url.startsWith( URL_DELIMITER_PUSH ) )\n        {\n            String push = url.substring( URL_DELIMITER_PUSH.length() );\n\n            int indexFetchDelimiter = push.indexOf( URL_DELIMITER_FETCH );\n            if ( indexFetchDelimiter >= 0 )\n            {\n                String fetch = push.substring( indexFetchDelimiter + URL_DELIMITER_FETCH.length() );\n                fetchInfo = parseUrl( fetch );\n                \n                push = push.substring( 0, indexFetchDelimiter );\n            }\n            \n            pushInfo = parseUrl( push );\n            \n            if ( fetchInfo == null )\n            {\n                fetchInfo = pushInfo;\n            }\n        }\n        else\n        {\n            fetchInfo = pushInfo = parseUrl( url );\n        }\n        \n        // set the default values for backward compatibility from the push url\n        // because it's more likely that the push URL contains 'better' credentials\n        setUser( pushInfo.getUserName() );\n        setPassword( pushInfo.getPassword() );\n        setHost( pushInfo.getHost() );\n        if ( pushInfo.getPort() != null && pushInfo.getPort().length() > 0 )\n        {\n            setPort( Integer.parseInt( pushInfo.getPort() ) );\n        }\n    }\n\n    public GitScmProviderRepository( String url, String user, String password )\n        throws ScmException\n    {\n        this( url );\n\n        setUser( user );\n\n        setPassword( password );\n    }\n\n    /** \n     * @return either 'git' or 'jgit' depending on the underlying implementation being used \n     */\n    public String getProvider()\n    {\n        return provider;\n    }\n    \n    public RepositoryUrl getFetchInfo()\n    {\n        return fetchInfo;\n    }\n    \n    public RepositoryUrl getPushInfo()\n    {\n        return pushInfo;\n    }\n    \n    \n    /**\n     * @return the URL used to fetch from the upstream repository \n     */\n    public String getFetchUrl()\n    {\n        return getUrl( fetchInfo );\n    }\n   \n    /**\n     * @return the URL used to push to the upstream repository \n     */\n    public String getPushUrl()\n    {\n        return getUrl( pushInfo );\n    }\n   \n\n    /**\n     * Parse the given url string and store all the extracted\n     * information in a {@code RepositoryUrl}\n     * @param url to parse\n     * @return filled with the information from the given URL\n     * @throws ScmException\n     */\n    private RepositoryUrl parseUrl( String url )\n        throws ScmException\n    {\n        RepositoryUrl repoUrl = new RepositoryUrl();\n        \n        url = parseProtocol( repoUrl, url );\n        url = parseUserInfo( repoUrl, url );\n        url = parseHostAndPort( repoUrl, url );\n        // the rest of the url must be the path to the repository on the server\n        repoUrl.setPath( url );\n        return repoUrl;\n    }\n        \n    \n     \n    /**\n     * \n     * @param repoUrl\n     * @return\n     */\n    private String getUrl( RepositoryUrl repoUrl )\n    {\n        StringBuffer urlSb = new StringBuffer( repoUrl.getProtocol() );\n        boolean urlSupportsUserInformation = false;\n\n        if ( PROTOCOL_SSH.equals( repoUrl.getProtocol() )   || \n             PROTOCOL_RSYNC.equals( repoUrl.getProtocol() ) ||  \n             PROTOCOL_GIT.equals( repoUrl.getProtocol() )   ||\n             PROTOCOL_NONE.equals(  repoUrl.getProtocol() )   )\n        {\n            urlSupportsUserInformation = true;\n        }\n\n        if ( repoUrl.getProtocol() != null && repoUrl.getProtocol().length() > 0 )\n        {\n            urlSb.append( \"://\" );\n        }\n        \n        // add user information if given and allowed for the protocol\n        if ( urlSupportsUserInformation )\n        {\n            String userName = repoUrl.getUserName();\n            // if specified on the commandline or other configuration, we take this.\n            if ( getUser() != null && getUser().length() > 0 ) \n            {\n                userName = getUser();\n            }\n            \n            String password = repoUrl.getPassword();\n            if ( getPassword() != null && getPassword().length() > 0 )\n            {\n                password = getPassword();\n            }\n            //X TODO passphrase handling is missing!\n            \n            if ( userName != null && userName.length() > 0 )\n            {\n                urlSb.append( userName );\n    \n                if ( password != null && password.length() > 0 )\n                {\n                    urlSb.append( ':' ).append( password );\n                }\n    \n                 urlSb.append( '@' );\n            }\n        }\n\n        // add host and port information\n        urlSb.append( repoUrl.getHost() );\n        if ( repoUrl.getPort() != null && repoUrl.getPort().length() > 0 )\n        {\n            urlSb.append( ':' ).append( repoUrl.getPort() );\n        }\n\n        // finaly we add the path to the repo on the host\n        urlSb.append( repoUrl.getPath() );\n        \n        return urlSb.toString();\n    }\n\n    /**\n     * Parse the protocol from the given url and fill it into the given RepositoryUrl.\n     * @param repoUrl\n     * @param url\n     * @return the given url with the protocol parts removed\n     */\n    private String parseProtocol( RepositoryUrl repoUrl, String url )\n        throws ScmException\n    {\n        // extract the protocol\n        if ( url.startsWith( PROTOCOL_FILE + PROTOCOL_SEPARATOR ) )\n        {\n            repoUrl.setProtocol( PROTOCOL_FILE );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTPS + PROTOCOL_SEPARATOR ) )\n        {\n            repoUrl.setProtocol( PROTOCOL_HTTPS );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTP + PROTOCOL_SEPARATOR ) )\n        {\n            repoUrl.setProtocol( PROTOCOL_HTTP );\n        }\n        else if ( url.startsWith( PROTOCOL_SSH + PROTOCOL_SEPARATOR ) )\n        {\n            repoUrl.setProtocol( PROTOCOL_SSH );\n        }\n        else if ( url.startsWith( PROTOCOL_GIT + PROTOCOL_SEPARATOR ) )\n        {\n            repoUrl.setProtocol( PROTOCOL_GIT );\n        }\n        else if ( url.startsWith( PROTOCOL_RSYNC + PROTOCOL_SEPARATOR ) )\n        {\n            repoUrl.setProtocol( PROTOCOL_RSYNC );\n        }\n        else\n        {\n            // when no protocol is specified git will pick either ssh:// or git://\n            // depending on whether we work locally or over the network\n            repoUrl.setProtocol( PROTOCOL_NONE );\n            return url;\n        }\n       \n        url = url.substring( repoUrl.getProtocol().length() + 3 );\n\n        return url;\n    }\n\n    /**\n     * Parse the user information from the given url and fill \n     * user name and password into the given RepositoryUrl.\n     * @param repoUrl\n     * @param url\n     * @return the given url with the user parts removed\n     */\n    private String parseUserInfo( RepositoryUrl repoUrl, String url )\n        throws ScmException\n    {\n        // extract user information\n        int indexAt = url.indexOf( \"@\" );\n        if ( indexAt >= 0 )\n        {\n            String userInfo = url.substring( 0, indexAt );\n            int indexPwdSep = userInfo.indexOf( \":\" ); \n            if ( indexPwdSep < 0 )\n            {\n                repoUrl.setUserName( userInfo );\n            }\n            else\n            {\n                repoUrl.setUserName( userInfo.substring( 0, indexPwdSep ) );\n                repoUrl.setPassword( userInfo.substring( indexPwdSep + 1 ) );\n            }\n\n            url = url.substring( indexAt + 1 );\n        }\n        return url;\n    }\n\n    /**\n     * Parse server and port from the given url and fill it into the \n     * given RepositoryUrl.\n     * @param repoUrl\n     * @param url\n     * @return the given url with the server parts removed\n     * @throws ScmException \n     */\n    private String parseHostAndPort( RepositoryUrl repoUrl, String url ) \n        throws ScmException\n    {\n        StringBuilder host = new StringBuilder();\n        StringBuilder port = new StringBuilder();\n        \n        int i = 0;\n        boolean isPort = false;\n        \n        while ( i < url.length() )\n        {\n            char c = url.charAt( i );\n            \n            if ( c == ':' )\n            {\n                i++;\n                isPort = true;\n                continue;\n            }\n\n            if ( c == '/' || c == '\\\\' || c == '~' )\n            {\n                // if we find a slash (backslash for windows compatibility)\n                // or a home sign (~) then we are finished\n                break;\n            }\n\n            if ( isPort )\n            {\n                if ( ! Character.isDigit( c ) )\n                {\n                    // this seems not to be a port, so it must be the start of the the path block   \n                    i--; // because the ':' seems to belong to the path in this case\n                    break;\n                }\n                else\n                {\n                    port.append( c );\n                    i++;\n                    continue;\n                }\n            }\n\n            // otherwise this must still be part of the host\n            host.append( c );\n            i++;\n        }\n\n        repoUrl.setHost( host.toString() );\n        repoUrl.setPort( port.toString() );\n\n        url = url.substring( i );\n\n        return url;\n    }\n\n\n    /** {@inheritDoc} */\n    public String getRelativePath( ScmProviderRepository ancestor )\n    {\n        if ( ancestor instanceof GitScmProviderRepository )\n        {\n            GitScmProviderRepository gitAncestor = (GitScmProviderRepository) ancestor;\n            \n            //X TODO review!\n            String url = getFetchUrl();\n            String path = url.replaceFirst( gitAncestor.getFetchUrl() + \"/\", \"\" );\n\n            if ( !path.equals( url ) )\n            {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        // yes we really like to check if those are the exact same instance!\n        if ( fetchInfo == pushInfo )\n        {\n            return getUrl( fetchInfo ); \n        }\n        return URL_DELIMITER_FETCH + getUrl( fetchInfo ) + \n               URL_DELIMITER_PUSH + getUrl( pushInfo );\n    }\n\n}\n","lineNo":338}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.Date;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class PerforceChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements PerforceCommand\n{\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        if ( branch != null && StringUtils.isNotEmpty( branch.getName() ) )\n        {\n            throw new ScmException( \"This SCM doesn't support branches.\" );\n        }\n\n        PerforceScmProviderRepository p4repo = (PerforceScmProviderRepository) repo;\n        String clientspec = PerforceScmProvider.getClientspecName( getLogger(), p4repo, fileSet.getBasedir() );\n        Commandline cl = createCommandLine( p4repo, fileSet.getBasedir(), clientspec );\n\n        String location = PerforceScmProvider.getRepoPath( getLogger(), p4repo, fileSet.getBasedir() );\n        PerforceChangeLogConsumer consumer =\n            new PerforceChangeLogConsumer( location, startDate, endDate, datePattern, getLogger() );\n\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing \" + cl.toString() ) );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        return new ChangeLogScmResult( cl.toString(),\n                                       new ChangeLogSet( consumer.getModifications(), startDate, endDate ) );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 String clientspec )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        if ( clientspec != null )\n        {\n            command.createArg().setValue( \"-c\" );\n            command.createArg().setValue( clientspec );\n        }\n        command.createArg().setValue( \"filelog\" );\n        command.createArg().setValue( \"-t\" );\n        command.createArg().setValue( \"-l\" );\n        command.createArg().setValue( \"...\" );\n\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmRevision;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class PerforceChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements PerforceCommand\n{\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    /** {@inheritDoc} */\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        if ( branch != null && StringUtils.isNotEmpty( branch.getName() ) )\n        {\n            throw new ScmException( \"This SCM doesn't support branches.\" );\n        }\n\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        PerforceScmProviderRepository p4repo = (PerforceScmProviderRepository) repo;\n        String clientspec = PerforceScmProvider.getClientspecName( getLogger(), p4repo, fileSet.getBasedir() );\n        Commandline cl = createCommandLine( p4repo, fileSet.getBasedir(), clientspec, null, startDate, endDate, startVersion, endVersion );\n\n        String location = PerforceScmProvider.getRepoPath( getLogger(), p4repo, fileSet.getBasedir() );\n        PerforceChangesConsumer consumer =\n            new PerforceChangesConsumer( getLogger() );\n\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing \" + cl.toString() ) );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        List changes = consumer.getChanges();\n\n        cl = PerforceScmProvider.createP4Command( p4repo, fileSet.getBasedir() );\n        cl.createArg().setValue( \"describe\" );\n        cl.createArg().setValue( \"-s\" );\n\n        for( int i = 0; i < changes.size(); i++ ) {\n            cl.createArg().setValue( (String)changes.get(i) );\n        }\n\n        PerforceDescribeConsumer describeConsumer =\n            new PerforceDescribeConsumer( location, datePattern, getLogger() );\n\n        try\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( PerforceScmProvider.clean( \"Executing \" + cl.toString() ) );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, describeConsumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            if ( getLogger().isErrorEnabled() )\n            {\n                getLogger().error( \"CommandLineException \" + e.getMessage(), e );\n            }\n        }\n\n        ChangeLogSet cls = new ChangeLogSet( describeConsumer.getModifications(), null, null );\n        cls.setStartVersion(startVersion);\n        cls.setEndVersion(endVersion);\n        return new ChangeLogScmResult( cl.toString(), cls );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 String clientspec,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy/MM/dd:HH:mm:ss\");\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        if ( clientspec != null )\n        {\n            command.createArg().setValue( \"-c\" );\n            command.createArg().setValue( clientspec );\n        }\n        command.createArg().setValue( \"changes\" );\n        command.createArg().setValue( \"-t\" );\n\n        StringBuffer fileSpec = new StringBuffer(\"...\");\n        if ( startDate != null )\n        {\n            fileSpec.append( \"@\" )\n                 .append( dateFormat.format(startDate) )\n                 .append( \",\" );\n\n            if ( endDate != null )\n            {\n                fileSpec.append( dateFormat.format(endDate) );\n            }\n            else\n            {\n                fileSpec.append( \"now\" );\n            }\n        }\n\n        if ( startVersion != null )\n        {\n            fileSpec.append(\"@\").append(startVersion.getName()).append(\",\");\n\n            if ( endVersion != null )\n            {\n                fileSpec.append( endVersion.getName() );\n            }\n            else\n            {\n                fileSpec.append(\"now\");\n            }\n        }\n\n        command.createArg().setValue( fileSpec.toString() );\n\n        return command;\n    }\n}\n","lineNo":162}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Tag the project.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"saden1@gmil.com\">Sharmarke Aden<\/a>\n * @version $Id$\n * @goal tag\n * @aggregator\n */\npublic class TagMojo\n    extends AbstractScmMojo\n{\n    /**\n     * The tag name.\n     *\n     * @parameter expression=\"${tag}\"\n     * @required\n     */\n    private String tag;\n\n    /**\n     * The message applied to the tag creation.\n     *\n     * @parameter expression=\"${message}\"\n     */\n    private String message;\n\n    /**\n     * Set the timestamp format.\n     *\n     * @parameter expression=\"${timestampFormat}\" default-value=\"yyyyMMddHHmmss\"\n     */\n    private String timestampFormat;\n\n    /**\n     * Use timestamp tagging.\n     *\n     * @parameter expression=\"${addTimestamp}\" default-value=\"false\"\n     */\n    private boolean addTimestamp;\n\n    /**\n     * Define the timestamp position (end or begin).\n     *\n     * @parameter expression=\"${timestampPosition}\" default-value=\"end\"\n     */\n    private String timestampPosition;\n\n    /**\n     * Timestamp tag prefix.\n     *\n     * @parameter expression=\"${timestampPrefix}\" default-value=\"-\"\n     */\n    private String timestampPrefix;\n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        try\n        {\n            SimpleDateFormat dateFormat = null;\n            String tagTimestamp = \"\";\n            String finalTag = tag;\n\n            if ( addTimestamp )\n            {\n                try\n                {\n                    getLog().info( \"Using timestamp pattern '\" + timestampFormat + \"'\" );\n                    dateFormat = new SimpleDateFormat( timestampFormat );\n                    tagTimestamp = dateFormat.format( new Date() );\n                    getLog().info( \"Using timestamp '\" + tagTimestamp + \"'\" );\n                }\n                catch ( IllegalArgumentException e )\n                {\n                    String msg = \"The timestamp format '\" + timestampFormat + \"' is invalid.\";\n                    getLog().error( msg, e );\n                    throw new MojoExecutionException( msg, e );\n                }\n\n                if ( \"end\".equals( timestampPosition ) )\n                {\n                    finalTag += timestampPrefix + tagTimestamp;\n                }\n                else\n                {\n                    finalTag = tagTimestamp + timestampPrefix + finalTag;\n                }\n            }\n\n            ScmRepository repository = getScmRepository();\n            ScmProvider provider = getScmManager().getProviderByRepository( repository );\n\n            finalTag = provider.sanitizeTagName( finalTag );\n            getLog().info( \"Final Tag Name: '\" + finalTag + \"'\" );\n\n            TagScmResult result = provider.tag( repository, getFileSet(), finalTag, message );\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmTagParameters;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Tag the project.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"saden1@gmil.com\">Sharmarke Aden<\/a>\n * @version $Id$\n * @goal tag\n * @aggregator\n */\npublic class TagMojo\n    extends AbstractScmMojo\n{\n    /**\n     * The tag name.\n     *\n     * @parameter expression=\"${tag}\"\n     * @required\n     */\n    private String tag;\n\n    /**\n     * The message applied to the tag creation.\n     *\n     * @parameter expression=\"${message}\"\n     */\n    private String message;\n\n    /**\n     * Set the timestamp format.\n     *\n     * @parameter expression=\"${timestampFormat}\" default-value=\"yyyyMMddHHmmss\"\n     */\n    private String timestampFormat;\n\n    /**\n     * Use timestamp tagging.\n     *\n     * @parameter expression=\"${addTimestamp}\" default-value=\"false\"\n     */\n    private boolean addTimestamp;\n\n    /**\n     * Define the timestamp position (end or begin).\n     *\n     * @parameter expression=\"${timestampPosition}\" default-value=\"end\"\n     */\n    private String timestampPosition;\n\n    /**\n     * Timestamp tag prefix.\n     *\n     * @parameter expression=\"${timestampPrefix}\" default-value=\"-\"\n     */\n    private String timestampPrefix;\n    \n    /**\n     * currently only implemented with svn scm. Enable a workaround to prevent issue \n     * due to svn client > 1.5.0 (http://jira.codehaus.org/browse/SCM-406)\n     *      \n     * \n     * @parameter expression=\"${remoteTagging}\" default-value=\"true\"\n     * @since 1.2\n     */    \n    private boolean remoteTagging;    \n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        try\n        {\n            SimpleDateFormat dateFormat = null;\n            String tagTimestamp = \"\";\n            String finalTag = tag;\n\n            if ( addTimestamp )\n            {\n                try\n                {\n                    getLog().info( \"Using timestamp pattern '\" + timestampFormat + \"'\" );\n                    dateFormat = new SimpleDateFormat( timestampFormat );\n                    tagTimestamp = dateFormat.format( new Date() );\n                    getLog().info( \"Using timestamp '\" + tagTimestamp + \"'\" );\n                }\n                catch ( IllegalArgumentException e )\n                {\n                    String msg = \"The timestamp format '\" + timestampFormat + \"' is invalid.\";\n                    getLog().error( msg, e );\n                    throw new MojoExecutionException( msg, e );\n                }\n\n                if ( \"end\".equals( timestampPosition ) )\n                {\n                    finalTag += timestampPrefix + tagTimestamp;\n                }\n                else\n                {\n                    finalTag = tagTimestamp + timestampPrefix + finalTag;\n                }\n            }\n\n            ScmRepository repository = getScmRepository();\n            ScmProvider provider = getScmManager().getProviderByRepository( repository );\n\n            finalTag = provider.sanitizeTagName( finalTag );\n            getLog().info( \"Final Tag Name: '\" + finalTag + \"'\" );\n\n            ScmTagParameters scmTagParameters = new ScmTagParameters( message);\n            scmTagParameters.setRemoteTagging( remoteTagging );\n            \n            TagScmResult result = provider.tag( repository, getFileSet(), finalTag, scmTagParameters);\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n    }\n}\n","lineNo":142}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * Get a fresh copy of the latest source from the configured scm url.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @goal checkout\n * @requiresProject false\n */\npublic class CheckoutMojo\n    extends AbstractScmMojo\n{\n    /**\n     * The directory to checkout the sources to for the bootstrap and checkout goals.\n     *\n     * @parameter expression=\"${checkoutDirectory}\" default-value=\"${project.build.directory}/checkout\"\n     */\n    private File checkoutDirectory;\n\n    /**\n     * Skip checkout if checkoutDirectory exists.\n     *\n     * @parameter expression=\"${skipCheckoutIfExists}\" default-value=\"false\"\n     */\n    private boolean skipCheckoutIfExists = false;\n\n    /**\n     * The version type (branch/tag/revision) of scmVersion.\n     *\n     * @parameter expression=\"${scmVersionType}\"\n     */\n    private String scmVersionType;\n\n    /**\n     * The version (revision number/branch name/tag name).\n     *\n     * @parameter expression=\"${scmVersion}\"\n     */\n    private String scmVersion;\n\n    /**\n     * allow extended mojo (ie BootStrap ) to see checkout result\n     */\n    private CheckOutScmResult checkoutResult;\n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        //skip checkout if checkout directory is already created. See SCM-201\n        checkoutResult = null;\n        if ( !getCheckoutDirectory().isDirectory() || !this.skipCheckoutIfExists )\n        {\n            checkoutResult = checkout();\n        }\n    }\n\n    protected File getCheckoutDirectory()\n    {\n        return this.checkoutDirectory;\n    }\n\n    public void setCheckoutDirectory( File checkoutDirectory )\n    {\n        this.checkoutDirectory = checkoutDirectory;\n    }\n\n    protected CheckOutScmResult checkout()\n        throws MojoExecutionException\n    {\n        try\n        {\n            ScmRepository repository = getScmRepository();\n\n            try\n            {\n                this.getLog().info( \"Removing \" + getCheckoutDirectory() );\n\n                FileUtils.deleteDirectory( getCheckoutDirectory() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot remove \" + getCheckoutDirectory() );\n            }\n\n            if ( !getCheckoutDirectory().mkdirs() )\n            {\n                throw new MojoExecutionException( \"Cannot create \" + getCheckoutDirectory() );\n            }\n\n            CheckOutScmResult result = getScmManager().checkOut( repository, new ScmFileSet(\n                getCheckoutDirectory().getAbsoluteFile() ), getScmVersion( scmVersionType, scmVersion ) );\n\n            checkResult( result );\n\n            return result;\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run checkout command : \", e );\n        }\n    }\n\n    protected CheckOutScmResult getCheckoutResult()\n    {\n        return checkoutResult;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.FileUtils;\n\n/**\n * Get a fresh copy of the latest source from the configured scm url.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @goal checkout\n * @requiresProject false\n */\npublic class CheckoutMojo\n    extends AbstractScmMojo\n{\n    /**\n     * Use Export instead of checkout\n     *\n     * @parameter expression=\"${useExport}\" defaultValue=\"false\";\n     */\n    private boolean useExport;\n    \n    /**\n     * The directory to checkout the sources to for the bootstrap and checkout goals.\n     *\n     * @parameter expression=\"${checkoutDirectory}\" default-value=\"${project.build.directory}/checkout\"\n     */\n    private File checkoutDirectory;\n\n    /**\n     * Skip checkout if checkoutDirectory exists.\n     *\n     * @parameter expression=\"${skipCheckoutIfExists}\" default-value=\"false\"\n     */\n    private boolean skipCheckoutIfExists = false;\n\n    /**\n     * The version type (branch/tag/revision) of scmVersion.\n     *\n     * @parameter expression=\"${scmVersionType}\"\n     */\n    private String scmVersionType;\n\n    /**\n     * The version (revision number/branch name/tag name).\n     *\n     * @parameter expression=\"${scmVersion}\"\n     */\n    private String scmVersion;\n\n    /**\n     * allow extended mojo (ie BootStrap ) to see checkout result\n     */\n    private ScmResult checkoutResult;\n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        //skip checkout if checkout directory is already created. See SCM-201\n        checkoutResult = null;\n        if ( !getCheckoutDirectory().isDirectory() || !this.skipCheckoutIfExists )\n        {\n            checkoutResult = checkout();\n        }\n    }\n\n    protected File getCheckoutDirectory()\n    {\n        return this.checkoutDirectory;\n    }\n\n    public void setCheckoutDirectory( File checkoutDirectory )\n    {\n        this.checkoutDirectory = checkoutDirectory;\n    }\n\n    protected ScmResult checkout()\n        throws MojoExecutionException\n    {\n        try\n        {\n            ScmRepository repository = getScmRepository();\n\n            this.prepareOutputDirectory( getCheckoutDirectory() );\n            \n            ScmResult result = null;\n            \n            ScmFileSet fileSet = new ScmFileSet( getCheckoutDirectory().getAbsoluteFile() );\n            if ( useExport )\n            {\n                result = getScmManager().export( repository,fileSet, getScmVersion( scmVersionType, scmVersion ) );\n            }\n            else\n            {\n                result = getScmManager().checkOut( repository,fileSet , getScmVersion( scmVersionType, scmVersion ) );\n            }\n\n            checkResult( result );\n\n            return result;\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run checkout command : \", e );\n        }\n    }\n\n    private void prepareOutputDirectory( File ouputDirectory )\n        throws MojoExecutionException\n    {\n        try\n        {\n            this.getLog().info( \"Removing \" + ouputDirectory );\n\n            FileUtils.deleteDirectory( getCheckoutDirectory() );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot remove \" + ouputDirectory );\n        }\n        \n        if ( !getCheckoutDirectory().mkdirs() )\n        {\n            throw new MojoExecutionException( \"Cannot create \" + ouputDirectory );\n        }\n    }\n    \n    protected ScmResult getCheckoutResult()\n    {\n        return checkoutResult;\n    }\n}\n","lineNo":119}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.login;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.login.AbstractLoginCommand;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.StringBufferInputStream;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceLoginCommand\n    extends AbstractLoginCommand\n    implements PerforceCommand\n{\n    /** {@inheritDoc} */\n    public LoginScmResult executeLoginCommand( ScmProviderRepository repo, ScmFileSet files, CommandParameters params )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        PerforceLoginConsumer consumer = new PerforceLoginConsumer();\n\n        try\n        {\n            String password = repo.getPassword();\n            if ( StringUtils.isEmpty( password ) )\n            {\n                throw new ScmException( \"password is required for the perforce scm plugin.\" );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, new StringBufferInputStream(password), consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new ScmException( \"\", e );\n        }\n\n        return new LoginScmResult( cl.toString(), consumer.isSuccess() ? \"Login successful\" : \"Login failed\",\n                        consumer.getOutput(), consumer.isSuccess() );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDir )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDir );\n\n        command.createArg().setValue( \"login\" );\n        if ( !StringUtils.isEmpty( repo.getUser() ) )\n        {\n            command.createArg().setValue( repo.getUser() );\n        }\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.login;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.login.AbstractLoginCommand;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.StringBufferInputStream;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceLoginCommand\n    extends AbstractLoginCommand\n    implements PerforceCommand\n{\n    /** {@inheritDoc} */\n    public LoginScmResult executeLoginCommand( ScmProviderRepository repo, ScmFileSet files, CommandParameters params )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        PerforceLoginConsumer consumer = new PerforceLoginConsumer();\n        boolean isSuccess = false;\n\n        try\n        {\n            String password = repo.getPassword();\n            if ( StringUtils.isEmpty( password ) )\n            {\n                if ( getLogger().isInfoEnabled() )\n                {\n                    getLogger().info( \"No password found, proceeding without it.\" );\n                }\n                isSuccess = true;\n            }\n            else {\n                CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n                int exitCode = CommandLineUtils.executeCommandLine( cl, new StringBufferInputStream(password), consumer, err );\n                isSuccess = consumer.isSuccess();\n\n                if ( isSuccess )\n                {\n                    String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                    StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                    msg.append( '\\n' );\n                    msg.append( \"Command line was:\" + cmdLine );\n\n                    throw new CommandLineException( msg.toString() );\n                }\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new ScmException( \"\", e );\n        }\n\n        return new LoginScmResult( cl.toString(), isSuccess ? \"Login successful\" : \"Login failed\",\n                        consumer.getOutput(), isSuccess );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDir )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDir );\n\n        command.createArg().setValue( \"login\" );\n        if ( !StringUtils.isEmpty( repo.getUser() ) )\n        {\n            command.createArg().setValue( repo.getUser() );\n        }\n        return command;\n    }\n}\n","lineNo":54}
{"Smelly Sample":"package org.apache.maven.scm.provider.git.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class GitScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String url;\n\n    /**\n     * the protocol to use\n     */\n    private String protocol;\n\n    /** use local file as transport*/\n    public static final String PROTOCOL_FILE = \"file\";\n\n    /** use gits internal protocol */\n    public static final String PROTOCOL_GIT = \"git\";\n\n    /** use secure shell protocol */\n    public static final String PROTOCOL_SSH = \"ssh\";\n\n    /** use the standard port 80 http protocol */\n    public static final String PROTOCOL_HTTP = \"http\";\n\n    /** use the standard port 443 https protocol */\n    public static final String PROTOCOL_HTTPS = \"https\";\n\n    /** use rsync for retrieving the data\n     * TODO implement! */\n    public static final String PROTOCOL_RSYNC = \"rsync\";\n\n\n    public GitScmProviderRepository( String url )\n    {\n        parseUrl( url );\n    }\n\n    public GitScmProviderRepository( String url, String user, String password )\n    {\n        this( url );\n\n        setUser( user );\n\n        setPassword( password );\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    private void setProtocol( String protocol )\n    {\n        this.protocol = protocol;\n    }\n\n    /**\n     * @return the protocol used in this repository (file, http, https, git, ...)\n     */\n    public String getProtocol()\n    {\n        return protocol;\n    }\n\n    private void parseUrl( String url )\n    {\n        if ( url.startsWith( PROTOCOL_FILE ) )\n        {\n            setProtocol( PROTOCOL_FILE );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTPS ) )\n        {\n            setProtocol( PROTOCOL_HTTPS );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTP ) )\n        {\n            setProtocol( PROTOCOL_HTTP );\n        }\n        else if ( url.startsWith( PROTOCOL_SSH ) )\n        {\n            setProtocol( PROTOCOL_SSH );\n        }\n        else if ( url.startsWith( PROTOCOL_GIT ) )\n        {\n            setProtocol( PROTOCOL_GIT );\n        }\n        else if ( url.startsWith( PROTOCOL_RSYNC ) )\n        {\n            setProtocol( PROTOCOL_RSYNC );\n        }\n\n        if ( getProtocol() == null )\n        {\n            return;\n        }\n\n        String urlPath = url.substring( getProtocol().length() );\n\n        if ( urlPath.startsWith( \"://\" ) )\n        {\n            urlPath = urlPath.substring( 3 );\n        }\n        int indexAt = urlPath.indexOf( \"@\" );\n\n        if ( indexAt > 0 )\n        {\n            String userPassword = urlPath.substring( 0, indexAt );\n            if ( userPassword.indexOf( \":\" ) < 0 )\n            {\n                setUser( userPassword );\n            }\n            else\n            {\n                setUser( userPassword.substring( 0, userPassword.indexOf( \":\" ) ) );\n                setPassword( userPassword.substring( userPassword.indexOf( \":\" ) + 1 ) );\n            }\n\n            urlPath = urlPath.substring( indexAt + 1 );\n\n            if ( PROTOCOL_SSH.equals( getProtocol() ) )\n            {\n                StringBuffer urlSb = new StringBuffer( getProtocol() );\n\n                urlSb.append( \"://\" );\n\n                if ( getUser() != null )\n                {\n                     urlSb.append( getUser() );\n\n                     if ( getPassword() != null )\n                     {\n                         urlSb.append( ':' ).append( getPassword() );\n                     }\n\n                     urlSb.append( '@' );\n                }\n\n                urlSb.append( urlPath );\n\n                this.url = urlSb.toString();\n            }\n            else\n            {\n                this.url = getProtocol() + \"://\" + urlPath;\n            }\n        }\n        else\n        {\n            this.url = getProtocol() + \"://\"  + urlPath;\n        }\n\n        if ( !PROTOCOL_FILE.equals( getProtocol() ) )\n        {\n            int indexSlash = urlPath.indexOf( \"/\" );\n\n            String hostPort = urlPath;\n\n            if ( indexSlash > 0 )\n            {\n                hostPort = urlPath.substring( 0, indexSlash );\n            }\n\n            int indexColon = hostPort.indexOf( \":\" );\n\n            if ( indexColon > 0 )\n            {\n                setHost( hostPort.substring( 0, indexColon ) );\n                setPort( Integer.parseInt( hostPort.substring( indexColon + 1 ) ) );\n            }\n            else\n            {\n                setHost( hostPort );\n            }\n\n        }\n    }\n\n    /** {@inheritDoc} */\n    public ScmProviderRepository getParent()\n    {\n        String newUrl = getUrl().substring( getProtocol().length() );\n\n        while ( newUrl.endsWith( \"/.\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() - 1 );\n        }\n\n        while ( newUrl.endsWith( \"/\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() );\n        }\n\n        int i = newUrl.lastIndexOf( \"/\" );\n\n        if ( i < 0 )\n        {\n            return null;\n        }\n        newUrl = newUrl.substring( 0, i );\n\n        return new GitScmProviderRepository( getProtocol() + newUrl, getUser(), getPassword() );\n    }\n\n    /** {@inheritDoc} */\n    public String getRelativePath( ScmProviderRepository ancestor )\n    {\n        if ( ancestor instanceof GitScmProviderRepository )\n        {\n            GitScmProviderRepository gitAncestor = (GitScmProviderRepository) ancestor;\n\n            String path = getUrl().replaceFirst( gitAncestor.getUrl() + \"/\", \"\" );\n\n            if ( !path.equals( getUrl() ) )\n            {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        return getUrl();\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.git.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class GitScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String url;\n\n    /**\n     * the protocol to use\n     */\n    private String protocol;\n\n    /** use local file as transport*/\n    public static final String PROTOCOL_FILE = \"file\";\n\n    /** use gits internal protocol */\n    public static final String PROTOCOL_GIT = \"git\";\n\n    /** use secure shell protocol */\n    public static final String PROTOCOL_SSH = \"ssh\";\n\n    /** use the standard port 80 http protocol */\n    public static final String PROTOCOL_HTTP = \"http\";\n\n    /** use the standard port 443 https protocol */\n    public static final String PROTOCOL_HTTPS = \"https\";\n\n    /** use rsync for retrieving the data\n     * TODO implement! */\n    public static final String PROTOCOL_RSYNC = \"rsync\";\n\n\n    public GitScmProviderRepository( String url )\n    {\n        parseUrl( url );\n    }\n\n    public GitScmProviderRepository( String url, String user, String password )\n    {\n        this( url );\n\n        setUser( user );\n\n        setPassword( password );\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    private void setProtocol( String protocol )\n    {\n        this.protocol = protocol;\n    }\n\n    /**\n     * @return the protocol used in this repository (file, http, https, git, ...)\n     */\n    public String getProtocol()\n    {\n        return protocol;\n    }\n\n    private void parseUrl( String url )\n    {\n        if ( url.startsWith( PROTOCOL_FILE ) )\n        {\n            setProtocol( PROTOCOL_FILE );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTPS ) )\n        {\n            setProtocol( PROTOCOL_HTTPS );\n        }\n        else if ( url.startsWith( PROTOCOL_HTTP ) )\n        {\n            setProtocol( PROTOCOL_HTTP );\n        }\n        else if ( url.startsWith( PROTOCOL_SSH ) )\n        {\n            setProtocol( PROTOCOL_SSH );\n        }\n        else if ( url.startsWith( PROTOCOL_GIT ) )\n        {\n            setProtocol( PROTOCOL_GIT );\n        }\n        else if ( url.startsWith( PROTOCOL_RSYNC ) )\n        {\n            setProtocol( PROTOCOL_RSYNC );\n        }\n\n        if ( getProtocol() == null )\n        {\n            return;\n        }\n\n        String urlPath = url.substring( getProtocol().length() );\n\n        if ( urlPath.startsWith( \"://\" ) )\n        {\n            urlPath = urlPath.substring( 3 );\n        }\n        int indexAt = urlPath.indexOf( \"@\" );\n\n        if ( indexAt > 0 )\n        {\n            String userPassword = urlPath.substring( 0, indexAt );\n            if ( userPassword.indexOf( \":\" ) < 0 )\n            {\n                setUser( userPassword );\n            }\n            else\n            {\n                setUser( userPassword.substring( 0, userPassword.indexOf( \":\" ) ) );\n                setPassword( userPassword.substring( userPassword.indexOf( \":\" ) + 1 ) );\n            }\n\n            urlPath = urlPath.substring( indexAt + 1 );\n\n            if ( PROTOCOL_SSH.equals( getProtocol() ) )\n            {\n                StringBuffer urlSb = new StringBuffer( getProtocol() );\n\n                urlSb.append( \"://\" );\n\n                if ( getUser() != null )\n                {\n                     urlSb.append( getUser() );\n\n                     if ( getPassword() != null )\n                     {\n                         urlSb.append( ':' ).append( getPassword() );\n                     }\n\n                     urlSb.append( '@' );\n                }\n\n                urlSb.append( urlPath );\n\n                this.url = urlSb.toString();\n            }\n            else\n            {\n                this.url = getProtocol() + \"://\" + urlPath;\n            }\n        }\n        else\n        {\n            this.url = getProtocol() + \"://\"  + urlPath;\n        }\n\n        if ( !PROTOCOL_FILE.equals( getProtocol() ) )\n        {\n            int indexSlash = urlPath.indexOf( \"/\" );\n\n            String hostPort = urlPath;\n\n            if ( indexSlash > 0 )\n            {\n                hostPort = urlPath.substring( 0, indexSlash );\n            }\n\n            int indexColon = hostPort.indexOf( \":\" );\n\n            if ( indexColon > 0 )\n            {\n                boolean sshGitDev = false;\n                // url = scm:git:git@github.com:22:olamy/scm-git-test-one-module.git\n                if ( hostPort.startsWith( \"@\" ) )\n                {\n                    setHost( hostPort.substring( 1, indexColon ) );\n                }\n                else\n                {\n                    setHost( hostPort.substring( 0, indexColon ) );\n                }\n                String port = hostPort.substring( indexColon + 1 );\n\n                if ( port.indexOf( \":\" ) > 0 )\n                {\n                    port = port.substring( 0, port.indexOf( \":\" ) );\n                    sshGitDev = true;\n                }\n                \n                // url = scm:git:git@github.com:olamy/scm-git-test-one-module.git -> Nan\n                try\n                {\n                    setPort( Integer.parseInt( port ) );\n                }\n                catch ( NumberFormatException e )\n                {\n                    if ( !PROTOCOL_GIT.equals( getProtocol() ) )\n                    {\n                        throw e;\n                    }\n                    sshGitDev = true;\n                }\n                if (sshGitDev)\n                {\n                    this.url = \"git\" + urlPath;\n                }\n            }\n            else\n            {\n                setHost( hostPort );\n            }\n\n        }\n    }\n\n    /** {@inheritDoc} */\n    public ScmProviderRepository getParent()\n    {\n        String newUrl = getUrl().substring( getProtocol().length() );\n\n        while ( newUrl.endsWith( \"/.\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() - 1 );\n        }\n\n        while ( newUrl.endsWith( \"/\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() );\n        }\n\n        int i = newUrl.lastIndexOf( \"/\" );\n\n        if ( i < 0 )\n        {\n            return null;\n        }\n        newUrl = newUrl.substring( 0, i );\n\n        return new GitScmProviderRepository( getProtocol() + newUrl, getUser(), getPassword() );\n    }\n\n    /** {@inheritDoc} */\n    public String getRelativePath( ScmProviderRepository ancestor )\n    {\n        if ( ancestor instanceof GitScmProviderRepository )\n        {\n            GitScmProviderRepository gitAncestor = (GitScmProviderRepository) ancestor;\n\n            String path = getUrl().replaceFirst( gitAncestor.getUrl() + \"/\", \"\" );\n\n            if ( !path.equals( getUrl() ) )\n            {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        return getUrl();\n    }\n\n}\n","lineNo":204}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.login;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.login.AbstractLoginCommand;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceLoginCommand\n    extends AbstractLoginCommand\n    implements PerforceCommand\n{\n    /** {@inheritDoc} */\n    public LoginScmResult executeLoginCommand( ScmProviderRepository repo, ScmFileSet files, CommandParameters params )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        PerforceLoginConsumer consumer = new PerforceLoginConsumer();\n\n        try\n        {\n            if ( StringUtils.isEmpty( repo.getPassword() ) )\n            {\n                throw new ScmException( \"password is required for the perforce scm plugin.\" );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new ScmException( \"\", e );\n        }\n\n        return new LoginScmResult( cl.toString(), consumer.isSuccess() ? \"Login successful\" : \"Login failed\",\n                        consumer.getOutput(), consumer.isSuccess() );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDir )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDir );\n\n        command.createArg().setValue( \"login\" );\n        if ( !StringUtils.isEmpty( repo.getUser() ) )\n        {\n            command.createArg().setValue( repo.getUser() );\n        }\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.login;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.login.AbstractLoginCommand;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.StringBufferInputStream;\n\n/**\n * @author Mike Perham\n * @version $Id$\n */\npublic class PerforceLoginCommand\n    extends AbstractLoginCommand\n    implements PerforceCommand\n{\n    /** {@inheritDoc} */\n    public LoginScmResult executeLoginCommand( ScmProviderRepository repo, ScmFileSet files, CommandParameters params )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir() );\n        PerforceLoginConsumer consumer = new PerforceLoginConsumer();\n\n        try\n        {\n            String password = repo.getPassword();\n            if ( StringUtils.isEmpty( password ) )\n            {\n                throw new ScmException( \"password is required for the perforce scm plugin.\" );\n            }\n\n            CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n            int exitCode = CommandLineUtils.executeCommandLine( cl, new StringBufferInputStream(password), consumer, err );\n\n            if ( exitCode != 0 )\n            {\n                String cmdLine = CommandLineUtils.toString( cl.getCommandline() );\n\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + cmdLine );\n\n                throw new CommandLineException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new ScmException( \"\", e );\n        }\n\n        return new LoginScmResult( cl.toString(), consumer.isSuccess() ? \"Login successful\" : \"Login failed\",\n                        consumer.getOutput(), consumer.isSuccess() );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDir )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDir );\n\n        command.createArg().setValue( \"login\" );\n        if ( !StringUtils.isEmpty( repo.getUser() ) )\n        {\n            command.createArg().setValue( repo.getUser() );\n        }\n        return command;\n    }\n}\n","lineNo":57}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.cvslib.AbstractCvsScmProvider;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String cvsroot;\n\n    /** */\n    private String transport;\n\n    /** */\n    private String path;\n\n    /** */\n    private String module;\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host,\n                                     String path, String module )\n    {\n        this( cvsroot, transport, user, password, host, -1, path, module );\n    }\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host,\n                                     int port, String path, String module )\n    {\n        this.cvsroot = cvsroot;\n\n        this.transport = transport;\n\n        if ( user == null && AbstractCvsScmProvider.TRANSPORT_EXT.equals( transport ) )\n        {\n            user = System.getProperty( \"user.name\" );\n        }\n\n        setUser( user );\n\n        setPassword( password );\n\n        setHost( host );\n\n        setPort( port );\n\n        this.path = path;\n\n        this.module = module;\n    }\n\n    /**\n     * @return The cvs root\n     */\n    public String getCvsRoot()\n    {\n        String root = getCvsRootForCvsPass();\n\n        return removeDefaultPortFromCvsRoot( root );\n    }\n\n    private String removeDefaultPortFromCvsRoot( String root )\n    {\n        if ( root != null && root.indexOf( \":2401\" ) > 0 )\n        {\n            root = root.substring( 0, root.indexOf( \":2401\" ) ) + \":\" + root.substring( root.indexOf( \":2401\" ) + 5 );\n        }\n\n        return root;\n    }\n\n    /**\n     * @return The cvs root stored in .cvspass\n     */\n    public String getCvsRootForCvsPass()\n    {\n        if ( getUser() != null )\n        {\n            return getCvsRootWithCorrectUser( getUser() );\n        }\n        else\n        {\n            if ( AbstractCvsScmProvider.TRANSPORT_LOCAL.equals( getTransport() ) )\n            {\n                return cvsroot;\n            }\n            else\n            {\n                throw new IllegalArgumentException( \"Username isn't defined.\" );\n            }\n        }\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     */\n    public String getTransport()\n    {\n        return transport;\n    }\n\n    /**\n     * @return The path.\n     */\n    public String getPath()\n    {\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     */\n    public String getModule()\n    {\n        return module;\n    }\n\n    private String getCvsRootWithCorrectUser()\n    {\n        return getCvsRootWithCorrectUser( null );\n    }\n\n    /**\n     * @param user user name\n     * @return\n     */\n    private String getCvsRootWithCorrectUser( String user )\n    {\n        //:transport:rest_of_cvsroot\n        int indexOfUsername = getTransport().length() + 2;\n\n        int indexOfAt = cvsroot.indexOf( \"@\" );\n\n        String userString = user == null ? \"\" : \":\" + user;\n\n        if ( indexOfAt > 0 )\n        {\n            cvsroot = \":\" + getTransport() + userString + cvsroot.substring( indexOfAt );\n        }\n        else\n        {\n            cvsroot = \":\" + getTransport() + userString + \"@\" + cvsroot.substring( indexOfUsername );\n        }\n\n        return cvsroot;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        StringBuffer sb = new StringBuffer();\n\n        if ( getUser() == null )\n        {\n            if ( AbstractCvsScmProvider.TRANSPORT_LOCAL.equals( getTransport() ) )\n            {\n                sb.append( \":\" );\n                sb.append( getTransport() );\n                sb.append( \":\" );\n                sb.append( getCvsRoot() );\n            }\n            else\n            {\n                sb.append( removeDefaultPortFromCvsRoot( getCvsRootWithCorrectUser() ) );\n            }\n        }\n        else\n        {\n            sb.append( getCvsRoot() );\n        }\n        sb.append( \":\" );\n        sb.append( getModule() );\n\n        /* remove first colon */\n        if ( sb.charAt( 0 ) == ':' )\n        {\n            sb.deleteCharAt( 0 );\n        }\n        return sb.toString();\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.cvslib.AbstractCvsScmProvider;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String cvsroot;\n\n    /** */\n    private String transport;\n\n    /** */\n    private String path;\n\n    /** */\n    private String module;\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host,\n                                     String path, String module )\n    {\n        this( cvsroot, transport, user, password, host, -1, path, module );\n    }\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host,\n                                     int port, String path, String module )\n    {\n        this.cvsroot = cvsroot;\n\n        this.transport = transport;\n\n        if ( user == null && AbstractCvsScmProvider.TRANSPORT_EXT.equals( transport ) )\n        {\n            user = System.getProperty( \"user.name\" );\n        }\n\n        setUser( user );\n\n        setPassword( password );\n\n        setHost( host );\n\n        setPort( port );\n\n        this.path = path;\n\n        this.module = module;\n    }\n\n    /**\n     * @return The cvs root\n     */\n    public String getCvsRoot()\n    {\n        String root = getCvsRootForCvsPass();\n\n        return removeDefaultPortFromCvsRoot( root );\n    }\n\n    private String removeDefaultPortFromCvsRoot( String root )\n    {\n        if ( root != null && root.indexOf( \":2401\" ) > 0 )\n        {\n            root = root.substring( 0, root.indexOf( \":2401\" ) ) + \":\" + root.substring( root.indexOf( \":2401\" ) + 5 );\n        }\n\n        return root;\n    }\n\n    /**\n     * @return The cvs root stored in .cvspass\n     */\n    public String getCvsRootForCvsPass()\n    {\n        String result;\n        String transport = getTransport();\n        if ( AbstractCvsScmProvider.TRANSPORT_LOCAL.equals( transport ) )\n        {\n            result = \":\" + transport + \":\" + cvsroot;\n        }\n        else if ( getUser() != null )\n        {\n            result = getCvsRootWithCorrectUser( getUser() );\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Username isn't defined.\" );\n        }\n        return result;\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     */\n    public String getTransport()\n    {\n        return transport;\n    }\n\n    /**\n     * @return The path.\n     */\n    public String getPath()\n    {\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     */\n    public String getModule()\n    {\n        return module;\n    }\n\n    private String getCvsRootWithCorrectUser()\n    {\n        return getCvsRootWithCorrectUser( null );\n    }\n\n    /**\n     * @param user user name\n     * @return\n     */\n    private String getCvsRootWithCorrectUser( String user )\n    {\n        //:transport:rest_of_cvsroot\n        int indexOfUsername = getTransport().length() + 2;\n\n        int indexOfAt = cvsroot.indexOf( \"@\" );\n\n        String userString = user == null ? \"\" : \":\" + user;\n\n        if ( indexOfAt > 0 )\n        {\n            cvsroot = \":\" + getTransport() + userString + cvsroot.substring( indexOfAt );\n        }\n        else\n        {\n            cvsroot = \":\" + getTransport() + userString + \"@\" + cvsroot.substring( indexOfUsername );\n        }\n\n        return cvsroot;\n    }\n\n    /** {@inheritDoc} */\n    public String toString()\n    {\n        StringBuffer sb = new StringBuffer();\n\n        if ( getUser() == null )\n        {\n            if ( AbstractCvsScmProvider.TRANSPORT_LOCAL.equals( getTransport() ) )\n            {\n                sb.append( getCvsRoot() );\n            }\n            else\n            {\n                sb.append( removeDefaultPortFromCvsRoot( getCvsRootWithCorrectUser() ) );\n            }\n        }\n        else\n        {\n            sb.append( getCvsRoot() );\n        }\n        sb.append( \":\" );\n        sb.append( getModule() );\n\n        /* remove first colon */\n        if ( sb.charAt( 0 ) == ':' )\n        {\n            sb.deleteCharAt( 0 );\n        }\n        return sb.toString();\n    }\n\n}\n","lineNo":102}
{"Smelly Sample":"package org.apache.maven.scm.provider.synergy.util;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:julien.henry@capgemini.com\">Julien Henry<\/a>\n */\npublic class SynergyCCMTest\n    extends ScmTestCase\n{\n\n    public void testShowTaskObjects()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.showTaskObjects( 45, \"my format\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm task -show objects -f \\\"my format\\\" 45\", null, cl );\n        cl = SynergyCCM.showTaskObjects( 45, null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm task -show objects 45\", null, cl );\n    }\n\n    public void testQuery()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.query( \"my query\", \"my format\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm query -u -f \\\"my format\\\" \\\"my query\\\"\", null, cl );\n        cl = SynergyCCM.query( \"my query\", null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm query -u \\\"my query\\\"\", null, cl );\n    }\n\n    public void testCreateBaseline()\n        throws Exception\n    {\n        Commandline cl =\n            SynergyCCM.createBaseline( \"myProject~1\", \"theBaseline\", \"my_release\", \"my_purpose\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm baseline -create theBaseline -p myProject~1 -release my_release -purpose my_purpose\",\n                           null, cl );\n    }\n\n    public void testCreate()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.create( list, \"test creation\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm create -c \\\"test creation\\\" \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm create -c \\\"test creation\\\" \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.create( list, \"test creation\", \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm create -c \\\"test creation\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" +\n                    f2.getCanonicalPath() + \"\\\"\", null, cl );\n            }\n            else\n            {\n                assertCommandLine(\n                    \"ccm create -c \\\"test creation\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\",\n                    null, cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine(\n                    \"ccm create -c \\\"test creation\\\" \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\",\n                    null, cl );\n            }\n            else\n            {\n                assertCommandLine(\n                    \"ccm create -c \\\"test creation\\\" \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(), null, cl );\n            }\n        }\n    }\n\n    public void testCreateTask()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.createTask( \"the synopsis\", \"release\", true, \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        String expected = \"ccm task -create -synopsis 'the synopsis' -release release\";\n        assertTrue( \"[\" + cl.toString() + \"] do not contain [\" + expected + \"]\",\n                    cl.toString().indexOf( expected ) > -1 );\n        cl = SynergyCCM.createTask( \"the synopsis\", null, true, \"CCM_ADDR\" );\n        expected = \"ccm task -create -synopsis 'the synopsis'\";\n        assertTrue( \"[\" + cl.toString() + \"] do not contain [\" + expected + \"]\",\n                    cl.toString().indexOf( expected ) > -1 );\n    }\n\n    public void testCheckinTask()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.checkinTask( \"truc\", \"a comment\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm task -checkin truc -comment \\\"a comment\\\"\", null, cl );\n    }\n\n    public void testDelete()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.delete( list, \"CCM_ADDR\", true );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm delete -replace \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm delete -replace \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.delete( list, \"CCM_ADDR\", false );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm delete \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" + f2.getCanonicalPath() + \"\\\"\",\n                                   null, cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm delete \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\", null,\n                                   cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm delete \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                                   cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm delete \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(), null, cl );\n            }\n        }\n    }\n\n    public void testReconfigure()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconfigure( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm reconfigure -recurse -p project~1\", null, cl );\n    }\n\n    public void testReconfigureProperties()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconfigureProperties( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm reconfigure_properties -refresh project~1\", null, cl );\n    }\n\n    public void testReconcileUwa()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconcileUwa( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm rwa -r -uwa -p project~1\", null, cl );\n        cl = SynergyCCM.reconcileUwa( null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm rwa -r -uwa\", null, cl );\n    }\n\n    public void testReconcileUdb()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconcileUdb( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm rwa -r -udb -p project~1\", null, cl );\n        cl = SynergyCCM.reconcileUdb( null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm rwa -r -udb\", null, cl );\n    }\n\n    public void testDir()\n        throws Exception\n    {\n        File f = File.createTempFile( \"foo\", null );\n        f.deleteOnExit();\n        Commandline cl = SynergyCCM.dir( f.getParentFile(), \"format\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertEquals( f.getParentFile().getCanonicalFile(), cl.getWorkingDirectory().getCanonicalFile() );\n        assertCommandLine( \"ccm dir -m -f format\", f.getParentFile().getCanonicalFile(), cl );\n    }\n\n    public void testCheckoutFiles()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.checkoutFiles( list, \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm co \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm co \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.checkoutFiles( list, \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm co \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                                   cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm co \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\", null, cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm co \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null, cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm co \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(), null, cl );\n            }\n        }\n    }\n\n    public void testCheckoutProject()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.checkoutProject( null, \"MyProject\", new ScmTag( \"MyVersion\" ), \"MyPurpose\",\n                                                     \"MyRelease\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm co -subprojects -rel -t MyVersion -purpose MyPurpose -release MyRelease -p MyProject\",\n                           null, cl );\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        cl = SynergyCCM.checkoutProject( f.getParentFile(), \"MyProject\", new ScmTag( \"MyVersion\" ), \"MyPurpose\",\n                                         \"MyRelease\", \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm co -subprojects -rel -t MyVersion -purpose MyPurpose -release MyRelease -path \\\"\" +\n                f.getParentFile().getCanonicalPath() + \"\\\" -p MyProject\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm co -subprojects -rel -t MyVersion -purpose MyPurpose -release MyRelease -path \" +\n                f.getParentFile().getCanonicalPath() + \" -p MyProject\", null, cl );\n        }\n    }\n\n    public void testCheckinProject()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.checkinProject( \"MyProject\", \"a comment\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm ci -c \\\"a comment\\\" -p MyProject\", null, cl );\n    }\n\n    public void testCheckinFiles()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.checkinFiles( list, \"a comment\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm ci -c \\\"a comment\\\" \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm ci -c \\\"a comment\\\" \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.checkinFiles( list, \"a comment\", \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine(\n                    \"ccm ci -c \\\"a comment\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                    cl );\n            }\n            else\n            {\n                assertCommandLine(\n                    \"ccm ci -c \\\"a comment\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\", null,\n                    cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine(\n                    \"ccm ci -c \\\"a comment\\\" \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                    cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm ci -c \\\"a comment\\\" \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(),\n                                   null, cl );\n            }\n        }\n    }\n\n    public void testSync()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.synchronize( \"myProject\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm sync -r -p myProject\", null, cl );\n    }\n\n    public void testShowWorkArea()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.showWorkArea( \"MyProject~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm wa -show MyProject~1\", null, cl );\n    }\n\n    public void testStart()\n        throws ScmException\n    {\n        Commandline cl = SynergyCCM.start( \"user\", \"pass\", SynergyRole.BUILD_MGR );\n        assertCommandLine( \"ccm start -nogui -m -q -n user -pw pass -r build_mgr\", null, cl );\n    }\n\n    public void testStop()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.stop( \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm stop\", null, cl );\n    }\n\n    public void testDelimiter()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.delimiter( \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm delimiter\", null, cl );\n    }\n\n    public boolean assertContains( String[] array, String value )\n    {\n        for ( int i = 0; i < array.length; i++ )\n        {\n            if ( array[i].equals( value ) )\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.synergy.util;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:julien.henry@capgemini.com\">Julien Henry<\/a>\n */\npublic class SynergyCCMTest\n    extends ScmTestCase\n{\n\n    public void testShowTaskObjects()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.showTaskObjects( 45, \"my format\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm task -show objects -f \\\"my format\\\" 45\", null, cl );\n        cl = SynergyCCM.showTaskObjects( 45, null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm task -show objects 45\", null, cl );\n    }\n\n    public void testQuery()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.query( \"my query\", \"my format\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm query -u -f \\\"my format\\\" \\\"my query\\\"\", null, cl );\n        cl = SynergyCCM.query( \"my query\", null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm query -u \\\"my query\\\"\", null, cl );\n    }\n\n    public void testCreateBaseline()\n        throws Exception\n    {\n        Commandline cl =\n            SynergyCCM.createBaseline( \"myProject~1\", \"theBaseline\", \"my_release\", \"my_purpose\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm baseline -create theBaseline -p myProject~1 -release my_release -purpose my_purpose\",\n                           null, cl );\n    }\n\n    public void testCreate()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.create( list, \"test creation\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm create -c \\\"test creation\\\" \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm create -c \\\"test creation\\\" \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.create( list, \"test creation\", \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm create -c \\\"test creation\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" +\n                    f2.getCanonicalPath() + \"\\\"\", null, cl );\n            }\n            else\n            {\n                assertCommandLine(\n                    \"ccm create -c \\\"test creation\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\",\n                    null, cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine(\n                    \"ccm create -c \\\"test creation\\\" \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\",\n                    null, cl );\n            }\n            else\n            {\n                assertCommandLine(\n                    \"ccm create -c \\\"test creation\\\" \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(), null, cl );\n            }\n        }\n    }\n\n    public void testCreateTask()\n        throws Exception\n    {\n        /*\n         * NOTE: Quoting of arguments can differ for Windows/Unix, hence we normalize to single quotes for the purpose\n         * of testing.\n         */\n\n        Commandline cl = SynergyCCM.createTask( \"the synopsis\", \"release\", true, \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        String actual = cl.toString().replace( '\\\"', '\\'' );\n        String expected = \"ccm task -create -synopsis 'the synopsis' -release release\";\n        assertTrue( \"[\" + actual + \"] does not contain [\" + expected + \"]\",\n                    actual.indexOf( expected ) > -1 );\n\n        cl = SynergyCCM.createTask( \"the synopsis\", null, true, \"CCM_ADDR\" );\n        actual = cl.toString().replace( '\\\"', '\\'' );\n        expected = \"ccm task -create -synopsis 'the synopsis'\";\n        assertTrue( \"[\" + actual + \"] does not contain [\" + expected + \"]\",\n                    actual.indexOf( expected ) > -1 );\n    }\n\n    public void testCheckinTask()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.checkinTask( \"truc\", \"a comment\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm task -checkin truc -comment \\\"a comment\\\"\", null, cl );\n    }\n\n    public void testDelete()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.delete( list, \"CCM_ADDR\", true );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm delete -replace \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm delete -replace \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.delete( list, \"CCM_ADDR\", false );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm delete \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" + f2.getCanonicalPath() + \"\\\"\",\n                                   null, cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm delete \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\", null,\n                                   cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm delete \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                                   cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm delete \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(), null, cl );\n            }\n        }\n    }\n\n    public void testReconfigure()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconfigure( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm reconfigure -recurse -p project~1\", null, cl );\n    }\n\n    public void testReconfigureProperties()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconfigureProperties( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm reconfigure_properties -refresh project~1\", null, cl );\n    }\n\n    public void testReconcileUwa()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconcileUwa( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm rwa -r -uwa -p project~1\", null, cl );\n        cl = SynergyCCM.reconcileUwa( null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm rwa -r -uwa\", null, cl );\n    }\n\n    public void testReconcileUdb()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.reconcileUdb( \"project~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm rwa -r -udb -p project~1\", null, cl );\n        cl = SynergyCCM.reconcileUdb( null, \"CCM_ADDR\" );\n        assertCommandLine( \"ccm rwa -r -udb\", null, cl );\n    }\n\n    public void testDir()\n        throws Exception\n    {\n        File f = File.createTempFile( \"foo\", null );\n        f.deleteOnExit();\n        Commandline cl = SynergyCCM.dir( f.getParentFile(), \"format\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertEquals( f.getParentFile().getCanonicalFile(), cl.getWorkingDirectory().getCanonicalFile() );\n        assertCommandLine( \"ccm dir -m -f format\", f.getParentFile().getCanonicalFile(), cl );\n    }\n\n    public void testCheckoutFiles()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.checkoutFiles( list, \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm co \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm co \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.checkoutFiles( list, \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm co \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                                   cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm co \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\", null, cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine( \"ccm co \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null, cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm co \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(), null, cl );\n            }\n        }\n    }\n\n    public void testCheckoutProject()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.checkoutProject( null, \"MyProject\", new ScmTag( \"MyVersion\" ), \"MyPurpose\",\n                                                     \"MyRelease\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm co -subprojects -rel -t MyVersion -purpose MyPurpose -release MyRelease -p MyProject\",\n                           null, cl );\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        cl = SynergyCCM.checkoutProject( f.getParentFile(), \"MyProject\", new ScmTag( \"MyVersion\" ), \"MyPurpose\",\n                                         \"MyRelease\", \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm co -subprojects -rel -t MyVersion -purpose MyPurpose -release MyRelease -path \\\"\" +\n                f.getParentFile().getCanonicalPath() + \"\\\" -p MyProject\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm co -subprojects -rel -t MyVersion -purpose MyPurpose -release MyRelease -path \" +\n                f.getParentFile().getCanonicalPath() + \" -p MyProject\", null, cl );\n        }\n    }\n\n    public void testCheckinProject()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.checkinProject( \"MyProject\", \"a comment\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm ci -c \\\"a comment\\\" -p MyProject\", null, cl );\n    }\n\n    public void testCheckinFiles()\n        throws Exception\n    {\n        File f = File.createTempFile( \"test\", null );\n        f.deleteOnExit();\n        List list = new LinkedList();\n        list.add( f );\n        Commandline cl = SynergyCCM.checkinFiles( list, \"a comment\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            assertCommandLine( \"ccm ci -c \\\"a comment\\\" \\\"\" + f.getCanonicalPath() + \"\\\"\", null, cl );\n        }\n        else\n        {\n            assertCommandLine( \"ccm ci -c \\\"a comment\\\" \" + f.getCanonicalPath(), null, cl );\n        }\n        File f2 = File.createTempFile( \"test\", null );\n        f2.deleteOnExit();\n        list.add( f2 );\n        cl = SynergyCCM.checkinFiles( list, \"a comment\", \"CCM_ADDR\" );\n        if ( f.getCanonicalPath().indexOf( \" \" ) > -1 )\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine(\n                    \"ccm ci -c \\\"a comment\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                    cl );\n            }\n            else\n            {\n                assertCommandLine(\n                    \"ccm ci -c \\\"a comment\\\" \\\"\" + f.getCanonicalPath() + \"\\\" \" + f2.getCanonicalPath() + \"\", null,\n                    cl );\n            }\n        }\n        else\n        {\n            if ( f2.getCanonicalPath().indexOf( \" \" ) > -1 )\n            {\n                assertCommandLine(\n                    \"ccm ci -c \\\"a comment\\\" \" + f.getCanonicalPath() + \" \\\"\" + f2.getCanonicalPath() + \"\\\"\", null,\n                    cl );\n            }\n            else\n            {\n                assertCommandLine( \"ccm ci -c \\\"a comment\\\" \" + f.getCanonicalPath() + \" \" + f2.getCanonicalPath(),\n                                   null, cl );\n            }\n        }\n    }\n\n    public void testSync()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.synchronize( \"myProject\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm sync -r -p myProject\", null, cl );\n    }\n\n    public void testShowWorkArea()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.showWorkArea( \"MyProject~1\", \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm wa -show MyProject~1\", null, cl );\n    }\n\n    public void testStart()\n        throws ScmException\n    {\n        Commandline cl = SynergyCCM.start( \"user\", \"pass\", SynergyRole.BUILD_MGR );\n        assertCommandLine( \"ccm start -nogui -m -q -n user -pw pass -r build_mgr\", null, cl );\n    }\n\n    public void testStop()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.stop( \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm stop\", null, cl );\n    }\n\n    public void testDelimiter()\n        throws Exception\n    {\n        Commandline cl = SynergyCCM.delimiter( \"CCM_ADDR\" );\n        assertTrue( \"CCM_ADDR is not set.\", assertContains( cl.getEnvironmentVariables(), \"CCM_ADDR=CCM_ADDR\" ) );\n        assertCommandLine( \"ccm delimiter\", null, cl );\n    }\n\n    public boolean assertContains( String[] array, String value )\n    {\n        for ( int i = 0; i < array.length; i++ )\n        {\n            if ( array[i].equals( value ) )\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","lineNo":129}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResultWithRevision;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.apache.maven.scm.provider.svn.svnexe.command.changelog.SvnChangeLogCommand;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnUpdateCommand\n    extends AbstractUpdateCommand\n    implements SvnCommand\n{\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (SvnScmProviderRepository) repo, fileSet.getBasedir(), version );\n\n        SvnUpdateConsumer consumer = new SvnUpdateConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n        getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new UpdateScmResult( cl.toString(), \"The svn command failed.\", stderr.getOutput(), false );\n        }\n\n        return new UpdateScmResultWithRevision( cl.toString(), consumer.getUpdatedFiles(),\n                                                String.valueOf( consumer.getRevision() ) );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 ScmVersion version )\n    {\n        if ( version != null && StringUtils.isEmpty( version.getName() ) )\n        {\n            version = null;\n        }\n\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        if ( version == null || SvnTagBranchUtils.isRevisionSpecifier( version ) )\n        {\n            cl.createArgument().setValue( \"update\" );\n\n            if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n            {\n                cl.createArgument().setValue( \"-r\" );\n                cl.createArgument().setValue( version.getName() );\n            }\n\n            cl.createArgument().setValue( workingDirectory.getAbsolutePath() );\n        }\n        else\n        {\n            if ( version instanceof ScmBranch )\n            {\n                // The tag specified does not appear to be numeric, so assume it refers\n                // to a branch/tag url and perform a switch operation rather than update\n                cl.createArgument().setValue( \"switch\" );\n                if ( version instanceof ScmTag )\n                {\n                    cl.createArgument().setValue( SvnTagBranchUtils.resolveTagUrl( repository, (ScmTag) version ) );\n                }\n                else\n                {\n                    cl.createArgument().setValue(\n                        SvnTagBranchUtils.resolveBranchUrl( repository, (ScmBranch) version ) );\n                }\n                cl.createArgument().setValue( workingDirectory.getAbsolutePath() );\n            }\n        }\n\n        return cl;\n    }\n\n    /**\n     * @see org.apache.maven.scm.command.update.AbstractUpdateCommand#getChangeLogCommand()\n     */\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        SvnChangeLogCommand command = new SvnChangeLogCommand();\n\n        command.setLogger( getLogger() );\n\n        return command;\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.update;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResultWithRevision;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.apache.maven.scm.provider.svn.svnexe.command.changelog.SvnChangeLogCommand;\nimport org.apache.maven.scm.provider.svn.util.SvnUtil;\nimport org.apache.maven.scm.providers.svn.settings.Settings;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnUpdateCommand\n    extends AbstractUpdateCommand\n    implements SvnCommand\n{\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, ScmVersion version )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (SvnScmProviderRepository) repo, fileSet.getBasedir(), version );\n\n        SvnUpdateConsumer consumer = new SvnUpdateConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n        getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new UpdateScmResult( cl.toString(), \"The svn command failed.\", stderr.getOutput(), false );\n        }\n\n        return new UpdateScmResultWithRevision( cl.toString(), consumer.getUpdatedFiles(),\n                                                String.valueOf( consumer.getRevision() ) );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 ScmVersion version )\n    {\n        Settings settings = SvnUtil.getSettings();\n\n        String workingDir = workingDirectory.getAbsolutePath();\n\n        if ( settings.isUseCygwinPath() )\n        {\n            workingDir = \"/cygdrive/\" + workingDir;\n            workingDir = StringUtils.replace( workingDir, \":\", \"\" );\n            workingDir = StringUtils.replace( workingDir, \"\\\\\", \"/\" );\n        }\n\n        if ( version != null && StringUtils.isEmpty( version.getName() ) )\n        {\n            version = null;\n        }\n\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        if ( version == null || SvnTagBranchUtils.isRevisionSpecifier( version ) )\n        {\n            cl.createArgument().setValue( \"update\" );\n\n            if ( version != null && StringUtils.isNotEmpty( version.getName() ) )\n            {\n                cl.createArgument().setValue( \"-r\" );\n                cl.createArgument().setValue( version.getName() );\n            }\n\n            cl.createArgument().setValue( workingDir );\n        }\n        else\n        {\n            if ( version instanceof ScmBranch )\n            {\n                // The tag specified does not appear to be numeric, so assume it refers\n                // to a branch/tag url and perform a switch operation rather than update\n                cl.createArgument().setValue( \"switch\" );\n                if ( version instanceof ScmTag )\n                {\n                    cl.createArgument().setValue( SvnTagBranchUtils.resolveTagUrl( repository, (ScmTag) version ) );\n                }\n                else\n                {\n                    cl.createArgument().setValue(\n                        SvnTagBranchUtils.resolveBranchUrl( repository, (ScmBranch) version ) );\n                }\n                cl.createArgument().setValue( workingDir );\n            }\n        }\n\n        return cl;\n    }\n\n    /**\n     * @see org.apache.maven.scm.command.update.AbstractUpdateCommand#getChangeLogCommand()\n     */\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        SvnChangeLogCommand command = new SvnChangeLogCommand();\n\n        command.setLogger( getLogger() );\n\n        return command;\n    }\n\n\n}\n","lineNo":95}
{"Smelly Sample":"package org.apache.maven.scm.provider.vss.commands.add;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.vss.commands.VssCommandLineUtils;\nimport org.apache.maven.scm.provider.vss.repository.VssScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class VssAddCommandTest\n    extends ScmTestCase\n{\n    private ScmManager scmManager;\n\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = getScmManager();\n    }\n\n    public void testBuildCmdLine()\n        throws Exception\n    {\n        ScmRepository repository =\n            scmManager.makeScmRepository( \"scm:vss|username|password@C:/Program File/Visual Source Safe|D:/myProject\" );\n        ScmFileSet fileSet = new ScmFileSet( getTestFile( \"target\" ) );\n        VssAddCommand command = new VssAddCommand();\n        Commandline cl = command.buildCmdLine( (VssScmProviderRepository) repository.getProviderRepository(), fileSet );\n        String ssPath = VssCommandLineUtils.getSsDir().replace( '/', File.separatorChar );\n        assertEquals( ssPath + \"ss Add -Yusername,password -I-\", cl.toString() );\n    }\n\n    public void testBuildSetCurrentProjectCmdLine()\n        throws Exception\n    {\n        ScmRepository repository =\n            scmManager.makeScmRepository( \"scm:vss|username|password@C:/Program File/Visual Source Safe|D:/myProject\" );\n        VssAddCommand command = new VssAddCommand();\n        Commandline cl =\n            command.buildSetCurrentProjectCmdLine( (VssScmProviderRepository) repository.getProviderRepository() );\n        String ssPath = VssCommandLineUtils.getSsDir().replace( '/', File.separatorChar );\n        assertEquals( ssPath + \"ss CP $D:/myProject -Yusername,password -I-\", cl.toString() );\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.vss.commands.add;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.vss.commands.VssCommandLineUtils;\nimport org.apache.maven.scm.provider.vss.repository.VssScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class VssAddCommandTest\n    extends ScmTestCase\n{\n    private ScmManager scmManager;\n\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = getScmManager();\n    }\n\n    public void testBuildCmdLine()\n        throws Exception\n    {\n        ScmRepository repository =\n            scmManager.makeScmRepository( \"scm:vss|username|password@C:/Program File/Visual Source Safe|D:/myProject\" );\n        File dir = getTestFile( \"target\" );\n        ScmFileSet fileSet = new ScmFileSet( dir );\n        VssAddCommand command = new VssAddCommand();\n        Commandline cl = command.buildCmdLine( (VssScmProviderRepository) repository.getProviderRepository(), fileSet );\n        String ssPath = VssCommandLineUtils.getSsDir().replace( '/', File.separatorChar );\n        assertCommandLine( ssPath + \"ss Add -Yusername,password -I-\", dir, cl );\n    }\n\n    public void testBuildSetCurrentProjectCmdLine()\n        throws Exception\n    {\n        ScmRepository repository =\n            scmManager.makeScmRepository( \"scm:vss|username|password@C:/Program File/Visual Source Safe|D:/myProject\" );\n        VssAddCommand command = new VssAddCommand();\n        Commandline cl =\n            command.buildSetCurrentProjectCmdLine( (VssScmProviderRepository) repository.getProviderRepository() );\n        String ssPath = VssCommandLineUtils.getSsDir().replace( '/', File.separatorChar );\n        assertCommandLine( ssPath + \"ss CP $D:/myProject -Yusername,password -I-\", null, cl );\n    }\n\n\n}\n","lineNo":54}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResultWithRevision;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\n\n/**\n * Update the local working copy with the latest source from the configured scm url.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @goal update\n * @aggregator\n * @description Update the project\n */\npublic class UpdateMojo\n    extends AbstractScmMojo\n{\n    /**\n     * The version type (branch/tag/revision) of scmVersion.\n     *\n     * @parameter expression=\"${scmVersionType}\"\n     */\n    private String scmVersionType;\n\n    /**\n     * The version (revision number/branch name/tag name).\n     *\n     * @parameter expression=\"${scmVersion}\"\n     */\n    private String scmVersion;\n\n    /**\n     * The project property where to store the revision name.\n     *\n     * @parameter expression=\"${revisionKey}\" default-value=\"scm.revision\"\n     */\n    private String revisionKey;\n\n    /**\n     * The maven project.\n     *\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    private MavenProject project;\n\n    /**\n     * Run Changelog after update.\n     *\n     * @parameter expression=\"${runChangelog}\" default-value=\"false\"\n     */\n    private boolean runChangelog = false;\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        try\n        {\n            ScmRepository repository = getScmRepository();\n\n            UpdateScmResult result = getScmManager().update( repository, getFileSet(),\n                                                             getScmVersion( scmVersionType, scmVersion ),\n                                                             runChangelog );\n\n            checkResult( result );\n\n            if ( result instanceof UpdateScmResultWithRevision )\n            {\n                getLog().info( \"Storing revision in '\" + revisionKey + \"' project property.\" );\n\n                if ( project.getProperties() != null ) // Remove the test when we'll use plugin-test-harness 1.0-alpha-2\n                {\n                    project.getProperties().put( revisionKey, ( (UpdateScmResultWithRevision) result ).getRevision() );\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run update command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run update command : \", e );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResultWithRevision;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\n\n/**\n * Update the local working copy with the latest source from the configured scm url.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @goal update\n * @aggregator\n * @description Update the project\n */\npublic class UpdateMojo\n    extends AbstractScmMojo\n{\n    /**\n     * The version type (branch/tag/revision) of scmVersion.\n     *\n     * @parameter expression=\"${scmVersionType}\"\n     */\n    private String scmVersionType;\n\n    /**\n     * The version (revision number/branch name/tag name).\n     *\n     * @parameter expression=\"${scmVersion}\"\n     */\n    private String scmVersion;\n\n    /**\n     * The project property where to store the revision name.\n     *\n     * @parameter expression=\"${revisionKey}\" default-value=\"scm.revision\"\n     */\n    private String revisionKey;\n\n    /**\n     * The maven project.\n     *\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    private MavenProject project;\n\n    /**\n     * Run Changelog after update.\n     *\n     * @parameter expression=\"${runChangelog}\" default-value=\"false\"\n     */\n    private boolean runChangelog = false;\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        super.execute();\n\n        try\n        {\n            ScmRepository repository = getScmRepository();\n\n            UpdateScmResult result = getScmManager().update( repository, getFileSet(),\n                                                             getScmVersion( scmVersionType, scmVersion ),\n                                                             runChangelog );\n\n            checkResult( result );\n\n            if ( result instanceof UpdateScmResultWithRevision )\n            {\n                String revision = ( (UpdateScmResultWithRevision) result ).getRevision();\n\n                getLog().info( \"Storing revision in '\" + revisionKey + \"' project property.\" );\n\n                if ( project.getProperties() != null ) // Remove the test when we'll use plugin-test-harness 1.0-alpha-2\n                {\n                    project.getProperties().put( revisionKey, revision );\n                }\n\n                getLog().info( \"Project at revision \" + revision );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run update command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run update command : \", e );\n        }\n    }\n}\n","lineNo":97}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmRevision;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.settings.Server;\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmMojo\n    extends AbstractMojo\n{\n    /**\n     * The SCM connection URL.\n     *\n     * @parameter expression=\"${connectionUrl}\" default-value=\"${project.scm.connection}\"\n     */\n    private String connectionUrl;\n\n    /**\n     * The SCM connection URL for developers.\n     *\n     * @parameter expression=\"${connectionUrl}\" default-value=\"${project.scm.developerConnection}\"\n     */\n    private String developerConnectionUrl;\n\n    /**\n     * The type of connection to use (connection or developerConnection).\n     *\n     * @parameter expression=\"${connectionType}\" default-value=\"connection\"\n     */\n    private String connectionType;\n\n    /**\n     * The working directory.\n     *\n     * @parameter expression=\"${workingDirectory}\"\n     */\n    private File workingDirectory;\n\n    /**\n     * The user name (used by svn and starteam protocol).\n     *\n     * @parameter expression=\"${username}\"\n     */\n    private String username;\n\n    /**\n     * The user password (used by svn and starteam protocol).\n     *\n     * @parameter expression=\"${password}\"\n     */\n    private String password;\n\n    /**\n     * The private key (used by java svn).\n     *\n     * @parameter expression=\"${privateKey}\"\n     */\n    private String privateKey;\n\n    /**\n     * The passphrase (used by java svn).\n     *\n     * @parameter expression=\"${passphrase}\"\n     */\n    private String passphrase;\n\n    /**\n     * The url of tags base directory (used by svn protocol). It is not\n     * necessary to set it if you use the standard svn layout\n     * (branches/tags/trunk).\n     *\n     * @parameter expression=\"${tagBase}\"\n     */\n    private String tagBase;\n\n    /**\n     * Comma separated list of includes file pattern.\n     *\n     * @parameter expression=\"${includes}\"\n     */\n    private String includes;\n\n    /**\n     * Comma separated list of excludes file pattern.\n     *\n     * @parameter expression=\"${excludes}\"\n     */\n    private String excludes;\n\n    /**\n     * @parameter expression=\"${component.org.apache.maven.scm.manager.ScmManager}\"\n     * @required\n     * @readonly\n     */\n    private ScmManager manager;\n\n    /**\n     * The base directory.\n     *\n     * @parameter expression=\"${basedir}\"\n     * @required\n     */\n    private File basedir;\n\n    /**\n     * @parameter expression=\"${settings}\"\n     * @required\n     * @readonly\n     */\n    private Settings settings;\n\n    protected void setConnectionType( String connectionType )\n    {\n        this.connectionType = connectionType;\n    }\n\n    public String getConnectionUrl()\n    {\n        if ( StringUtils.isNotEmpty( connectionUrl ) && \"connection\".equals( connectionType.toLowerCase() ) )\n        {\n            return connectionUrl;\n        }\n        else if ( StringUtils.isNotEmpty( developerConnectionUrl ) )\n        {\n            return developerConnectionUrl;\n        }\n\n        throw new NullPointerException( \"You need to define a connectionUrl parameter\" );\n    }\n\n    public void setConnectionUrl( String connectionUrl )\n    {\n        this.connectionUrl = connectionUrl;\n    }\n\n    public File getWorkingDirectory()\n    {\n        if ( workingDirectory == null )\n        {\n            return basedir;\n        }\n\n        return workingDirectory;\n    }\n\n    public void setWorkingDirectory( File workingDirectory )\n    {\n        this.workingDirectory = workingDirectory;\n    }\n\n    public ScmManager getScmManager()\n    {\n        return manager;\n    }\n\n    public ScmFileSet getFileSet()\n        throws IOException\n    {\n        if ( includes != null || excludes != null )\n        {\n            return new ScmFileSet( getWorkingDirectory(), includes, excludes );\n        }\n        else\n        {\n            return new ScmFileSet( getWorkingDirectory() );\n        }\n    }\n\n    public ScmRepository getScmRepository()\n        throws ScmException\n    {\n        ScmRepository repository;\n\n        try\n        {\n            repository = getScmManager().makeScmRepository( getConnectionUrl() );\n\n            ScmProviderRepository providerRepo = repository.getProviderRepository();\n\n            if ( !StringUtils.isEmpty( username ) )\n            {\n                providerRepo.setUser( username );\n            }\n\n            if ( !StringUtils.isEmpty( password ) )\n            {\n                providerRepo.setPassword( password );\n            }\n\n            if ( repository.getProviderRepository() instanceof ScmProviderRepositoryWithHost )\n            {\n                ScmProviderRepositoryWithHost repo = (ScmProviderRepositoryWithHost) repository.getProviderRepository();\n\n                loadInfosFromSettings( repo );\n\n                if ( !StringUtils.isEmpty( username ) )\n                {\n                    repo.setUser( username );\n                }\n\n                if ( !StringUtils.isEmpty( password ) )\n                {\n                    repo.setPassword( password );\n                }\n\n                if ( !StringUtils.isEmpty( privateKey ) )\n                {\n                    repo.setPrivateKey( privateKey );\n                }\n\n                if ( !StringUtils.isEmpty( passphrase ) )\n                {\n                    repo.setPassphrase( passphrase );\n                }\n            }\n\n            if ( !StringUtils.isEmpty( tagBase ) && repository.getProvider().equals( \"svn\" ) )\n            {\n                SvnScmProviderRepository svnRepo = (SvnScmProviderRepository) repository.getProviderRepository();\n\n                svnRepo.setTagBase( tagBase );\n            }\n        }\n        catch ( ScmRepositoryException e )\n        {\n            if ( !e.getValidationMessages().isEmpty() )\n            {\n                for ( Iterator i = e.getValidationMessages().iterator(); i.hasNext(); )\n                {\n                    String message = (String) i.next();\n                    getLog().error( message );\n                }\n            }\n\n            throw new ScmException( \"Can't load the scm provider.\", e );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"Can't load the scm provider.\", e );\n        }\n\n        return repository;\n    }\n\n    /**\n     * Load username password from settings if user has not set them in JVM properties\n     *\n     * @param repo\n     */\n    private void loadInfosFromSettings( ScmProviderRepositoryWithHost repo )\n    {\n        if ( username == null || password == null )\n        {\n            String host = repo.getHost();\n\n            int port = repo.getPort();\n\n            if ( port > 0 )\n            {\n                host += \":\" + port;\n            }\n\n            Server server = this.settings.getServer( host );\n\n            if ( server != null )\n            {\n                if ( username == null )\n                {\n                    username = this.settings.getServer( host ).getUsername();\n                }\n\n                if ( password == null )\n                {\n                    password = this.settings.getServer( host ).getPassword();\n                }\n\n                if ( privateKey == null )\n                {\n                    privateKey = this.settings.getServer( host ).getPrivateKey();\n                }\n\n                if ( passphrase == null )\n                {\n                    passphrase = this.settings.getServer( host ).getPassphrase();\n                }\n            }\n        }\n    }\n\n    public void checkResult( ScmResult result )\n        throws MojoExecutionException\n    {\n        if ( !result.isSuccess() )\n        {\n            getLog().error( \"Provider message:\" );\n\n            getLog().error( result.getProviderMessage() == null ? \"\" : result.getProviderMessage() );\n\n            getLog().error( \"Command output:\" );\n\n            getLog().error( result.getCommandOutput() == null ? \"\" : result.getCommandOutput() );\n\n            throw new MojoExecutionException(\n                \"Command failed.\" + StringUtils.defaultString( result.getProviderMessage() ) );\n        }\n    }\n\n    public String getIncludes()\n    {\n        return includes;\n    }\n\n    public void setIncludes( String includes )\n    {\n        this.includes = includes;\n    }\n\n    public String getExcludes()\n    {\n        return excludes;\n    }\n\n    public void setExcludes( String excludes )\n    {\n        this.excludes = excludes;\n    }\n\n    public ScmVersion getScmVersion( String versionType, String version )\n        throws MojoExecutionException\n    {\n        if ( StringUtils.isEmpty( versionType ) && StringUtils.isNotEmpty( version ) )\n        {\n            throw new MojoExecutionException( \"You must specify the version type.\" );\n        }\n\n        if ( StringUtils.isEmpty( version ) )\n        {\n            return null;\n        }\n\n        if ( \"branch\".equals( versionType ) )\n        {\n            return new ScmBranch( version );\n        }\n\n        if ( \"tag\".equals( versionType ) )\n        {\n            return new ScmTag( version );\n        }\n\n        if ( \"revision\".equals( versionType ) )\n        {\n            return new ScmRevision( version );\n        }\n\n        throw new MojoExecutionException( \"Unknown '\" + versionType + \"' version type.\" );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.ScmRevision;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.settings.Server;\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmMojo\n    extends AbstractMojo\n{\n    /**\n     * The SCM connection URL.\n     *\n     * @parameter expression=\"${connectionUrl}\" default-value=\"${project.scm.connection}\"\n     */\n    private String connectionUrl;\n\n    /**\n     * The SCM connection URL for developers.\n     *\n     * @parameter expression=\"${connectionUrl}\" default-value=\"${project.scm.developerConnection}\"\n     */\n    private String developerConnectionUrl;\n\n    /**\n     * The type of connection to use (connection or developerConnection).\n     *\n     * @parameter expression=\"${connectionType}\" default-value=\"connection\"\n     */\n    private String connectionType;\n\n    /**\n     * The working directory.\n     *\n     * @parameter expression=\"${workingDirectory}\"\n     */\n    private File workingDirectory;\n\n    /**\n     * The user name (used by svn and starteam protocol).\n     *\n     * @parameter expression=\"${username}\"\n     */\n    private String username;\n\n    /**\n     * The user password (used by svn and starteam protocol).\n     *\n     * @parameter expression=\"${password}\"\n     */\n    private String password;\n\n    /**\n     * The private key (used by java svn).\n     *\n     * @parameter expression=\"${privateKey}\"\n     */\n    private String privateKey;\n\n    /**\n     * The passphrase (used by java svn).\n     *\n     * @parameter expression=\"${passphrase}\"\n     */\n    private String passphrase;\n\n    /**\n     * The url of tags base directory (used by svn protocol). It is not\n     * necessary to set it if you use the standard svn layout\n     * (branches/tags/trunk).\n     *\n     * @parameter expression=\"${tagBase}\"\n     */\n    private String tagBase;\n\n    /**\n     * Comma separated list of includes file pattern.\n     *\n     * @parameter expression=\"${includes}\"\n     */\n    private String includes;\n\n    /**\n     * Comma separated list of excludes file pattern.\n     *\n     * @parameter expression=\"${excludes}\"\n     */\n    private String excludes;\n\n    /**\n     * @parameter expression=\"${component.org.apache.maven.scm.manager.ScmManager}\"\n     * @required\n     * @readonly\n     */\n    private ScmManager manager;\n\n    /**\n     * The base directory.\n     *\n     * @parameter expression=\"${basedir}\"\n     * @required\n     */\n    private File basedir;\n\n    /**\n     * @parameter expression=\"${settings}\"\n     * @required\n     * @readonly\n     */\n    private Settings settings;\n\n    protected void setConnectionType( String connectionType )\n    {\n        this.connectionType = connectionType;\n    }\n\n    public String getConnectionUrl()\n    {\n        boolean requireDeveloperConnection = !\"connection\".equals( connectionType.toLowerCase() );\n        if ( StringUtils.isNotEmpty( connectionUrl ) && !requireDeveloperConnection )\n        {\n            return connectionUrl;\n        }\n        else if ( StringUtils.isNotEmpty( developerConnectionUrl ) )\n        {\n            return developerConnectionUrl;\n        }\n        if ( requireDeveloperConnection )\n        {\n            throw new NullPointerException( \"You need to define a developerConnectionUrl parameter\" );\n        }\n        else\n        {\n            throw new NullPointerException( \"You need to define a connectionUrl parameter\" );\n        }\n    }\n\n    public void setConnectionUrl( String connectionUrl )\n    {\n        this.connectionUrl = connectionUrl;\n    }\n\n    public File getWorkingDirectory()\n    {\n        if ( workingDirectory == null )\n        {\n            return basedir;\n        }\n\n        return workingDirectory;\n    }\n\n    public void setWorkingDirectory( File workingDirectory )\n    {\n        this.workingDirectory = workingDirectory;\n    }\n\n    public ScmManager getScmManager()\n    {\n        return manager;\n    }\n\n    public ScmFileSet getFileSet()\n        throws IOException\n    {\n        if ( includes != null || excludes != null )\n        {\n            return new ScmFileSet( getWorkingDirectory(), includes, excludes );\n        }\n        else\n        {\n            return new ScmFileSet( getWorkingDirectory() );\n        }\n    }\n\n    public ScmRepository getScmRepository()\n        throws ScmException\n    {\n        ScmRepository repository;\n\n        try\n        {\n            repository = getScmManager().makeScmRepository( getConnectionUrl() );\n\n            ScmProviderRepository providerRepo = repository.getProviderRepository();\n\n            if ( !StringUtils.isEmpty( username ) )\n            {\n                providerRepo.setUser( username );\n            }\n\n            if ( !StringUtils.isEmpty( password ) )\n            {\n                providerRepo.setPassword( password );\n            }\n\n            if ( repository.getProviderRepository() instanceof ScmProviderRepositoryWithHost )\n            {\n                ScmProviderRepositoryWithHost repo = (ScmProviderRepositoryWithHost) repository.getProviderRepository();\n\n                loadInfosFromSettings( repo );\n\n                if ( !StringUtils.isEmpty( username ) )\n                {\n                    repo.setUser( username );\n                }\n\n                if ( !StringUtils.isEmpty( password ) )\n                {\n                    repo.setPassword( password );\n                }\n\n                if ( !StringUtils.isEmpty( privateKey ) )\n                {\n                    repo.setPrivateKey( privateKey );\n                }\n\n                if ( !StringUtils.isEmpty( passphrase ) )\n                {\n                    repo.setPassphrase( passphrase );\n                }\n            }\n\n            if ( !StringUtils.isEmpty( tagBase ) && repository.getProvider().equals( \"svn\" ) )\n            {\n                SvnScmProviderRepository svnRepo = (SvnScmProviderRepository) repository.getProviderRepository();\n\n                svnRepo.setTagBase( tagBase );\n            }\n        }\n        catch ( ScmRepositoryException e )\n        {\n            if ( !e.getValidationMessages().isEmpty() )\n            {\n                for ( Iterator i = e.getValidationMessages().iterator(); i.hasNext(); )\n                {\n                    String message = (String) i.next();\n                    getLog().error( message );\n                }\n            }\n\n            throw new ScmException( \"Can't load the scm provider.\", e );\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"Can't load the scm provider.\", e );\n        }\n\n        return repository;\n    }\n\n    /**\n     * Load username password from settings if user has not set them in JVM properties\n     *\n     * @param repo\n     */\n    private void loadInfosFromSettings( ScmProviderRepositoryWithHost repo )\n    {\n        if ( username == null || password == null )\n        {\n            String host = repo.getHost();\n\n            int port = repo.getPort();\n\n            if ( port > 0 )\n            {\n                host += \":\" + port;\n            }\n\n            Server server = this.settings.getServer( host );\n\n            if ( server != null )\n            {\n                if ( username == null )\n                {\n                    username = this.settings.getServer( host ).getUsername();\n                }\n\n                if ( password == null )\n                {\n                    password = this.settings.getServer( host ).getPassword();\n                }\n\n                if ( privateKey == null )\n                {\n                    privateKey = this.settings.getServer( host ).getPrivateKey();\n                }\n\n                if ( passphrase == null )\n                {\n                    passphrase = this.settings.getServer( host ).getPassphrase();\n                }\n            }\n        }\n    }\n\n    public void checkResult( ScmResult result )\n        throws MojoExecutionException\n    {\n        if ( !result.isSuccess() )\n        {\n            getLog().error( \"Provider message:\" );\n\n            getLog().error( result.getProviderMessage() == null ? \"\" : result.getProviderMessage() );\n\n            getLog().error( \"Command output:\" );\n\n            getLog().error( result.getCommandOutput() == null ? \"\" : result.getCommandOutput() );\n\n            throw new MojoExecutionException(\n                \"Command failed.\" + StringUtils.defaultString( result.getProviderMessage() ) );\n        }\n    }\n\n    public String getIncludes()\n    {\n        return includes;\n    }\n\n    public void setIncludes( String includes )\n    {\n        this.includes = includes;\n    }\n\n    public String getExcludes()\n    {\n        return excludes;\n    }\n\n    public void setExcludes( String excludes )\n    {\n        this.excludes = excludes;\n    }\n\n    public ScmVersion getScmVersion( String versionType, String version )\n        throws MojoExecutionException\n    {\n        if ( StringUtils.isEmpty( versionType ) && StringUtils.isNotEmpty( version ) )\n        {\n            throw new MojoExecutionException( \"You must specify the version type.\" );\n        }\n\n        if ( StringUtils.isEmpty( version ) )\n        {\n            return null;\n        }\n\n        if ( \"branch\".equals( versionType ) )\n        {\n            return new ScmBranch( version );\n        }\n\n        if ( \"tag\".equals( versionType ) )\n        {\n            return new ScmTag( version );\n        }\n\n        if ( \"revision\".equals( versionType ) )\n        {\n            return new ScmRevision( version );\n        }\n\n        throw new MojoExecutionException( \"Unknown '\" + versionType + \"' version type.\" );\n    }\n}\n","lineNo":160}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceWhereCommand;\nimport org.apache.maven.scm.provider.perforce.command.add.PerforceAddCommand;\nimport org.apache.maven.scm.provider.perforce.command.changelog.PerforceChangeLogCommand;\nimport org.apache.maven.scm.provider.perforce.command.checkin.PerforceCheckInCommand;\nimport org.apache.maven.scm.provider.perforce.command.checkout.PerforceCheckOutCommand;\nimport org.apache.maven.scm.provider.perforce.command.diff.PerforceDiffCommand;\nimport org.apache.maven.scm.provider.perforce.command.edit.PerforceEditCommand;\nimport org.apache.maven.scm.provider.perforce.command.login.PerforceLoginCommand;\nimport org.apache.maven.scm.provider.perforce.command.remove.PerforceRemoveCommand;\nimport org.apache.maven.scm.provider.perforce.command.status.PerforceStatusCommand;\nimport org.apache.maven.scm.provider.perforce.command.tag.PerforceTagCommand;\nimport org.apache.maven.scm.provider.perforce.command.unedit.PerforceUnEditCommand;\nimport org.apache.maven.scm.provider.perforce.command.update.PerforceUpdateCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l <\/a>\n * @author mperham\n * @version $Id$\n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"perforce\"\n */\npublic class PerforceScmProvider\n    extends AbstractScmProvider\n{\n    // ----------------------------------------------------------------------\n    // ScmProvider Implementation\n    // ----------------------------------------------------------------------\n\n    public boolean requiresEditMode()\n    {\n        return true;\n    }\n\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n        String path;\n        int port = 0;\n        String host = null;\n\n        int i1 = scmSpecificUrl.indexOf( delimiter );\n        int i2 = scmSpecificUrl.indexOf( delimiter, i1 + 1 );\n\n        if ( i1 > 0 )\n        {\n            int lastDelimiter = scmSpecificUrl.lastIndexOf( delimiter );\n            path = scmSpecificUrl.substring( lastDelimiter + 1 );\n            host = scmSpecificUrl.substring( 0, i1 );\n\n            // If there is tree parts in the scm url, the second is the port\n            if ( i2 >= 0 )\n            {\n                try\n                {\n                    String tmp = scmSpecificUrl.substring( i1 + 1, lastDelimiter );\n                    port = Integer.parseInt( tmp );\n                }\n                catch ( NumberFormatException ex )\n                {\n                    throw new ScmRepositoryException( \"The port has to be a number.\" );\n                }\n            }\n        }\n        else\n        {\n            path = scmSpecificUrl;\n        }\n\n        String user = null;\n        String password = null;\n        if ( host != null && host.indexOf( \"@\" ) > 1 )\n        {\n            user = host.substring( 0, host.indexOf( \"@\" ) );\n            host = host.substring( host.indexOf( \"@\" ) + 1 );\n        }\n\n        if ( path.indexOf( \"@\" ) > 1 )\n        {\n            if ( host != null )\n            {\n                getLogger().warn( \"Username as part of path is deprecated, the new format is \" +\n                    \"scm:perforce:[username@]host:port:path_to_repository\" );\n            }\n\n            user = path.substring( 0, path.indexOf( \"@\" ) );\n            path = path.substring( path.indexOf( \"@\" ) + 1 );\n        }\n\n        return new PerforceScmProviderRepository( host, port, path, user, password );\n    }\n\n    public String getScmType()\n    {\n        return \"perforce\";\n    }\n\n    /**\n     * @see org.apache.maven.scm.provider.AbstractScmProvider#changelog(org.apache.maven.scm.provider.ScmProviderRepository,org.apache.maven.scm.ScmFileSet,org.apache.maven.scm.CommandParameters)\n     */\n    protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                            CommandParameters parameters )\n        throws ScmException\n    {\n        PerforceChangeLogCommand command = new PerforceChangeLogCommand();\n        command.setLogger( getLogger() );\n        return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    protected AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceAddCommand command = new PerforceAddCommand();\n        command.setLogger( getLogger() );\n        return (AddScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceRemoveCommand command = new PerforceRemoveCommand();\n        command.setLogger( getLogger() );\n        return (RemoveScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceCheckInCommand command = new PerforceCheckInCommand();\n        command.setLogger( getLogger() );\n        return (CheckInScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                          CommandParameters params )\n        throws ScmException\n    {\n        PerforceCheckOutCommand command = new PerforceCheckOutCommand();\n        command.setLogger( getLogger() );\n        return (CheckOutScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected DiffScmResult diff( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceDiffCommand command = new PerforceDiffCommand();\n        command.setLogger( getLogger() );\n        return (DiffScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceEditCommand command = new PerforceEditCommand();\n        command.setLogger( getLogger() );\n        return (EditScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceLoginCommand command = new PerforceLoginCommand();\n        command.setLogger( getLogger() );\n        return (LoginScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceStatusCommand command = new PerforceStatusCommand();\n        command.setLogger( getLogger() );\n        return (StatusScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceTagCommand command = new PerforceTagCommand();\n        command.setLogger( getLogger() );\n        return (TagScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected UnEditScmResult unedit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceUnEditCommand command = new PerforceUnEditCommand();\n        command.setLogger( getLogger() );\n        return (UnEditScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceUpdateCommand command = new PerforceUpdateCommand();\n        command.setLogger( getLogger() );\n        return (UpdateScmResult) command.execute( repository, fileSet, params );\n    }\n\n    public static Commandline createP4Command( PerforceScmProviderRepository repo, File workingDir )\n    {\n        Commandline command = new Commandline();\n        command.setExecutable( \"p4\" );\n        if ( workingDir != null )\n        {\n            command.setWorkingDirectory( workingDir.getAbsolutePath() );\n        }\n\n        // SCM-209\n//        command.createArgument().setValue(\"-d\");\n//        command.createArgument().setValue(workingDir.getAbsolutePath());        \n\n        if ( repo.getHost() != null )\n        {\n            command.createArgument().setValue( \"-p\" );\n            String value = repo.getHost();\n            if ( repo.getPort() != 0 )\n            {\n                value += \":\" + Integer.toString( repo.getPort() );\n            }\n            command.createArgument().setValue( value );\n        }\n\n        if ( StringUtils.isNotEmpty( repo.getUser() ) )\n        {\n            command.createArgument().setValue( \"-u\" );\n            command.createArgument().setValue( repo.getUser() );\n        }\n\n        if ( StringUtils.isNotEmpty( repo.getPassword() ) )\n        {\n            command.createArgument().setValue( \"-P\" );\n            command.createArgument().setValue( repo.getPassword() );\n        }\n        return command;\n    }\n\n    public static String clean( String string )\n    {\n        if ( string.indexOf( \" -P \" ) == -1 )\n        {\n            return string;\n        }\n        int idx = string.indexOf( \" -P \" ) + 4;\n        int end = string.indexOf( ' ', idx );\n        return string.substring( 0, idx ) + StringUtils.repeat( \"*\", end - idx ) + string.substring( end );\n    }\n\n    /**\n     * Given a path like \"//depot/foo/bar\", returns the\n     * proper path to include everything beneath it.\n     * <p/>\n     * //depot/foo/bar -> //depot/foo/bar/...\n     * //depot/foo/bar/ -> //depot/foo/bar/...\n     * //depot/foo/bar/... -> //depot/foo/bar/...\n     */\n    public static String getCanonicalRepoPath( String repoPath )\n    {\n        if ( repoPath.endsWith( \"/...\" ) )\n        {\n            return repoPath;\n        }\n        else if ( repoPath.endsWith( \"/\" ) )\n        {\n            return repoPath + \"...\";\n        }\n        else\n        {\n            return repoPath + \"/...\";\n        }\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /* \n     * Clientspec name can be overridden with the system property below.  I don't\n     * know of any way for this code to get access to maven's settings.xml so this\n     * is the best I can do.\n     * \n     * Sample clientspec:\n\n     Client: mperham-mikeperham-dt-maven\n     Root: d:\\temp\\target\n     Owner: mperham\n     View:\n     //depot/sandbox/mperham/tsa/tsa-domain/... //mperham-mikeperham-dt-maven/...\n     Description:\n     Created by maven-scm-provider-perforce\n\n     */\n    public static String createClientspec( PerforceScmProviderRepository repo, File workDir, String repoPath )\n    {\n        String clientspecName = getClientspecName( repo, workDir );\n        String userName = getUsername( repo );\n\n        String rootDir;\n        try\n        {\n            // SCM-184\n            rootDir = workDir.getCanonicalPath();\n        }\n        catch ( IOException ex )\n        {\n            //getLogger().error(\"Error getting canonical path for working directory: \" + workDir, ex);\n            rootDir = workDir.getAbsolutePath();\n        }\n\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Client: \" ).append( clientspecName ).append( NEWLINE );\n        buf.append( \"Root: \" ).append( rootDir ).append( NEWLINE );\n        buf.append( \"Owner: \" ).append( userName ).append( NEWLINE );\n        buf.append( \"View:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( PerforceScmProvider.getCanonicalRepoPath( repoPath ) );\n        buf.append( \" //\" ).append( clientspecName ).append( \"/...\" ).append( NEWLINE );\n        buf.append( \"Description:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( \"Created by maven-scm-provider-perforce\" ).append( NEWLINE );\n        return buf.toString();\n    }\n\n    public static final String DEFAULT_CLIENTSPEC_PROPERTY = \"maven.scm.perforce.clientspec.name\";\n\n    public static String getClientspecName( PerforceScmProviderRepository repo, File workDir )\n    {\n        return System.getProperty( DEFAULT_CLIENTSPEC_PROPERTY, generateDefaultClientspecName( repo, workDir ) );\n    }\n\n    private static String generateDefaultClientspecName( PerforceScmProviderRepository repo, File workDir )\n    {\n        String username = getUsername( repo );\n        String hostname;\n        String path;\n        try\n        {\n            hostname = InetAddress.getLocalHost().getHostName();\n            path = workDir.getCanonicalPath();\n        }\n        catch ( UnknownHostException e )\n        {\n            // Should never happen\n            throw new RuntimeException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        return username + \"-\" + hostname + \"-MavenSCM-\" + path;\n    }\n\n    private static String getUsername( PerforceScmProviderRepository repo )\n    {\n        String username = PerforceInfoCommand.getInfo( null, repo ).getEntry( \"User name\" );\n        if ( username == null )\n        {\n            // os user != perforce user\n            username = repo.getUser();\n            if ( username == null )\n            {\n                username = System.getProperty( \"user.name\", \"nouser\" );\n            }\n        }\n        return username;\n    }\n\n    /**\n     * This is a \"safe\" method which handles cases where repo.getPath() is\n     * not actually a valid Perforce depot location.  This is a frequent error\n     * due to branches and directory naming where dir name != artifactId.\n     *\n     * @param log     the logging object to use\n     * @param repo    the Perforce repo\n     * @param basedir the base directory we are operating in.  If pom.xml exists in this directory,\n     *                this method will verify <pre>repo.getPath()/pom.xml<\/pre> == <pre>p4 where basedir/pom.xml<\/pre>\n     * @return repo.getPath if it is determined to be accurate.  The p4 where location otherwise.\n     */\n    public static String getRepoPath( ScmLogger log, PerforceScmProviderRepository repo, File basedir )\n    {\n        PerforceWhereCommand where = new PerforceWhereCommand( log, repo );\n\n        // Handle an edge case where we release:prepare'd a module with an invalid SCM location.\n        // In this case, the release.properties will contain the invalid URL for checkout purposes\n        // during release:perform.  In this case, the basedir is not the module root so we detect that\n        // and remove the trailing target/checkout directory.\n        if ( basedir.toString().replace( '\\\\', '/' ).endsWith( \"/target/checkout\" ) )\n        {\n            String dir = basedir.toString();\n            basedir = new File( dir.substring( 0, dir.length() - \"/target/checkout\".length() ) );\n            log.debug( \"Fixing checkout URL: \" + basedir );\n        }\n        File pom = new File( basedir, \"pom.xml\" );\n        String loc = repo.getPath();\n        log.debug( \"SCM path in pom: \" + loc );\n        if ( pom.exists() )\n        {\n            loc = where.getDepotLocation( pom );\n            if ( loc.endsWith( \"/pom.xml\" ) )\n            {\n                loc = loc.substring( 0, loc.length() - \"/pom.xml\".length() );\n                log.debug( \"Actual POM location: \" + loc );\n                if ( !repo.getPath().equals( loc ) )\n                {\n                    log.info( \"The SCM location in your pom.xml (\" + repo.getPath() +\n                        \") is not equal to the depot location (\" + loc +\n                        \").  This happens frequently with branches.  \" + \"Ignoring the SCM location.\" );\n                }\n            }\n        }\n        return loc;\n    }\n\n\n    private static Boolean live = null;\n\n    public static boolean isLive()\n    {\n        if ( live == null )\n        {\n            if ( !Boolean.getBoolean( \"maven.scm.testing\" ) )\n            {\n                // We are not executing in the tests so we are live.\n                live = Boolean.TRUE;\n            }\n            else\n            {\n                // During unit tests, we need to check the local system\n                // to see if the user has Perforce installed.  If not, we mark\n                // the provider as \"not live\" (or dead, I suppose!) and skip\n                // anything that requires an active server connection.\n                try\n                {\n                    Commandline command = new Commandline();\n                    command.setExecutable( \"p4\" );\n                    Process proc = command.execute();\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        //System.out.println(line);\n                    }\n                    int rc = proc.exitValue();\n                    live = ( rc == 0 ? Boolean.TRUE : Boolean.FALSE );\n                }\n                catch ( Exception e )\n                {\n                    e.printStackTrace();\n                    live = Boolean.FALSE;\n                }\n            }\n        }\n\n        return live.booleanValue();\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.command.login.LoginScmResult;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.command.PerforceInfoCommand;\nimport org.apache.maven.scm.provider.perforce.command.PerforceWhereCommand;\nimport org.apache.maven.scm.provider.perforce.command.add.PerforceAddCommand;\nimport org.apache.maven.scm.provider.perforce.command.changelog.PerforceChangeLogCommand;\nimport org.apache.maven.scm.provider.perforce.command.checkin.PerforceCheckInCommand;\nimport org.apache.maven.scm.provider.perforce.command.checkout.PerforceCheckOutCommand;\nimport org.apache.maven.scm.provider.perforce.command.diff.PerforceDiffCommand;\nimport org.apache.maven.scm.provider.perforce.command.edit.PerforceEditCommand;\nimport org.apache.maven.scm.provider.perforce.command.login.PerforceLoginCommand;\nimport org.apache.maven.scm.provider.perforce.command.remove.PerforceRemoveCommand;\nimport org.apache.maven.scm.provider.perforce.command.status.PerforceStatusCommand;\nimport org.apache.maven.scm.provider.perforce.command.tag.PerforceTagCommand;\nimport org.apache.maven.scm.provider.perforce.command.unedit.PerforceUnEditCommand;\nimport org.apache.maven.scm.provider.perforce.command.update.PerforceUpdateCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport sun.security.action.GetLongAction;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l <\/a>\n * @author mperham\n * @version $Id$\n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"perforce\"\n */\npublic class PerforceScmProvider\n    extends AbstractScmProvider\n{\n    // ----------------------------------------------------------------------\n    // ScmProvider Implementation\n    // ----------------------------------------------------------------------\n\n    public boolean requiresEditMode()\n    {\n        return true;\n    }\n\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n        String path;\n        int port = 0;\n        String host = null;\n\n        int i1 = scmSpecificUrl.indexOf( delimiter );\n        int i2 = scmSpecificUrl.indexOf( delimiter, i1 + 1 );\n\n        if ( i1 > 0 )\n        {\n            int lastDelimiter = scmSpecificUrl.lastIndexOf( delimiter );\n            path = scmSpecificUrl.substring( lastDelimiter + 1 );\n            host = scmSpecificUrl.substring( 0, i1 );\n\n            // If there is tree parts in the scm url, the second is the port\n            if ( i2 >= 0 )\n            {\n                try\n                {\n                    String tmp = scmSpecificUrl.substring( i1 + 1, lastDelimiter );\n                    port = Integer.parseInt( tmp );\n                }\n                catch ( NumberFormatException ex )\n                {\n                    throw new ScmRepositoryException( \"The port has to be a number.\" );\n                }\n            }\n        }\n        else\n        {\n            path = scmSpecificUrl;\n        }\n\n        String user = null;\n        String password = null;\n        if ( host != null && host.indexOf( \"@\" ) > 1 )\n        {\n            user = host.substring( 0, host.indexOf( \"@\" ) );\n            host = host.substring( host.indexOf( \"@\" ) + 1 );\n        }\n\n        if ( path.indexOf( \"@\" ) > 1 )\n        {\n            if ( host != null )\n            {\n                getLogger().warn( \"Username as part of path is deprecated, the new format is \" +\n                    \"scm:perforce:[username@]host:port:path_to_repository\" );\n            }\n\n            user = path.substring( 0, path.indexOf( \"@\" ) );\n            path = path.substring( path.indexOf( \"@\" ) + 1 );\n        }\n\n        return new PerforceScmProviderRepository( host, port, path, user, password );\n    }\n\n    public String getScmType()\n    {\n        return \"perforce\";\n    }\n\n    /**\n     * @see org.apache.maven.scm.provider.AbstractScmProvider#changelog(org.apache.maven.scm.provider.ScmProviderRepository,org.apache.maven.scm.ScmFileSet,org.apache.maven.scm.CommandParameters)\n     */\n    protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                            CommandParameters parameters )\n        throws ScmException\n    {\n        PerforceChangeLogCommand command = new PerforceChangeLogCommand();\n        command.setLogger( getLogger() );\n        return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    protected AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceAddCommand command = new PerforceAddCommand();\n        command.setLogger( getLogger() );\n        return (AddScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceRemoveCommand command = new PerforceRemoveCommand();\n        command.setLogger( getLogger() );\n        return (RemoveScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceCheckInCommand command = new PerforceCheckInCommand();\n        command.setLogger( getLogger() );\n        return (CheckInScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                          CommandParameters params )\n        throws ScmException\n    {\n        PerforceCheckOutCommand command = new PerforceCheckOutCommand();\n        command.setLogger( getLogger() );\n        return (CheckOutScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected DiffScmResult diff( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceDiffCommand command = new PerforceDiffCommand();\n        command.setLogger( getLogger() );\n        return (DiffScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceEditCommand command = new PerforceEditCommand();\n        command.setLogger( getLogger() );\n        return (EditScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceLoginCommand command = new PerforceLoginCommand();\n        command.setLogger( getLogger() );\n        return (LoginScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceStatusCommand command = new PerforceStatusCommand();\n        command.setLogger( getLogger() );\n        return (StatusScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceTagCommand command = new PerforceTagCommand();\n        command.setLogger( getLogger() );\n        return (TagScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected UnEditScmResult unedit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceUnEditCommand command = new PerforceUnEditCommand();\n        command.setLogger( getLogger() );\n        return (UnEditScmResult) command.execute( repository, fileSet, params );\n    }\n\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )\n        throws ScmException\n    {\n        PerforceUpdateCommand command = new PerforceUpdateCommand();\n        command.setLogger( getLogger() );\n        return (UpdateScmResult) command.execute( repository, fileSet, params );\n    }\n\n    public static Commandline createP4Command( PerforceScmProviderRepository repo, File workingDir )\n    {\n        Commandline command = new Commandline();\n        command.setExecutable( \"p4\" );\n        if ( workingDir != null )\n        {\n            command.setWorkingDirectory( workingDir.getAbsolutePath() );\n        }\n\n        // SCM-209\n//        command.createArgument().setValue(\"-d\");\n//        command.createArgument().setValue(workingDir.getAbsolutePath());        \n\n        if ( repo.getHost() != null )\n        {\n            command.createArgument().setValue( \"-p\" );\n            String value = repo.getHost();\n            if ( repo.getPort() != 0 )\n            {\n                value += \":\" + Integer.toString( repo.getPort() );\n            }\n            command.createArgument().setValue( value );\n        }\n\n        if ( StringUtils.isNotEmpty( repo.getUser() ) )\n        {\n            command.createArgument().setValue( \"-u\" );\n            command.createArgument().setValue( repo.getUser() );\n        }\n\n        if ( StringUtils.isNotEmpty( repo.getPassword() ) )\n        {\n            command.createArgument().setValue( \"-P\" );\n            command.createArgument().setValue( repo.getPassword() );\n        }\n        return command;\n    }\n\n    public static String clean( String string )\n    {\n        if ( string.indexOf( \" -P \" ) == -1 )\n        {\n            return string;\n        }\n        int idx = string.indexOf( \" -P \" ) + 4;\n        int end = string.indexOf( ' ', idx );\n        return string.substring( 0, idx ) + StringUtils.repeat( \"*\", end - idx ) + string.substring( end );\n    }\n\n    /**\n     * Given a path like \"//depot/foo/bar\", returns the\n     * proper path to include everything beneath it.\n     * <p/>\n     * //depot/foo/bar -> //depot/foo/bar/...\n     * //depot/foo/bar/ -> //depot/foo/bar/...\n     * //depot/foo/bar/... -> //depot/foo/bar/...\n     */\n    public static String getCanonicalRepoPath( String repoPath )\n    {\n        if ( repoPath.endsWith( \"/...\" ) )\n        {\n            return repoPath;\n        }\n        else if ( repoPath.endsWith( \"/\" ) )\n        {\n            return repoPath + \"...\";\n        }\n        else\n        {\n            return repoPath + \"/...\";\n        }\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /* \n     * Clientspec name can be overridden with the system property below.  I don't\n     * know of any way for this code to get access to maven's settings.xml so this\n     * is the best I can do.\n     * \n     * Sample clientspec:\n\n     Client: mperham-mikeperham-dt-maven\n     Root: d:\\temp\\target\n     Owner: mperham\n     View:\n     //depot/sandbox/mperham/tsa/tsa-domain/... //mperham-mikeperham-dt-maven/...\n     Description:\n     Created by maven-scm-provider-perforce\n\n     */\n    public static String createClientspec(ScmLogger logger, PerforceScmProviderRepository repo, File workDir, String repoPath )\n    {\n        String clientspecName = getClientspecName( logger, repo, workDir );\n        String userName = getUsername( logger, repo );\n\n        String rootDir;\n        try\n        {\n            // SCM-184\n            rootDir = workDir.getCanonicalPath();\n        }\n        catch ( IOException ex )\n        {\n            //getLogger().error(\"Error getting canonical path for working directory: \" + workDir, ex);\n            rootDir = workDir.getAbsolutePath();\n        }\n\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Client: \" ).append( clientspecName ).append( NEWLINE );\n        buf.append( \"Root: \" ).append( rootDir ).append( NEWLINE );\n        buf.append( \"Owner: \" ).append( userName ).append( NEWLINE );\n        buf.append( \"View:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( PerforceScmProvider.getCanonicalRepoPath( repoPath ) );\n        buf.append( \" //\" ).append( clientspecName ).append( \"/...\" ).append( NEWLINE );\n        buf.append( \"Description:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( \"Created by maven-scm-provider-perforce\" ).append( NEWLINE );\n        return buf.toString();\n    }\n\n    public static final String DEFAULT_CLIENTSPEC_PROPERTY = \"maven.scm.perforce.clientspec.name\";\n\n    public static String getClientspecName( ScmLogger logger,PerforceScmProviderRepository repo, File workDir )\n    {\n        String def = generateDefaultClientspecName( logger, repo, workDir );\n        // until someone put clearProperty in DefaultContinuumScm.getScmRepository( Project , boolean  )\n        String l = System.getProperty( DEFAULT_CLIENTSPEC_PROPERTY, def );\n        if ( l == null || \"\".equals( l.trim() ) ) \n        {\n            return def;\n        }\n        return l;\n    }\n\n    private static String generateDefaultClientspecName(ScmLogger logger, PerforceScmProviderRepository repo, File workDir )\n    {\n        String username = getUsername( logger, repo );\n        String hostname;\n        String path;\n        try\n        {\n            hostname = InetAddress.getLocalHost().getHostName();\n            path = workDir.getCanonicalPath();\n        }\n        catch ( UnknownHostException e )\n        {\n            // Should never happen\n            throw new RuntimeException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        return username + \"-\" + hostname + \"-MavenSCM-\" + path;\n    }\n\n    private static String getUsername( ScmLogger logger, PerforceScmProviderRepository repo )\n    {\n        String username = PerforceInfoCommand.getInfo( logger, repo ).getEntry( \"User name\" );\n        if ( username == null )\n        {\n            // os user != perforce user\n            username = repo.getUser();\n            if ( username == null )\n            {\n                username = System.getProperty( \"user.name\", \"nouser\" );\n            }\n        }\n        return username;\n    }\n\n    /**\n     * This is a \"safe\" method which handles cases where repo.getPath() is\n     * not actually a valid Perforce depot location.  This is a frequent error\n     * due to branches and directory naming where dir name != artifactId.\n     *\n     * @param log     the logging object to use\n     * @param repo    the Perforce repo\n     * @param basedir the base directory we are operating in.  If pom.xml exists in this directory,\n     *                this method will verify <pre>repo.getPath()/pom.xml<\/pre> == <pre>p4 where basedir/pom.xml<\/pre>\n     * @return repo.getPath if it is determined to be accurate.  The p4 where location otherwise.\n     */\n    public static String getRepoPath( ScmLogger log, PerforceScmProviderRepository repo, File basedir )\n    {\n        PerforceWhereCommand where = new PerforceWhereCommand( log, repo );\n\n        // Handle an edge case where we release:prepare'd a module with an invalid SCM location.\n        // In this case, the release.properties will contain the invalid URL for checkout purposes\n        // during release:perform.  In this case, the basedir is not the module root so we detect that\n        // and remove the trailing target/checkout directory.\n        if ( basedir.toString().replace( '\\\\', '/' ).endsWith( \"/target/checkout\" ) )\n        {\n            String dir = basedir.toString();\n            basedir = new File( dir.substring( 0, dir.length() - \"/target/checkout\".length() ) );\n            log.debug( \"Fixing checkout URL: \" + basedir );\n        }\n        File pom = new File( basedir, \"pom.xml\" );\n        String loc = repo.getPath();\n        log.debug( \"SCM path in pom: \" + loc );\n        if ( pom.exists() )\n        {\n            loc = where.getDepotLocation( pom );\n            if ( loc == null )\n            {\n            \tloc = repo.getPath();\n            \tlog.debug( \"cannot find depot => using \" + loc );\n            }\n            else if ( loc.endsWith( \"/pom.xml\" ) )\n            {\n                loc = loc.substring( 0, loc.length() - \"/pom.xml\".length() );\n                log.debug( \"Actual POM location: \" + loc );\n                if ( !repo.getPath().equals( loc ) )\n                {\n                    log.info( \"The SCM location in your pom.xml (\" + repo.getPath() +\n                        \") is not equal to the depot location (\" + loc +\n                        \").  This happens frequently with branches.  \" + \"Ignoring the SCM location.\" );\n                }\n            }\n        }\n        return loc;\n    }\n\n\n    private static Boolean live = null;\n\n    public static boolean isLive()\n    {\n        if ( live == null )\n        {\n            if ( !Boolean.getBoolean( \"maven.scm.testing\" ) )\n            {\n                // We are not executing in the tests so we are live.\n                live = Boolean.TRUE;\n            }\n            else\n            {\n                // During unit tests, we need to check the local system\n                // to see if the user has Perforce installed.  If not, we mark\n                // the provider as \"not live\" (or dead, I suppose!) and skip\n                // anything that requires an active server connection.\n                try\n                {\n                    Commandline command = new Commandline();\n                    command.setExecutable( \"p4\" );\n                    Process proc = command.execute();\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        //System.out.println(line);\n                    }\n                    int rc = proc.exitValue();\n                    live = ( rc == 0 ? Boolean.TRUE : Boolean.FALSE );\n                }\n                catch ( Exception e )\n                {\n                    e.printStackTrace();\n                    live = Boolean.FALSE;\n                }\n            }\n        }\n\n        return live.booleanValue();\n    }\n}\n","lineNo":375}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements SvnCommand\n{\n    private final static String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        Commandline cl =\n            createCommandLine( (SvnScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate, endDate );\n\n        SvnChangeLogConsumer consumer = new SvnChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n        getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing svn command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The svn command failed.\", stderr.getOutput(), false );\n        }\n\n        return new ChangeLogScmResult( cl.toString(),\n                                       new ChangeLogSet( consumer.getModifications(), startDate, endDate ) );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArgument().setValue( \"log\" );\n\n        cl.createArgument().setValue( \"-v\" );\n\n        // TODO: May want to add some kind of support for --stop-on-copy and --limit NUM\n\n        if ( startDate != null )\n        {\n            cl.createArgument().setValue( \"-r\" );\n\n            if ( endDate != null )\n            {\n                cl.createArgument().setValue(\n                    \"{\" + dateFormat.format( startDate ) + \"}\" + \":\" + \"{\" + dateFormat.format( endDate ) + \"}\" );\n            }\n            else\n            {\n                cl.createArgument().setValue( \"{\" + dateFormat.format( startDate ) + \"}:HEAD\" );\n            }\n        }\n\n        if ( branch != null && StringUtils.isNotEmpty( branch.getName() ) )\n        {\n            // By specifying a branch and this repository url below, subversion should show \n            // the changelog of that branch, but limit it to paths that also occur in this repository.\n            if ( branch instanceof ScmTag )\n            {\n                cl.createArgument().setValue( SvnTagBranchUtils.resolveTagUrl( repository, (ScmTag) branch ) );\n            }\n            else\n            {\n                cl.createArgument().setValue( SvnTagBranchUtils.resolveBranchUrl( repository, branch ) );\n            }\n        }\n\n        cl.createArgument().setValue( repository.getUrl() );\n\n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmBranch;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTag;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements SvnCommand\n{\n    private final static String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss Z\";\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          ScmVersion startVersion, ScmVersion endVersion,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, null, null, null, datePattern, startVersion, endVersion );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        return executeChangeLogCommand( repo, fileSet, startDate, endDate, branch, datePattern, null, null );\n    }\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, ScmBranch branch,\n                                                          String datePattern, ScmVersion startVersion,\n                                                          ScmVersion endVersion )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (SvnScmProviderRepository) repo, fileSet.getBasedir(), branch, startDate,\n                                            endDate, startVersion, endVersion );\n\n        SvnChangeLogConsumer consumer = new SvnChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n        getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, consumer, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing svn command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The svn command failed.\", stderr.getOutput(), false );\n        }\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 ScmBranch branch, Date startDate, Date endDate,\n                                                 ScmVersion startVersion, ScmVersion endVersion )\n    {\n        SimpleDateFormat dateFormat = new SimpleDateFormat( DATE_FORMAT );\n\n        dateFormat.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArgument().setValue( \"log\" );\n\n        cl.createArgument().setValue( \"-v\" );\n\n        // TODO: May want to add some kind of support for --stop-on-copy and --limit NUM\n\n        if ( startDate != null )\n        {\n            cl.createArgument().setValue( \"-r\" );\n\n            if ( endDate != null )\n            {\n                cl.createArgument().setValue(\n                    \"{\" + dateFormat.format( startDate ) + \"}\" + \":\" + \"{\" + dateFormat.format( endDate ) + \"}\" );\n            }\n            else\n            {\n                cl.createArgument().setValue( \"{\" + dateFormat.format( startDate ) + \"}:HEAD\" );\n            }\n        }\n\n        if ( startVersion != null )\n        {\n            cl.createArgument().setValue( \"-r\" );\n\n            if ( endVersion != null )\n            {\n                if ( startVersion.getName().equals( endVersion.getName() ) )\n                {\n                    cl.createArgument().setValue( startVersion.getName() );\n                }\n                else\n                {\n                    cl.createArgument().setValue( startVersion.getName() + \":\" + endVersion.getName() );\n                }\n            }\n            else\n            {\n                cl.createArgument().setValue( startVersion.getName() + \":HEAD\" );\n            }\n        }\n\n        if ( branch != null && StringUtils.isNotEmpty( branch.getName() ) )\n        {\n            // By specifying a branch and this repository url below, subversion should show \n            // the changelog of that branch, but limit it to paths that also occur in this repository.\n            if ( branch instanceof ScmTag )\n            {\n                cl.createArgument().setValue( SvnTagBranchUtils.resolveTagUrl( repository, (ScmTag) branch ) );\n            }\n            else\n            {\n                cl.createArgument().setValue( SvnTagBranchUtils.resolveBranchUrl( repository, branch ) );\n            }\n        }\n\n        cl.createArgument().setValue( repository.getUrl() );\n\n        return cl;\n    }\n}\n","lineNo":102}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.cvsexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.AbstractCvsChangeLogCommand;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.CvsChangeLogConsumer;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.util.Date;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class CvsExeChangeLogCommand\n    extends AbstractCvsChangeLogCommand\n{\n    protected ChangeLogScmResult executeCvsCommand( Commandline cl, Date startDate, Date endDate, String datePattern )\n        throws ScmException\n    {\n        CvsChangeLogConsumer consumer = new CvsChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing cvs command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The cvs command failed.\", stderr.getOutput(), false );\n        }\n\n        return new ChangeLogScmResult( cl.toString(),\n                                       new ChangeLogSet( consumer.getModifications(), startDate, endDate ) );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.cvsexe.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.AbstractCvsChangeLogCommand;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.CvsChangeLogConsumer;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.util.Date;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class CvsExeChangeLogCommand\n    extends AbstractCvsChangeLogCommand\n{\n    protected ChangeLogScmResult executeCvsCommand( Commandline cl, Date startDate, Date endDate, String datePattern,\n                                                    ScmVersion startVersion, ScmVersion endVersion )\n        throws ScmException\n    {\n        CvsChangeLogConsumer consumer = new CvsChangeLogConsumer( getLogger(), datePattern );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing cvs command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( cl.toString(), \"The cvs command failed.\", stderr.getOutput(), false );\n        }\n\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n}\n","lineNo":65}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.cvsjava.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.AbstractCvsChangeLogCommand;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.CvsChangeLogConsumer;\nimport org.apache.maven.scm.provider.cvslib.cvsjava.util.CvsConnection;\nimport org.apache.maven.scm.provider.cvslib.cvsjava.util.CvsLogListener;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStreamReader;\nimport java.util.Date;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class CvsJavaChangeLogCommand\n    extends AbstractCvsChangeLogCommand\n{\n    protected ChangeLogScmResult executeCvsCommand( Commandline cl, Date startDate, Date endDate, String datePattern )\n        throws ScmException\n    {\n        CvsLogListener logListener = new CvsLogListener();\n\n        CvsChangeLogConsumer consumer = new CvsChangeLogConsumer( getLogger(), datePattern );\n\n        try\n        {\n            boolean isSuccess = CvsConnection.processCommand( cl.getArguments(),\n                                                              cl.getWorkingDirectory().getAbsolutePath(), logListener,\n                                                              getLogger() );\n\n            if ( !isSuccess )\n            {\n                return new ChangeLogScmResult( cl.toString(), \"The cvs command failed.\",\n                                               logListener.getStderr().toString(), false );\n            }\n            BufferedReader stream = new BufferedReader(\n                new InputStreamReader( new ByteArrayInputStream( logListener.getStdout().toString().getBytes() ) ) );\n\n            String line;\n\n            while ( ( line = stream.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            return new ChangeLogScmResult( cl.toString(), \"The cvs command failed.\", logListener.getStdout().toString(),\n                                           false );\n        }\n\n        return new ChangeLogScmResult( cl.toString(),\n                                       new ChangeLogSet( consumer.getModifications(), startDate, endDate ) );\n    }\n\n    protected void addDateRangeParameter( Commandline cl, String dateRange )\n    {\n        cl.createArgument().setValue( dateRange );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.cvsjava.command.changelog;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.AbstractCvsChangeLogCommand;\nimport org.apache.maven.scm.provider.cvslib.command.changelog.CvsChangeLogConsumer;\nimport org.apache.maven.scm.provider.cvslib.cvsjava.util.CvsConnection;\nimport org.apache.maven.scm.provider.cvslib.cvsjava.util.CvsLogListener;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStreamReader;\nimport java.util.Date;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class CvsJavaChangeLogCommand\n    extends AbstractCvsChangeLogCommand\n{\n    protected ChangeLogScmResult executeCvsCommand( Commandline cl, Date startDate, Date endDate,\n                                                    ScmVersion startVersion, ScmVersion endVersion, String datePattern )\n        throws ScmException\n    {\n        CvsLogListener logListener = new CvsLogListener();\n\n        CvsChangeLogConsumer consumer = new CvsChangeLogConsumer( getLogger(), datePattern );\n\n        try\n        {\n            boolean isSuccess = CvsConnection.processCommand( cl.getArguments(),\n                                                              cl.getWorkingDirectory().getAbsolutePath(), logListener,\n                                                              getLogger() );\n\n            if ( !isSuccess )\n            {\n                return new ChangeLogScmResult( cl.toString(), \"The cvs command failed.\",\n                                               logListener.getStderr().toString(), false );\n            }\n            BufferedReader stream = new BufferedReader(\n                new InputStreamReader( new ByteArrayInputStream( logListener.getStdout().toString().getBytes() ) ) );\n\n            String line;\n\n            while ( ( line = stream.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            return new ChangeLogScmResult( cl.toString(), \"The cvs command failed.\", logListener.getStdout().toString(),\n                                           false );\n        }\n\n        ChangeLogSet changeLogSet = new ChangeLogSet( consumer.getModifications(), startDate, endDate );\n        changeLogSet.setStartVersion( startVersion );\n        changeLogSet.setEndVersion( endVersion );\n\n        return new ChangeLogScmResult( cl.toString(), changeLogSet );\n    }\n\n    protected void addDateRangeParameter( Commandline cl, String dateRange )\n    {\n        cl.createArgument().setValue( dateRange );\n    }\n}\n","lineNo":80}
{"Smelly Sample":"package org.apache.maven.scm.provider.clearcase.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\n\nimport java.io.File;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.StringTokenizer;\n\n/**\n * Provider Repository\n * <p/>\n * Url format is [view_name]:[configspec|] or [view_name]|[configspec]\n * <p/>\n * [configspec] can be used in two different ways:\n * <ul>\n * <li>Path to a config spec file that is\n * used when creating the snapshot view, e.g.\n * \"\\\\myserver\\clearcase\\configspecs\\my_module.txt\", or:<\/li>\n * <li>A load rule that is used to automatically create a config spec, e.g. \"load /MY_VOB/my/project/dir\"<\/li>\n * <\/ul>\n * Notice that checking out from a tag is currently only supported when the second option is used.\n *\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id: ClearCaseScmProviderRepository.java 483105 2006-12-06 15:07:54Z\n *          evenisse $\n */\npublic class ClearCaseScmProviderRepository\n    extends ScmProviderRepository\n{\n    private ScmLogger logger;\n\n    private boolean viewNameGivenByUser = false;\n\n    private String viewName;\n\n    /**\n     * The user-specified config spec; may be null.\n     */\n    private File configSpec;\n\n    /**\n     * The directory to be loaded, when auto-generating the config spec.\n     */\n    private String loadDirectory;\n\n    public ClearCaseScmProviderRepository( ScmLogger logger, String url )\n        throws ScmRepositoryException\n    {\n        this.logger = logger;\n        try\n        {\n            parseUrl( url );\n        }\n        catch ( MalformedURLException e )\n        {\n            throw new ScmRepositoryException( \"Illegal URL: \" + url + \"(\" + e.getMessage() + \")\" );\n        }\n        catch ( URISyntaxException e )\n        {\n            throw new ScmRepositoryException( \"Illegal URL: \" + url + \"(\" + e.getMessage() + \")\" );\n        }\n        catch ( UnknownHostException e )\n        {\n            throw new ScmRepositoryException( \"Illegal URL: \" + url + \"(\" + e.getMessage() + \")\" );\n        }\n    }\n\n    private void parseUrl( String url )\n        throws MalformedURLException, URISyntaxException, UnknownHostException\n    {\n        if ( url.indexOf( '|' ) != -1 )\n        {\n            StringTokenizer tokenizer = new StringTokenizer( url, \"|\" );\n            fillInProperties( tokenizer );\n        }\n        else\n        {\n            StringTokenizer tokenizer = new StringTokenizer( url, \":\" );\n            fillInProperties( tokenizer );\n        }\n    }\n\n    private void fillInProperties( StringTokenizer tokenizer )\n        throws UnknownHostException, URISyntaxException, MalformedURLException\n    {\n\n        String configSpecString;\n        if ( tokenizer.countTokens() == 1 )\n        {\n            //No view name was given\n            viewName = getDefaultViewName();\n            configSpecString = tokenizer.nextToken();\n        }\n        else\n        {\n            viewName = tokenizer.nextToken();\n            if ( viewName.length() > 0 )\n            {\n                viewNameGivenByUser = true;\n            }\n            else\n            {\n                viewName = getDefaultViewName();\n            }\n            configSpecString = tokenizer.nextToken();\n        }\n        logger.debug( \"viewName = '\" + viewName + \"' ; configSpec = '\" + configSpecString + \"'\" );\n        if ( !configSpecString.startsWith( \"load \" ) )\n        {\n            configSpec = createConfigSpecFile( configSpecString );\n            loadDirectory = null;\n        }\n        else\n        {\n            configSpec = null;\n            loadDirectory = configSpecString.substring( 5 );\n\n        }\n    }\n\n    private File createConfigSpecFile( String spec )\n        throws URISyntaxException, MalformedURLException\n    {\n        File result;\n        if ( spec.indexOf( ':' ) == -1 )\n        {\n            result = new File( spec );\n        }\n        else\n        {\n            result = new File( new URI( new URL( spec ).toString() ) );\n        }\n        return result;\n    }\n\n    /**\n     * Default: ${hostname}-{user.name}-maven\n     *\n     * @return the default view name\n     */\n    private String getDefaultViewName()\n        throws UnknownHostException\n    {\n        String username = System.getProperty( \"user.name\", \"nouser\" );\n        String hostname = getHostName();\n        return username + \"-\" + hostname + \"-maven\";\n    }\n\n    private String getHostName()\n        throws UnknownHostException\n    {\n        return InetAddress.getLocalHost().getHostName();\n    }\n\n    /**\n     * Returns the name of the view. If it is defined in the scm url, then it is returned as defined there.\n     * If it is the default name, then the uniqueId is added\n     *\n     * @param uniqueId\n     * @return the name of the view\n     */\n    public String getViewName( String uniqueId )\n    {\n        String result;\n        if ( viewNameGivenByUser )\n        {\n            result = viewName;\n        }\n        else\n        {\n            result = viewName + \"-\" + uniqueId;\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the user-supplied config spec or <code>null<\/code> in case it\n     * should be automatically generated\n     *\n     * @return File or <code>null<\/code>\n     * @see #isAutoConfigSpec()\n     */\n    public File getConfigSpec()\n    {\n        return configSpec;\n    }\n\n    /**\n     * Returns true when the config spec has not been supplied by the user, but\n     * instead should automatically be generated by the plugin\n     *\n     * @return true if auto config spec\n     */\n    public boolean isAutoConfigSpec()\n    {\n        return configSpec == null;\n    }\n\n    /**\n     * Returns the VOB directory to be loaded when auto-generating the config\n     * spec.\n     *\n     * @return <code>null<\/code> when isAutoConfigSpec() returns false;\n     *         otherwise the VOB directory\n     */\n    public String getLoadDirectory()\n    {\n        return loadDirectory;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.clearcase.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.providers.clearcase.settings.Settings;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\n\nimport java.io.File;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.StringTokenizer;\n\n/**\n * Provider Repository for ClearCase (standard, LT, UCM)\n * <p />\n * Url format for ClearCase and ClearCaseLT : <br />\n * [view_name]:[configspec] or [view_name]|[configspec] \n * <p />\n * Url format for ClearCaseUCM : <br />\n * [view_name]|[configspec]|[vob_name]|[stream_name] or [view_name]:[configspec]:[vob_name]:[stream_name]  \n * <p />\n * [configspec] can be used in two different ways:\n * <ul>\n * <li>Path to a config spec file that is\n * used when creating the snapshot view, e.g.\n * \"\\\\myserver\\clearcase\\configspecs\\my_module.txt\", or:<\/li>\n * <li>A load rule that is used to automatically create a config spec, e.g. \"load /MY_VOB/my/project/dir\"<\/li>\n * <\/ul>\n * Notice that checking out from a tag is currently only supported when the second option is used.\n *\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id: ClearCaseScmProviderRepository.java 483105 2006-12-06 15:07:54Z\n *          evenisse $\n */\npublic class ClearCaseScmProviderRepository\n    extends ScmProviderRepository\n{\n    private ScmLogger logger;\n\n    private boolean viewNameGivenByUser = false;\n\n    private String viewName;\n\n    /**\n     * The user-specified config spec; may be null.\n     */\n    private File configSpec;\n\n    /**\n     * The directory to be loaded, when auto-generating the config spec.\n     */\n    private String loadDirectory;\n\n    /**\n     * Describe the stream linked to the view. Only used with ClearCaseUCM\n     */\n    private String streamName;\n\n    /**\n     * Describe the vob containing the stream. Only used with ClearCaseUCM\n     */\n    private String vobName;\n    \n    /**\n     * Provider configuration settings\n     */\n    private Settings settings;\n    \n    /**\n     * Define the flag used in the clearcase-settings.xml when using ClearCaseLT\n     */\n    public static final String CLEARCASE_LT = \"LT\";\n\n    /**\n     * Define the flag used in the clearcase-settings.xml when using ClearCaseUCM\n     */\n    public static final String CLEARCASE_UCM = \"UCM\";\n\n    /**\n     * Define the default value from the clearcase-settings.xml when using ClearCase\n     */\n    public static final String CLEARCASE_DEFAULT = null;\n    \n    public ClearCaseScmProviderRepository( ScmLogger logger, String url, Settings settings )\n        throws ScmRepositoryException\n    {\n        this.logger = logger;\n        this.settings = settings;\n        try\n        {\n            parseUrl( url );\n        }\n        catch ( MalformedURLException e )\n        {\n            throw new ScmRepositoryException( \"Illegal URL: \" + url + \"(\" + e.getMessage() + \")\" );\n        }\n        catch ( URISyntaxException e )\n        {\n            throw new ScmRepositoryException( \"Illegal URL: \" + url + \"(\" + e.getMessage() + \")\" );\n        }\n        catch ( UnknownHostException e )\n        {\n            throw new ScmRepositoryException( \"Illegal URL: \" + url + \"(\" + e.getMessage() + \")\" );\n        }\n    }\n\n    private void parseUrl( String url )\n        throws MalformedURLException, URISyntaxException, UnknownHostException\n    {\n        if ( url.indexOf( '|' ) != -1 )\n        {\n            StringTokenizer tokenizer = new StringTokenizer( url, \"|\" );\n            fillInProperties( tokenizer );\n        }\n        else\n        {\n            StringTokenizer tokenizer = new StringTokenizer( url, \":\" );\n            fillInProperties( tokenizer );\n        }\n    }\n\n    private void fillInProperties( StringTokenizer tokenizer )\n        throws UnknownHostException, URISyntaxException, MalformedURLException\n    {\n        String configSpecString = null;\n        \n        if (CLEARCASE_UCM.equals(settings.getClearcaseType()))\n            configSpecString = fillUCMProperties(tokenizer);\n        else\n            configSpecString = fillDefaultProperties(tokenizer);\n        \n        if ( !configSpecString.startsWith( \"load \" ) )\n        {\n            configSpec = createConfigSpecFile( configSpecString );\n            loadDirectory = null;\n        }\n        else\n        {\n            configSpec = null;\n            loadDirectory = configSpecString.substring( 5 );\n\n        }\n    }\n\n    private String fillDefaultProperties(StringTokenizer tokenizer) throws UnknownHostException \n    {\n        int tokenNumber = tokenizer.countTokens();  \n        String configSpecString;\n        if ( tokenNumber == 1 )\n        {\n            //No view name was given\n            viewName = getDefaultViewName();\n            configSpecString = tokenizer.nextToken();\n        }\n        else\n        {\n            configSpecString = checkViewName(tokenizer);\n            checkUnexpectedParameter(tokenizer, tokenNumber, 2);\n        }\n        logger.debug( \"viewName = '\" + viewName + \"' ; configSpec = '\" + configSpecString + \"'\" );\n        return configSpecString;\n    }\n\n    private String fillUCMProperties(StringTokenizer tokenizer) throws UnknownHostException, MalformedURLException \n    {\n        int tokenNumber = tokenizer.countTokens();\n        if ( tokenNumber <= 2 )\n            throw new MalformedURLException(\"ClearCaseUCM need more parameters. Expected url format : [view_name]|[configspec]|[vob_name]|[stream_name]\");\n        \n        String configSpecString;\n        if ( tokenNumber == 3 )\n        {\n            //No view name was given\n            viewName = getDefaultViewName();\n            configSpecString = tokenizer.nextToken();\n            vobName = tokenizer.nextToken();\n            streamName = tokenizer.nextToken();\n        }\n        else\n        {\n            configSpecString = checkViewName(tokenizer);\n            vobName = tokenizer.nextToken();\n            streamName = tokenizer.nextToken();       \n            checkUnexpectedParameter(tokenizer, tokenNumber, 4);\n        }\n        logger.info( \"viewName = '\" + viewName + \"' ; configSpec = '\" + configSpecString + \"' ; vobName = '\" + vobName + \"' ; streamName = '\" + streamName + \"'\" );\n        return configSpecString;\n    }\n\n    private String checkViewName(StringTokenizer tokenizer) throws UnknownHostException \n    {\n        viewName = tokenizer.nextToken();\n        if ( viewName.length() > 0 )\n        {\n            viewNameGivenByUser = true;\n        }\n        else\n        {\n            viewName = getDefaultViewName();\n        }\n        return tokenizer.nextToken();\n    }\n\n    private void checkUnexpectedParameter(StringTokenizer tokenizer, int tokenNumber, int maxTokenNumber) \n    {\n        if (tokenNumber > maxTokenNumber)\n        {\n            String unexpectedToken = tokenizer.nextToken();\n            logger.info(\"The SCM URL contains unused parameter : \" + unexpectedToken);\n        }\n    }\n    \n    private File createConfigSpecFile( String spec )\n        throws URISyntaxException, MalformedURLException\n    {\n        File result;\n        if ( spec.indexOf( ':' ) == -1 )\n        {\n            result = new File( spec );\n        }\n        else\n        {\n            result = new File( new URI( new URL( spec ).toString() ) );\n        }\n        return result;\n    }\n\n    /**\n     * Default: ${hostname}-{user.name}-maven\n     *\n     * @return the default view name\n     */\n    private String getDefaultViewName()\n        throws UnknownHostException\n    {\n        String username = System.getProperty( \"user.name\", \"nouser\" );\n        String hostname = getHostName();\n        return username + \"-\" + hostname + \"-maven\";\n    }\n\n    private String getHostName()\n        throws UnknownHostException\n    {\n        return InetAddress.getLocalHost().getHostName();\n    }\n\n    /**\n     * Returns the name of the view. If it is defined in the scm url, then it is returned as defined there.\n     * If it is the default name, then the uniqueId is added\n     *\n     * @param uniqueId\n     * @return the name of the view\n     */\n    public String getViewName( String uniqueId )\n    {\n        String result;\n        if ( viewNameGivenByUser )\n        {\n            result = viewName;\n        }\n        else\n        {\n            result = viewName + \"-\" + uniqueId;\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the user-supplied config spec or <code>null<\/code> in case it\n     * should be automatically generated\n     *\n     * @return File or <code>null<\/code>\n     * @see #isAutoConfigSpec()\n     */\n    public File getConfigSpec()\n    {\n        return configSpec;\n    }\n\n    /**\n     * Returns true when the config spec has not been supplied by the user, but\n     * instead should automatically be generated by the plugin\n     *\n     * @return true if auto config spec\n     */\n    public boolean isAutoConfigSpec()\n    {\n        return configSpec == null;\n    }\n\n    /**\n     * Returns the VOB directory to be loaded when auto-generating the config\n     * spec.\n     *\n     * @return <code>null<\/code> when isAutoConfigSpec() returns false;\n     *         otherwise the VOB directory\n     */\n    public String getLoadDirectory()\n    {\n        return loadDirectory;\n    }\n\n    public String getStreamName() {\n        return streamName;\n    }\n\n    public String getVobName() {\n        return vobName;\n    }\n}\n","lineNo":170}
{"Smelly Sample":"package org.apache.maven.scm.command.branch;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic abstract class AbstractBranchCommand\n    extends AbstractCommand\n{\n    protected abstract ScmResult executeBranch( ScmProviderRepository repository, File workingDirectory,\n                                                String branchName )\n        throws ScmException;\n\n    public ScmResult executeCommand( ScmProviderRepository repository, File workingDirectory,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        return executeBranch( repository, workingDirectory, parameters.getString( CommandParameter.BRANCH_NAME ) );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.command.branch;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameter;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.AbstractCommand;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic abstract class AbstractBranchCommand\n    extends AbstractCommand\n{\n    protected abstract ScmResult executeBranch( ScmProviderRepository repository, File workingDirectory,\n                                                String branchName, String message )\n        throws ScmException;\n\n    public ScmResult executeCommand( ScmProviderRepository repository, File workingDirectory,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        String branchName = parameters.getString( CommandParameter.BRANCH_NAME );\n\n        String message = parameters.getString( CommandParameter.MESSAGE, \"[maven-scm] copy for branch \" + branchName );\n\n        return executeBranch( repository, workingDirectory, branchName, message );\n    }\n}\n","lineNo":47}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.diff;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.diff.AbstractDiffCommand;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceDiffCommand\n    extends AbstractDiffCommand\n    implements PerforceCommand\n{\n\n    protected DiffScmResult executeDiffCommand( ScmProviderRepository repo, ScmFileSet files, String startRev,\n                                                String endRev )\n        throws ScmException\n    {\n        Commandline cl =\n            createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), startRev, endRev );\n        PerforceDiffConsumer consumer = new PerforceDiffConsumer();\n        boolean success = false;\n        try\n        {\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n            success = proc.waitFor() == 0;\n        }\n        catch ( CommandLineException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( InterruptedException e )\n        {\n            e.printStackTrace();\n        }\n\n        return new DiffScmResult( cl.toString(), success ? \"Diff successful\" : \"Unable to diff\", consumer\n            .getOutput(), success );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 String startRev, String endRev )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"diff2\" );\n        command.createArgument().setValue( \"-u\" );\n        // I'm assuming the \"revs\" are actually labels\n        command.createArgument().setValue( \"...\" + ( startRev != null ? \"@\" + startRev : \"\" ) );\n        command.createArgument().setValue( \"...@\" + ( endRev != null ? endRev : \"head\" ) );\n        return command;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.diff;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmVersion;\nimport org.apache.maven.scm.command.diff.AbstractDiffCommand;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceDiffCommand\n    extends AbstractDiffCommand\n    implements PerforceCommand\n{\n\n    protected DiffScmResult executeDiffCommand( ScmProviderRepository repo, ScmFileSet files, ScmVersion startRev,\n                                                ScmVersion endRev )\n        throws ScmException\n    {\n        Commandline cl =\n            createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), startRev, endRev );\n        PerforceDiffConsumer consumer = new PerforceDiffConsumer();\n        boolean success = false;\n        try\n        {\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n            success = proc.waitFor() == 0;\n        }\n        catch ( CommandLineException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( InterruptedException e )\n        {\n            e.printStackTrace();\n        }\n\n        return new DiffScmResult( cl.toString(), success ? \"Diff successful\" : \"Unable to diff\", consumer\n            .getOutput(), success );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                 ScmVersion startRev, ScmVersion endRev )\n    {\n        String start = startRev != null && StringUtils.isNotEmpty( startRev.getName() ) ? \"@\" + startRev.getName() : \"\";\n        String end = endRev != null && StringUtils.isNotEmpty( endRev.getName() ) ? endRev.getName() : \"head\";\n\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"diff2\" );\n        command.createArgument().setValue( \"-u\" );\n        // I'm assuming the \"revs\" are actually labels\n        command.createArgument().setValue( \"...\" + start );\n        command.createArgument().setValue( \"...@\" + end );\n        return command;\n    }\n\n}\n","lineNo":90}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String url;\n\n    private String protocol;\n\n    /**\n     * The base directory for any tags. Can be relative to the repository URL or an absolute URL.\n     */\n    private String tagBase;\n\n    /**\n     * The base directory for any branches. Can be relative to the repository URL or an absolute URL.\n     */\n    private String branchBase;\n\n    public SvnScmProviderRepository( String url )\n    {\n        parseUrl( url );\n\n        tagBase = SvnTagBranchUtils.resolveTagBase( url );\n\n        branchBase = SvnTagBranchUtils.resolveBranchBase( url );\n    }\n\n    public SvnScmProviderRepository( String url, String user, String password )\n    {\n        this( url );\n\n        setUser( user );\n\n        setPassword( password );\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    /**\n     * Returns the url/directory to be used when tagging this repository.\n     */\n    public String getTagBase()\n    {\n        return tagBase;\n    }\n\n    /**\n     * Sets the url/directory to be used when tagging this repository.\n     * The TagBase is a way to override the default tag location for the\n     * repository.  The default tag location is automatically determined\n     * for repositories in the standard subversion layout (with /tags /branches /trunk).\n     * Specify this value only if the repository is using a directory other than \"/tags\" for tagging.\n     *\n     * @param tagBase an absolute or relative url to the base directory to create tags in.\n     *                URL should be in a format that svn client understands, not the scm url format.\n     */\n    public void setTagBase( String tagBase )\n    {\n        this.tagBase = tagBase;\n    }\n\n    /**\n     * Returns the url/directory to be used when tagging this repository.\n     */\n    public String getBranchBase()\n    {\n        return branchBase;\n    }\n\n    /**\n     * Sets the url/directory to be used when branching this repository.\n     * The BranchBase is a way to override the default branch location for the\n     * repository.  The default branch location is automatically determined\n     * for repositories in the standard subversion layout (with /tags /branches /trunk).\n     * Specify this value only if the repository is using a directory other than \"/branches\" for branching.\n     *\n     * @param branchBase an absolute or relative url to the base directory to create branch in.\n     *                   URL should be in a format that svn client understands, not the scm url format.\n     */\n    public void setBranchBase( String branchBase )\n    {\n        this.branchBase = branchBase;\n    }\n\n    private void setProtocol( String protocol )\n    {\n        this.protocol = protocol;\n    }\n\n    /**\n     * Get the protocol used in this repository (file://, http://, https://,...)\n     *\n     * @return the protocol\n     */\n    public String getProtocol()\n    {\n        return protocol;\n    }\n\n    private void parseUrl( String url )\n    {\n        if ( url.startsWith( \"file\" ) )\n        {\n            setProtocol( \"file://\" );\n        }\n        else if ( url.startsWith( \"https\" ) )\n        {\n            setProtocol( \"https://\" );\n        }\n        else if ( url.startsWith( \"http\" ) )\n        {\n            setProtocol( \"http://\" );\n        }\n        else if ( url.startsWith( \"svn+\" ) )\n        {\n            setProtocol( url.substring( 0, url.indexOf( \"://\" ) + 3 ) );\n        }\n        else if ( url.startsWith( \"svn\" ) )\n        {\n            setProtocol( \"svn://\" );\n        }\n\n        if ( getProtocol() == null )\n        {\n            return;\n        }\n\n        String urlPath = url.substring( getProtocol().length() );\n\n        int indexAt = urlPath.indexOf( \"@\" );\n\n        if ( indexAt > 0 && !getProtocol().startsWith( \"svn+\" ) )\n        {\n            setUser( urlPath.substring( 0, indexAt ) );\n\n            urlPath = urlPath.substring( indexAt + 1 );\n\n            this.url = getProtocol() + urlPath;\n        }\n        else\n        {\n            this.url = getProtocol() + urlPath;\n        }\n\n        if ( !\"file://\".equals( getProtocol() ) )\n        {\n            int indexSlash = urlPath.indexOf( \"/\" );\n\n            String hostPort = urlPath;\n\n            if ( indexSlash > 0 )\n            {\n                hostPort = urlPath.substring( 0, indexSlash );\n            }\n\n            int indexColon = hostPort.indexOf( \":\" );\n\n            if ( indexColon > 0 )\n            {\n                setHost( hostPort.substring( 0, indexColon ) );\n                setPort( Integer.parseInt( hostPort.substring( indexColon + 1 ) ) );\n            }\n            else\n            {\n                setHost( hostPort );\n            }\n        }\n    }\n\n    /**\n     * A ScmProviderRepository like this but with the parent url (stripping the last directory)\n     *\n     * @return the parent repository or <code>null<\/null> if this is the top level repository\n     */\n    public ScmProviderRepository getParent()\n    {\n        String newUrl = getUrl().substring( getProtocol().length() );\n\n        while ( newUrl.endsWith( \"/.\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() - 1 );\n        }\n\n        while ( newUrl.endsWith( \"/\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() );\n        }\n\n        int i = newUrl.lastIndexOf( \"/\" );\n\n        if ( i < 0 )\n        {\n            return null;\n        }\n        newUrl = newUrl.substring( 0, i );\n\n        return new SvnScmProviderRepository( getProtocol() + newUrl, getUser(), getPassword() );\n    }\n\n    /**\n     * Get the relative path from the ancestor to this repository\n     */\n    public String getRelativePath( ScmProviderRepository ancestor )\n    {\n        if ( ancestor instanceof SvnScmProviderRepository )\n        {\n            SvnScmProviderRepository svnAncestor = (SvnScmProviderRepository) ancestor;\n\n            String path = getUrl().replaceFirst( svnAncestor.getUrl() + \"/\", \"\" );\n\n            if ( !path.equals( getUrl() ) )\n            {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    public String toString()\n    {\n        return getUrl();\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.repository;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String url;\n\n    private String protocol;\n\n    /**\n     * The base directory for any tags. Can be relative to the repository URL or an absolute URL.\n     */\n    private String tagBase;\n\n    /**\n     * The base directory for any branches. Can be relative to the repository URL or an absolute URL.\n     */\n    private String branchBase;\n\n    public SvnScmProviderRepository( String url )\n    {\n        parseUrl( url );\n\n        tagBase = SvnTagBranchUtils.resolveTagBase( url );\n\n        branchBase = SvnTagBranchUtils.resolveBranchBase( url );\n    }\n\n    public SvnScmProviderRepository( String url, String user, String password )\n    {\n        this( url );\n\n        setUser( user );\n\n        setPassword( password );\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    /**\n     * Returns the url/directory to be used when tagging this repository.\n     */\n    public String getTagBase()\n    {\n        return tagBase;\n    }\n\n    /**\n     * Sets the url/directory to be used when tagging this repository.\n     * The TagBase is a way to override the default tag location for the\n     * repository.  The default tag location is automatically determined\n     * for repositories in the standard subversion layout (with /tags /branches /trunk).\n     * Specify this value only if the repository is using a directory other than \"/tags\" for tagging.\n     *\n     * @param tagBase an absolute or relative url to the base directory to create tags in.\n     *                URL should be in a format that svn client understands, not the scm url format.\n     */\n    public void setTagBase( String tagBase )\n    {\n        this.tagBase = tagBase;\n    }\n\n    /**\n     * Returns the url/directory to be used when tagging this repository.\n     */\n    public String getBranchBase()\n    {\n        return branchBase;\n    }\n\n    /**\n     * Sets the url/directory to be used when branching this repository.\n     * The BranchBase is a way to override the default branch location for the\n     * repository.  The default branch location is automatically determined\n     * for repositories in the standard subversion layout (with /tags /branches /trunk).\n     * Specify this value only if the repository is using a directory other than \"/branches\" for branching.\n     *\n     * @param branchBase an absolute or relative url to the base directory to create branch in.\n     *                   URL should be in a format that svn client understands, not the scm url format.\n     */\n    public void setBranchBase( String branchBase )\n    {\n        this.branchBase = branchBase;\n    }\n\n    private void setProtocol( String protocol )\n    {\n        this.protocol = protocol;\n    }\n\n    /**\n     * Get the protocol used in this repository (file://, http://, https://,...)\n     *\n     * @return the protocol\n     */\n    public String getProtocol()\n    {\n        return protocol;\n    }\n\n    private void parseUrl( String url )\n    {\n        if ( url.startsWith( \"file\" ) )\n        {\n            setProtocol( \"file://\" );\n        }\n        else if ( url.startsWith( \"https\" ) )\n        {\n            setProtocol( \"https://\" );\n        }\n        else if ( url.startsWith( \"http\" ) )\n        {\n            setProtocol( \"http://\" );\n        }\n        else if ( url.startsWith( \"svn+\" ) )\n        {\n            setProtocol( url.substring( 0, url.indexOf( \"://\" ) + 3 ) );\n        }\n        else if ( url.startsWith( \"svn\" ) )\n        {\n            setProtocol( \"svn://\" );\n        }\n\n        if ( getProtocol() == null )\n        {\n            return;\n        }\n\n        String urlPath = url.substring( getProtocol().length() );\n\n        int indexAt = urlPath.indexOf( \"@\" );\n\n        if ( indexAt > 0 && !getProtocol().startsWith( \"svn+\" ) )\n        {\n            String userPassword = urlPath.substring( 0, indexAt );\n            if ( userPassword.indexOf( \":\" ) < 0 )\n            {\n                setUser( userPassword );\n            }\n            else\n            {\n                setUser( userPassword.substring( 0, userPassword.indexOf( \":\" ) ) );\n                setPassword( userPassword.substring( userPassword.indexOf( \":\" ) + 1 ) );\n            }\n\n            urlPath = urlPath.substring( indexAt + 1 );\n\n            this.url = getProtocol() + urlPath;\n        }\n        else\n        {\n            this.url = getProtocol() + urlPath;\n        }\n\n        if ( !\"file://\".equals( getProtocol() ) )\n        {\n            int indexSlash = urlPath.indexOf( \"/\" );\n\n            String hostPort = urlPath;\n\n            if ( indexSlash > 0 )\n            {\n                hostPort = urlPath.substring( 0, indexSlash );\n            }\n\n            int indexColon = hostPort.indexOf( \":\" );\n\n            if ( indexColon > 0 )\n            {\n                setHost( hostPort.substring( 0, indexColon ) );\n                setPort( Integer.parseInt( hostPort.substring( indexColon + 1 ) ) );\n            }\n            else\n            {\n                setHost( hostPort );\n            }\n        }\n    }\n\n    /**\n     * A ScmProviderRepository like this but with the parent url (stripping the last directory)\n     *\n     * @return the parent repository or <code>null<\/null> if this is the top level repository\n     */\n    public ScmProviderRepository getParent()\n    {\n        String newUrl = getUrl().substring( getProtocol().length() );\n\n        while ( newUrl.endsWith( \"/.\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() - 1 );\n        }\n\n        while ( newUrl.endsWith( \"/\" ) )\n        {\n            newUrl = newUrl.substring( 0, newUrl.length() );\n        }\n\n        int i = newUrl.lastIndexOf( \"/\" );\n\n        if ( i < 0 )\n        {\n            return null;\n        }\n        newUrl = newUrl.substring( 0, i );\n\n        return new SvnScmProviderRepository( getProtocol() + newUrl, getUser(), getPassword() );\n    }\n\n    /**\n     * Get the relative path from the ancestor to this repository\n     */\n    public String getRelativePath( ScmProviderRepository ancestor )\n    {\n        if ( ancestor instanceof SvnScmProviderRepository )\n        {\n            SvnScmProviderRepository svnAncestor = (SvnScmProviderRepository) ancestor;\n\n            String path = getUrl().replaceFirst( svnAncestor.getUrl() + \"/\", \"\" );\n\n            if ( !path.equals( getUrl() ) )\n            {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    public String toString()\n    {\n        return getUrl();\n    }\n\n}\n","lineNo":166}
{"Smelly Sample":"package org.apache.maven.scm.manager;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmUrlUtils;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmManager\n    implements ScmManager\n{\n    private Map scmProviders = new HashMap();\n\n    private ScmLogger logger;\n\n    protected void setScmProviders( Map providers )\n    {\n        this.scmProviders = providers;\n    }\n\n    /**\n     * @deprecated use {@link #setScmProvider(String,ScmProvider)} instead\n     */\n    protected void addScmProvider( String providerType, ScmProvider provider )\n    {\n        setScmProvider( providerType, provider );\n    }\n\n    /**\n     * Set a provider to be used for a type of SCM.\n     * If there was already a designed provider for that type it will be replaced.\n     *\n     * @param providerType the type of SCM, eg. <code>svn<\/code>, <code>cvs<\/code>\n     * @param provider     the provider that will be used for that SCM type\n     */\n    public void setScmProvider( String providerType, ScmProvider provider )\n    {\n        scmProviders.put( providerType, provider );\n    }\n\n    protected abstract ScmLogger getScmLogger();\n\n    // ----------------------------------------------------------------------\n    // ScmManager Implementation\n    // ----------------------------------------------------------------------\n\n    public ScmProvider getProviderByUrl( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        return getProviderByType( providerType );\n    }\n\n    public ScmProvider getProviderByType( String providerType )\n        throws NoSuchScmProviderException\n    {\n        if ( logger == null )\n        {\n            logger = getScmLogger();\n\n            for ( Iterator i = scmProviders.keySet().iterator(); i.hasNext(); )\n            {\n                String key = (String) i.next();\n\n                ScmProvider p = (ScmProvider) scmProviders.get( key );\n\n                p.addListener( logger );\n            }\n        }\n\n        ScmProvider scmProvider = (ScmProvider) scmProviders.get( providerType );\n\n        if ( scmProvider == null )\n        {\n            throw new NoSuchScmProviderException( providerType );\n        }\n\n        return scmProvider;\n    }\n\n    public ScmProvider getProviderByRepository( ScmRepository repository )\n        throws NoSuchScmProviderException\n    {\n        return getProviderByType( repository.getProvider() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Repository\n    // ----------------------------------------------------------------------\n\n    public ScmRepository makeScmRepository( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        char delimiter = ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( scmSpecificUrl, delimiter );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    protected String cleanScmUrl( String scmUrl )\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String pathSeparator = \"\";\n\n        int indexOfDoubleDot = -1;\n\n        // Clean Unix path\n        if ( scmUrl.indexOf( \"../\" ) > 1 )\n        {\n            pathSeparator = \"/\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"../\" );\n        }\n\n        // Clean windows path\n        if ( scmUrl.indexOf( \"..\\\\\" ) > 1 )\n        {\n            pathSeparator = \"\\\\\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"..\\\\\" );\n        }\n\n        if ( indexOfDoubleDot > 1 )\n        {\n            int startOfTextToRemove = scmUrl.substring( 0, indexOfDoubleDot - 1 ).lastIndexOf( pathSeparator );\n\n            String beginUrl = \"\";\n            if ( startOfTextToRemove >= 0 )\n            {\n                beginUrl = scmUrl.substring( 0, startOfTextToRemove );\n            }\n\n            String endUrl = scmUrl.substring( indexOfDoubleDot + 3 );\n\n            scmUrl = beginUrl + pathSeparator + endUrl;\n\n            // Check if we have other double dot\n            if ( scmUrl.indexOf( \"../\" ) > 1 || scmUrl.indexOf( \"..\\\\\" ) > 1 )\n            {\n                scmUrl = cleanScmUrl( scmUrl );\n            }\n        }\n\n        return scmUrl;\n    }\n\n    public ScmRepository makeProviderScmRepository( String providerType, File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure, NoSuchScmProviderException\n    {\n        if ( providerType == null )\n        {\n            throw new NullPointerException( \"The provider type cannot be null.\" );\n        }\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( path );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    public List validateScmRepository( String scmUrl )\n    {\n        List messages = new ArrayList();\n\n        messages.addAll( ScmUrlUtils.validate( scmUrl ) );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider;\n\n        try\n        {\n            provider = getProviderByType( providerType );\n        }\n        catch ( NoSuchScmProviderException e )\n        {\n            messages.add( \"No such provider installed '\" + providerType + \"'.\" );\n\n            return messages;\n        }\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        List providerMessages =\n            provider.validateScmUrl( scmSpecificUrl, ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 ) );\n\n        if ( providerMessages == null )\n        {\n            throw new RuntimeException( \"The SCM provider cannot return null from validateScmUrl().\" );\n        }\n\n        messages.addAll( providerMessages );\n\n        return messages;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.manager;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.ScmUrlUtils;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.scm.repository.UnknownRepositoryStructure;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic abstract class AbstractScmManager\n    implements ScmManager\n{\n    private Map scmProviders = new HashMap();\n\n    private ScmLogger logger;\n\n    protected void setScmProviders( Map providers )\n    {\n        this.scmProviders = providers;\n    }\n\n    /**\n     * @deprecated use {@link #setScmProvider(String,ScmProvider)} instead\n     */\n    protected void addScmProvider( String providerType, ScmProvider provider )\n    {\n        setScmProvider( providerType, provider );\n    }\n\n    /**\n     * Set a provider to be used for a type of SCM.\n     * If there was already a designed provider for that type it will be replaced.\n     *\n     * @param providerType the type of SCM, eg. <code>svn<\/code>, <code>cvs<\/code>\n     * @param provider     the provider that will be used for that SCM type\n     */\n    public void setScmProvider( String providerType, ScmProvider provider )\n    {\n        scmProviders.put( providerType, provider );\n    }\n\n    protected abstract ScmLogger getScmLogger();\n\n    // ----------------------------------------------------------------------\n    // ScmManager Implementation\n    // ----------------------------------------------------------------------\n\n    public ScmProvider getProviderByUrl( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        return getProviderByType( providerType );\n    }\n\n    public ScmProvider getProviderByType( String providerType )\n        throws NoSuchScmProviderException\n    {\n        if ( logger == null )\n        {\n            logger = getScmLogger();\n\n            for ( Iterator i = scmProviders.keySet().iterator(); i.hasNext(); )\n            {\n                String key = (String) i.next();\n\n                ScmProvider p = (ScmProvider) scmProviders.get( key );\n\n                p.addListener( logger );\n            }\n        }\n\n        String usedProviderType = System.getProperty( \"maven.scm.provider.\" + providerType + \".implementation\" );\n\n        if ( usedProviderType == null )\n        {\n            usedProviderType = providerType;\n        }\n\n        ScmProvider scmProvider = (ScmProvider) scmProviders.get( usedProviderType );\n\n        if ( scmProvider == null )\n        {\n            throw new NoSuchScmProviderException( usedProviderType );\n        }\n\n        return scmProvider;\n    }\n\n    public ScmProvider getProviderByRepository( ScmRepository repository )\n        throws NoSuchScmProviderException\n    {\n        return getProviderByType( repository.getProvider() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Repository\n    // ----------------------------------------------------------------------\n\n    public ScmRepository makeScmRepository( String scmUrl )\n        throws ScmRepositoryException, NoSuchScmProviderException\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        char delimiter = ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( scmSpecificUrl, delimiter );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    protected String cleanScmUrl( String scmUrl )\n    {\n        if ( scmUrl == null )\n        {\n            throw new NullPointerException( \"The scm url cannot be null.\" );\n        }\n\n        String pathSeparator = \"\";\n\n        int indexOfDoubleDot = -1;\n\n        // Clean Unix path\n        if ( scmUrl.indexOf( \"../\" ) > 1 )\n        {\n            pathSeparator = \"/\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"../\" );\n        }\n\n        // Clean windows path\n        if ( scmUrl.indexOf( \"..\\\\\" ) > 1 )\n        {\n            pathSeparator = \"\\\\\";\n\n            indexOfDoubleDot = scmUrl.indexOf( \"..\\\\\" );\n        }\n\n        if ( indexOfDoubleDot > 1 )\n        {\n            int startOfTextToRemove = scmUrl.substring( 0, indexOfDoubleDot - 1 ).lastIndexOf( pathSeparator );\n\n            String beginUrl = \"\";\n            if ( startOfTextToRemove >= 0 )\n            {\n                beginUrl = scmUrl.substring( 0, startOfTextToRemove );\n            }\n\n            String endUrl = scmUrl.substring( indexOfDoubleDot + 3 );\n\n            scmUrl = beginUrl + pathSeparator + endUrl;\n\n            // Check if we have other double dot\n            if ( scmUrl.indexOf( \"../\" ) > 1 || scmUrl.indexOf( \"..\\\\\" ) > 1 )\n            {\n                scmUrl = cleanScmUrl( scmUrl );\n            }\n        }\n\n        return scmUrl;\n    }\n\n    public ScmRepository makeProviderScmRepository( String providerType, File path )\n        throws ScmRepositoryException, UnknownRepositoryStructure, NoSuchScmProviderException\n    {\n        if ( providerType == null )\n        {\n            throw new NullPointerException( \"The provider type cannot be null.\" );\n        }\n\n        ScmProvider provider = getProviderByType( providerType );\n\n        ScmProviderRepository providerRepository = provider.makeProviderScmRepository( path );\n\n        return new ScmRepository( providerType, providerRepository );\n    }\n\n    public List validateScmRepository( String scmUrl )\n    {\n        List messages = new ArrayList();\n\n        messages.addAll( ScmUrlUtils.validate( scmUrl ) );\n\n        String providerType = ScmUrlUtils.getProvider( scmUrl );\n\n        ScmProvider provider;\n\n        try\n        {\n            provider = getProviderByType( providerType );\n        }\n        catch ( NoSuchScmProviderException e )\n        {\n            messages.add( \"No such provider installed '\" + providerType + \"'.\" );\n\n            return messages;\n        }\n\n        String scmSpecificUrl = cleanScmUrl( scmUrl.substring( providerType.length() + 5 ) );\n\n        List providerMessages =\n            provider.validateScmUrl( scmSpecificUrl, ScmUrlUtils.getDelimiter( scmUrl ).charAt( 0 ) );\n\n        if ( providerMessages == null )\n        {\n            throw new RuntimeException( \"The SCM provider cannot return null from validateScmUrl().\" );\n        }\n\n        messages.addAll( providerMessages );\n\n        return messages;\n    }\n}\n","lineNo":111}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Tag the project.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"saden1@gmil.com\">Sharmarke Aden<\/a>\n * @version $Id$\n * @goal tag\n * @description Tag the project\n */\npublic class TagMojo\n    extends AbstractScmMojo\n{\n    /**\n     * Tag name.\n     *\n     * @parameter expression=\"${tag}\"\n     */\n    private String tag;\n\n    /**\n     * Set the timestamp format.\n     *\n     * @parameter expression=\"${timestampFormat}\" default-value=\"yyyyMMddHHmmss\"\n     */\n    private String timestampFormat;\n\n    /**\n     * Use timestamp tagging.\n     *\n     * @parameter expression=\"${addTimestamp}\" default-value=\"false\"\n     */\n    private boolean addTimestamp;\n\n    /**\n     * Timestamp tag prefix.\n     *\n     * @parameter expression=\"${timestampPrefix}\" default-value=\"-\"\n     */\n    private String timestampPrefix;\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            SimpleDateFormat dateFormat = null;\n            String tagTimestamp = \"\";\n            String finalTag = tag;\n\n            if ( addTimestamp )\n            {\n                try\n                {\n                    getLog().info( \"Using timestamp pattern '\" + timestampFormat + \"'\" );\n                    dateFormat = new SimpleDateFormat( timestampFormat );\n                    tagTimestamp = dateFormat.format( new Date() );\n                    getLog().info( \"Using timestamp '\" + tagTimestamp + \"'\" );\n                }\n                catch ( IllegalArgumentException e )\n                {\n                    String msg = \"The timestamp format '\" + timestampFormat + \"' is invalid.\";\n                    getLog().error( msg, e );\n                    throw new MojoExecutionException( msg, e );\n                }\n\n                finalTag += timestampPrefix + tagTimestamp;\n                getLog().info( \"Final Tag Name'\" + finalTag + \"'\" );\n\n            }\n\n            ScmRepository repository = getScmRepository();\n\n            TagScmResult result =\n                getScmManager().getProviderByRepository( repository ).tag( repository, getFileSet(), finalTag );\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Tag the project.\n *\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"saden1@gmil.com\">Sharmarke Aden<\/a>\n * @version $Id$\n * @goal tag\n * @description Tag the project\n */\npublic class TagMojo\n    extends AbstractScmMojo\n{\n    /**\n     * Tag name.\n     *\n     * @parameter expression=\"${tag}\"\n     */\n    private String tag;\n\n    /**\n     * Set the timestamp format.\n     *\n     * @parameter expression=\"${timestampFormat}\" default-value=\"yyyyMMddHHmmss\"\n     */\n    private String timestampFormat;\n\n    /**\n     * Use timestamp tagging.\n     *\n     * @parameter expression=\"${addTimestamp}\" default-value=\"false\"\n     */\n    private boolean addTimestamp;\n\n    /**\n     * Timestamp tag prefix.\n     *\n     * @parameter expression=\"${timestampPrefix}\" default-value=\"-\"\n     */\n    private String timestampPrefix;\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            SimpleDateFormat dateFormat = null;\n            String tagTimestamp = \"\";\n            String finalTag = tag;\n\n            if ( addTimestamp )\n            {\n                try\n                {\n                    getLog().info( \"Using timestamp pattern '\" + timestampFormat + \"'\" );\n                    dateFormat = new SimpleDateFormat( timestampFormat );\n                    tagTimestamp = dateFormat.format( new Date() );\n                    getLog().info( \"Using timestamp '\" + tagTimestamp + \"'\" );\n                }\n                catch ( IllegalArgumentException e )\n                {\n                    String msg = \"The timestamp format '\" + timestampFormat + \"' is invalid.\";\n                    getLog().error( msg, e );\n                    throw new MojoExecutionException( msg, e );\n                }\n\n                finalTag += timestampPrefix + tagTimestamp;\n            }\n\n            ScmRepository repository = getScmRepository();\n            ScmProvider provider = getScmManager().getProviderByRepository( repository );\n\n            finalTag = provider.sanitizeTagName( finalTag );\n            getLog().info( \"Final Tag Name'\" + finalTag + \"'\" );\n\n            TagScmResult result = provider.tag( repository, getFileSet(), finalTag );\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n    }\n}\n","lineNo":101}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.edit;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.edit.AbstractEditCommand;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamEditCommand\n    extends AbstractEditCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractEditCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected ScmResult executeEditCommand( ScmProviderRepository repo, ScmFileSet fileSet )\n        throws ScmException\n    {\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamEditConsumer consumer = new StarteamEditConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        File[] editFiles = fileSet.getFiles();\n\n        if ( editFiles.length == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet.getBasedir() );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new EditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //edit only interested files already on the local disk\n            for ( int i = 0; i < editFiles.length; ++i )\n            {\n                Commandline cl = createCommandLine( repository, editFiles[i] );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new EditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                              false );\n                }\n            }\n        }\n\n        return new EditScmResult( null, consumer.getEditedFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File dirOrFile )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"lck\", dirOrFile, repo );\n\n        cl.createArgument().setValue( \"-l\" );\n\n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n            cl.createArgument().setValue( dirOrFile.getName() );\n        }\n\n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.edit;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.edit.AbstractEditCommand;\nimport org.apache.maven.scm.command.edit.EditScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamEditCommand\n    extends AbstractEditCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractEditCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected ScmResult executeEditCommand( ScmProviderRepository repo, ScmFileSet fileSet )\n        throws ScmException\n    {\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamEditConsumer consumer = new StarteamEditConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        List editFiles = fileSet.getFileList();\n\n        if ( editFiles.size() == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new EditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //edit only interested files already on the local disk\n            for ( int i = 0; i < editFiles.size(); ++i )\n            {\n            \tScmFileSet editFile = new ScmFileSet( fileSet.getBasedir(), (File) editFiles.get( i ) );\n                Commandline cl = createCommandLine( repository, editFile );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new EditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                              false );\n                }\n            }\n        }\n\n        return new EditScmResult( null, consumer.getEditedFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, ScmFileSet dirOrFile )\n    {\n    \tList args = new ArrayList();\n        args.add( \"-l\" );\n        \n        return StarteamCommandLineUtils.createStarteamCommandLine( \"lck\", args, dirOrFile, repo );\n    }\n}\n","lineNo":76}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.unedit;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.unedit.AbstractUnEditCommand;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamUnEditCommand\n    extends AbstractUnEditCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractEditCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected ScmResult executeUnEditCommand( ScmProviderRepository repo, ScmFileSet fileSet )\n        throws ScmException\n    {\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamUnEditConsumer consumer = new StarteamUnEditConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        File[] editFiles = fileSet.getFiles();\n\n        if ( editFiles.length == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet.getBasedir() );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new UnEditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //edit only interested files already on the local disk\n            for ( int i = 0; i < editFiles.length; ++i )\n            {\n                Commandline cl = createCommandLine( repository, editFiles[i] );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new UnEditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new UnEditScmResult( null, consumer.getUnEditFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File dirOrFile )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"lck\", dirOrFile, repo );\n\n        cl.createArgument().setValue( \"-u\" );\n\n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n            cl.createArgument().setValue( dirOrFile.getName() );\n        }\n\n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.unedit;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.unedit.AbstractUnEditCommand;\nimport org.apache.maven.scm.command.unedit.UnEditScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamUnEditCommand\n    extends AbstractUnEditCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractEditCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected ScmResult executeUnEditCommand( ScmProviderRepository repo, ScmFileSet fileSet )\n        throws ScmException\n    {\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamUnEditConsumer consumer = new StarteamUnEditConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        List unlockFiles = fileSet.getFileList();\n\n        if ( unlockFiles.size() == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new UnEditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //edit only interested files already on the local disk\n            for ( int i = 0; i < unlockFiles.size(); ++i )\n            {\n            \tScmFileSet unlockFile = new ScmFileSet( fileSet.getBasedir(), (File) unlockFiles.get( i ) );\n                Commandline cl = createCommandLine( repository, unlockFile );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new UnEditScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new UnEditScmResult( null, consumer.getUnEditFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, ScmFileSet dirOrFile )\n    {\n    \tList args = new ArrayList();\n        args.add( \"-u\" );\n    \t\n        return StarteamCommandLineUtils.createStarteamCommandLine( \"lck\", args, dirOrFile, repo );\n    }\n}\n","lineNo":76}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.update;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.command.changelog.StarteamChangeLogCommand;\nimport org.apache.maven.scm.provider.starteam.command.checkout.StarteamCheckOutConsumer;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.DefaultConsumer;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamUpdateCommand\n    extends AbstractUpdateCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractUpdateCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckOutConsumer consumer = new StarteamCheckOutConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        File[] checkInFiles = fileSet.getFiles();\n\n        if ( checkInFiles.length == 0 )\n        {\n            //update everything\n            Commandline cl = createCommandLine( repository, fileSet.getBasedir(), tag );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new UpdateScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n            else\n            {\n                //hiden feature to allow Continuous Integration machine to\n                // delete local files. It affectively remove all build ouput as well\n                String doDeleteLocal = System.getProperty( \"maven.scm.starteam.deleteLocal\" );\n\n                if ( \"true\".equalsIgnoreCase( doDeleteLocal ) )\n                {\n                    this.deleteLocal( repository, fileSet.getBasedir(), tag );\n                }\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < checkInFiles.length; ++i )\n            {\n                Commandline cl = createCommandLine( repository, checkInFiles[i], tag );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new UpdateScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new UpdateScmResult( null, consumer.getCheckedOutFiles() );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File dirOrFile, String tag )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"co\", dirOrFile, repo );\n\n        cl.createArgument().setValue( \"-merge\" );\n\n        cl.createArgument().setValue( \"-neverprompt\" );\n\n        if ( tag != null && tag.length() != 0 )\n        {\n            cl.createArgument().setValue( \"-vl\" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n            cl.createArgument().setValue( dirOrFile.getName() );\n        }\n\n        return cl;\n    }\n\n    /**\n     * @see org.apache.maven.scm.command.update.AbstractUpdateCommand#getChangeLogCommand()\n     */\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        StarteamChangeLogCommand command = new StarteamChangeLogCommand();\n\n        command.setLogger( getLogger() );\n\n        return command;\n    }\n\n    private void deleteLocal( StarteamScmProviderRepository repo, File dir, String tag )\n        throws ScmException\n    {\n        if ( dir.isFile() )\n        {\n            return;\n        }\n\n        Commandline cl = createDeleteLocalCommand( repo, dir, tag );\n\n        StreamConsumer consumer = new DefaultConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n        if ( exitCode != 0 )\n        {\n            throw new ScmException( \"Error executing delete-local: \" + stderr.toString() );\n        }\n    }\n\n    public static Commandline createDeleteLocalCommand( StarteamScmProviderRepository repo, File dirOrFile, String tag )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"delete-local\", dirOrFile, repo );\n\n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n\n        if ( tag != null && tag.length() != 0 )\n        {\n            cl.createArgument().setValue( \"-cfgl \" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        cl.createArgument().setValue( \"-filter\" );\n\n        cl.createArgument().setValue( \"N\" );\n\n        return cl;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.update;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.command.changelog.StarteamChangeLogCommand;\nimport org.apache.maven.scm.provider.starteam.command.checkout.StarteamCheckOutConsumer;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.DefaultConsumer;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.io.File;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamUpdateCommand\n    extends AbstractUpdateCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractUpdateCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckOutConsumer consumer = new StarteamCheckOutConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        List updateFiles = fileSet.getFileList();\n\n        if ( updateFiles.size() == 0 )\n        {\n            //update everything\n            Commandline cl = createCommandLine( repository, fileSet, tag );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new UpdateScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n            else\n            {\n                //hiden feature to allow Continuous Integration machine to\n                // delete local files. It affectively remove all build ouput as well\n                String doDeleteLocal = System.getProperty( \"maven.scm.starteam.deleteLocal\" );\n\n                if ( \"true\".equalsIgnoreCase( doDeleteLocal ) )\n                {\n                    this.deleteLocal( repository, fileSet.getBasedir(), tag );\n                }\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < updateFiles.size(); ++i )\n            {\n            \tFile updateFile = (File) updateFiles.get( i );\n            \tScmFileSet scmFileSet = new ScmFileSet( fileSet.getBasedir(), updateFile );\n                Commandline cl = createCommandLine( repository, scmFileSet, tag );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new UpdateScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new UpdateScmResult( null, consumer.getCheckedOutFiles() );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, ScmFileSet fileSet, String tag )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"co\", fileSet, repo );\n\n        cl.createArgument().setValue( \"-merge\" );\n\n        cl.createArgument().setValue( \"-neverprompt\" );\n\n        if ( tag != null && tag.length() != 0 )\n        {\n            cl.createArgument().setValue( \"-vl\" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        if ( fileSet.getFileList().size() == 0 )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n        \tFile updateFile = (File) fileSet.getFileList().get( 0 );\n            cl.createArgument().setValue( updateFile.getName() );\n        }\n\n        return cl;\n    }\n\n    /**\n     * @see org.apache.maven.scm.command.update.AbstractUpdateCommand#getChangeLogCommand()\n     */\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        StarteamChangeLogCommand command = new StarteamChangeLogCommand();\n\n        command.setLogger( getLogger() );\n\n        return command;\n    }\n\n    private void deleteLocal( StarteamScmProviderRepository repo, File dir, String tag )\n        throws ScmException\n    {\n        if ( dir.isFile() )\n        {\n            return;\n        }\n\n        Commandline cl = createDeleteLocalCommand( repo, dir, tag );\n\n        StreamConsumer consumer = new DefaultConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n        if ( exitCode != 0 )\n        {\n            throw new ScmException( \"Error executing delete-local: \" + stderr.toString() );\n        }\n    }\n\n    public static Commandline createDeleteLocalCommand( StarteamScmProviderRepository repo, File dirOrFile, String tag )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"delete-local\", dirOrFile, repo );\n\n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n\n        if ( tag != null && tag.length() != 0 )\n        {\n            cl.createArgument().setValue( \"-cfgl \" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        cl.createArgument().setValue( \"-filter\" );\n\n        cl.createArgument().setValue( \"N\" );\n\n        return cl;\n    }\n\n}\n","lineNo":93}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.remove;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.remove.AbstractRemoveCommand;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.command.checkin.StarteamCheckInConsumer;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamRemoveCommand\n    extends AbstractRemoveCommand\n    implements StarteamCommand\n{\n    protected ScmResult executeRemoveCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckInConsumer consumer = new StarteamCheckInConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        File[] checkInFiles = fileSet.getFiles();\n\n        if ( checkInFiles.length == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet.getBasedir() );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < checkInFiles.length; ++i )\n            {\n                Commandline cl = createCommandLine( repository, checkInFiles[i] );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new RemoveScmResult( null, consumer.getCheckedInFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File dirOrFile )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"remove\", dirOrFile, repo );\n\n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n            cl.createArgument().setValue( dirOrFile.getName() );\n        }\n\n        //remove working file(s)\n        //cl.createArgument().setValue( \"-df\" );\n\n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.remove;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.remove.AbstractRemoveCommand;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.command.checkin.StarteamCheckInConsumer;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamRemoveCommand\n    extends AbstractRemoveCommand\n    implements StarteamCommand\n{\n    protected ScmResult executeRemoveCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckInConsumer consumer = new StarteamCheckInConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        List remvoveFiles = fileSet.getFileList();\n\n        if ( remvoveFiles.size() == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < remvoveFiles.size(); ++i )\n            {\n            \tFile fileToBeRemoved = (File) remvoveFiles.get( i );\n            \tScmFileSet scmFileSet = new ScmFileSet( fileSet.getBasedir(), fileToBeRemoved );\n                Commandline cl = createCommandLine( repository, scmFileSet );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new RemoveScmResult( null, consumer.getCheckedInFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, ScmFileSet dirOrFile )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"remove\", dirOrFile, repo );\n\n        if ( dirOrFile.getFileList().size() == 0 )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n        \tFile fileToBeRemoved = (File) dirOrFile.getFileList().get(0);\n            cl.createArgument().setValue( fileToBeRemoved.getName() );\n        }\n\n        return cl;\n    }\n}\n","lineNo":74}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.remove;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.remove.AbstractRemoveCommand;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.command.checkin.StarteamCheckInConsumer;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamRemoveCommand\n    extends AbstractRemoveCommand\n    implements StarteamCommand\n{\n    protected ScmResult executeRemoveCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckInConsumer consumer = new StarteamCheckInConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        File[] checkInFiles = fileSet.getFiles();\n\n        if ( checkInFiles.length == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet.getBasedir() );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < checkInFiles.length; ++i )\n            {\n                Commandline cl = createCommandLine( repository, checkInFiles[i] );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new RemoveScmResult( null, consumer.getCheckedInFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File dirOrFile )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"remove\", dirOrFile, repo );\n\n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n            cl.createArgument().setValue( dirOrFile.getName() );\n        }\n\n        //remove working file(s)\n        //cl.createArgument().setValue( \"-df\" );\n\n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.remove;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.remove.AbstractRemoveCommand;\nimport org.apache.maven.scm.command.remove.RemoveScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.command.checkin.StarteamCheckInConsumer;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamRemoveCommand\n    extends AbstractRemoveCommand\n    implements StarteamCommand\n{\n    protected ScmResult executeRemoveCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message )\n        throws ScmException\n    {\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckInConsumer consumer = new StarteamCheckInConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        List remvoveFiles = fileSet.getFileList();\n\n        if ( remvoveFiles.size() == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < remvoveFiles.size(); ++i )\n            {\n            \tFile fileToBeRemoved = (File) remvoveFiles.get( i );\n            \tScmFileSet scmFileSet = new ScmFileSet( fileSet.getBasedir(), fileToBeRemoved );\n                Commandline cl = createCommandLine( repository, scmFileSet );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new RemoveScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                false );\n                }\n            }\n        }\n\n        return new RemoveScmResult( null, consumer.getCheckedInFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, ScmFileSet dirOrFile )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"remove\", dirOrFile, repo );\n\n        if ( dirOrFile.getFileList().size() == 0 )\n        {\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n        \tFile fileToBeRemoved = (File) dirOrFile.getFileList().get(0);\n            cl.createArgument().setValue( fileToBeRemoved.getName() );\n        }\n\n        return cl;\n    }\n}\n","lineNo":101}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamCheckInCommand\n    extends AbstractCheckInCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractCheckInCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      String tag )\n        throws ScmException\n    {\n\n        //work around until maven-scm-api allow this\n        String issueType = System.getProperty( \"maven.scm.issue.type\" );\n        String issueValue = System.getProperty( \"maven.scm.issue.value\" );\n        String deprecatedIssue = System.getProperty( \"maven.scm.issue\" );\n        \n        if ( deprecatedIssue != null && deprecatedIssue.trim().length() > 0 )\n        {\n            issueType = \"cr\";\n            issueValue = deprecatedIssue;\n        }\n        \n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckInConsumer consumer = new StarteamCheckInConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        File[] checkInFiles = fileSet.getFiles();\n\n        if ( checkInFiles.length == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet.getBasedir(), message, tag, issueType, issueValue );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new CheckInScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < checkInFiles.length; ++i )\n            {\n                Commandline cl = createCommandLine( repository, checkInFiles[i], message, tag, issueType, issueValue );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new CheckInScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                 false );\n                }\n            }\n        }\n\n        return new CheckInScmResult( null, consumer.getCheckedInFiles() );\n\n    }\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File dirOrFile, String message,\n                                                 String tag, String issueType, String issueValue )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"ci\", dirOrFile, repo );\n\n        if ( message != null && message.length() > 0 )\n        {\n            cl.createArgument().setValue( \"-r\" );\n\n            cl.createArgument().setValue( message );\n        }\n\n        if ( tag != null && tag.length() > 0 )\n        {\n            cl.createArgument().setValue( \"-vl\" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        if ( issueType != null && issueType.trim().length() > 0 )\n        {\n            cl.createArgument().setValue( \"-\" + issueType.trim() );\n            if ( issueValue != null && issueValue.trim().length() > 0 )\n            {\n                cl.createArgument().setValue( issueValue.trim() );\n            }\n        }\n        \n        if ( dirOrFile.isDirectory() )\n        {\n            cl.createArgument().setValue( \"-f\" );\n\n            cl.createArgument().setValue( \"NCI\" );\n\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n            cl.createArgument().setValue( dirOrFile.getName() );\n        }\n\n        return cl;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamCheckInCommand\n    extends AbstractCheckInCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractCheckInCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                      String tag )\n        throws ScmException\n    {\n\n        //work around until maven-scm-api allow this\n        String issueType = System.getProperty( \"maven.scm.issue.type\" );\n        String issueValue = System.getProperty( \"maven.scm.issue.value\" );\n        String deprecatedIssue = System.getProperty( \"maven.scm.issue\" );\n        \n        if ( deprecatedIssue != null && deprecatedIssue.trim().length() > 0 )\n        {\n            issueType = \"cr\";\n            issueValue = deprecatedIssue;\n        }\n        \n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        StarteamCheckInConsumer consumer = new StarteamCheckInConsumer( getLogger(), fileSet.getBasedir() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        List checkInFiles = fileSet.getFileList();\n\n        if ( checkInFiles.size() == 0 )\n        {\n            Commandline cl = createCommandLine( repository, fileSet, message, tag, issueType, issueValue );\n\n            int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n            if ( exitCode != 0 )\n            {\n                return new CheckInScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(), false );\n            }\n        }\n        else\n        {\n            //update only interested files already on the local disk\n            for ( int i = 0; i < checkInFiles.size(); ++i )\n            {\n            \tScmFileSet checkInFile = new ScmFileSet( fileSet.getBasedir(), (File) checkInFiles.get( i ) );\n            \t\n                Commandline cl = createCommandLine( repository, checkInFile, message, tag, issueType, issueValue );\n\n                int exitCode = StarteamCommandLineUtils.executeCommandline( cl, consumer, stderr, getLogger() );\n\n                if ( exitCode != 0 )\n                {\n                    return new CheckInScmResult( cl.toString(), \"The starteam command failed.\", stderr.getOutput(),\n                                                 false );\n                }\n            }\n        }\n\n        return new CheckInScmResult( null, consumer.getCheckedInFiles() );\n\n    }\n\n  \n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, ScmFileSet fileSet, String message,\n                                                 String tag, String issueType, String issueValue )\n    {\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine( \"ci\", fileSet, repo );\n\n        if ( message != null && message.length() > 0 )\n        {\n            cl.createArgument().setValue( \"-r\" );\n\n            cl.createArgument().setValue( message );\n        }\n\n        if ( tag != null && tag.length() > 0 )\n        {\n            cl.createArgument().setValue( \"-vl\" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        if ( issueType != null && issueType.trim().length() > 0 )\n        {\n            cl.createArgument().setValue( \"-\" + issueType.trim() );\n            if ( issueValue != null && issueValue.trim().length() > 0 )\n            {\n                cl.createArgument().setValue( issueValue.trim() );\n            }\n        }\n        \n        if ( fileSet.getFileList().size() == 0 )\n        {\n            cl.createArgument().setValue( \"-f\" );\n\n            cl.createArgument().setValue( \"NCI\" );\n\n            cl.createArgument().setValue( \"-is\" );\n        }\n        else\n        {\n        \tFile checkinFile = (File) fileSet.getFileList().get( 0 ) ;\n            cl.createArgument().setValue( checkinFile.getName() );\n        }\n\n        return cl;\n    }\n\n}\n","lineNo":87}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamAddCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"\", expectedCmd );\n    }\n\n    public void testGetCommandLineWithCR()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" -cr view_root/dummycr\" + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"view_root/dummycr\",\n                         expectedCmd );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n\n        File testFile = new File( \"target/testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/target\" +\n            \" -fp \" + testFileDirAbsolutePath + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, expectedCmd );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File fileName, String crPath, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamAddCommand.createCommandLine( repository, fileName, crPath );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamAddCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" testfile\";\n\n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", expectedCmd );\n    }\n\n    public void testGetCommandLineWithCR()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" -cr view_root/dummycr\" + \" testfile\";\n\n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"view_root/dummycr\",\n                         expectedCmd );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n\n        File testFile = new File( \"target/testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() ) + \"/target\";\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/target\" +\n            \" -fp \" + testFileDirAbsolutePath + \" testfile\";\n                \n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, expectedCmd );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String crPath, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamAddCommand.createCommandLine( repository, fileSet, crPath );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n}\n","lineNo":48}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamAddCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"\", expectedCmd );\n    }\n\n    public void testGetCommandLineWithCR()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" -cr view_root/dummycr\" + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"view_root/dummycr\",\n                         expectedCmd );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n\n        File testFile = new File( \"target/testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/target\" +\n            \" -fp \" + testFileDirAbsolutePath + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, expectedCmd );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File fileName, String crPath, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamAddCommand.createCommandLine( repository, fileName, crPath );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamAddCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" testfile\";\n\n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", expectedCmd );\n    }\n\n    public void testGetCommandLineWithCR()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" -cr view_root/dummycr\" + \" testfile\";\n\n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"view_root/dummycr\",\n                         expectedCmd );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n\n        File testFile = new File( \"target/testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() ) + \"/target\";\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/target\" +\n            \" -fp \" + testFileDirAbsolutePath + \" testfile\";\n                \n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, expectedCmd );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String crPath, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamAddCommand.createCommandLine( repository, fileSet, crPath );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n}\n","lineNo":64}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamAddCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"\", expectedCmd );\n    }\n\n    public void testGetCommandLineWithCR()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" -cr view_root/dummycr\" + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"view_root/dummycr\",\n                         expectedCmd );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n\n        File testFile = new File( \"target/testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/target\" +\n            \" -fp \" + testFileDirAbsolutePath + \" testfile\";\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, expectedCmd );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File fileName, String crPath, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamAddCommand.createCommandLine( repository, fileName, crPath );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamAddCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" testfile\";\n\n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", expectedCmd );\n    }\n\n    public void testGetCommandLineWithCR()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() );\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl\" + \" -fp \" +\n            testFileDirAbsolutePath + \" -cr view_root/dummycr\" + \" testfile\";\n\n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"view_root/dummycr\",\n                         expectedCmd );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n\n        File testFile = new File( \"target/testfile\" );\n\n        File testFileDir = testFile.getAbsoluteFile().getParentFile();\n\n        String testFileDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFileDir.getAbsolutePath() ) + \"/target\";\n\n        String expectedCmd = \"stcmd add -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/target\" +\n            \" -fp \" + testFileDirAbsolutePath + \" testfile\";\n                \n        ScmFileSet fileSet = new ScmFileSet( testFileDir, testFile );\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, expectedCmd );\n\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String crPath, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamAddCommand.createCommandLine( repository, fileSet, crPath );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n}\n","lineNo":83}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", workDir, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                             testFileAbsolutePath + \" -cr myCr \" + \"testfile\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File testFileOrDir, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, testFileOrDir, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        ScmFileSet fileSet = new ScmFileSet( workDir );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        ScmFileSet fileSet = new ScmFileSet( testFile.getAbsoluteFile().getParentFile(), testFile );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile.txt\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileDirectory = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                         testFileDirectory + \" -cr myCr \" + \"testfile.txt\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, fileSet, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","lineNo":42}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", workDir, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                             testFileAbsolutePath + \" -cr myCr \" + \"testfile\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File testFileOrDir, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, testFileOrDir, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        ScmFileSet fileSet = new ScmFileSet( workDir );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        ScmFileSet fileSet = new ScmFileSet( testFile.getAbsoluteFile().getParentFile(), testFile );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile.txt\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileDirectory = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                         testFileDirectory + \" -cr myCr \" + \"testfile.txt\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, fileSet, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","lineNo":56}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", workDir, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                             testFileAbsolutePath + \" -cr myCr \" + \"testfile\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File testFileOrDir, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, testFileOrDir, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        ScmFileSet fileSet = new ScmFileSet( workDir );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        ScmFileSet fileSet = new ScmFileSet( testFile.getAbsoluteFile().getParentFile(), testFile );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile.txt\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileDirectory = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                         testFileDirectory + \" -cr myCr \" + \"testfile.txt\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, fileSet, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","lineNo":69}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", workDir, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                             testFileAbsolutePath + \" -cr myCr \" + \"testfile\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File testFileOrDir, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, testFileOrDir, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        ScmFileSet fileSet = new ScmFileSet( workDir );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        ScmFileSet fileSet = new ScmFileSet( testFile.getAbsoluteFile().getParentFile(), testFile );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile.txt\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileDirectory = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                         testFileDirectory + \" -cr myCr \" + \"testfile.txt\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, fileSet, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","lineNo":70}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", workDir, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                             testFileAbsolutePath + \" -cr myCr \" + \"testfile\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File testFileOrDir, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, testFileOrDir, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        ScmFileSet fileSet = new ScmFileSet( workDir );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        ScmFileSet fileSet = new ScmFileSet( testFile.getAbsoluteFile().getParentFile(), testFile );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile.txt\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileDirectory = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                         testFileDirectory + \" -cr myCr \" + \"testfile.txt\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, fileSet, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","lineNo":84}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", workDir, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                             testFileAbsolutePath + \" -cr myCr \" + \"testfile\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", testFile, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, File testFileOrDir, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, testFileOrDir, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.checkin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n */\npublic class StarteamCheckInCommandTest\n    extends ScmTestCase\n{\n\n    public void testGetCommandLineWithWorkingDirectory()\n        throws Exception\n    {\n        File workDir = new File( getBasedir() + \"/target\" );\n\n        String workDirAbsolutePath = StarteamCommandLineUtils.toJavaPath( workDir.getAbsolutePath() );\n\n        ScmFileSet fileSet = new ScmFileSet( workDir );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"\", \"\", \"\", \"\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n                             workDirAbsolutePath + \" -f NCI -is\" );\n    }\n\n    public void testGetCommandLineWithFileOnRoot()\n        throws Exception\n    {\n        File testFile = new File( \"testfile\" );\n\n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        ScmFileSet fileSet = new ScmFileSet( testFile.getAbsoluteFile().getParentFile(), testFile );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, \"myMessage\", \"myTag\",\n                         \"\", \"\", \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl \" + \"-fp \" +\n            testFileAbsolutePath + \" -r myMessage -vl myTag \" + \"testfile\" );\n\n    }\n\n    public void testGetCommandLineWithFileInSubDir()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile.txt\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileDirectory = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"cr\" ,\"myCr\",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \" +\n                         testFileDirectory + \" -cr myCr \" + \"testfile.txt\" );\n    }\n\n    public void testGetCommandLineWithEmptyIssueValue()\n        throws Exception\n    {\n        File testFile = new File( \"src/testfile\" );\n\n        File workingDir = testFile.getAbsoluteFile().getParentFile().getParentFile();\n        ScmFileSet fileSet = new ScmFileSet( workingDir, testFile );\n        \n        String testFileAbsolutePath = StarteamCommandLineUtils.toJavaPath( testFile.getAbsoluteFile().getParent() );\n\n        testCommandLine( \"scm:starteam:myusername:mypassword@myhost:1234/projecturl\", fileSet, null, \"\", \"active\", \" \",\n                         \"stcmd ci -x -nologo -stop -p myusername:mypassword@myhost:1234/projecturl/src \" + \"-fp \"\n                             + testFileAbsolutePath + \" -active \" + \"testfile\" );\n    }    \n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\n\n    private void testCommandLine( String scmUrl, ScmFileSet fileSet, String message, String tag, String issueType,\n    \t\t                      String issueValue, String commandLine )\n        throws Exception\n    {\n        ScmRepository repo = getScmManager().makeScmRepository( scmUrl );\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo.getProviderRepository();\n\n        Commandline cl = StarteamCheckInCommand.createCommandLine( repository, fileSet, message, tag, issueType, issueValue );\n\n        assertEquals( commandLine, cl.toString() );\n    }\n\n\n}\n","lineNo":85}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.svnexe.command.tag;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @version $Id$\n * @todo since this is just a copy, use that instead.\n */\npublic class SvnTagCommand\n    extends AbstractTagCommand\n    implements SvnCommand\n{\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n        if ( tag == null || StringUtils.isEmpty( tag.trim() ) )\n        {\n            throw new ScmException( \"tag must be specified\" );\n        }\n\n        if ( fileSet.getFiles().length != 0 )\n        {\n            throw new ScmException( \"This provider doesn't support tagging subsets of a directory\" );\n        }\n\n        SvnScmProviderRepository repository = (SvnScmProviderRepository) repo;\n\n        File messageFile = FileUtils.createTempFile( \"maven-scm-\", \".commit\", null );\n\n        try\n        {\n            // TODO: should message be customisable?\n            FileUtils.fileWrite( messageFile.getAbsolutePath(), \"[maven-scm] copy for tag \" + tag );\n        }\n        catch ( IOException ex )\n        {\n            return new TagScmResult( null,\n                                     \"Error while making a temporary file for the commit message: \" + ex.getMessage(),\n                                     null, false );\n        }\n\n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), tag, messageFile );\n\n        CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n        getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, stdout, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            // TODO: Improve this error message\n            return new TagScmResult( cl.toString(), \"The svn tag command failed.\", stderr.getOutput(), false );\n        }\n\n        List fileList = new ArrayList();\n\n        List files = null;\n\n        try\n        {\n            files = FileUtils.getFiles( fileSet.getBasedir(), \"**\", \"**/.svn/**\", false );\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( \"Error while executing command.\", e );\n        }\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File f = (File) i.next();\n\n            fileList.add( new ScmFile( f.getPath(), ScmFileStatus.TAGGED ) );\n        }\n\n        return new TagScmResult( cl.toString(), fileList );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                  String tag, File messageFile )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArgument().setValue( \"copy\" );\n\n        cl.createArgument().setValue( \"--file\" );\n\n        cl.createArgument().setValue( messageFile.getAbsolutePath() );\n\n        cl.createArgument().setValue( \".\" );\n\n        // Note: this currently assumes you have the tag base checked out too\n        cl.createArgument().setValue( SvnTagBranchUtils.resolveTagUrl( repository, tag ) );\n\n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.svnexe.command.tag;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.SvnTagBranchUtils;\nimport org.apache.maven.scm.provider.svn.SvnCommandUtils;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.svnexe.command.SvnCommandLineUtils;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @version $Id$\n * @todo since this is just a copy, use that instead.\n */\npublic class SvnTagCommand\n    extends AbstractTagCommand\n    implements SvnCommand\n{\n    public ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n        if ( tag == null || StringUtils.isEmpty( tag.trim() ) )\n        {\n            throw new ScmException( \"tag must be specified\" );\n        }\n\n        if ( fileSet.getFiles().length != 0 )\n        {\n            throw new ScmException( \"This provider doesn't support tagging subsets of a directory\" );\n        }\n\n        SvnScmProviderRepository repository = (SvnScmProviderRepository) repo;\n\n        File messageFile = FileUtils.createTempFile( \"maven-scm-\", \".commit\", null );\n\n        try\n        {\n            // TODO: should message be customisable?\n            FileUtils.fileWrite( messageFile.getAbsolutePath(), \"[maven-scm] copy for tag \" + tag );\n        }\n        catch ( IOException ex )\n        {\n            return new TagScmResult( null,\n                                     \"Error while making a temporary file for the commit message: \" + ex.getMessage(),\n                                     null, false );\n        }\n\n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), tag, messageFile );\n\n        CommandLineUtils.StringStreamConsumer stdout = new CommandLineUtils.StringStreamConsumer();\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        getLogger().info( \"Executing: \" + SvnCommandLineUtils.cryptPassword( cl ) );\n        getLogger().info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n        int exitCode;\n\n        try\n        {\n            exitCode = SvnCommandLineUtils.execute( cl, stdout, stderr, getLogger() );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            // TODO: Improve this error message\n            return new TagScmResult( cl.toString(), \"The svn tag command failed.\", stderr.getOutput(), false );\n        }\n\n        List fileList = new ArrayList();\n\n        List files = null;\n\n        try\n        {\n            files = FileUtils.getFiles( fileSet.getBasedir(), \"**\", \"**/.svn/**\", false );\n        }\n        catch ( IOException e )\n        {\n            throw new ScmException( \"Error while executing command.\", e );\n        }\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File f = (File) i.next();\n\n            fileList.add( new ScmFile( f.getPath(), ScmFileStatus.TAGGED ) );\n        }\n\n        return new TagScmResult( cl.toString(), fileList );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                  String tag, File messageFile )\n    {\n        Commandline cl = SvnCommandLineUtils.getBaseSvnCommandLine( workingDirectory, repository );\n\n        cl.createArgument().setValue( \"copy\" );\n\n        cl.createArgument().setValue( \"--file\" );\n\n        cl.createArgument().setValue( messageFile.getAbsolutePath() );\n\n        cl.createArgument().setValue( \".\" );\n\n        // Note: this currently assumes you have the tag base checked out too\n        String tagUrl = SvnTagBranchUtils.resolveTagUrl( repository, tag );\n        cl.createArgument().setValue( SvnCommandUtils.fixUrl( tagUrl, repository.getUser() ) );\n\n        return cl;\n    }\n}\n","lineNo":149}
{"Smelly Sample":"package org.apache.maven.scm.provider.vss.commands;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.vss.repository.VssScmProviderRepository;\nimport org.apache.maven.scm.providers.vss.settings.Settings;\nimport org.apache.maven.scm.providers.vss.settings.io.xpp3.VssXpp3Reader;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class VssCommandLineUtils\n    implements VssConstants\n{\n    public static void addFiles( Commandline cl, File[] files )\n    {\n        for ( int i = 0; i < files.length; i++ )\n        {\n            cl.createArgument().setValue( files[i].getPath().replace( '\\\\', '/' ) );\n        }\n    }\n\n    public static Commandline getBaseSvnCommandLine( File workingDirectory, String cmd,\n                                                     VssScmProviderRepository repository )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( VssConstants.SS_EXE );\n\n        cl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n\n        if ( !StringUtils.isEmpty( repository.getUser() ) )\n        {\n            cl.createArgument().setValue( \"-Y\" );\n\n            StringBuffer sb = new StringBuffer( repository.getUser() );\n            if ( !StringUtils.isEmpty( repository.getPassword() ) )\n            {\n                sb.append( \",\" ).append( repository.getPassword() );\n            }\n            cl.createArgument().setValue( sb.toString() );\n        }\n\n        return cl;\n    }\n\n    public static int executeCommandline( Commandline cl, StreamConsumer consumer,\n                                          CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws ScmException\n    {\n        try\n        {\n            logger.info( \"Executing: \" + cl );\n            logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n            return CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n    }\n\n\n    public static final Settings getSettings()\n    {\n        Settings settings = null;\n        File scmUserHome = new File( System.getProperty( \"user.home\" ), \".scm\" );\n        File settingsFile = new File( scmUserHome, \"vss-settings.xml\" );\n        if ( settingsFile.exists() )\n        {\n            VssXpp3Reader reader = new VssXpp3Reader();\n            try\n            {\n                settings = reader.read( new FileReader( settingsFile ) );\n            }\n            catch ( FileNotFoundException e )\n            {\n            }\n            catch ( IOException e )\n            {\n            }\n            catch ( XmlPullParserException e )\n            {\n                String message = settingsFile.getAbsolutePath() + \" isn't well formed. SKIPPED.\" + e.getMessage();\n\n                System.out.println( message );\n            }\n        }\n        return settings;\n    }\n\n    public static final String getSsDir()\n    {\n        String ssDir = \"\";\n        if ( VssCommandLineUtils.getSettings() != null )\n        {\n            ssDir = VssCommandLineUtils.getSettings().getVssDirectory();\n\n            ssDir = StringUtils.replace( ssDir, \"\\\\\", \"/\" );\n\n            if ( !ssDir.endsWith( \"/\" ) )\n            {\n                ssDir += \"/\";\n            }\n        }\n        return ssDir;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.vss.commands;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.vss.repository.VssScmProviderRepository;\nimport org.apache.maven.scm.providers.vss.settings.Settings;\nimport org.apache.maven.scm.providers.vss.settings.io.xpp3.VssXpp3Reader;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\n// FIXME extend CommandLineUtils\npublic class VssCommandLineUtils\n    implements VssConstants\n{\n    public static void addFiles( Commandline cl, File[] files )\n    {\n        for ( int i = 0; i < files.length; i++ )\n        {\n            cl.createArgument().setValue( files[i].getPath().replace( '\\\\', '/' ) );\n        }\n    }\n\n    public static Commandline getBaseVssCommandLine( File workingDirectory, String cmd,\n                                                     VssScmProviderRepository repository )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( VssConstants.SS_EXE );\n\n        cl.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n\n        if ( !StringUtils.isEmpty( repository.getUser() ) )\n        {\n            cl.createArgument().setValue( \"-Y\" );\n\n            StringBuffer sb = new StringBuffer( repository.getUser() );\n            if ( !StringUtils.isEmpty( repository.getPassword() ) )\n            {\n                sb.append( \",\" ).append( repository.getPassword() );\n            }\n            cl.createArgument().setValue( sb.toString() );\n        }\n\n        return cl;\n    }\n\n    public static int executeCommandline( Commandline cl, StreamConsumer consumer,\n                                          CommandLineUtils.StringStreamConsumer stderr, ScmLogger logger )\n        throws ScmException\n    {\n        try\n        {\n            logger.info( \"Executing: \" + cl );\n            logger.info( \"Working directory: \" + cl.getWorkingDirectory().getAbsolutePath() );\n\n            int exitcode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n            \n            logger.debug( \"VSS Command Exit_Code: \" + exitcode );\n\n            return exitcode;\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n    }\n\n\n    public static final Settings getSettings()\n    {\n        Settings settings = null;\n        File scmUserHome = new File( System.getProperty( \"user.home\" ), \".scm\" );\n        File settingsFile = new File( scmUserHome, \"vss-settings.xml\" );\n        if ( settingsFile.exists() )\n        {\n            VssXpp3Reader reader = new VssXpp3Reader();\n            try\n            {\n                settings = reader.read( new FileReader( settingsFile ) );\n            }\n            catch ( FileNotFoundException e )\n            {\n            }\n            catch ( IOException e )\n            {\n            }\n            catch ( XmlPullParserException e )\n            {\n                String message = settingsFile.getAbsolutePath() + \" isn't well formed. SKIPPED.\" + e.getMessage();\n\n                System.out.println( message );\n            }\n        }\n        return settings;\n    }\n\n    public static final String getSsDir()\n    {\n        String ssDir = \"\";\n        if ( VssCommandLineUtils.getSettings() != null )\n        {\n            ssDir = VssCommandLineUtils.getSettings().getVssDirectory();\n\n            ssDir = StringUtils.replace( ssDir, \"\\\\\", \"/\" );\n\n            if ( !ssDir.endsWith( \"/\" ) )\n            {\n                ssDir += \"/\";\n            }\n        }\n        return ssDir;\n    }\n}\n","lineNo":81}
{"Smelly Sample":"package org.apache.maven.scm.plugin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\n\n/**\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n * @goal tag\n * @description Tag the project\n */\npublic class TagMojo\n    extends AbstractScmMojo\n{\n    /**\n     * @parameter expression=\"${tag}\n     */\n    private String tag;\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            ScmRepository repository = getScmRepository();\n\n            TagScmResult result =\n                getScmManager().getProviderByRepository( repository ).tag( repository, getFileSet(), tag );\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run checkout command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run checkout command : \", e );\n        }\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.plugin;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @author <a href=\"evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"saden1@gmil.com\">Sharmarke Aden<\/a>\n * \n * @version $Id$\n * @goal tag\n * @description Tag the project\n */\npublic class TagMojo\n    extends AbstractScmMojo {\n    /**\n     * @parameter expression=\"${tag}\"\n     */\n    private String tag;\n\n    /**\n     * @parameter expression=\"${timestampFormat}\" default-value=\"yyyyMMddHHmmss\"\n     */\n    private String timestampFormat;\n\n    /**\n     * @parameter expression=\"${addTimestamp}\" default-value=\"false\"\n     */\n    private boolean addTimestamp;\n\n    /**\n     * @parameter expression=\"${timestampPrefix}\" default-value=\"-\"\n     */\n    private String timestampPrefix;\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            SimpleDateFormat dateFormat = null;\n            String tagTimestamp = \"\";\n            String finalTag = tag;\n\n            if ( addTimestamp )\n            {\n                try\n                {\n                    getLog().info( \"Using timestamp pattern '\" + timestampFormat + \"'\" );\n                    dateFormat = new SimpleDateFormat( timestampFormat );\n                    tagTimestamp = dateFormat.format( new Date() );\n                    getLog().info( \"Using timestamp '\" + tagTimestamp + \"'\" );\n                }\n                catch ( IllegalArgumentException e )\n                {\n                    String msg = \"The timestamp format '\" + timestampFormat + \"' is invalid.\";\n                    getLog().error( msg, e );\n                    throw new MojoExecutionException( msg, e );\n                }\n\n                finalTag += timestampPrefix + tagTimestamp;\n                getLog().info( \"Final Tag Name'\" + finalTag + \"'\" );\n\n            }\n\n            ScmRepository repository = getScmRepository();\n\n            TagScmResult result = \n                getScmManager().getProviderByRepository( repository ).tag( repository, getFileSet(), finalTag );\n\n            checkResult( result );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n        catch ( ScmException e )\n        {\n            throw new MojoExecutionException( \"Cannot run tag command : \", e );\n        }\n    }\n}\n","lineNo":65}
{"Smelly Sample":"package org.apache.maven.scm.provider.bazaar.command.changelog;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.bazaar.BazaarUtils;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements BazaarCommand\n{\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, String branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        String[] cmd = new String[]{LOG_CMD, VERBOSE_OPTION};\n        BazaarChangeLogConsumer consumer =\n            new BazaarChangeLogConsumer( getLogger(), datePattern, fileSet.getBasedir() );\n        ScmResult result = BazaarUtils.execute( consumer, getLogger(), fileSet.getBasedir(), cmd );\n\n        List logEntries = consumer.getModifications();\n        List inRange = new ArrayList();\n        startDate = startDate == null ? new Date( 0 ) : startDate; //From 1. Jan 1970\n        endDate = endDate == null ? new Date() : endDate; //Upto now\n\n        for ( Iterator it = logEntries.iterator(); it.hasNext(); )\n        {\n            ChangeSet change = (ChangeSet) it.next();\n            if ( startDate != null )\n            {\n                if ( !change.getDate().before( startDate ) && !change.getDate().after( endDate ) )\n                {\n                    inRange.add( change );\n                }\n            }\n        }\n\n        return new ChangeLogScmResult( new ChangeLogSet( inRange, startDate, endDate ), result );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.bazaar.command.changelog;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.bazaar.BazaarUtils;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements BazaarCommand\n{\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, String branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        String[] cmd = new String[]{LOG_CMD, VERBOSE_OPTION};\n        BazaarChangeLogConsumer consumer =\n            new BazaarChangeLogConsumer( getLogger(), datePattern, fileSet.getBasedir() );\n        ScmResult result = BazaarUtils.execute( consumer, getLogger(), fileSet.getBasedir(), cmd );\n\n        List logEntries = consumer.getModifications();\n        List inRangeAndValid = new ArrayList();\n        startDate = startDate == null ? new Date( 0 ) : startDate; //From 1. Jan 1970\n        endDate = endDate == null ? new Date() : endDate; //Upto now\n\n        getLogger().info(startDate.toString());\n        getLogger().info(endDate.toString());\n        for ( Iterator it = logEntries.iterator(); it.hasNext(); )\n        {\n            ChangeSet change = (ChangeSet) it.next();\n            if ( change.getFiles().size() > 0)\n            {\n                if ( !change.getDate().before( startDate ) && !change.getDate().after( endDate ) )\n                {\n                    inRangeAndValid.add( change );\n                }\n            }\n        }\n\n        getLogger().info(\"Got \" + inRangeAndValid.size() + \" of \" + logEntries.size()  + \" log entries\");\n        ChangeLogSet changeLogSet = new ChangeLogSet( inRangeAndValid, startDate, endDate );\n        return new ChangeLogScmResult(changeLogSet, result );\n    }\n}\n","lineNo":72}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.cvslib.AbstractCvsScmTest;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsScmProviderRepositoryTest\n    extends AbstractCvsScmTest\n{\n    private ScmManager scmManager;\n\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = getScmManager();\n    }\n\n    public void testParseConnectionFromPath()\n        throws Exception\n    {\n        TestCvsScmProvider provider = new TestCvsScmProvider();\n\n        CvsScmProviderRepository repo = (CvsScmProviderRepository) provider\n            .makeProviderScmRepository( getTestFile( \"src/test/resources/checkoutdir\" ) );\n\n        assertEquals( \"ext\", repo.getTransport() );\n\n        assertEquals( \"evenisse\", repo.getUser() );\n\n        assertEquals( \"cvs.surefire.codehaus.org\", repo.getHost() );\n\n        assertEquals( \"/home/projects/surefire/scm\", repo.getPath() );\n\n        assertEquals( \"surefire\", repo.getModule() );\n    }\n\n    public void testParseRemotePserverConnection()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs@cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithUsernameDefinedInScmRepository()\n        throws Exception\n    {\n        String url = \"pserver:cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url );\n\n        repo.setUser( \"myusername\" );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"myusername\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:myusername@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:myusername@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithoutUsername()\n        throws Exception\n    {\n        String url = \"pserver:cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url );\n\n        try\n        {\n            repo.getCvsRoot();\n\n            fail( \"username isn't defined.\" );\n        }\n        catch ( Exception e )\n        {\n        }\n    }\n\n    public void testParseRemotePserverConnection2()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:@cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithPort()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:@cvs.apache.org:2401:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"\", repo.getPassword() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( 2401, repo.getPort() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithPassword()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:mypassword@cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"mypassword\", repo.getPassword() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithPortAndPassword()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:mypassword@cvs.apache.org:2401:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"mypassword\", repo.getPassword() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( 2401, repo.getPort() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithBarsAsDelimiter()\n        throws Exception\n    {\n        String url = \"pserver|anoncvs@cvs.apache.org|/home/cvspublic|maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, '|' );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testIllegalRepository()\n        throws Exception\n    {\n        testIllegalUrl( \"pserver:cvs.apache.org:/home/cvspublic:maven\" );\n    }\n\n    public void testParseLocalConnection()\n        throws Exception\n    {\n        CvsScmProviderRepository repo = testUrl( \"local:/home/cvspublic:maven\" );\n\n        assertEquals( \"local\", repo.getTransport() );\n\n        assertNull( repo.getUser() );\n\n        assertNull( repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \"/home/cvspublic\", repo.getCvsRoot() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private CvsScmProviderRepository testUrl( String url, char delimiter, int nbErrorMessages )\n        throws Exception\n    {\n        assertEquals( nbErrorMessages, scmManager.validateScmRepository( \"scm:cvs\" + delimiter + url ).size() );\n\n        ScmRepository repository = scmManager.makeScmRepository( \"scm:cvs\" + delimiter + url );\n\n        assertNotNull( \"ScmManager.makeScmRepository() returned null\", repository );\n\n        assertNotNull( \"The provider repository was null.\", repository.getProviderRepository() );\n\n        assertTrue( \"The SCM Repository isn't a \" + CvsScmProviderRepository.class.getName() + \".\", repository\n            .getProviderRepository() instanceof CvsScmProviderRepository );\n\n        return (CvsScmProviderRepository) repository.getProviderRepository();\n    }\n\n    private CvsScmProviderRepository testUrl( String url )\n        throws Exception\n    {\n        return testUrl( url, ':', 0 );\n    }\n\n    private CvsScmProviderRepository testUrl( String url, char delimiter )\n        throws Exception\n    {\n        return testUrl( url, delimiter, 0 );\n    }\n\n    private void testIllegalUrl( String url )\n        throws Exception\n    {\n        try\n        {\n            testUrl( \"scm:cvs:\" + url, ':', 1 );\n\n            fail( \"Expected a ScmRepositoryException while testing the url '\" + url + \"'.\" );\n        }\n        catch ( ScmRepositoryException e )\n        {\n            // expected\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.cvslib.AbstractCvsScmTest;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsScmProviderRepositoryTest\n    extends AbstractCvsScmTest\n{\n    private ScmManager scmManager;\n\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = getScmManager();\n    }\n\n    public void testParseConnectionFromPath()\n        throws Exception\n    {\n        TestCvsScmProvider provider = new TestCvsScmProvider();\n\n        CvsScmProviderRepository repo = (CvsScmProviderRepository) provider\n            .makeProviderScmRepository( getTestFile( \"src/test/resources/checkoutdir\" ) );\n\n        assertEquals( \"ext\", repo.getTransport() );\n\n        assertEquals( \"evenisse\", repo.getUser() );\n\n        assertEquals( \"cvs.surefire.codehaus.org\", repo.getHost() );\n\n        assertEquals( \"/home/projects/surefire/scm\", repo.getPath() );\n\n        assertEquals( \"surefire\", repo.getModule() );\n    }\n\n    public void testParseRemotePserverConnection()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs@cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithUsernameDefinedInScmRepository()\n        throws Exception\n    {\n        String url = \"pserver:cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url.replaceFirst( \":cvs\", \"@cvs\" ) );\n\n        repo.setUser( \"myusername\" );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"myusername\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:myusername@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:myusername@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithoutUsername()\n        throws Exception\n    {\n        String url = \"pserver:cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url.replaceFirst( \":cvs\", \"@cvs\" ) );\n\n        try\n        {\n            repo.getCvsRoot();\n\n            fail( \"username isn't defined.\" );\n        }\n        catch ( Exception e )\n        {\n        }\n    }\n\n    public void testParseRemotePserverConnection2()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:@cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url.replaceFirst( \":@\", \"@\" ) );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithPort()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:@cvs.apache.org:2401:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url.replaceFirst( \":2401\", \"\" ).replaceFirst( \":@\", \"@\" ) );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"\", repo.getPassword() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( 2401, repo.getPort() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithPassword()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:mypassword@cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url.replaceFirst( \":mypassword\", \"\" ) );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"mypassword\", repo.getPassword() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithPortAndPassword()\n        throws Exception\n    {\n        String url = \"pserver:anoncvs:mypassword@cvs.apache.org:2401:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url.replaceFirst( \":mypassword\", \"\" ).replaceFirst( \":2401\", \"\" ) );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"mypassword\", repo.getPassword() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( 2401, repo.getPort() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testParseRemotePserverConnectionWithBarsAsDelimiter()\n        throws Exception\n    {\n        String url = \"pserver|anoncvs@cvs.apache.org|/home/cvspublic|maven\";\n\n        String urlResult = \"pserver:anoncvs@cvs.apache.org:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, urlResult, '|' );\n\n        assertEquals( \"pserver\", repo.getTransport() );\n\n        assertEquals( \"anoncvs\", repo.getUser() );\n\n        assertEquals( \"cvs.apache.org\", repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:/home/cvspublic\", repo.getCvsRoot() );\n\n        assertEquals( \":pserver:anoncvs@cvs.apache.org:2401/home/cvspublic\", repo.getCvsRootForCvsPass() );\n    }\n\n    public void testIllegalRepository()\n        throws Exception\n    {\n        testIllegalUrl( \"pserver:cvs.apache.org:/home/cvspublic:maven\" );\n    }\n\n    public void testParseLocalConnection()\n        throws Exception\n    {\n        String url = \"local:/home/cvspublic:maven\";\n\n        CvsScmProviderRepository repo = testUrl( url, url );\n\n        assertEquals( \"local\", repo.getTransport() );\n\n        assertNull( repo.getUser() );\n\n        assertNull( repo.getHost() );\n\n        assertEquals( \"/home/cvspublic\", repo.getPath() );\n\n        assertEquals( \"/home/cvspublic\", repo.getCvsRoot() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    /**\n     * @param expectedUrl url that should be printed in the toString method \n     */\n    private CvsScmProviderRepository testUrl( String url, String expectedUrl, char delimiter, int nbErrorMessages )\n        throws Exception\n    {\n        assertEquals( nbErrorMessages, scmManager.validateScmRepository( \"scm:cvs\" + delimiter + url ).size() );\n\n        ScmRepository repository = scmManager.makeScmRepository( \"scm:cvs\" + delimiter + url );\n\n        assertNotNull( \"ScmManager.makeScmRepository() returned null\", repository );\n\n        assertNotNull( \"The provider repository was null.\", repository.getProviderRepository() );\n\n        assertTrue( \"The SCM Repository isn't a \" + CvsScmProviderRepository.class.getName() + \".\", repository\n            .getProviderRepository() instanceof CvsScmProviderRepository );\n        \n        assertEquals( \"cvs:\" + expectedUrl, repository.toString() );\n\n        return (CvsScmProviderRepository) repository.getProviderRepository();\n    }\n\n    private CvsScmProviderRepository testUrl( String url, String urlResult )\n        throws Exception\n    {\n        return testUrl( url, urlResult, ':', 0 );\n    }\n\n    private CvsScmProviderRepository testUrl( String url, String urlResult, char delimiter )\n        throws Exception\n    {\n        return testUrl( url, urlResult, delimiter, 0 );\n    }\n\n    private void testIllegalUrl( String url )\n        throws Exception\n    {\n        try\n        {\n            testUrl( \"scm:cvs:\" + url, null, ':', 1 );\n\n            fail( \"Expected a ScmRepositoryException while testing the url '\" + url + \"'.\" );\n        }\n        catch ( ScmRepositoryException e )\n        {\n            // expected\n        }\n    }\n\n}\n","lineNo":242}
{"Smelly Sample":"package org.apache.maven.scm.provider.bazaar.command.update;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.bazaar.BazaarUtils;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.apache.maven.scm.provider.bazaar.command.changelog.BazaarChangeLogCommand;\nimport org.apache.maven.scm.provider.bazaar.command.diff.BazaarDiffConsumer;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUpdateCommand\n    extends AbstractUpdateCommand\n    implements BazaarCommand\n{\n\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n\n        if ( !StringUtils.isEmpty( tag ) )\n        {\n            throw new ScmException( \"This provider can't handle tags.\" );\n        }\n\n        File workingDir = fileSet.getBasedir();\n\n        // Update branch\n        String[] update_cmd = new String[]{BazaarCommand.PULL_CMD};\n        ScmResult updateResult =\n            BazaarUtils.execute( new BazaarConsumer( getLogger() ), getLogger(), workingDir, update_cmd );\n\n        if ( !updateResult.isSuccess() )\n        {\n            return new UpdateScmResult( null, null, updateResult );\n        }\n\n        // Find changes from last revision\n        int prev_revi = BazaarUtils.getCurrentRevisionNumber( getLogger(), workingDir ) - 1;\n        String[] diffCmd = new String[]{DIFF_CMD, REVISION_OPTION, \"\" + prev_revi};\n        BazaarDiffConsumer diffConsumer = new BazaarDiffConsumer( getLogger(), workingDir );\n        ScmResult diffResult = BazaarUtils.execute( diffConsumer, getLogger(), workingDir, diffCmd );\n\n        // Now translate between diff and update file status\n        List updatedFiles = new ArrayList();\n        List changes = new ArrayList();\n        List diffFiles = diffConsumer.getChangedFiles();\n        Map diffChanges = diffConsumer.getDifferences();\n        for ( Iterator it = diffFiles.iterator(); it.hasNext(); )\n        {\n            ScmFile file = (ScmFile) it.next();\n            changes.add( diffChanges.get( file ) );\n            if ( file.getStatus() == ScmFileStatus.MODIFIED )\n            {\n                updatedFiles.add( new ScmFile( file.getPath(), ScmFileStatus.PATCHED ) );\n            }\n            else\n            {\n                updatedFiles.add( file );\n            }\n        }\n\n        return new UpdateScmResult( updatedFiles, changes, diffResult );\n    }\n\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        BazaarChangeLogCommand command = new BazaarChangeLogCommand();\n        command.setLogger( getLogger() );\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.bazaar.command.update;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.command.update.UpdateScmResultWithRevision;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.bazaar.BazaarUtils;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.apache.maven.scm.provider.bazaar.command.changelog.BazaarChangeLogCommand;\nimport org.apache.maven.scm.provider.bazaar.command.diff.BazaarDiffConsumer;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUpdateCommand\n    extends AbstractUpdateCommand\n    implements BazaarCommand\n{\n\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n\n        if ( !StringUtils.isEmpty( tag ) )\n        {\n            throw new ScmException( \"This provider can't handle tags.\" );\n        }\n\n        File workingDir = fileSet.getBasedir();\n\n        // Update branch\n        String[] update_cmd = new String[]{BazaarCommand.PULL_CMD};\n        ScmResult updateResult =\n            BazaarUtils.execute( new BazaarConsumer( getLogger() ), getLogger(), workingDir, update_cmd );\n\n        if ( !updateResult.isSuccess() )\n        {\n            return new UpdateScmResult( null, null, updateResult );\n        }\n\n        // Find changes from last revision\n        int currentRevision = BazaarUtils.getCurrentRevisionNumber( getLogger(), workingDir );\n        int previousRevision = currentRevision - 1;\n        String[] diffCmd = new String[]{DIFF_CMD, REVISION_OPTION, \"\" + previousRevision};\n        BazaarDiffConsumer diffConsumer = new BazaarDiffConsumer( getLogger(), workingDir );\n        ScmResult diffResult = BazaarUtils.execute( diffConsumer, getLogger(), workingDir, diffCmd );\n\n        // Now translate between diff and update file status\n        List updatedFiles = new ArrayList();\n        List changes = new ArrayList();\n        List diffFiles = diffConsumer.getChangedFiles();\n        Map diffChanges = diffConsumer.getDifferences();\n        for ( Iterator it = diffFiles.iterator(); it.hasNext(); )\n        {\n            ScmFile file = (ScmFile) it.next();\n            changes.add( diffChanges.get( file ) );\n            if ( file.getStatus() == ScmFileStatus.MODIFIED )\n            {\n                updatedFiles.add( new ScmFile( file.getPath(), ScmFileStatus.PATCHED ) );\n            }\n            else\n            {\n                updatedFiles.add( file );\n            }\n        }\n\n        return new UpdateScmResultWithRevision( updatedFiles, changes, String.valueOf( currentRevision ), diffResult );\n    }\n\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        BazaarChangeLogCommand command = new BazaarChangeLogCommand();\n        command.setLogger( getLogger() );\n        return command;\n    }\n}\n","lineNo":72}
{"Smelly Sample":"package org.apache.maven.scm.provider.clearcase.command.status;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.log.DefaultLog;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collection;\n\n/**\n * @author <a href=\"mailto:wim.deblauwe@gmail.com\">Wim Deblauwe<\/a>\n */\npublic class ClearCaseStatusConsumerTest\n    extends ScmTestCase\n{\n    public void testConsumer()\n        throws IOException\n    {\n        InputStream inputStream = getResourceAsStream( \"/clearcase/status/status.txt\" );\n\n        BufferedReader in = new BufferedReader( new InputStreamReader( inputStream ) );\n\n        String s = in.readLine();\n\n        ClearCaseStatusConsumer consumer = new ClearCaseStatusConsumer( new DefaultLog(), getWorkingDirectory() );\n\n        while ( s != null )\n        {\n            consumer.consumeLine( s );\n\n            s = in.readLine();\n        }\n\n        Collection entries = consumer.getCheckedOutFiles();\n\n        assertEquals( \"Wrong number of entries returned\", 1, entries.size() );\n\n        ScmFile scmFile = (ScmFile) entries.iterator().next();\n        assertEquals( new File( getWorkingDirectory(), \"test.java\" ).getAbsolutePath(), scmFile.getPath() );\n        assertEquals( ScmFileStatus.CHECKED_OUT, scmFile.getStatus() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.clearcase.command.status;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collection;\n\n/**\n * @author <a href=\"mailto:wim.deblauwe@gmail.com\">Wim Deblauwe<\/a>\n */\npublic class ClearCaseStatusConsumerTest\n    extends ScmTestCase\n{\n    public void testConsumer()\n        throws IOException\n    {\n        InputStream inputStream = getResourceAsStream( \"/clearcase/status/status.txt\" );\n\n        BufferedReader in = new BufferedReader( new InputStreamReader( inputStream ) );\n\n        String s = in.readLine();\n\n        ClearCaseStatusConsumer consumer = new ClearCaseStatusConsumer( new DefaultLog(), getWorkingDirectory() );\n\n        while ( s != null )\n        {\n            consumer.consumeLine( s );\n\n            s = in.readLine();\n        }\n\n        Collection entries = consumer.getCheckedOutFiles();\n\n        assertEquals( \"Wrong number of entries returned\", 1, entries.size() );\n\n        ScmFile scmFile = (ScmFile) entries.iterator().next();\n\n        String scmFilePath = StringUtils.replace( scmFile.getPath(), \"\\\\\", File.separator );\n\n        assertEquals( new File( getWorkingDirectory(), \"test.java\" ).getAbsolutePath(), scmFilePath );\n\n        assertEquals( ScmFileStatus.CHECKED_OUT, scmFile.getStatus() );\n    }\n}\n","lineNo":62}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.changelog;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Date;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class PerforceChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements PerforceCommand\n{\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, String branch,\n                                                          String datePattern )\n        throws ScmException\n    {\n        if ( StringUtils.isNotEmpty( branch ) )\n        {\n            throw new ScmException( \"This SCM doesn't support branches.\" );\n        }\n\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, fileSet.getBasedir() );\n\n        PerforceChangeLogConsumer consumer =\n            new PerforceChangeLogConsumer( startDate, endDate, datePattern, getLogger() );\n\n        try\n        {\n            getLogger().debug( PerforceScmProvider.clean( \"Executing \" + cl.toString() ) );\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e.getMessage(), e );\n        }\n\n        return new ChangeLogScmResult( cl.toString(),\n                                       new ChangeLogSet( consumer.getModifications(), startDate, endDate ) );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"filelog\" );\n        command.createArgument().setValue( \"-t\" );\n        command.createArgument().setValue( \"-l\" );\n        command.createArgument().setValue( \"...\" );\n\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.changelog;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Date;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class PerforceChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements PerforceCommand\n{\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                         Date startDate, Date endDate, String branch, String datePattern )\n        throws ScmException\n    {\n        if ( StringUtils.isNotEmpty( branch ) )\n        {\n            throw new ScmException( \"This SCM doesn't support branches.\" );\n        }\n\n        PerforceScmProviderRepository p4repo = (PerforceScmProviderRepository) repo;\n        String clientspec = System.getProperty( PerforceScmProvider.DEFAULT_CLIENTSPEC_PROPERTY );\n        Commandline cl = createCommandLine( p4repo, fileSet.getBasedir(), clientspec );\n\n        PerforceChangeLogConsumer consumer = new PerforceChangeLogConsumer( p4repo.getPath(), startDate, endDate, \n                                                                            datePattern, getLogger() );\n\n        try\n        {\n            getLogger().debug( PerforceScmProvider.clean( \"Executing \" + cl.toString() ) );\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e.getMessage(), e );\n        }\n\n        return new ChangeLogScmResult( cl.toString(),\n                                       new ChangeLogSet( consumer.getModifications(), startDate, endDate ) );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                String clientspec )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        if ( clientspec != null )\n        {\n            command.createArgument().setValue( \"-c\" );\n            command.createArgument().setValue( clientspec );\n        }\n        command.createArgument().setValue( \"filelog\" );\n        command.createArgument().setValue( \"-t\" );\n        command.createArgument().setValue( \"-l\" );\n        command.createArgument().setValue( \"...\" );\n\n        return command;\n    }\n}\n","lineNo":56}
{"Smelly Sample":"package org.apache.maven.scm.provider.bazaar;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils.StringStreamConsumer;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Common code for executing bazaar commands.\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUtils\n{\n\n    /**\n     * Map between command  and its valid exitcodes\n     */\n    private static final Map exitCodeMap = new HashMap();\n\n    /**\n     * Defualt exit codes for entries not in exitCodeMap\n     */\n    private static final List defaultExitCodes = new ArrayList();\n\n    /** Setup exit codes*/\n    static\n    {\n        defaultExitCodes.add( new Integer( 0 ) );\n\n        //Diff is different\n        List diffExitCodes = new ArrayList();\n        diffExitCodes.add( new Integer( 0 ) ); //No difference\n        diffExitCodes.add( new Integer( 1 ) ); //Difference exisits\n        exitCodeMap.put( BazaarCommand.DIFF_CMD, diffExitCodes );\n    }\n\n    public static ScmResult execute( StreamConsumer consumer, ScmLogger logger, File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        Commandline cmd = new Commandline();\n        cmd.setExecutable( BazaarCommand.EXEC );\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n        cmd.addArguments( cmdAndArgs );\n\n        if ( !workingDir.exists() )\n        {\n            boolean success = workingDir.mkdirs();\n            if ( !success )\n            {\n                throw new ScmException( \"Working directory did not exist and it couldn't be created: \" + workingDir );\n            }\n        }\n\n        logger.info( \"Executing: \" + cmd );\n        logger.info( \"Working directory: \" + workingDir.getAbsolutePath() );\n\n        final int exitCode;\n        StringStreamConsumer stderr = new StringStreamConsumer();\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cmd, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Command could not be executed: \" + cmd, ex );\n        }\n\n        List exitCodes =\n            exitCodeMap.containsKey( cmdAndArgs[0] ) ? (List) exitCodeMap.get( cmdAndArgs[0] ) : defaultExitCodes;\n        boolean success = exitCodes.contains( new Integer( exitCode ) );\n\n        return new ScmResult( cmd.toString(), \"Execution of bazaar command failed\", stderr.getOutput(), success );\n    }\n\n    public static ScmResult execute( File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        return execute( new StringStreamConsumer(), new DefaultLog(), workingDir, cmdAndArgs );\n    }\n\n    public static String[] expandCommandLine( String[] cmdAndArgs, ScmFileSet additionalFiles )\n    {\n        File[] files = additionalFiles.getFiles();\n        String[] cmd = new String[files.length + cmdAndArgs.length];\n\n        // Copy command into array\n        System.arraycopy( cmdAndArgs, 0, cmd, 0, cmdAndArgs.length );\n\n        // Add files as additional parameter into the array\n        for ( int i = 0; i < files.length; i++ )\n        {\n            String file = files[i].getPath().replace( '\\\\', File.separatorChar );\n            cmd[i + cmdAndArgs.length] = file;\n        }\n\n        return cmd;\n    }\n\n    public static int getCurrentRevisionNumber( ScmLogger logger, File workingDir )\n        throws ScmException\n    {\n\n        String[] revCmd = new String[]{BazaarCommand.REVNO_CMD};\n        BazaarRevNoConsumer consumer = new BazaarRevNoConsumer( logger );\n        BazaarUtils.execute( consumer, logger, workingDir, revCmd );\n\n        return consumer.getCurrentRevisionNumber();\n    }\n\n    /**\n     * Get current (working) revision.\n     * <p/>\n     * Resolves revision to the last integer found in the command output.\n     */\n    private static class BazaarRevNoConsumer\n        extends BazaarConsumer\n    {\n\n        private int revNo;\n\n        BazaarRevNoConsumer( ScmLogger logger )\n        {\n            super( logger );\n        }\n\n        public void doConsume( ScmFileStatus status, String line )\n        {\n            try\n            {\n                revNo = Integer.valueOf( line ).intValue();\n            }\n            catch ( NumberFormatException e )\n            {\n                // ignore\n            }\n        }\n\n        int getCurrentRevisionNumber()\n        {\n            return revNo;\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.bazaar;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * Common code for executing bazaar commands.\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUtils\n{\n\n    /**\n     * Map between command and its valid exit codes\n     */\n    private static final Map exitCodeMap = new HashMap();\n\n    /**\n     * Default exit codes for entries not in exitCodeMap\n     */\n    private static final List defaultExitCodes = new ArrayList();\n\n    /** Setup exit codes*/\n    static\n    {\n        defaultExitCodes.add( new Integer( 0 ) );\n\n        //Diff is different\n        List diffExitCodes = new ArrayList();\n        diffExitCodes.add( new Integer( 0 ) ); //No difference\n        diffExitCodes.add( new Integer( 1 ) ); //Difference exisits\n        exitCodeMap.put( BazaarCommand.DIFF_CMD, diffExitCodes );\n    }\n\n    public static ScmResult execute( BazaarConsumer consumer, ScmLogger logger, File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        Commandline cmd = new Commandline();\n        cmd.setExecutable( BazaarCommand.EXEC );\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n        cmd.addArguments( cmdAndArgs );\n\n        if ( !workingDir.exists() )\n        {\n            boolean success = workingDir.mkdirs();\n            if ( !success )\n            {\n                String msg = \"Working directory did not exist and it couldn't be created: \" + workingDir;\n                throw new ScmException( msg );\n            }\n        }\n\n        logger.info( \"Executing: \" + cmd );\n        logger.info( \"Working directory: \" + workingDir.getAbsolutePath() );\n\n        final int exitCode;\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cmd, consumer, consumer );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Command could not be executed: \" + cmd, ex );\n        }\n\n        List exitCodes = exitCodeMap.containsKey( cmdAndArgs[0] ) ? (List) exitCodeMap.get( cmdAndArgs[0] )\n                                                                 : defaultExitCodes;\n        boolean success = exitCodes.contains( new Integer( exitCode ) );\n\n        String providerMsg = \"Execution of bazaar command: \" + ( success ? \"succeded\" : \"failed\" );\n        return new ScmResult( cmd.toString(), providerMsg, consumer.getStdErr(), success );\n    }\n\n    public static ScmResult execute( File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        ScmLogger logger = new DefaultLog();\n        return execute( new BazaarConsumer(logger), logger, workingDir, cmdAndArgs );\n    }\n\n    public static String[] expandCommandLine( String[] cmdAndArgs, ScmFileSet additionalFiles )\n    {\n        File[] files = additionalFiles.getFiles();\n        String[] cmd = new String[files.length + cmdAndArgs.length];\n\n        // Copy command into array\n        System.arraycopy( cmdAndArgs, 0, cmd, 0, cmdAndArgs.length );\n\n        // Add files as additional parameter into the array\n        for ( int i = 0; i < files.length; i++ )\n        {\n            String file = files[i].getPath().replace( '\\\\', File.separatorChar );\n            cmd[i + cmdAndArgs.length] = file;\n        }\n\n        return cmd;\n    }\n\n    public static int getCurrentRevisionNumber( ScmLogger logger, File workingDir )\n        throws ScmException\n    {\n\n        String[] revCmd = new String[] { BazaarCommand.REVNO_CMD };\n        BazaarRevNoConsumer consumer = new BazaarRevNoConsumer( logger );\n        BazaarUtils.execute( consumer, logger, workingDir, revCmd );\n\n        return consumer.getCurrentRevisionNumber();\n    }\n\n    /**\n     * Get current (working) revision.\n     * <p/>\n     * Resolve revision to the last integer found in the command output.\n     */\n    private static class BazaarRevNoConsumer\n        extends BazaarConsumer\n    {\n\n        private int revNo;\n\n        BazaarRevNoConsumer( ScmLogger logger )\n        {\n            super( logger );\n        }\n\n        public void doConsume( ScmFileStatus status, String line )\n        {\n            try\n            {\n                revNo = Integer.valueOf( line ).intValue();\n            }\n            catch ( NumberFormatException e )\n            {\n                // ignore\n            }\n        }\n\n        int getCurrentRevisionNumber()\n        {\n            return revNo;\n        }\n    }\n}\n","lineNo":109}
{"Smelly Sample":"package org.apache.maven.scm.provider.bazaar;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.CommandLineUtils.StringStreamConsumer;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Common code for executing bazaar commands.\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUtils\n{\n\n    /**\n     * Map between command  and its valid exitcodes\n     */\n    private static final Map exitCodeMap = new HashMap();\n\n    /**\n     * Defualt exit codes for entries not in exitCodeMap\n     */\n    private static final List defaultExitCodes = new ArrayList();\n\n    /** Setup exit codes*/\n    static\n    {\n        defaultExitCodes.add( new Integer( 0 ) );\n\n        //Diff is different\n        List diffExitCodes = new ArrayList();\n        diffExitCodes.add( new Integer( 0 ) ); //No difference\n        diffExitCodes.add( new Integer( 1 ) ); //Difference exisits\n        exitCodeMap.put( BazaarCommand.DIFF_CMD, diffExitCodes );\n    }\n\n    public static ScmResult execute( StreamConsumer consumer, ScmLogger logger, File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        Commandline cmd = new Commandline();\n        cmd.setExecutable( BazaarCommand.EXEC );\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n        cmd.addArguments( cmdAndArgs );\n\n        if ( !workingDir.exists() )\n        {\n            boolean success = workingDir.mkdirs();\n            if ( !success )\n            {\n                throw new ScmException( \"Working directory did not exist and it couldn't be created: \" + workingDir );\n            }\n        }\n\n        logger.info( \"Executing: \" + cmd );\n        logger.info( \"Working directory: \" + workingDir.getAbsolutePath() );\n\n        final int exitCode;\n        StringStreamConsumer stderr = new StringStreamConsumer();\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cmd, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Command could not be executed: \" + cmd, ex );\n        }\n\n        List exitCodes =\n            exitCodeMap.containsKey( cmdAndArgs[0] ) ? (List) exitCodeMap.get( cmdAndArgs[0] ) : defaultExitCodes;\n        boolean success = exitCodes.contains( new Integer( exitCode ) );\n\n        return new ScmResult( cmd.toString(), \"Execution of bazaar command failed\", stderr.getOutput(), success );\n    }\n\n    public static ScmResult execute( File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        return execute( new StringStreamConsumer(), new DefaultLog(), workingDir, cmdAndArgs );\n    }\n\n    public static String[] expandCommandLine( String[] cmdAndArgs, ScmFileSet additionalFiles )\n    {\n        File[] files = additionalFiles.getFiles();\n        String[] cmd = new String[files.length + cmdAndArgs.length];\n\n        // Copy command into array\n        System.arraycopy( cmdAndArgs, 0, cmd, 0, cmdAndArgs.length );\n\n        // Add files as additional parameter into the array\n        for ( int i = 0; i < files.length; i++ )\n        {\n            String file = files[i].getPath().replace( '\\\\', File.separatorChar );\n            cmd[i + cmdAndArgs.length] = file;\n        }\n\n        return cmd;\n    }\n\n    public static int getCurrentRevisionNumber( ScmLogger logger, File workingDir )\n        throws ScmException\n    {\n\n        String[] revCmd = new String[]{BazaarCommand.REVNO_CMD};\n        BazaarRevNoConsumer consumer = new BazaarRevNoConsumer( logger );\n        BazaarUtils.execute( consumer, logger, workingDir, revCmd );\n\n        return consumer.getCurrentRevisionNumber();\n    }\n\n    /**\n     * Get current (working) revision.\n     * <p/>\n     * Resolves revision to the last integer found in the command output.\n     */\n    private static class BazaarRevNoConsumer\n        extends BazaarConsumer\n    {\n\n        private int revNo;\n\n        BazaarRevNoConsumer( ScmLogger logger )\n        {\n            super( logger );\n        }\n\n        public void doConsume( ScmFileStatus status, String line )\n        {\n            try\n            {\n                revNo = Integer.valueOf( line ).intValue();\n            }\n            catch ( NumberFormatException e )\n            {\n                // ignore\n            }\n        }\n\n        int getCurrentRevisionNumber()\n        {\n            return revNo;\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.bazaar;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * Common code for executing bazaar commands.\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUtils\n{\n\n    /**\n     * Map between command and its valid exit codes\n     */\n    private static final Map exitCodeMap = new HashMap();\n\n    /**\n     * Default exit codes for entries not in exitCodeMap\n     */\n    private static final List defaultExitCodes = new ArrayList();\n\n    /** Setup exit codes*/\n    static\n    {\n        defaultExitCodes.add( new Integer( 0 ) );\n\n        //Diff is different\n        List diffExitCodes = new ArrayList();\n        diffExitCodes.add( new Integer( 0 ) ); //No difference\n        diffExitCodes.add( new Integer( 1 ) ); //Difference exisits\n        exitCodeMap.put( BazaarCommand.DIFF_CMD, diffExitCodes );\n    }\n\n    public static ScmResult execute( BazaarConsumer consumer, ScmLogger logger, File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        Commandline cmd = new Commandline();\n        cmd.setExecutable( BazaarCommand.EXEC );\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n        cmd.addArguments( cmdAndArgs );\n\n        if ( !workingDir.exists() )\n        {\n            boolean success = workingDir.mkdirs();\n            if ( !success )\n            {\n                String msg = \"Working directory did not exist and it couldn't be created: \" + workingDir;\n                throw new ScmException( msg );\n            }\n        }\n\n        logger.info( \"Executing: \" + cmd );\n        logger.info( \"Working directory: \" + workingDir.getAbsolutePath() );\n\n        final int exitCode;\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cmd, consumer, consumer );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Command could not be executed: \" + cmd, ex );\n        }\n\n        List exitCodes = exitCodeMap.containsKey( cmdAndArgs[0] ) ? (List) exitCodeMap.get( cmdAndArgs[0] )\n                                                                 : defaultExitCodes;\n        boolean success = exitCodes.contains( new Integer( exitCode ) );\n\n        String providerMsg = \"Execution of bazaar command: \" + ( success ? \"succeded\" : \"failed\" );\n        return new ScmResult( cmd.toString(), providerMsg, consumer.getStdErr(), success );\n    }\n\n    public static ScmResult execute( File workingDir, String[] cmdAndArgs )\n        throws ScmException\n    {\n        ScmLogger logger = new DefaultLog();\n        return execute( new BazaarConsumer(logger), logger, workingDir, cmdAndArgs );\n    }\n\n    public static String[] expandCommandLine( String[] cmdAndArgs, ScmFileSet additionalFiles )\n    {\n        File[] files = additionalFiles.getFiles();\n        String[] cmd = new String[files.length + cmdAndArgs.length];\n\n        // Copy command into array\n        System.arraycopy( cmdAndArgs, 0, cmd, 0, cmdAndArgs.length );\n\n        // Add files as additional parameter into the array\n        for ( int i = 0; i < files.length; i++ )\n        {\n            String file = files[i].getPath().replace( '\\\\', File.separatorChar );\n            cmd[i + cmdAndArgs.length] = file;\n        }\n\n        return cmd;\n    }\n\n    public static int getCurrentRevisionNumber( ScmLogger logger, File workingDir )\n        throws ScmException\n    {\n\n        String[] revCmd = new String[] { BazaarCommand.REVNO_CMD };\n        BazaarRevNoConsumer consumer = new BazaarRevNoConsumer( logger );\n        BazaarUtils.execute( consumer, logger, workingDir, revCmd );\n\n        return consumer.getCurrentRevisionNumber();\n    }\n\n    /**\n     * Get current (working) revision.\n     * <p/>\n     * Resolve revision to the last integer found in the command output.\n     */\n    private static class BazaarRevNoConsumer\n        extends BazaarConsumer\n    {\n\n        private int revNo;\n\n        BazaarRevNoConsumer( ScmLogger logger )\n        {\n            super( logger );\n        }\n\n        public void doConsume( ScmFileStatus status, String line )\n        {\n            try\n            {\n                revNo = Integer.valueOf( line ).intValue();\n            }\n            catch ( NumberFormatException e )\n            {\n                // ignore\n            }\n        }\n\n        int getCurrentRevisionNumber()\n        {\n            return revNo;\n        }\n    }\n}\n","lineNo":80}
{"Smelly Sample":"package org.apache.maven.scm.provider.bazaar.command.update;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.bazaar.BazaarUtils;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.apache.maven.scm.provider.bazaar.command.changelog.BazaarChangeLogCommand;\nimport org.apache.maven.scm.provider.bazaar.command.diff.BazaarDiffConsumer;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUpdateCommand\n    extends AbstractUpdateCommand\n    implements BazaarCommand\n{\n\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n\n        if ( !StringUtils.isEmpty( tag ) )\n        {\n            throw new ScmException( \"This provider can't handle tags.\" );\n        }\n\n        File workingDir = fileSet.getBasedir();\n\n        // Update branch\n        String[] update_cmd = new String[]{BazaarCommand.PULL_CMD};\n        ScmResult updateResult =\n            BazaarUtils.execute( new BazaarConsumer( getLogger() ), getLogger(), workingDir, update_cmd );\n\n        if ( !updateResult.isSuccess() )\n        {\n            return wrapResult( new ArrayList(), updateResult );\n        }\n\n        // Find changes from last revision\n        int prev_revi = BazaarUtils.getCurrentRevisionNumber( getLogger(), workingDir ) - 1;\n        String[] diff_cmd = new String[]{DIFF_CMD, REVISION_OPTION, \"\" + prev_revi};\n        BazaarDiffConsumer diff_consumer = new BazaarDiffConsumer( getLogger(), workingDir );\n        ScmResult diffResult = BazaarUtils.execute( diff_consumer, getLogger(), workingDir, diff_cmd );\n\n        // Now translate between diff and update file status\n        List updatedFiles = new ArrayList();\n        for ( Iterator it = diff_consumer.getChangedFiles().iterator(); it.hasNext(); )\n        {\n            ScmFile file = (ScmFile) it.next();\n            if ( file.getStatus() == ScmFileStatus.MODIFIED )\n            {\n                updatedFiles.add( new ScmFile( file.getPath(), ScmFileStatus.PATCHED ) );\n            }\n            else\n            {\n                updatedFiles.add( file );\n            }\n        }\n\n        return wrapResult( updatedFiles, diffResult );\n    }\n\n    private UpdateScmResult wrapResult( List files, ScmResult baseResult )\n    {\n        UpdateScmResult result;\n        if ( baseResult.isSuccess() )\n        {\n            result = new UpdateScmResult( baseResult.getCommandLine(), files );\n        }\n        else\n        {\n            result = new UpdateScmResult( baseResult.getCommandLine(), baseResult.getProviderMessage(), baseResult\n                .getCommandOutput(), baseResult.isSuccess() );\n        }\n        return result;\n    }\n\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        BazaarChangeLogCommand command = new BazaarChangeLogCommand();\n        command.setLogger( getLogger() );\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.bazaar.command.update;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogCommand;\nimport org.apache.maven.scm.command.update.AbstractUpdateCommand;\nimport org.apache.maven.scm.command.update.UpdateScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.bazaar.BazaarUtils;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarCommand;\nimport org.apache.maven.scm.provider.bazaar.command.BazaarConsumer;\nimport org.apache.maven.scm.provider.bazaar.command.changelog.BazaarChangeLogCommand;\nimport org.apache.maven.scm.provider.bazaar.command.diff.BazaarDiffConsumer;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbjrn Eikli Smrgrav<\/a>\n */\npublic class BazaarUpdateCommand\n    extends AbstractUpdateCommand\n    implements BazaarCommand\n{\n\n    protected UpdateScmResult executeUpdateCommand( ScmProviderRepository repo,\n                                                    ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n\n        if ( !StringUtils.isEmpty( tag ) )\n        {\n            throw new ScmException( \"This provider can't handle tags.\" );\n        }\n\n        File workingDir = fileSet.getBasedir();\n\n        // Update branch\n        String[] update_cmd = new String[]{BazaarCommand.PULL_CMD};\n        ScmResult updateResult =\n            BazaarUtils.execute( new BazaarConsumer( getLogger() ), getLogger(),\n                                 workingDir, update_cmd );\n\n        if ( !updateResult.isSuccess() )\n        {\n            return new UpdateScmResult( null, null, updateResult );\n        }\n\n        // Find changes from last revision\n        int prev_revi = BazaarUtils.getCurrentRevisionNumber( getLogger(), workingDir ) - 1;\n        String[] diffCmd = new String[]{DIFF_CMD, REVISION_OPTION, \"\" + prev_revi};\n        BazaarDiffConsumer diffConsumer = new BazaarDiffConsumer( getLogger(), workingDir );\n        ScmResult diffResult = BazaarUtils.execute( diffConsumer, getLogger(), workingDir, diffCmd );\n\n        // Now translate between diff and update file status\n        List updatedFiles = new ArrayList();\n        List changes = new ArrayList();\n        List diffFiles = diffConsumer.getChangedFiles();\n        Map diffChanges = diffConsumer.getDifferences();\n        for ( Iterator it = diffFiles.iterator(); it.hasNext(); )\n        {\n            ScmFile file = (ScmFile) it.next();\n            changes.add(diffChanges.get(file));\n            if ( file.getStatus() == ScmFileStatus.MODIFIED )\n            {\n                updatedFiles.add( new ScmFile( file.getPath(), ScmFileStatus.PATCHED ) );\n            }\n            else\n            {\n                updatedFiles.add( file );\n            }\n        }\n\n        return new UpdateScmResult( updatedFiles, changes, diffResult );\n    }\n\n    protected ChangeLogCommand getChangeLogCommand()\n    {\n        BazaarChangeLogCommand command = new BazaarChangeLogCommand();\n        command.setLogger( getLogger() );\n        return command;\n    }\n}\n","lineNo":80}
{"Smelly Sample":"package org.apache.maven.scm.tck.command.diff;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.command.add.AddScmResult;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.codehaus.plexus.PlexusTestCase;\nimport org.codehaus.plexus.util.FileUtils;\n\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeSet;\n\n/**\n * This test tests the diff command.\n *\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @version $Id$\n */\npublic abstract class DiffCommandTckTest\n    extends ScmTestCase\n{\n    // ----------------------------------------------------------------------\n    // Methods the test has to implement\n    // ----------------------------------------------------------------------\n\n    public abstract String getScmUrl()\n        throws Exception;\n\n    /**\n     * Copy the existing checked in repository to the working directory.\n     * <p/>\n     * (src/test/repository/my-cvs-repository)\n     *\n     * @throws Exception\n     */\n    public abstract void initRepo()\n        throws Exception;\n\n    private void checkOut( File workingDirectory, ScmRepository repository )\n        throws Exception\n    {\n        CheckOutScmResult result = getScmManager().getProviderByUrl( getScmUrl() )\n            .checkOut( repository, new ScmFileSet( workingDirectory ), null );\n\n        assertTrue( \"Check result was successful, output: \" + result.getCommandOutput(), result.isSuccess() );\n    }\n\n    private void addToRepository( File workingDirectory, File file, ScmRepository repository )\n        throws Exception\n    {\n        AddScmResult result =\n            getScmManager().getProviderByUrl( getScmUrl() ).add( repository, new ScmFileSet( workingDirectory, file ) );\n        assertTrue( \"Check result was successful, output: \" + result.getCommandOutput(), result.isSuccess() );\n\n        List addedFiles = result.getAddedFiles();\n\n        assertEquals( \"Expected 1 files in the added files list \" + addedFiles, 1, addedFiles.size() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Directories the test must use\n    // ----------------------------------------------------------------------\n\n    protected File getRepositoryRoot()\n    {\n        return PlexusTestCase.getTestFile( \"target/scm-test/repository\" );\n    }\n\n    protected File getWorkingCopy()\n    {\n        return PlexusTestCase.getTestFile( \"target/scm-test/working-copy\" );\n    }\n\n    protected File getUpdatingCopy()\n    {\n        return PlexusTestCase.getTestFile( \"target/scm-test/updating-copy\" );\n    }\n\n    // ----------------------------------------------------------------------\n    // The test implementation\n    // ----------------------------------------------------------------------\n\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        FileUtils.deleteDirectory( getRepositoryRoot() );\n\n        FileUtils.deleteDirectory( getWorkingCopy() );\n\n        FileUtils.deleteDirectory( getUpdatingCopy() );\n\n        initRepo();\n    }\n\n    public void testDiffCommand()\n        throws Exception\n    {\n        ScmRepository repository = makeScmRepository( getScmUrl() );\n\n        checkOut( getWorkingCopy(), repository );\n\n        // ----------------------------------------------------------------------\n        // Assert that the required files is there\n        // ----------------------------------------------------------------------\n\n        assertFile( getWorkingCopy(), \"/pom.xml\" );\n\n        assertFile( getWorkingCopy(), \"/readme.txt\" );\n\n        assertFile( getWorkingCopy(), \"/src/main/java/Application.java\" );\n\n        assertFile( getWorkingCopy(), \"/src/test/java/Test.java\" );\n\n        // ----------------------------------------------------------------------\n        // Change the files\n        // ----------------------------------------------------------------------\n\n        //\n        // readme.txt is changed (changed file in the root directory)\n        // project.xml is added (added file in the root directory)\n        // src/test/resources is untouched (a empty directory is left untouched)\n        // src/test/java is untouched (a non empty directory is left untouched)\n        // src/test/java/org (a empty directory is added)\n        // src/main/java/org/Foo.java (a non empty directory is added)\n        //\n\n        // /readme.txt\n        ScmTestCase.makeFile( getWorkingCopy(), \"/readme.txt\", \"changed readme.txt\" );\n\n        // /project.xml\n        ScmTestCase.makeFile( getWorkingCopy(), \"/project.xml\", \"changed project.xml\" );\n\n        addToRepository( getWorkingCopy(), new File( \"project.xml\" ), repository );\n\n        // /src/test/java/org\n        ScmTestCase.makeDirectory( getWorkingCopy(), \"/src/test/java/org\" );\n\n        addToRepository( getWorkingCopy(), new File( \"src/test/java/org\" ), repository );\n\n        // /src/main/java/org/Foo.java\n        ScmTestCase.makeFile( getWorkingCopy(), \"/src/main/java/org/Foo.java\" );\n\n        addToRepository( getWorkingCopy(), new File( \"src/main/java/org\" ), repository );\n\n        // src/main/java/org/Foo.java\n        addToRepository( getWorkingCopy(), new File( \"src/main/java/org/Foo.java\" ), repository );\n\n        // ----------------------------------------------------------------------\n        // Diff the project\n        // ----------------------------------------------------------------------\n\n        ScmManager scmManager = getScmManager();\n\n        DiffScmResult result = scmManager.getProviderByUrl( getScmUrl() ).diff( repository,\n                                                                                new ScmFileSet( getWorkingCopy() ),\n                                                                                null, null );\n\n        assertNotNull( \"The command returned a null result.\", result );\n\n        assertResultIsSuccess( result );\n\n        assertNull( \"The provider message wasn't null\", result.getProviderMessage() );\n\n        assertNull( \"The command output wasn't null\", result.getCommandOutput() );\n\n        List changedFiles = result.getChangedFiles();\n\n        Map differences = result.getDifferences();\n\n        assertEquals( \"Expected 3 files in the changed files list \" + changedFiles, 3, changedFiles.size() );\n\n        assertEquals( \"Expected 3 files in the differences list \" + differences, 3, differences.size() );\n\n        // ----------------------------------------------------------------------\n        // Assert the files in the changed files list\n        // ----------------------------------------------------------------------\n\n        Iterator files = new TreeSet( changedFiles ).iterator();\n\n        ScmFile file = (ScmFile) files.next();\n\n        assertPath( \"/src/main/java/org/Foo.java\", file.getPath() );\n\n        assertEquals( ScmFileStatus.MODIFIED, file.getStatus() );\n\n        assertEquals( \"@@ -0,0 +1 @@\\n+/src/main/java/org/Foo.java\\n\\\\ No newline at end of file\\n\", differences\n            .get( file.getPath() ).toString() );\n\n        file = (ScmFile) files.next();\n\n        assertPath( \"/readme.txt\", file.getPath() );\n\n        assertEquals( ScmFileStatus.MODIFIED, file.getStatus() );\n\n        assertEquals(\n            \"@@ -1 +1 @@\\n-/readme.txt\\n\\\\ No newline at end of file\\n+changed readme.txt\\n\\\\ No newline at end of file\\n\",\n            differences.get( file.getPath() ).toString() );\n\n        file = (ScmFile) files.next();\n\n        assertPath( \"/project.xml\", file.getPath() );\n\n        assertEquals( \"@@ -0,0 +1 @@\\n+changed project.xml\\n\\\\ No newline at end of file\\n\", differences\n            .get( file.getPath() ).toString() );\n\n        assertEquals( ScmFileStatus.MODIFIED, file.getStatus() );\n    }\n\n    // ----------------------------------------------------------------------\n    // Assertions\n    // ----------------------------------------------------------------------\n\n    private void assertFile( File root, String fileName )\n        throws Exception\n    {\n        File file = new File( root, fileName );\n\n        assertTrue( \"Missing file: '\" + file.getAbsolutePath() + \"'.\", file.exists() );\n\n        assertTrue( \"File isn't a file: '\" + file.getAbsolutePath() + \"'.\", file.isFile() );\n\n        String expected = fileName;\n\n        String actual = FileUtils.fileRead( file );\n\n        assertEquals( \"The file doesn't contain the expected contents. File: \" + file.getAbsolutePath(), expected,\n                      actual );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.tck.command.diff;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.ScmTckTestCase;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.command.diff.DiffScmResult;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeSet;\n\n/**\n * This test tests the diff command.\n *\n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @version $Id$\n */\npublic abstract class DiffCommandTckTest\n    extends ScmTckTestCase\n{\n\n    public void testDiffCommand()\n        throws Exception\n    {\n        ScmRepository repository = getScmRepository();\n\n        // ----------------------------------------------------------------------\n        // Change the files\n        // ----------------------------------------------------------------------\n\n        //\n        // readme.txt is changed (changed file in the root directory)\n        // project.xml is added (added file in the root directory)\n        // src/test/resources is untouched (a empty directory is left untouched)\n        // src/test/java is untouched (a non empty directory is left untouched)\n        // src/test/java/org (a empty directory is added)\n        // src/main/java/org/Foo.java (a non empty directory is added)\n        //\n\n        // /readme.txt\n        ScmTestCase.makeFile( getWorkingCopy(), \"/readme.txt\", \"changed readme.txt\" );\n\n        // /project.xml\n        ScmTestCase.makeFile( getWorkingCopy(), \"/project.xml\", \"changed project.xml\" );\n\n        addToWorkingTree( getWorkingCopy(), new File( \"project.xml\" ), repository );\n\n        // /src/test/java/org\n        ScmTestCase.makeDirectory( getWorkingCopy(), \"/src/test/java/org\" );\n\n        addToWorkingTree( getWorkingCopy(), new File( \"src/test/java/org\" ), repository );\n\n        // /src/main/java/org/Foo.java\n        ScmTestCase.makeFile( getWorkingCopy(), \"/src/main/java/org/Foo.java\" );\n\n        addToWorkingTree( getWorkingCopy(), new File( \"src/main/java/org\" ), repository );\n\n        // src/main/java/org/Foo.java\n        addToWorkingTree( getWorkingCopy(), new File( \"src/main/java/org/Foo.java\" ), repository );\n\n        // ----------------------------------------------------------------------\n        // Diff the project\n        // ----------------------------------------------------------------------\n\n        ScmProvider provider = getScmManager().getProviderByUrl( getScmUrl() );\n        ScmFileSet fileSet = new ScmFileSet( getWorkingCopy() );\n        DiffScmResult result = provider.diff( repository, fileSet, null, null );\n\n        assertNotNull( \"The command returned a null result.\", result );\n\n        assertResultIsSuccess( result );\n\n        List changedFiles = result.getChangedFiles();\n\n        Map differences = result.getDifferences();\n\n        assertEquals( \"Expected 3 files in the changed files list \" + changedFiles, 3, changedFiles.size() );\n\n        assertEquals( \"Expected 3 files in the differences list \" + differences, 3, differences.size() );\n\n        // ----------------------------------------------------------------------\n        // Assert the files in the changed files list\n        // ----------------------------------------------------------------------\n\n        Iterator files = new TreeSet( changedFiles ).iterator();\n\n        //Check Foo.java\n        ScmFile file = (ScmFile) files.next();\n\n        assertPath( \"/src/main/java/org/Foo.java\", file.getPath() );\n\n        assertTrue( isDiff( file.getStatus() ) );\n\n        String postRangeStr = \"+/src/main/java/org/Foo.java\\n\\\\ No newline at end of file\\n\";\n        String actualStr = differences.get( file.getPath() ).toString();\n        assertTrue( actualStr.endsWith( postRangeStr ) );\n\n        //Check readme.txt\n        file = (ScmFile) files.next();\n\n        assertPath( \"/readme.txt\", file.getPath() );\n\n        assertTrue( isDiff( file.getStatus() ) );\n\n        postRangeStr =\n            \"-/readme.txt\\n\\\\ No newline at end of file\\n+changed readme.txt\\n\\\\ No newline at end of file\\n\";\n        actualStr = differences.get( file.getPath() ).toString();\n        assertTrue( actualStr.endsWith( postRangeStr ) );\n\n        //Check project.xml\n        file = (ScmFile) files.next();\n\n        assertPath( \"/project.xml\", file.getPath() );\n\n        postRangeStr = \"+changed project.xml\\n\\\\ No newline at end of file\\n\";\n        actualStr = differences.get( file.getPath() ).toString();\n        assertTrue( actualStr.endsWith( postRangeStr ) );\n\n        assertTrue( isDiff( file.getStatus() ) );\n    }\n\n    /**\n     * TODO refactor into ScmFileResult\n     */\n    private static boolean isDiff( ScmFileStatus status )\n    {\n        return status == ScmFileStatus.ADDED || status == ScmFileStatus.DELETED || status == ScmFileStatus.MODIFIED;\n    }\n}\n","lineNo":88}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.repository;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnScmProviderRepository\n    extends ScmProviderRepository\n{\n    /** */\n    private String url;\n\n    /**\n     * The base directory for any tags. Can be relative to the repository URL or an absolute URL.\n     */\n    private String tagBase;\n\n    public SvnScmProviderRepository( String url, String user, String password )\n    {\n        setUser( user );\n\n        setPassword( password );\n\n        parseUrl( url );\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    /**\n     * Returns the url/directory to be used when tagging this repository.\n     */\n    public String getTagBase()\n    {\n        return tagBase;\n    }\n\n    /**\n     * Sets the url/directory to be used when tagging this repository.\n     * The TagBase is a way to override the default tag location for the\n     * repository.  The default tag location is automatically determined\n     * for repositories in the standard subversion layout (with /tags /branches /trunk).\n     * Specify this value only if the repository is using a directory other than \"/tags\" for tagging.\n     *\n     * @param tagBase an absolute or relative url to the base directory to create tags in.\n     *                URL should be in a format that svn client understands, not the scm url format.\n     */\n    public void setTagBase( String tagBase )\n    {\n        this.tagBase = tagBase;\n    }\n\n    private void parseUrl( String url )\n    {\n        String protocol = null;\n\n        if ( url.startsWith( \"file\" ) )\n        {\n            protocol = \"file://\";\n        }\n        else if ( url.startsWith( \"https\" ) )\n        {\n            protocol = \"https://\";\n        }\n        else if ( url.startsWith( \"http\" ) )\n        {\n            protocol = \"http://\";\n        }\n        else if ( url.startsWith( \"svn+ssh\" ) )\n        {\n            protocol = \"svn+ssh://\";\n        }\n        else if ( url.startsWith( \"svn\" ) )\n        {\n            protocol = \"svn://\";\n        }\n\n        String urlPath = url.substring( protocol.length() );\n\n        int indexAt = urlPath.indexOf( \"@\" );\n\n        if ( indexAt > 0 && !\"svn+ssh://\".equals( protocol ) )\n        {\n            setUser( urlPath.substring( 0, indexAt ) );\n\n            this.url = protocol + urlPath.substring( indexAt + 1 );\n        }\n        else\n        {\n            this.url = protocol + urlPath;\n        }\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.repository;\n\n/*\n * Copyright 2001-2006 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepositoryWithHost;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnScmProviderRepository\n    extends ScmProviderRepositoryWithHost\n{\n    /** */\n    private String url;\n\n    /**\n     * The base directory for any tags. Can be relative to the repository URL or an absolute URL.\n     */\n    private String tagBase;\n\n    public SvnScmProviderRepository( String url, String user, String password )\n    {\n        setUser( user );\n\n        setPassword( password );\n\n        parseUrl( url );\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    /**\n     * Returns the url/directory to be used when tagging this repository.\n     */\n    public String getTagBase()\n    {\n        return tagBase;\n    }\n\n    /**\n     * Sets the url/directory to be used when tagging this repository.\n     * The TagBase is a way to override the default tag location for the\n     * repository.  The default tag location is automatically determined\n     * for repositories in the standard subversion layout (with /tags /branches /trunk).\n     * Specify this value only if the repository is using a directory other than \"/tags\" for tagging.\n     *\n     * @param tagBase an absolute or relative url to the base directory to create tags in.\n     *                URL should be in a format that svn client understands, not the scm url format.\n     */\n    public void setTagBase( String tagBase )\n    {\n        this.tagBase = tagBase;\n    }\n\n    private void parseUrl( String url )\n    {\n        String protocol = null;\n\n        if ( url.startsWith( \"file\" ) )\n        {\n            protocol = \"file://\";\n        }\n        else if ( url.startsWith( \"https\" ) )\n        {\n            protocol = \"https://\";\n        }\n        else if ( url.startsWith( \"http\" ) )\n        {\n            protocol = \"http://\";\n        }\n        else if ( url.startsWith( \"svn+ssh\" ) )\n        {\n            protocol = \"svn+ssh://\";\n        }\n        else if ( url.startsWith( \"svn\" ) )\n        {\n            protocol = \"svn://\";\n        }\n\n        String urlPath = url.substring( protocol.length() );\n\n        int indexAt = urlPath.indexOf( \"@\" );\n\n        if ( indexAt > 0 && !\"svn+ssh://\".equals( protocol ) )\n        {\n            setUser( urlPath.substring( 0, indexAt ) );\n\n            urlPath = urlPath.substring( indexAt + 1 );\n\n            this.url = protocol + urlPath;\n        }\n        else\n        {\n            this.url = protocol + urlPath;\n        }\n\n        if ( !\"file://\".equals( protocol ) )\n        {\n            int indexSlash = urlPath.indexOf( \"/\" );\n            if ( indexSlash > 0 )\n            {\n                String hostPort = urlPath.substring( 0, indexSlash );\n                int indexColon = hostPort.indexOf( \":\" );\n\n                if ( indexColon > 0 )\n                {\n                    setHost( hostPort.substring( 0, indexColon ) );\n                    setPort( Integer.parseInt( hostPort.substring( indexColon ) ) );\n                }\n            }\n        }\n    }\n}\n","lineNo":98}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n\n    /**\n     * Check out the depot code at <code>repo.getPath()<\/code> into the target\n     * directory at <code>files.getBasedir<\/code>. Perforce does not support\n     * arbitrary checkout of versioned source so we need to set up a well-known\n     * clientspec which will hold the required info.\n     * \n     * 1) A clientspec will be created or updated which holds a temporary\n     * mapping from the repo path to the target directory. \n     * 2) This clientspec is sync'd to pull all the files onto the client\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files, String tag )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        String specname = getClientspecName();\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer( specname, prepo.getPath() );\n        File workingDirectory = new File( files.getBasedir().getAbsolutePath() );\n        getLogger().info( \"Checkout working directory: \" + workingDirectory );\n        Commandline cl = null;\n        \n        try\n        {\n            // Ahhh, glorious Perforce.  Create and update of clientspecs is the exact\n            // same operation so we don't need to distinguish between the two modes. \n            cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n            cl.createArgument().setValue( \"client\" );\n            cl.createArgument().setValue( \"-i\" );\n            getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n            Process proc = cl.execute();\n\n            // Write clientspec to STDIN\n            OutputStream out = proc.getOutputStream();\n            DataOutputStream dos = new DataOutputStream( out );\n            String client = createClientspec( specname, workingDirectory, prepo.getPath() );\n            getLogger().debug( \"Updating clientspec:\\n\" + client );\n            dos.write( client.getBytes() );\n            dos.close();\n            out.close();\n\n            // Read result from STDOUT\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                consumer.consumeLine( line );\n            }\n            br.close();\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            try\n            {\n                cl = createCommandLine( prepo, workingDirectory, tag, specname );\n                getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                Process proc = cl.execute();\n                BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                String line = null;\n                while ( ( line = br.readLine() ) != null )\n                {\n                    getLogger().debug( \"Consuming: \" + line );\n                    consumer.consumeLine( line );\n                }\n                br.close();\n                getLogger().debug( \"Perforce sync complete.\" );\n            }\n            catch ( IOException e )\n            {\n                getLogger().error( e );\n            }\n            catch ( CommandLineException e )\n            {\n                getLogger().error( e );\n            }\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            return new CheckOutScmResult( cl.toString(), consumer.getCheckedout() );\n        }\n        else\n        {\n            return new CheckOutScmResult( cl.toString(), \"Unable to sync.  Are you logged in?\", consumer.getOutput(), consumer.isSuccess() );\n        }\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /* \n     * Clientspec name can be overridden with the system property below.  I don't\n     * know of any way for this code to get access to maven's settings.xml so this\n     * is the best I can do.\n     * \n     * Sample clientspec:\n\n     Client: mperham-mikeperham-dt-maven\n     Root: d:\\temp\\target\n     View:\n         //depot/sandbox/mperham/tsa/tsa-domain/... //mperham-mikeperham-dt-maven/...\n     Description:\n        Created by maven-scm-provider-perforce\n\n     */\n    public static String createClientspec( String specname, File workDir, String repoPath )\n    {\n        String clientspecName = getClientspecName();\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Client: \" ).append( clientspecName ).append( NEWLINE );\n        buf.append( \"Root: \" ).append( workDir ).append( NEWLINE );\n        buf.append( \"View:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( PerforceScmProvider.getCanonicalRepoPath( repoPath ) );\n        buf.append( \" //\" ).append( clientspecName ).append( \"/...\" ).append( NEWLINE );\n        buf.append( \"Description:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( \"Created by maven-scm-provider-perforce\" ).append( NEWLINE );\n        return buf.toString();\n    }\n\n    private static String getClientspecName()\n    {\n        String clientspecName = System.getProperty( \"maven.scm.perforce.clientspec.name\",\n                                                    generateDefaultClientspecName() );\n        return clientspecName;\n    }\n\n    private static String generateDefaultClientspecName()\n    {\n        String username = System.getProperty( \"user.name\", \"nouser\" );\n        String hostname = \"nohost\";\n        try\n        {\n            hostname = InetAddress.getLocalHost().getHostName();\n        }\n        catch ( UnknownHostException e )\n        {\n            // Should never happen\n            throw new RuntimeException( e );\n        }\n        return username + \"-\" + hostname + \"-MavenSCM\";\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory, String tag,\n                                                String specname )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"-c\" + specname );\n        command.createArgument().setValue( \"sync\" );\n        \n        // Use a simple heuristic to determine if we should use the Force flag\n        // on sync.  Forcing sync is a HUGE performance hit but is required in\n        // rare instances where source is somehow deleted.  If the target\n        // directory is completely empty, assume a force is required.  If\n        // not empty, we assume a previous checkout was already done and a normal\n        // sync will suffice.\n        // SCM-110\n        String[] files = workingDirectory.list(); \n        if ( files == null || files.length == 0 ) \n        {\n            // We need to force so checkout to an empty directory will work.\n            command.createArgument().setValue( \"-f\" );\n        }\n        \n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        if ( tag != null )\n        {\n            command.createArgument().setValue( \"@\" + tag );\n        }\n        return command;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n\n    /**\n     * Check out the depot code at <code>repo.getPath()<\/code> into the target\n     * directory at <code>files.getBasedir<\/code>. Perforce does not support\n     * arbitrary checkout of versioned source so we need to set up a well-known\n     * clientspec which will hold the required info.\n     * \n     * 1) A clientspec will be created or updated which holds a temporary\n     * mapping from the repo path to the target directory. \n     * 2) This clientspec is sync'd to pull all the files onto the client\n     */\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files, String tag )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        File workingDirectory = new File( files.getBasedir().getAbsolutePath() );\n\n        String specname = getClientspecName( prepo, workingDirectory );\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer( specname, prepo.getPath() );\n        getLogger().info( \"Checkout working directory: \" + workingDirectory );\n        Commandline cl = null;\n\n        // Create or update a clientspec so we can checkout the code to a particular location\n        try\n        {\n            // Ahhh, glorious Perforce.  Create and update of clientspecs is the exact\n            // same operation so we don't need to distinguish between the two modes. \n            cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n            cl.createArgument().setValue( \"client\" );\n            cl.createArgument().setValue( \"-i\" );\n            getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n            Process proc = cl.execute();\n\n            // Write clientspec to STDIN\n            OutputStream out = proc.getOutputStream();\n            DataOutputStream dos = new DataOutputStream( out );\n            String client = createClientspec( prepo, specname, workingDirectory );\n            getLogger().debug( \"Updating clientspec:\\n\" + client );\n            dos.write( client.getBytes() );\n            dos.close();\n            out.close();\n\n            // Read result from STDOUT\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                consumer.consumeLine( line );\n            }\n            br.close();\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n\n        boolean clientspecExists = consumer.isSuccess();\n        // Perform the actual checkout using that clientspec\n        try\n        {\n            if ( clientspecExists )\n            {\n                try\n                {\n                    cl = createCommandLine( prepo, workingDirectory, tag, specname );\n                    getLogger().debug( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    Process proc = cl.execute();\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line = null;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        getLogger().debug( \"Consuming: \" + line );\n                        consumer.consumeLine( line );\n                    }\n                    br.close();\n                    getLogger().debug( \"Perforce sync complete.\" );\n                }\n                catch ( IOException e )\n                {\n                    getLogger().error( e );\n                }\n                catch ( CommandLineException e )\n                {\n                    getLogger().error( e );\n                }\n            }\n\n            if ( consumer.isSuccess() )\n            {\n                return new CheckOutScmResult( cl.toString(), consumer.getCheckedout() );\n            }\n            else\n            {\n                return new CheckOutScmResult( cl.toString(), \"Unable to sync.  Are you logged in?\", consumer\n                    .getOutput(), consumer.isSuccess() );\n            }\n        }\n        finally\n        {\n            // See SCM-113\n            // Support transient clientspecs as we don't want to create 1000s of permanent clientspecs\n            if ( clientspecExists && !prepo.isPersistCheckout() )\n            {\n                // Delete the clientspec\n                try\n                {\n                    cl = PerforceScmProvider.createP4Command( prepo, workingDirectory );\n                    cl.createArgument().setValue( \"client\" );\n                    cl.createArgument().setValue( \"-d\" );\n                    cl.createArgument().setValue( specname );\n                    getLogger().info( \"Executing: \" + PerforceScmProvider.clean( cl.toString() ) );\n                    Process proc = cl.execute();\n\n                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n                    String line = null;\n                    while ( ( line = br.readLine() ) != null )\n                    {\n                        getLogger().debug( \"Consuming: \" + line );\n                        consumer.consumeLine( line );\n                    }\n                    br.close();\n                }\n                catch ( CommandLineException e )\n                {\n                    getLogger().error( e.getMessage(), e );\n                }\n                catch ( IOException e )\n                {\n                    getLogger().error( e.getMessage(), e );\n                }\n            }\n        }\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /* \n     * Clientspec name can be overridden with the system property below.  I don't\n     * know of any way for this code to get access to maven's settings.xml so this\n     * is the best I can do.\n     * \n     * Sample clientspec:\n\n     Client: mperham-mikeperham-dt-maven\n     Root: d:\\temp\\target\n     Owner: mperham\n     View:\n     //depot/sandbox/mperham/tsa/tsa-domain/... //mperham-mikeperham-dt-maven/...\n     Description:\n     Created by maven-scm-provider-perforce\n\n     */\n    public static String createClientspec( PerforceScmProviderRepository repo, String specname, File workDir )\n    {\n        String clientspecName = getClientspecName( repo, workDir );\n        String userName = getUsername( repo );\n\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Client: \" ).append( clientspecName ).append( NEWLINE );\n        buf.append( \"Root: \" ).append( workDir ).append( NEWLINE );\n        buf.append( \"Owner: \" ).append( userName ).append( NEWLINE );\n        buf.append( \"View:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( PerforceScmProvider.getCanonicalRepoPath( repo.getPath() ) );\n        buf.append( \" //\" ).append( clientspecName ).append( \"/...\" ).append( NEWLINE );\n        buf.append( \"Description:\" ).append( NEWLINE );\n        buf.append( \"\\t\" ).append( \"Created by maven-scm-provider-perforce\" ).append( NEWLINE );\n        return buf.toString();\n    }\n\n    private static String getClientspecName( PerforceScmProviderRepository repo, File workDir )\n    {\n        String clientspecName = System.getProperty( \"maven.scm.perforce.clientspec.name\",\n                                                    generateDefaultClientspecName( repo, workDir ) );\n        return clientspecName;\n    }\n\n    private static String generateDefaultClientspecName( PerforceScmProviderRepository repo, File workDir )\n    {\n        String username = getUsername( repo );\n        String hostname = \"nohost\";\n        String path = \"nopath\";\n        try\n        {\n            hostname = InetAddress.getLocalHost().getHostName();\n            path = workDir.getCanonicalPath();\n        }\n        catch ( UnknownHostException e )\n        {\n            // Should never happen\n            throw new RuntimeException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        return username + \"-\" + hostname + \"-MavenSCM-\" + path;\n    }\n\n    private static String getUsername( PerforceScmProviderRepository repo )\n    {\n        String username = repo.getUser();\n        if ( username == null )\n        {\n            username = System.getProperty( \"user.name\", \"nouser\" );\n        }\n        return username;\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory, String tag,\n                                                String specname )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"-c\" + specname );\n        command.createArgument().setValue( \"sync\" );\n\n        // Use a simple heuristic to determine if we should use the Force flag\n        // on sync.  Forcing sync is a HUGE performance hit but is required in\n        // rare instances where source is somehow deleted.  If the target\n        // directory is completely empty, assume a force is required.  If\n        // not empty, we assume a previous checkout was already done and a normal\n        // sync will suffice.\n        // SCM-110\n        String[] files = workingDirectory.list();\n        if ( files == null || files.length == 0 )\n        {\n            // We need to force so checkout to an empty directory will work.\n            command.createArgument().setValue( \"-f\" );\n        }\n\n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        if ( tag != null )\n        {\n            command.createArgument().setValue( \"@\" + tag );\n        }\n        return command;\n    }\n\n}\n","lineNo":109}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.provider.perforce.command.AbstractPerforceConsumer;\nimport org.apache.maven.scm.provider.perforce.command.PerforceVerbMapper;\nimport org.apache.regexp.RE;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogConsumer.java 331276 2005-11-07 15:04:54Z\n *          evenisse $\n */\npublic class PerforceCheckOutConsumer\n    extends AbstractPerforceConsumer\n    implements StreamConsumer\n{\n    public static final int STATE_CLIENTSPEC = 0;\n\n    public static final int STATE_NORMAL = 1;\n\n    public static final int STATE_ERROR = 2;\n\n    private int currentState = STATE_CLIENTSPEC;\n\n    private RE fileRegexp = new RE( \"([^#]+)#\\\\d+ - ([a-z]+)\" );\n\n    private List checkedout = new ArrayList();\n\n    private String repo = null;\n\n    private String specname = null;\n\n    public PerforceCheckOutConsumer( String clientspec, String repoPath )\n    {\n        repo = repoPath;\n        specname = clientspec;\n    }\n\n    /*\n     * Client mperham-mikeperham-dt-maven saved.\n     */\n    /*\n     * //depot/modules/cordoba/runtime-ear/.j2ee#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\.j2ee\n     * //depot/modules/cordoba/runtime-ear/.project#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\.project\n     * //depot/modules/cordoba/runtime-ear/.runtime#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\.runtime\n     * //depot/modules/cordoba/runtime-ear/Foo.java#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\Foo.java\n     * //depot/modules/cordoba/runtime-ear/META-INF/.modulemaps#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\META-INF\\.modulemaps\n     * //depot/modules/cordoba/runtime-ear/META-INF/application.xml#1 - deleted\n     * as d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\META-INF\\application.xml\n     * //depot/modules/cordoba/runtime-ear/pom.xml#4 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\pom.xml\n     */\n    /*\n     * Invalid changelist/client/label/date '@somelabel'.\n     */\n    public void consumeLine( String line )\n    {\n        if ( currentState == STATE_CLIENTSPEC && \n                ( line.startsWith( \"Client \" + specname + \" saved.\" ) ||\n                  line.startsWith( \"Client \" + specname + \" not changed.\" ) ) )\n        {\n            currentState = STATE_NORMAL;\n            return;\n        }\n\n        if ( currentState != STATE_ERROR && fileRegexp.match( line ) )\n        {\n            String location = fileRegexp.getParen( 1 );\n            if ( location.startsWith( repo ) )\n            {\n                location = location.substring( repo.length() + 1 );\n            }\n            checkedout.add( new ScmFile( location, PerforceVerbMapper.toStatus( fileRegexp.getParen( 2 ) ) ) );\n            return;\n        }\n\n        error( line );\n    }\n\n    private void error( String line )\n    {\n        currentState = STATE_ERROR;\n        output.println( line );\n    }\n\n    public boolean isSuccess()\n    {\n        return currentState == STATE_NORMAL;\n    }\n\n    public List getCheckedout()\n    {\n        return checkedout;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.provider.perforce.command.AbstractPerforceConsumer;\nimport org.apache.maven.scm.provider.perforce.command.PerforceVerbMapper;\nimport org.apache.regexp.RE;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogConsumer.java 331276 2005-11-07 15:04:54Z\n *          evenisse $\n */\npublic class PerforceCheckOutConsumer\n    extends AbstractPerforceConsumer\n    implements StreamConsumer\n{\n    public static final int STATE_CLIENTSPEC = 0;\n\n    public static final int STATE_NORMAL = 1;\n\n    public static final int STATE_ERROR = 2;\n\n    private int currentState = STATE_CLIENTSPEC;\n\n    private RE fileRegexp = new RE( \"([^#]+)#\\\\d+ - ([a-z]+)\" );\n\n    private List checkedout = new ArrayList();\n\n    private String repo = null;\n\n    private String specname = null;\n\n    public PerforceCheckOutConsumer( String clientspec, String repoPath )\n    {\n        repo = repoPath;\n        specname = clientspec;\n    }\n\n    /*\n     * Client mperham-mikeperham-dt-maven saved.\n     */\n    /*\n     * //depot/modules/cordoba/runtime-ear/.j2ee#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\.j2ee\n     * //depot/modules/cordoba/runtime-ear/.project#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\.project\n     * //depot/modules/cordoba/runtime-ear/.runtime#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\.runtime\n     * //depot/modules/cordoba/runtime-ear/Foo.java#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\Foo.java\n     * //depot/modules/cordoba/runtime-ear/META-INF/.modulemaps#1 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\META-INF\\.modulemaps\n     * //depot/modules/cordoba/runtime-ear/META-INF/application.xml#1 - deleted\n     * as d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\META-INF\\application.xml\n     * //depot/modules/cordoba/runtime-ear/pom.xml#4 - deleted as\n     * d:\\perforce\\depot\\modules\\cordoba\\runtime-ear\\pom.xml\n     */\n    /*\n     * Invalid changelist/client/label/date '@somelabel'.\n     */\n    public void consumeLine( String line )\n    {\n        if ( currentState == STATE_CLIENTSPEC && \n                ( line.startsWith( \"Client \" + specname + \" saved.\" ) ||\n                  line.startsWith( \"Client \" + specname + \" not changed.\" ) ) )\n        {\n            currentState = STATE_NORMAL;\n            return;\n        }\n\n        if ( currentState != STATE_ERROR && fileRegexp.match( line ) )\n        {\n            String location = fileRegexp.getParen( 1 );\n            if ( location.startsWith( repo ) )\n            {\n                location = location.substring( repo.length() + 1 );\n            }\n            ScmFileStatus status = PerforceVerbMapper.toStatus( fileRegexp.getParen( 2 ) );\n            if ( status != null ) \n            {\n                // there are cases where Perforce prints out something but the file did not\n                // actually change (especially when force syncing).  Those files will have\n                // a null status.\n                checkedout.add( new ScmFile( location, status ) );\n            }\n            return;\n        }\n\n        error( line );\n    }\n\n    private void error( String line )\n    {\n        currentState = STATE_ERROR;\n        output.println( line );\n    }\n\n    public boolean isSuccess()\n    {\n        return currentState == STATE_NORMAL;\n    }\n\n    public List getCheckedout()\n    {\n        return checkedout;\n    }\n}\n","lineNo":99}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsScmProviderRepository\n\textends ScmProviderRepository\n{\n    /** */\n    private String cvsroot;\n\n    /** */\n    private String transport;\n\n    /** */\n    private String host;\n\n    /** */\n    private int port;\n\n    /** */\n    private String path;\n\n    /** */\n    private String module;\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host, String path, String module )\n    {\n        this( cvsroot, transport, user, password, host, -1, path, module );\n    }\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host, int port, String path, String module )\n    {\n        this.cvsroot = cvsroot;\n\n        this.transport = transport;\n\n        setUser( user );\n\n        setPassword( password );\n\n        this.host = host;\n\n        this.port = port;\n\n        this.path = path;\n\n        this.module = module;\n    }\n\n    public String getCvsRoot()\n    {\n        return cvsroot;\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     */\n    public String getTransport()\n    {\n        return transport;\n    }\n\n    /**\n     * @return The host.\n     */\n    public String getHost()\n    {\n        return host;\n    }\n\n    /**\n     * Returns the port or -1 if it isn't set.\n     * \n     * @return The port.\n     */\n    public int getPort()\n    {\n        return port;\n    }\n\n    /**\n     * @return The path.\n     */\n    public String getPath()\n    {\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     */\n    public String getModule()\n    {\n        return module;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsScmProviderRepository\n\textends ScmProviderRepository\n{\n    /** */\n    private String cvsroot;\n\n    /** */\n    private String transport;\n\n    /** */\n    private String host;\n\n    /** */\n    private int port;\n\n    /** */\n    private String path;\n\n    /** */\n    private String module;\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host, String path, String module )\n    {\n        this( cvsroot, transport, user, password, host, -1, path, module );\n    }\n\n    public CvsScmProviderRepository( String cvsroot, String transport, String user, String password, String host, int port, String path, String module )\n    {\n        this.cvsroot = cvsroot;\n\n        this.transport = transport;\n\n        setUser( user );\n\n        setPassword( password );\n\n        this.host = host;\n\n        this.port = port;\n\n        this.path = path;\n\n        this.module = module;\n    }\n\n    public String getCvsRoot()\n    {\n        String root = cvsroot;\n\n        if ( root != null && root.indexOf( \":2401\" ) > 0 )\n        {\n            root = root.substring( 0, root.indexOf( \":2401\" ) ) + \":\" + root.substring( root.indexOf( \":2401\" ) + 5 );\n        }\n\n        return root;\n    }\n\n    public String getCvsRootForCvsPass()\n    {\n        return cvsroot;\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     */\n    public String getTransport()\n    {\n        return transport;\n    }\n\n    /**\n     * @return The host.\n     */\n    public String getHost()\n    {\n        return host;\n    }\n\n    /**\n     * Returns the port or -1 if it isn't set.\n     * \n     * @return The port.\n     */\n    public int getPort()\n    {\n        return port;\n    }\n\n    /**\n     * @return The path.\n     */\n    public String getPath()\n    {\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     */\n    public String getModule()\n    {\n        return module;\n    }\n}\n","lineNo":73}
{"Smelly Sample":"package org.apache.maven.scm.provider.clearcase.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.clearcase.command.ClearCaseCommand;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class ClearCaseCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements ClearCaseCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractCheckOutCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                                        String tag )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( fileSet.getBasedir(), tag );\n\n        ClearCaseCheckOutConsumer consumer = new ClearCaseCheckOutConsumer( getLogger() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing clearcase command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new CheckOutScmResult( cl.toString(), \"The cleartool command failed.\", stderr.getOutput(), false );\n        }\n\n        return new CheckOutScmResult( cl.toString(), consumer.getCheckedOutFiles() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( File workingDirectory, String branch )\n    {\n        Commandline command = new Commandline();\n\n        command.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n\n        command.setExecutable( \"cleartool\" );\n\n        command.createArgument().setValue( \"co\" );\n\n        if ( branch != null )\n        {\n            command.createArgument().setValue( \"-branch\" );\n\n            command.createArgument().setValue( branch );\n        }\n\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.clearcase.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.providers.clearcase.settings.io.xpp3.ClearcaseXpp3Reader;\nimport org.apache.maven.scm.providers.clearcase.settings.Settings;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.clearcase.command.ClearCaseCommand;\nimport org.apache.maven.scm.provider.clearcase.repository.ClearCaseScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.FileReader;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author <a href=\"mailto:wim.deblauwe@gmail.com\">Wim Deblauwe<\/a>\n */\npublic class ClearCaseCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements ClearCaseCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractCheckOutCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repository, ScmFileSet fileSet,\n                                                        String tag )\n        throws ScmException\n    {\n        ClearCaseScmProviderRepository repo = (ClearCaseScmProviderRepository) repository;\n        File workingDirectory = fileSet.getBasedir();\n        getLogger().info( \"basedir: \" + workingDirectory );\n        getLogger().info( \"tag: \" + tag );\n        //Commandline cl = createCommandLine( fileSet.getBasedir(), tag );\n\n        ClearCaseCheckOutConsumer consumer = new ClearCaseCheckOutConsumer( getLogger() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        Commandline cl;\n        try\n        {\n            // Since clearcase only wants to checkout to a non-existent directory, first delete the working dir if it already exists\n            FileUtils.deleteDirectory( workingDirectory );\n            // First create the view\n            String viewName = getUniqueViewName( repo, workingDirectory.getAbsolutePath() );\n            cl = createCreateViewCommandLine( workingDirectory, viewName );\n            getLogger().info( \"create view: \" + cl.toString() );\n            exitCode = CommandLineUtils.executeCommandLine( cl, new CommandLineUtils.StringStreamConsumer(), stderr );\n\n            if ( exitCode == 0 )\n            {\n                File configSpecLocation;\n\n                if ( tag == null )\n                {\n                    configSpecLocation = repo.getConfigSpec();\n                }\n                else\n                {\n                    // TODO We are building on a label\n                    throw new UnsupportedOperationException( \"Building on a label not supported yet\" );\n//                    configSpecLocation = new File( \"configspec.txt\" );\n//                    FileWriter writer = new FileWriter( configSpecLocation );\n//                    writer.append( \"ELEMENT * \" + tag );\n//                    // If we did not tag the directories leading to the root directory\n//                    // of this module, then we need the following line also (otherwise, we will\n//                    // not be able to access our module in the given view\n//                    writer.append( \"element * /main/LATEST\" );\n//                    writer.close();\n                }\n                cl = createUpdateConfigSpecCommandLine( workingDirectory, configSpecLocation,\n                                                        viewName );\n\n                getLogger().info( \"update config spec: \" + cl.toString() );\n                exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n            }\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing clearcase command.\", ex );\n        }\n        catch ( IOException ex )\n        {\n            throw new ScmException( \"Error while deleting working directory.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new CheckOutScmResult( cl.toString(), \"The cleartool command failed.\", stderr.getOutput(), false );\n        }\n\n        return new CheckOutScmResult( cl.toString(), consumer.getCheckedOutFiles() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    private static Commandline createDeleteViewCommandLine( ClearCaseScmProviderRepository repository, File workingDirectory )\n    {\n        Commandline command = new Commandline();\n\n        command.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n\n        command.setExecutable( \"cleartool\" );\n\n        command.createArgument().setValue( \"rmview\" );\n        command.createArgument().setValue( \"-force\" );\n        command.createArgument().setValue( \"-tag\" );\n        command.createArgument().setValue( getUniqueViewName( repository, workingDirectory.getAbsolutePath() ) );\n\n        return command;\n    }\n\n    protected static Commandline createCreateViewCommandLine( File workingDirectory, String viewName )\n        throws IOException\n    {\n        Commandline command = new Commandline();\n\n        // We have to execute from 1 level up from the working dir, since we had to delete the working dir\n        command.setWorkingDirectory( new File( workingDirectory, \"..\" ).getAbsolutePath() );\n\n        command.setExecutable( \"cleartool\" );\n\n        command.createArgument().setValue( \"mkview\" );\n        command.createArgument().setValue( \"-snapshot\" );\n        command.createArgument().setValue( \"-tag\" );\n        command.createArgument().setValue( viewName );\n\n        command.createArgument().setValue( \"-vws\" );\n        command.createArgument().setValue( getViewStore() + viewName + \".vws\" );\n\n        command.createArgument().setValue( workingDirectory.getCanonicalPath() );\n\n\n        return command;\n    }\n\n    protected static Commandline createUpdateConfigSpecCommandLine( File workingDirectory, File configSpecLocation,\n                                                                    String viewName )\n    {\n        Commandline command = new Commandline();\n\n        command.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n\n        command.setExecutable( \"cleartool\" );\n\n        command.createArgument().setValue( \"setcs\" );\n        command.createArgument().setValue( \"-tag\" );\n        command.createArgument().setValue( viewName );\n        command.createArgument().setValue( configSpecLocation.getAbsolutePath() );\n\n        return command;\n\n    }\n\n    private static String getUniqueViewName( ClearCaseScmProviderRepository repository, String absolutePath )\n    {\n        String uniqueId;\n        int lastIndexBack = absolutePath.lastIndexOf( '\\\\' );\n        int lastIndexForward = absolutePath.lastIndexOf( '/' );\n        if( lastIndexBack != -1 )\n        {\n            uniqueId = absolutePath.substring( lastIndexBack + 1 );\n        }\n        else\n        {\n            uniqueId = absolutePath.substring( lastIndexForward + 1 );\n        }\n        return repository.getViewName(uniqueId);\n    }\n\n    protected static String getViewStore()\n    {\n        String result = null;\n\n        File scmUserDir = new File( System.getProperty( \"user.dir\" ), \".scm\" );\n        File settingsFile = new File( scmUserDir, \"clearcase-settings.xml\" );\n        if( settingsFile.exists() )\n        {\n            try\n            {\n                ClearcaseXpp3Reader reader = new ClearcaseXpp3Reader();\n                Settings settings = reader.read( new FileReader( settingsFile ) );\n                result = settings.getViewstore();\n            }\n            catch ( IOException e )\n            {\n                result = null;\n            }\n            catch ( XmlPullParserException e )\n            {\n                result = null;\n            }\n        }\n\n        if( result == null )\n        {\n            result = \"\\\\\\\\\" + getHostName() + \"\\\\viewstore\\\\\";\n        }\n        return result;\n    }\n\n    private static String getHostName()\n    {\n        String hostname;\n        try\n        {\n            hostname = InetAddress.getLocalHost().getHostName();\n        }\n        catch ( UnknownHostException e )\n        {\n            // Should never happen\n            throw new RuntimeException( e );\n        }\n        return hostname;\n    }\n\n}\n","lineNo":56}
{"Smelly Sample":"package org.apache.maven.scm.provider.clearcase.command.checkin;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:wim.deblauwe@gmail.com\">Wim Deblauwe<\/a>\n */\npublic class ClearCaseCheckInCommandTest extends ScmTestCase\n{\n    public void testCommand()\n    {\n        ScmFileSet scmFileSet = new ScmFileSet( getWorkingDirectory(), new File( \"test.java\" ) );\n        Commandline commandLine = ClearCaseCheckInCommand.createCommandLine( scmFileSet, \"done some changes\" );\n\n        assertEquals( \"cleartool ci -c \\\"done some changes\\\" test.java\", commandLine.toString() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.clearcase.command.checkin;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmTestCase;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:wim.deblauwe@gmail.com\">Wim Deblauwe<\/a>\n */\npublic class ClearCaseCheckInCommandTest extends ScmTestCase\n{\n    public void testCommand()\n    {\n        File file = new File( \"test.java\" );\n        ScmFileSet scmFileSet = new ScmFileSet( getWorkingDirectory(), file );\n        Commandline commandLine = ClearCaseCheckInCommand.createCommandLine( scmFileSet, \"done some changes\" );\n\n        assertEquals( \"cleartool ci -c \\\"done some changes\\\" \" + file.getAbsolutePath(), commandLine.toString() );\n    }\n}\n","lineNo":32}
{"Smelly Sample":"package org.apache.maven.scm.provider.clearcase.command.edit;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:wim.deblauwe@gmail.com\">Wim Deblauwe<\/a>\n */\npublic class ClearCaseEditCommandTest extends ScmTestCase\n{\n    public void testCommand()\n    {\n        ScmFileSet scmFileSet = new ScmFileSet( getWorkingDirectory(), new File( \"test.java\" ) );\n        Commandline commandLine = ClearCaseEditCommand.createCommandLine( new DefaultLog(), scmFileSet );\n        assertEquals( \"cleartool co -nc test.java\", commandLine.toString() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.clearcase.command.edit;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmTestCase;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.log.DefaultLog;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:wim.deblauwe@gmail.com\">Wim Deblauwe<\/a>\n */\npublic class ClearCaseEditCommandTest extends ScmTestCase\n{\n    public void testCommand()\n    {\n        File file = new File( \"test.java\" );\n        ScmFileSet scmFileSet = new ScmFileSet( getWorkingDirectory(), file );\n        Commandline commandLine = ClearCaseEditCommand.createCommandLine( new DefaultLog(), scmFileSet );\n        assertEquals( \"cleartool co -nc \" + file.getAbsolutePath(), commandLine.toString() );\n    }\n}\n","lineNo":33}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.checkin;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceCheckInCommand\n    extends AbstractCheckInCommand\n    implements PerforceCommand\n{\n\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet files, String message,\n                                                     String something )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files );\n        PerforceCheckInConsumer consumer = new PerforceCheckInConsumer();\n        try\n        {\n            Process proc = cl.execute();\n            DataOutputStream dos = new DataOutputStream( proc.getOutputStream() );\n            dos.writeUTF( createChangeListSpecification( (PerforceScmProviderRepository) repo, files, message ) );\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n\n        return new CheckInScmResult( cl.toString(), consumer.isSuccess() ? \"Checkin successful\" : \"Unable to submit\",\n                                     consumer.getOutput(), consumer.isSuccess() );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                ScmFileSet files )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"submit\" );\n        command.createArgument().setValue( \"-i\" );\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    public static String createChangeListSpecification( PerforceScmProviderRepository repo, ScmFileSet files, String msg )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Change: new\" ).append( NEWLINE ).append( NEWLINE );\n        buf.append( \"Description:\" ).append( NEWLINE ).append( \"\\t\" ).append( msg ).append( NEWLINE ).append( NEWLINE );\n        buf.append( \"Files:\" ).append( NEWLINE );\n        try\n        {\n            File workingDir = files.getBasedir();\n            String candir = workingDir.getCanonicalPath();\n            File[] fs = files.getFiles();\n            for ( int i = 0; i < fs.length; i++ )\n            {\n                File file = fs[i];\n                // XXX Submit requires the canonical repository path for each\n                // file.\n                // It is unclear how to get that from a File object.\n                // We assume the repo object has the relative prefix\n                // \"//depot/some/project\"\n                // and canfile has the relative path \"src/foo.xml\" to be added\n                // to that prefix.\n                // \"//depot/some/project/src/foo.xml\"\n                String canfile = file.getCanonicalPath();\n                if ( canfile.startsWith( candir ) )\n                {\n                    canfile = canfile.substring( candir.length() + 1 );\n                }\n                buf.append( \"\\t\" ).append( repo.getPath() ).append( \"/\" ).append( canfile.replace( '\\\\', '/' ) )\n                    .append( NEWLINE );\n            }\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n        return buf.toString();\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.checkin;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkin.AbstractCheckInCommand;\nimport org.apache.maven.scm.command.checkin.CheckInScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceCheckInCommand\n    extends AbstractCheckInCommand\n    implements PerforceCommand\n{\n\n    protected CheckInScmResult executeCheckInCommand( ScmProviderRepository repo, ScmFileSet files, String message,\n                                                     String something )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files );\n        PerforceCheckInConsumer consumer = new PerforceCheckInConsumer();\n        try\n        {\n            getLogger().debug( \"Executing: \" + cl.toString() );\n            Process proc = cl.execute();\n            OutputStream out = proc.getOutputStream();\n            DataOutputStream dos = new DataOutputStream( out );\n            String changes = createChangeListSpecification( (PerforceScmProviderRepository) repo, files, message );\n            getLogger().debug( \"Sending changelist:\\n\" + changes );\n            dos.write( changes.getBytes() );\n            dos.close();\n            out.close();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n\n        return new CheckInScmResult( cl.toString(), consumer.isSuccess() ? \"Checkin successful\" : \"Unable to submit\",\n                                     consumer.getOutput(), consumer.isSuccess() );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                ScmFileSet files )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"submit\" );\n        command.createArgument().setValue( \"-i\" );\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    public static String createChangeListSpecification( PerforceScmProviderRepository repo, ScmFileSet files, String msg )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Change: new\" ).append( NEWLINE ).append( NEWLINE );\n        buf.append( \"Description:\" ).append( NEWLINE ).append( \"\\t\" ).append( msg ).append( NEWLINE ).append( NEWLINE );\n        buf.append( \"Files:\" ).append( NEWLINE );\n        try\n        {\n            Set dupes = new HashSet();\n            File workingDir = files.getBasedir();\n            String candir = workingDir.getCanonicalPath();\n            File[] fs = files.getFiles();\n            for ( int i = 0; i < fs.length; i++ )\n            {\n                File file = fs[i];\n                // XXX Submit requires the canonical repository path for each\n                // file.\n                // It is unclear how to get that from a File object.\n                // We assume the repo object has the relative prefix\n                // \"//depot/some/project\"\n                // and canfile has the relative path \"src/foo.xml\" to be added\n                // to that prefix.\n                // \"//depot/some/project/src/foo.xml\"\n                String canfile = file.getCanonicalPath();\n                if ( dupes.contains( canfile ) )\n                {\n                    // XXX I am seeing duplicate files in the ScmFileSet.\n                    // I don't know why this is but we have to weed them out\n                    // or Perforce will barf\n                    System.err.println( \"Skipping duplicate file: \" + file );\n                    continue;\n                }\n                dupes.add( canfile );\n                if ( canfile.startsWith( candir ) )\n                {\n                    canfile = canfile.substring( candir.length() + 1 );\n                }\n                buf.append( \"\\t\" ).append( repo.getPath() ).append( \"/\" ).append( canfile.replace( '\\\\', '/' ) )\n                    .append( NEWLINE );\n            }\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n        return buf.toString();\n    }\n}\n","lineNo":59}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag )\n        throws ScmException\n    {\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        if ( consumer.isSuccess() )\n        {\n            createLabel( repo, files, tag, consumer );\n        }\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // TODO Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n        else\n        {\n            // TODO Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n        }\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            Process proc = cl.execute();\n            DataOutputStream dos = new DataOutputStream( proc.getOutputStream() );\n            dos.writeUTF( createLabelSpecification( (PerforceScmProviderRepository) repo, files, tag ) );\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                     ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"label\" );\n        command.createArgument().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                         ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"labelsync\" );\n        command.createArgument().setValue( \"-l\" );\n        command.createArgument().setValue( tag );\n\n        try\n        {\n            String candir = workingDirectory.getCanonicalPath();\n            File[] fs = files.getFiles();\n            for ( int i = 0; i < fs.length; i++ )\n            {\n                File file = fs[i];\n                // I want to use relative paths to add files to make testing\n                // simpler.\n                // Otherwise the absolute path will be different on everyone's\n                // machine\n                // and testing will be a little more painful.\n                String canfile = file.getCanonicalPath();\n                if ( canfile.startsWith( candir ) )\n                {\n                    canfile = canfile.substring( candir.length() + 1 );\n                }\n                command.createArgument().setValue( file.getName() );\n            }\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label \n     * View: //depot/path/to/repos/...\n     */\n    public static String createLabelSpecification( PerforceScmProviderRepository repo, ScmFileSet files, String tag )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( repo.getPath() ).append( \"/...\" ).append( NEWLINE );\n        return buf.toString();\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.tag;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.tag.AbstractTagCommand;\nimport org.apache.maven.scm.command.tag.TagScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceTagCommand\n    extends AbstractTagCommand\n    implements PerforceCommand\n{\n\n    protected ScmResult executeTagCommand( ScmProviderRepository repo, ScmFileSet files, String tag )\n        throws ScmException\n    {\n        PerforceTagConsumer consumer = new PerforceTagConsumer();\n        createLabel( repo, files, tag, consumer );\n        if ( consumer.isSuccess() )\n        {\n            syncLabel( repo, files, tag, consumer );\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", consumer.getTagged() );\n        }\n        else\n        {\n            // Unclear what to pass as the first arg\n            return new TagScmResult( \"p4 label -i\", \"Tag failed\", consumer.getOutput(), false );\n        }\n    }\n\n    private void syncLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl = createLabelsyncCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            getLogger().debug( \"Executing: \" + cl.toString() );\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n    }\n\n    private void createLabel( ScmProviderRepository repo, ScmFileSet files, String tag, PerforceTagConsumer consumer )\n    {\n        Commandline cl = createLabelCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), files, tag );\n        try\n        {\n            getLogger().debug( \"Executing: \" + cl.toString() );\n            Process proc = cl.execute();\n            OutputStream out = proc.getOutputStream();\n            DataOutputStream dos = new DataOutputStream( out );\n            String label = createLabelSpecification( (PerforceScmProviderRepository) repo, files, tag );\n            dos.write( label.getBytes() );\n            dos.close();\n            out.close();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                getLogger().debug( \"Consuming: \" + line );\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n    }\n\n    public static Commandline createLabelCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                     ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"label\" );\n        command.createArgument().setValue( \"-i\" );\n        return command;\n    }\n\n    public static Commandline createLabelsyncCommandLine( PerforceScmProviderRepository repo, File workingDirectory,\n                                                         ScmFileSet files, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"labelsync\" );\n        command.createArgument().setValue( \"-l\" );\n        command.createArgument().setValue( tag );\n\n        try\n        {\n            String candir = workingDirectory.getCanonicalPath();\n            File[] fs = files.getFiles();\n            for ( int i = 0; i < fs.length; i++ )\n            {\n                File file = fs[i];\n                // I want to use relative paths to add files to make testing\n                // simpler.\n                // Otherwise the absolute path will be different on everyone's\n                // machine\n                // and testing will be a little more painful.\n                String canfile = file.getCanonicalPath();\n                if ( canfile.startsWith( candir ) )\n                {\n                    canfile = canfile.substring( candir.length() + 1 );\n                }\n                command.createArgument().setValue( file.getName() );\n            }\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n        return command;\n    }\n\n    private static final String NEWLINE = \"\\r\\n\";\n\n    /*\n     * Label: foo-label \n     * View: //depot/path/to/repos/...\n     */\n    public static String createLabelSpecification( PerforceScmProviderRepository repo, ScmFileSet files, String tag )\n    {\n        StringBuffer buf = new StringBuffer();\n        buf.append( \"Label: \" ).append( tag ).append( NEWLINE );\n        buf.append( \"View: \" ).append( repo.getPath() ).append( \"/...\" ).append( NEWLINE );\n        return buf.toString();\n    }\n\n}\n","lineNo":102}
{"Smelly Sample":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files, String tag )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (PerforceScmProviderRepository) repo, files.getBasedir(), tag );\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer();\n        try\n        {\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            e.printStackTrace();\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n\n        return new CheckOutScmResult( cl.toString(), consumer.isSuccess() ? \"Checkout successful\" : \"Unable to sync\",\n                                      consumer.getOutput(), consumer.isSuccess() );\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"sync\" );\n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        command.createArgument().setValue( \"...\" + ( tag != null ? \"@\" + tag : \"\" ) );\n        return command;\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.perforce.command.checkout;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.perforce.PerforceScmProvider;\nimport org.apache.maven.scm.provider.perforce.command.PerforceCommand;\nimport org.apache.maven.scm.provider.perforce.repository.PerforceScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author Mike Perham\n * @version $Id: PerforceChangeLogCommand.java 264804 2005-08-30 16:09:04Z\n *          evenisse $\n */\npublic class PerforceCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements PerforceCommand\n{\n\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet files, String tag )\n        throws ScmException\n    {\n        PerforceScmProviderRepository prepo = (PerforceScmProviderRepository) repo;\n        Commandline cl = createCommandLine( prepo, files.getBasedir(), tag );\n        PerforceCheckOutConsumer consumer = new PerforceCheckOutConsumer( prepo.getPath() );\n        try\n        {\n            Process proc = cl.execute();\n            BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );\n            String line = null;\n            while ( ( line = br.readLine() ) != null )\n            {\n                consumer.consumeLine( line );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            getLogger().error( e );\n        }\n        catch ( IOException e )\n        {\n            getLogger().error( e );\n        }\n\n        if ( consumer.isSuccess() )\n        {\n            return new CheckOutScmResult( cl.toString(), consumer.getCheckedout() );\n        }\n        else\n        {\n            return new CheckOutScmResult( cl.toString(), \"Unable to sync\", consumer.getOutput(), consumer.isSuccess() );\n        }\n    }\n\n    public static Commandline createCommandLine( PerforceScmProviderRepository repo, File workingDirectory, String tag )\n    {\n        Commandline command = PerforceScmProvider.createP4Command( repo, workingDirectory );\n\n        command.createArgument().setValue( \"sync\" );\n        // Not sure what to do here. I'm unclear whether we should be\n        // sync'ing each file individually to the label or just sync the\n        // entire contents of the workingDir. I'm going to assume the\n        // latter until the exact semantics are clearer.\n        command.createArgument().setValue( \"...\" + ( tag != null ? \"@\" + tag : \"\" ) );\n        return command;\n    }\n\n}\n","lineNo":48}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamAddConsumer\n    implements StreamConsumer\n{\n    private ScmLogger logger;\n\n    private String workingDirectory;\n\n    /**\n     * the current directory entry being processed by the parser\n     */\n    private String currentDir;\n\n    private List files = new ArrayList();\n\n    /**\n     * Marks current directory data\n     */\n    private static final String DIR_MARKER = \"(working dir: \";\n\n    /**\n     * Marks current file data\n     */\n    private static final String ADDED_MARKER = \": added\";\n\n    /**\n     * Marks current file data\n     */\n    private static final String LINKTO_MARKER = \": linked to\";\n\n    public StarteamAddConsumer( ScmLogger logger, File basedir )\n    {\n        this.logger = logger;\n\n        this.workingDirectory = basedir.getPath().replace( '\\\\', '/' );\n    }\n\n    public void consumeLine( String line )\n    {\n        logger.debug( line );\n\n        int pos = 0;\n\n        if ( ( pos = line.indexOf( DIR_MARKER ) ) != -1 )\n        {\n            processDirectory( line, pos );\n        }\n        else if ( ( pos = line.indexOf( ADDED_MARKER ) ) != -1 )\n        {\n            processAddedFile( line, pos );\n        }\n        else if ( ( pos = line.indexOf( LINKTO_MARKER ) ) != -1 )\n        {\n            //ignore\n        }\n        else\n        {\n            this.logger.warn( \"Unknown add ouput: \" + line );\n        }\n    }\n\n    public List getAddedFiles()\n    {\n        return files;\n    }\n\n    private void processDirectory( String line, int pos )\n    {\n        String dirPath = line.substring( pos + DIR_MARKER.length(), line.length() - 1 ).replace( '\\\\', '/' );\n\n        if ( !dirPath.startsWith( workingDirectory ) )\n        {\n            logger.info( \"Working directory: \" + workingDirectory );\n\n            logger.info( \"Checkin directory path: \" + dirPath );\n\n            throw new IllegalStateException( \"Working and checkin directories are not on the same tree\" );\n        }\n\n        this.currentDir = \".\" + dirPath.substring( workingDirectory.length() );\n    }\n\n    private void processAddedFile( String line, int pos )\n    {\n        String addedFilePath = this.currentDir + \"/\" + line.substring( 0, pos );\n\n        this.files.add( new ScmFile( addedFilePath, ScmFileStatus.ADDED ) );\n\n        this.logger.info( \"Added: \" + addedFilePath );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.add;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamAddConsumer\n    implements StreamConsumer\n{\n    private ScmLogger logger;\n\n    private String workingDirectory;\n\n    /**\n     * the current directory entry being processed by the parser\n     */\n    private String currentDir;\n\n    private List files = new ArrayList();\n\n    /**\n     * Marks current directory data\n     */\n    private static final String DIR_MARKER = \"(working dir: \";\n\n    /**\n     * Marks current file data\n     */\n    private static final String ADDED_MARKER = \": added\";\n\n    /**\n     * Marks current file data\n     */\n    private static final String LINKTO_MARKER = \": linked to\";\n\n    public StarteamAddConsumer( ScmLogger logger, File basedir )\n    {\n        this.logger = logger;\n\n        this.workingDirectory = basedir.getPath().replace( '\\\\', '/' );\n    }\n\n    public void consumeLine( String line )\n    {\n        logger.debug( line );\n\n        int pos = 0;\n\n        if ( ( pos = line.indexOf( DIR_MARKER ) ) != -1 )\n        {\n            processDirectory( line, pos );\n        }\n        else if ( ( pos = line.indexOf( ADDED_MARKER ) ) != -1 )\n        {\n            processAddedFile( line, pos );\n        }\n        else if ( ( pos = line.indexOf( LINKTO_MARKER ) ) != -1 )\n        {\n            //ignore\n        }\n        else\n        {\n            this.logger.warn( \"Unknown add ouput: \" + line );\n        }\n    }\n\n    public List getAddedFiles()\n    {\n        return files;\n    }\n\n    private void processDirectory( String line, int pos )\n    {\n        String dirPath = line.substring( pos + DIR_MARKER.length(), line.length() - 1 ).replace( '\\\\', '/' );\n\n        try \n        {\n            this.currentDir = StarteamCommandLineUtils.getRelativeChildDirectory( this.workingDirectory, dirPath );\n        }\n        catch ( IllegalStateException e )\n        {\n            String error = \"Working and checkout directories are not on the same tree\";\n            \n            logger.error( error );\n            \n            logger.error( \"Working directory: \" + workingDirectory );\n            \n            logger.error( \"Checked out directory: \" + dirPath );\n            \n            throw new IllegalStateException( error );\n        }\n    }\n\n    private void processAddedFile( String line, int pos )\n    {\n        String addedFilePath = this.currentDir + \"/\" + line.substring( 0, pos );\n\n        this.files.add( new ScmFile( addedFilePath, ScmFileStatus.ADDED ) );\n\n        this.logger.info( \"Added: \" + addedFilePath );\n    }\n\n}\n","lineNo":108}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.remove;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamRemoveConsumer\n    implements StreamConsumer\n{\n    private ScmLogger logger;\n\n    private String workingDirectory;\n\n    /**\n     * the current directory entry being processed by the parser\n     */\n    private String currentDir;\n\n    private List files = new ArrayList();\n\n    /**\n     * Marks current directory data\n     */\n    private static final String DIR_MARKER = \"(working dir: \";\n\n    /**\n     * Marks current file data\n     */\n    private static final String ADDED_MARKER = \": removed\";\n\n    /**\n     * Marks current file data\n     */\n    private static final String LINKTO_MARKER = \": linked to\";\n\n    public StarteamRemoveConsumer( ScmLogger logger, File basedir )\n    {\n        this.logger = logger;\n\n        this.workingDirectory = basedir.getPath().replace( '\\\\', '/' );\n    }\n\n    public void consumeLine( String line )\n    {\n        logger.debug( line );\n\n        int pos = 0;\n\n        if ( ( pos = line.indexOf( DIR_MARKER ) ) != -1 )\n        {\n            processDirectory( line, pos );\n        }\n        else if ( ( pos = line.indexOf( ADDED_MARKER ) ) != -1 )\n        {\n            processRemovedFile( line, pos );\n        }\n        else if ( ( pos = line.indexOf( LINKTO_MARKER ) ) != -1 )\n        {\n            //ignore\n        }\n        else\n        {\n            this.logger.warn( \"Unknown remove ouput: \" + line );\n        }\n    }\n\n    public List getRemovedFiles()\n    {\n        return files;\n    }\n\n    private void processDirectory( String line, int pos )\n    {\n        String dirPath = line.substring( pos + DIR_MARKER.length(), line.length() - 1 ).replace( '\\\\', '/' );\n\n        if ( !dirPath.startsWith( workingDirectory ) )\n        {\n            logger.info( \"Working directory: \" + workingDirectory );\n\n            logger.info( \"Checkin directory path: \" + dirPath );\n\n            throw new IllegalStateException( \"Working and remove directories are not on the same tree\" );\n        }\n\n        this.currentDir = \".\" + dirPath.substring( workingDirectory.length() );\n    }\n\n    private void processRemovedFile( String line, int pos )\n    {\n        String addedFilePath = this.currentDir + \"/\" + line.substring( 0, pos );\n\n        this.files.add( new ScmFile( addedFilePath, ScmFileStatus.DELETED ) );\n\n        this.logger.info( \"Removed: \" + addedFilePath );\n    }\n\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.remove;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.codehaus.plexus.util.cli.StreamConsumer;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:dantran@gmail.com\">Dan T. Tran<\/a>\n * @version $Id$\n */\npublic class StarteamRemoveConsumer\n    implements StreamConsumer\n{\n    private ScmLogger logger;\n\n    private String workingDirectory;\n\n    /**\n     * the current directory entry being processed by the parser\n     */\n    private String currentDir;\n\n    private List files = new ArrayList();\n\n    /**\n     * Marks current directory data\n     */\n    private static final String DIR_MARKER = \"(working dir: \";\n\n    /**\n     * Marks current file data\n     */\n    private static final String ADDED_MARKER = \": removed\";\n\n    /**\n     * Marks current file data\n     */\n    private static final String LINKTO_MARKER = \": linked to\";\n\n    public StarteamRemoveConsumer( ScmLogger logger, File basedir )\n    {\n        this.logger = logger;\n\n        this.workingDirectory = basedir.getPath().replace( '\\\\', '/' );\n    }\n\n    public void consumeLine( String line )\n    {\n        logger.debug( line );\n\n        int pos = 0;\n\n        if ( ( pos = line.indexOf( DIR_MARKER ) ) != -1 )\n        {\n            processDirectory( line, pos );\n        }\n        else if ( ( pos = line.indexOf( ADDED_MARKER ) ) != -1 )\n        {\n            processRemovedFile( line, pos );\n        }\n        else if ( ( pos = line.indexOf( LINKTO_MARKER ) ) != -1 )\n        {\n            //ignore\n        }\n        else\n        {\n            this.logger.warn( \"Unknown remove ouput: \" + line );\n        }\n    }\n\n    public List getRemovedFiles()\n    {\n        return files;\n    }\n\n    private void processDirectory( String line, int pos )\n    {\n        String dirPath = line.substring( pos + DIR_MARKER.length(), line.length() - 1 ).replace( '\\\\', '/' );\n\n        try \n        {\n            this.currentDir = StarteamCommandLineUtils.getRelativeChildDirectory( this.workingDirectory, dirPath );\n        }\n        catch ( IllegalStateException e )\n        {\n            String error = \"Working and checkout directories are not on the same tree\";\n            \n            logger.error( error );\n            \n            logger.error( \"Working directory: \" + workingDirectory );\n            \n            logger.error( \"Checked out directory: \" + dirPath );\n            \n            throw new IllegalStateException( error );\n        }\n    }\n\n    private void processRemovedFile( String line, int pos )\n    {\n        String addedFilePath = this.currentDir + \"/\" + line.substring( 0, pos );\n\n        this.files.add( new ScmFile( addedFilePath, ScmFileStatus.DELETED ) );\n\n        this.logger.info( \"Removed: \" + addedFilePath );\n    }\n\n}\n","lineNo":108}
{"Smelly Sample":"package org.apache.maven.scm.provider.starteam.command.changelog;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\nimport java.util.Date;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\n\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class StarteamChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractChangeLogCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, int numDays, String branch )\n        throws ScmException\n    {\n        if ( startDate != null || endDate != null )\n        {\n            throw new ScmException( \"This provider doesn't support start and end dates.\" );\n        }\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        // TODO: revision\n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), branch );\n\n        StarteamChangeLogConsumer consumer = new StarteamChangeLogConsumer( getLogger(), startDate, endDate );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n        getLogger().info( \"Command line: \" + cl );\n\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( \"The 'stcmd' command failed.\", stderr.getOutput(), false );\n        }\n\n        return new ChangeLogScmResult( consumer.getModifications() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File workingDirectory, String tag )\n    {\n        Commandline command = new Commandline();\n        command.setExecutable( \"stcmd\" );\n\n        command.setWorkingDirectory( workingDirectory.getAbsolutePath() );\n\n        command.createArgument().setValue( \"hist\" );\n\n        command.createArgument().setValue( \"-x\" );\n\n        command.createArgument().setValue( \"-nologo\" );\n\n        command.createArgument().setValue( \"-is\" );\n\n        command.createArgument().setValue( \"-p\" );\n\n        String p = repo.getUser();\n\n        if ( repo.getPassword() != null )\n        {\n            p += \":\" + repo.getPassword();\n        }\n\n        p += \"@\" + repo.getUrl();\n\n        command.createArgument().setValue( p );\n\n        if ( tag != null )\n        {\n            command.createArgument().setValue( \"-vl\" );\n\n            command.createArgument().setValue( tag );\n        }\n\n        return command;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.starteam.command.changelog;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\nimport java.util.Date;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.AbstractChangeLogCommand;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommand;\nimport org.apache.maven.scm.provider.starteam.command.StarteamCommandLineUtils;\nimport org.apache.maven.scm.provider.starteam.repository.StarteamScmProviderRepository;\n\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class StarteamChangeLogCommand\n    extends AbstractChangeLogCommand\n    implements StarteamCommand\n{\n    // ----------------------------------------------------------------------\n    // AbstractChangeLogCommand Implementation\n    // ----------------------------------------------------------------------\n\n    protected ChangeLogScmResult executeChangeLogCommand( ScmProviderRepository repo, ScmFileSet fileSet,\n                                                          Date startDate, Date endDate, int numDays, String branch )\n        throws ScmException\n    {\n        if ( startDate != null || endDate != null )\n        {\n            throw new ScmException( \"This provider doesn't support start and end dates.\" );\n        }\n\n        StarteamScmProviderRepository repository = (StarteamScmProviderRepository) repo;\n\n        // TODO: revision\n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), branch );\n\n        StarteamChangeLogConsumer consumer = new StarteamChangeLogConsumer( getLogger(), startDate, endDate );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n        getLogger().debug( \"Command line: \" + cl );\n\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch ( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new ChangeLogScmResult( \"The 'stcmd' command failed.\", stderr.getOutput(), false );\n        }\n\n        return new ChangeLogScmResult( consumer.getModifications() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( StarteamScmProviderRepository repo, File workingDirectory, String tag )\n    {\n\t\tString workingDir =  workingDirectory.getAbsolutePath();\n\n        Commandline cl = StarteamCommandLineUtils.createStarteamBaseCommandLine(\"hist\", workingDirectory, repo);\n\n        cl.createArgument().setValue( \"-is\" );\n\n        if ( tag != null && tag.length() != 0 )\n        {\n            cl.createArgument().setValue( \"-cfgl\" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        return cl;\n    }\n}\n","lineNo":93}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.command.checkout;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements SvnCommand\n{\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n        Commandline cl = createCommandLine( (SvnScmProviderRepository)repo, fileSet.getBasedir(), tag );\n\n        SvnCheckOutConsumer consumer = new SvnCheckOutConsumer( getLogger(), fileSet.getBasedir().getParentFile() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n        getLogger().info( \"Command line: \" + cl );\n\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new CheckOutScmResult( \"The svn command failed.\", stderr.getOutput(), false );\n        }\n\n        return new CheckOutScmResult( consumer.getCheckedOutFiles() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory, String tag )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n\n        cl.setWorkingDirectory( workingDirectory.getParentFile().getAbsolutePath() );\n\n        cl.createArgument().setValue( \"checkout\" );\n\n        cl.createArgument().setValue( \"--non-interactive\" );\n\n        if ( tag != null)\n        {\n            cl.createArgument().setValue( \"-r\" );\n\n            cl.createArgument().setValue( tag );\n        }\n\n        if ( repository.getUser() != null )\n        {\n            cl.createArgument().setValue( \"--username\" );\n\n            cl.createArgument().setValue( repository.getUser() );\n        }\n\n        if ( repository.getPassword() != null )\n        {\n            cl.createArgument().setValue( \"--password\" );\n\n            cl.createArgument().setValue( repository.getPassword() );\n        }\n\n        cl.createArgument().setValue( repository.getUrl() );\n\n        cl.createArgument().setValue( workingDirectory.getName() );\n\n        return cl;\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.command.checkout;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.checkout.AbstractCheckOutCommand;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.provider.svn.command.SvnCommand;\nimport org.apache.maven.scm.provider.svn.repository.SvnScmProviderRepository;\nimport org.codehaus.plexus.util.cli.CommandLineException;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.io.File;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnCheckOutCommand\n    extends AbstractCheckOutCommand\n    implements SvnCommand\n{\n    protected CheckOutScmResult executeCheckOutCommand( ScmProviderRepository repo, ScmFileSet fileSet, String tag )\n        throws ScmException\n    {\n        SvnScmProviderRepository repository = (SvnScmProviderRepository) repo;\n\n        String url = repository.getUrl();\n        if ( tag != null )\n        {\n            String tagBase = repository.getTagBase();\n\n            if ( tagBase == null )\n            {\n                throw new ScmException( \"tag base must be specified\" );\n            }\n            url = tagBase + \"/\" + tag;\n        }\n\n        // TODO: revision\n        Commandline cl = createCommandLine( repository, fileSet.getBasedir(), null, url );\n\n        SvnCheckOutConsumer consumer = new SvnCheckOutConsumer( getLogger(), fileSet.getBasedir().getParentFile() );\n\n        CommandLineUtils.StringStreamConsumer stderr = new CommandLineUtils.StringStreamConsumer();\n\n        int exitCode;\n\n        getLogger().info( \"Working directory: \" + fileSet.getBasedir().getAbsolutePath() );\n        getLogger().info( \"Command line: \" + cl );\n\n        try\n        {\n            exitCode = CommandLineUtils.executeCommandLine( cl, consumer, stderr );\n        }\n        catch( CommandLineException ex )\n        {\n            throw new ScmException( \"Error while executing command.\", ex );\n        }\n\n        if ( exitCode != 0 )\n        {\n            return new CheckOutScmResult( \"The svn command failed.\", stderr.getOutput(), false );\n        }\n\n        return new CheckOutScmResult( consumer.getCheckedOutFiles() );\n    }\n\n    // ----------------------------------------------------------------------\n    //\n    // ----------------------------------------------------------------------\n\n    public static Commandline createCommandLine( SvnScmProviderRepository repository, File workingDirectory,\n                                                 String revision, String url )\n    {\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"svn\" );\n\n        cl.setWorkingDirectory( workingDirectory.getParentFile().getAbsolutePath() );\n\n        cl.createArgument().setValue( \"checkout\" );\n\n        cl.createArgument().setValue( \"--non-interactive\" );\n\n        if ( revision != null)\n        {\n            cl.createArgument().setValue( \"-r\" );\n\n            cl.createArgument().setValue( revision );\n        }\n\n        if ( repository.getUser() != null )\n        {\n            cl.createArgument().setValue( \"--username\" );\n\n            cl.createArgument().setValue( repository.getUser() );\n        }\n\n        if ( repository.getPassword() != null )\n        {\n            cl.createArgument().setValue( \"--password\" );\n\n            cl.createArgument().setValue( repository.getPassword() );\n        }\n\n        cl.createArgument().setValue( url );\n\n        cl.createArgument().setValue( workingDirectory.getName() );\n\n        return cl;\n    }\n}\n","lineNo":43}
{"Smelly Sample":"package org.apache.maven.scm.provider.local.command.checkout;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.tck.command.checkout.CheckOutCommandTckTest;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class LocalCheckOutCommandTckTest\n    extends CheckOutCommandTckTest\n{\n    public String getScmUrl()\n        throws Exception\n    {\n        return \"scm:local:\" + getRepositoryRoot().getAbsolutePath() + \":test-repo\";\n    }\n\n    public void initRepo()\n\t\tthrows Exception\n\t{\n        makeFile( getRepositoryRoot(), \"/pom.xml\" );\n\n        makeFile( getRepositoryRoot(), \"/readme.txt\" );\n\n        makeFile( getRepositoryRoot(), \"/src/main/java/Application.java\" );\n\n        makeFile( getRepositoryRoot(), \"/src/test/java/Test.java\" );\n\n        makeDirectory( getRepositoryRoot(), \"/src/test/resources\" );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.local.command.checkout;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.tck.command.checkout.CheckOutCommandTckTest;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class LocalCheckOutCommandTckTest\n    extends CheckOutCommandTckTest\n{\n    private String module = \"check-out\";\n\n    public String getScmUrl()\n        throws Exception\n    {\n        return \"scm:local:\" + getRepositoryRoot().getAbsolutePath() + \":\" + module;\n    }\n\n    public void initRepo()\n\t\tthrows Exception\n\t{\n        File root = new File( getRepositoryRoot() + \"/\" + module );\n\n        makeFile( root, \"/pom.xml\" );\n\n        makeFile( root, \"/readme.txt\" );\n\n        makeFile( root, \"/src/main/java/Application.java\" );\n\n        makeFile( root, \"/src/test/java/Test.java\" );\n\n        makeDirectory( root, \"/src/test/resources\" );\n    }\n}\n","lineNo":41}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.command.checkout;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.tck.command.checkout.CheckOutCommandTckTest;\nimport org.apache.maven.scm.provider.svn.SvnScmTestUtils;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnCheckOutCommandTckTest\n    extends CheckOutCommandTckTest\n{\n    public String getScmUrl()\n        throws Exception\n    {\n        return \"scm:svn:file://\" + getRepositoryRoot().getAbsolutePath();\n    }\n\n    public void initRepo()\n        throws Exception\n    {\n        SvnScmTestUtils.initializeRepository( getRepositoryRoot(), getTestFile( \"src/test/resources/tck/checkout.dump\" ) );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.command.checkout;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.scm.tck.command.checkout.CheckOutCommandTckTest;\nimport org.apache.maven.scm.provider.svn.SvnScmTestUtils;\n\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class SvnCheckOutCommandTckTest\n    extends CheckOutCommandTckTest\n{\n    public String getScmUrl()\n        throws Exception\n    {\n        String repositoryRoot = getRepositoryRoot().getAbsolutePath();\n\n        if ( System.getProperty( \"os.name\" ).startsWith( \"Windows\" ) )\n        {\n            repositoryRoot = \"/\" + StringUtils.replace( repositoryRoot, \"\\\\\", \"/\" );\n        }\n\n        return \"scm:svn:file://\" + repositoryRoot;\n    }\n\n    public void initRepo()\n        throws Exception\n    {\n        SvnScmTestUtils.initializeRepository( getRepositoryRoot(), getTestFile( \"src/test/resources/tck/checkout.dump\" ) );\n    }\n}\n","lineNo":34}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.command.update;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.tck.command.update.UpdateCommandTckTest;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.provider.svn.SvnScmTestUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class SvnUpdateCommandTckTest\n    extends UpdateCommandTckTest\n{\n    private final static File updateDump = getTestFile( \"src/test/resources/tck/update.dump\" );\n\n    public String getScmUrl()\n        throws Exception\n    {\n        return \"scm:svn:file://\" + getRepositoryRoot();\n    }\n\n    public void initRepo()\n        throws Exception\n    {\n        SvnScmTestUtils.initializeRepository( getRepositoryRoot(), updateDump );\n    }\n\n    public void checkOut( File workingDirectory )\n        throws Exception\n    {\n        execute( workingDirectory.getParentFile(), \"svn\", \"checkout file://\" + getRepositoryRoot() + \" \" + workingDirectory.getName() );\n    }\n\n    public void addFileToRepository( File workingDirectory, String file )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + file );\n    }\n\n    public void addDirectoryToRepository( File workingDirectory, String directory )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + directory );\n    }\n\n    public void commit( File workingDirectory, ScmRepository repository )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"commit -m '' --non-interactive\" );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.command.update;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.tck.command.update.UpdateCommandTckTest;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.provider.svn.SvnScmTestUtils;\n\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class SvnUpdateCommandTckTest\n    extends UpdateCommandTckTest\n{\n    private final static File updateDump = getTestFile( \"src/test/resources/tck/update.dump\" );\n\n    public String getScmUrl()\n        throws Exception\n    {\n        String repositoryRoot = getRepositoryRoot().getAbsolutePath();\n\n        if ( System.getProperty( \"os.name\" ).startsWith( \"Windows\" ) )\n        {\n            repositoryRoot = \"/\" + StringUtils.replace( repositoryRoot, \"\\\\\", \"/\" );\n        }\n\n        return \"scm:svn:file://\" + repositoryRoot;\n    }\n\n    public void initRepo()\n        throws Exception\n    {\n        SvnScmTestUtils.initializeRepository( getRepositoryRoot(), updateDump );\n    }\n\n    public void checkOut( File workingDirectory )\n        throws Exception\n    {\n        String repositoryRoot = getRepositoryRoot().getAbsolutePath();\n\n        if ( System.getProperty( \"os.name\" ).startsWith( \"Windows\" ) )\n        {\n            repositoryRoot = \"/\" + StringUtils.replace( repositoryRoot, \"\\\\\", \"/\" );\n        }\n\n        execute( workingDirectory.getParentFile(), \"svn\", \"checkout file://\" + repositoryRoot + \" \" + workingDirectory.getName() );\n    }\n\n    public void addFileToRepository( File workingDirectory, String file )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + file );\n    }\n\n    public void addDirectoryToRepository( File workingDirectory, String directory )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + directory );\n    }\n\n    public void commit( File workingDirectory, ScmRepository repository )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"commit -m '' --non-interactive\" );\n    }\n}\n","lineNo":39}
{"Smelly Sample":"package org.apache.maven.scm.provider.svn.command.update;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.tck.command.update.UpdateCommandTckTest;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.provider.svn.SvnScmTestUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class SvnUpdateCommandTckTest\n    extends UpdateCommandTckTest\n{\n    private final static File updateDump = getTestFile( \"src/test/resources/tck/update.dump\" );\n\n    public String getScmUrl()\n        throws Exception\n    {\n        return \"scm:svn:file://\" + getRepositoryRoot();\n    }\n\n    public void initRepo()\n        throws Exception\n    {\n        SvnScmTestUtils.initializeRepository( getRepositoryRoot(), updateDump );\n    }\n\n    public void checkOut( File workingDirectory )\n        throws Exception\n    {\n        execute( workingDirectory.getParentFile(), \"svn\", \"checkout file://\" + getRepositoryRoot() + \" \" + workingDirectory.getName() );\n    }\n\n    public void addFileToRepository( File workingDirectory, String file )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + file );\n    }\n\n    public void addDirectoryToRepository( File workingDirectory, String directory )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + directory );\n    }\n\n    public void commit( File workingDirectory, ScmRepository repository )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"commit -m '' --non-interactive\" );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.svn.command.update;\n\n/*\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.tck.command.update.UpdateCommandTckTest;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.provider.svn.SvnScmTestUtils;\n\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class SvnUpdateCommandTckTest\n    extends UpdateCommandTckTest\n{\n    private final static File updateDump = getTestFile( \"src/test/resources/tck/update.dump\" );\n\n    public String getScmUrl()\n        throws Exception\n    {\n        String repositoryRoot = getRepositoryRoot().getAbsolutePath();\n\n        if ( System.getProperty( \"os.name\" ).startsWith( \"Windows\" ) )\n        {\n            repositoryRoot = \"/\" + StringUtils.replace( repositoryRoot, \"\\\\\", \"/\" );\n        }\n\n        return \"scm:svn:file://\" + repositoryRoot;\n    }\n\n    public void initRepo()\n        throws Exception\n    {\n        SvnScmTestUtils.initializeRepository( getRepositoryRoot(), updateDump );\n    }\n\n    public void checkOut( File workingDirectory )\n        throws Exception\n    {\n        String repositoryRoot = getRepositoryRoot().getAbsolutePath();\n\n        if ( System.getProperty( \"os.name\" ).startsWith( \"Windows\" ) )\n        {\n            repositoryRoot = \"/\" + StringUtils.replace( repositoryRoot, \"\\\\\", \"/\" );\n        }\n\n        execute( workingDirectory.getParentFile(), \"svn\", \"checkout file://\" + repositoryRoot + \" \" + workingDirectory.getName() );\n    }\n\n    public void addFileToRepository( File workingDirectory, String file )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + file );\n    }\n\n    public void addDirectoryToRepository( File workingDirectory, String directory )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"add \" + directory );\n    }\n\n    public void commit( File workingDirectory, ScmRepository repository )\n        throws Exception\n    {\n        execute( workingDirectory, \"svn\", \"commit -m '' --non-interactive\" );\n    }\n}\n","lineNo":58}
{"Smelly Sample":"package org.apache.maven.scm.provider.local.command.checkout;\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport java.io.File;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.local.AbstractLocalScmTest;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport org.codehaus.plexus.util.FileUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckoutCommandTest\n    extends AbstractLocalScmTest\n{\n    protected String getModule()\n    {\n        return \"test-repo/checkout\";\n    }\n\n    public void testCheckOutWithTag()\n    \tthrows Exception\n    {\n        ScmManager scmManager = getScmManager();\n\n        try\n        {\n            scmManager.checkOut( makeScmRepository( \"scm:local:src/test/repositories:test-repo\" ), getWorkingDirectory(), \"my-tag\" );\n\n            fail( \"Expected ScmException\" );\n        }\n        catch( ScmException ex )\n        {\n            // expected\n        }\n    }\n\n    public void testTestScmWithRelativePath()\n        throws Exception\n    {\n        coTest( \"scm:local:src/test/repositories:test-repo\" );\n    }\n\n    public void testTestScmWithAbsolutePath()\n        throws Exception\n    {\n        coTest( \"scm:local:\" + getTestPath( \"src/test/repositories\" ) + \":test-repo\" );\n    }\n\n    private void coTest( String scmUrl )\n        throws Exception\n    {\n        ScmManager scmManager = (ScmManager) lookup( ScmManager.ROLE );\n\n        ScmRepository repository = scmManager.makeScmRepository( scmUrl );\n\n        File workingDirectory = getTestFile( \"target/local-scm-test\" );\n\n        FileUtils.deleteDirectory( workingDirectory );\n\n        assertTrue( workingDirectory.mkdir() );\n\n        CheckOutScmResult result = scmManager.checkOut( repository, workingDirectory, null );\n\n        // Assert the result\n        assertNotNull( result );\n\n        assertTrue( result.isSuccess() );\n\n        assertNotNull( result.getCheckedOutFiles() );\n\n        assertEquals( 2, result.getCheckedOutFiles().size() );\n\n        ScmFile file1 = (ScmFile) result.getCheckedOutFiles().get( 0 );\n\n        assertEquals( \"/test-repo/readme.txt\", file1.getPath( ) );\n\n        assertEquals( ScmFileStatus.CHECKED_OUT, file1.getStatus() );\n\n        ScmFile file2 = (ScmFile) result.getCheckedOutFiles().get( 1 );\n\n        assertEquals( \"/test-repo/src/main/java/Test.java\", file2.getPath( ) );\n\n        assertEquals( ScmFileStatus.CHECKED_OUT, file2.getStatus() );\n\n        // Assert that the files actually is there\n        File coDir = new File( workingDirectory, \"test-repo\" );\n\n        assertTrue( coDir.isDirectory() );\n\n        assertTrue( new File( coDir, \"src/main/java/Test.java\" ).isFile() );\n\n        assertTrue( new File( coDir, \"readme.txt\" ).isFile() );\n    }\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.local.command.checkout;\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport java.io.File;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFile;\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.command.checkout.CheckOutScmResult;\nimport org.apache.maven.scm.manager.ScmManager;\nimport org.apache.maven.scm.provider.local.AbstractLocalScmTest;\nimport org.apache.maven.scm.repository.ScmRepository;\n\nimport org.codehaus.plexus.util.FileUtils;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class LocalCheckoutCommandTest\n    extends AbstractLocalScmTest\n{\n    protected String getModule()\n    {\n        return \"test-repo/checkout\";\n    }\n\n    public void testCheckOutWithTag()\n    \tthrows Exception\n    {\n        ScmManager scmManager = getScmManager();\n\n        try\n        {\n            scmManager.checkOut( makeScmRepository( \"scm:local:src/test/repositories:test-repo\" ), getWorkingDirectory(), \"my-tag\" );\n\n            fail( \"Expected ScmException\" );\n        }\n        catch( ScmException ex )\n        {\n            // expected\n        }\n    }\n\n    public void testTestScmWithRelativePath()\n        throws Exception\n    {\n        coTest( \"scm:local:src/test/repositories:test-repo\" );\n    }\n\n    public void testTestScmWithAbsolutePath()\n        throws Exception\n    {\n        coTest( \"scm:local:\" + getTestPath( \"src/test/repositories\" ) + \":test-repo\" );\n    }\n\n    private void coTest( String scmUrl )\n        throws Exception\n    {\n        ScmManager scmManager = (ScmManager) lookup( ScmManager.ROLE );\n\n        ScmRepository repository = scmManager.makeScmRepository( scmUrl );\n\n        File workingDirectory = getTestFile( \"target/local-scm-test\" );\n\n        FileUtils.deleteDirectory( workingDirectory );\n\n        assertTrue( workingDirectory.mkdir() );\n\n        CheckOutScmResult result = scmManager.checkOut( repository, workingDirectory, null );\n\n        // Assert the result\n        assertNotNull( result );\n\n        assertTrue( result.isSuccess() );\n\n        assertNotNull( result.getCheckedOutFiles() );\n\n        assertEquals( 2, result.getCheckedOutFiles().size() );\n\n        // Sort the files as we're not guaranteed any ordering\n        SortedSet files = new TreeSet( result.getCheckedOutFiles() );\n\n        ScmFile file1 = (ScmFile) files.first();\n\n        assertEquals( \"/test-repo/src/main/java/Test.java\", file1.getPath( ) );\n\n        assertEquals( ScmFileStatus.CHECKED_OUT, file1.getStatus() );\n\n        ScmFile file2 = (ScmFile) files.last();\n\n        assertEquals( \"/test-repo/readme.txt\", file2.getPath( ) );\n\n        assertEquals( ScmFileStatus.CHECKED_OUT, file2.getStatus() );\n\n        // Assert that the files actually is there\n        File coDir = new File( workingDirectory, \"test-repo\" );\n\n        assertTrue( coDir.isDirectory() );\n\n        assertTrue( new File( coDir, \"src/main/java/Test.java\" ).isFile() );\n\n        assertTrue( new File( coDir, \"readme.txt\" ).isFile() );\n    }\n}\n","lineNo":100}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.repository.AbstractRepository;\nimport org.codehaus.plexus.util.cli.EnhancedStringTokenizer;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class CvsRepository extends AbstractRepository\n{\n    public static final int POS_SCM_SUBTYPE = 0;\n    public static final int POS_SCM_USERHOST = 1;\n    public static final int POS_SCM_PATH = 2;\n    public static final int POS_SCM_MODULE = 3;\n\n    private String cvsroot;\n    private String subtype;\n    private String user;\n    private String host;\n    private String path;\n    private String module;\n    private String password;\n\n    /**\n     * @return The cvsroot.\n     * @throws ScmException\n     */\n    public String getCvsRoot() throws ScmException\n    {\n        parseConnection();\n        return cvsroot;\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     * @throws ScmException\n     */\n    public String getSubType() throws ScmException\n    {\n        parseConnection();\n        return subtype;\n    }\n\n    /**\n     * @return The user.\n     * @throws ScmException\n     */\n    public String getUser() throws ScmException\n    {\n        parseConnection();\n        return user;\n    }\n\n    /**\n     * @return The host.\n     * @throws ScmException\n     */\n    public String getHost() throws ScmException\n    {\n        parseConnection();\n        return host;\n    }\n\n    /**\n     * @return The path.\n     * @throws ScmException\n     */\n    public String getPath() throws ScmException\n    {\n        parseConnection();\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     * @throws ScmException\n     */\n    public String getModule() throws ScmException\n    {\n        parseConnection();\n        return module;\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.maven.scm.repository.Repository#parseConnection()\n     */\n    public void parseConnection() throws ScmException\n    {\n        String[] tokens = splitConnection();\n\n        if (tokens.length < 4)\n        {\n            throw new ScmException(\"connection string is too short.\");\n        }\n\n        if (tokens[POS_SCM_SUBTYPE].equalsIgnoreCase(\"local\"))\n        {\n            // use the local repository directory eg. '/home/cvspublic'\n            cvsroot = tokens[POS_SCM_PATH];\n        }\n        else\n        {\n            if (tokens[POS_SCM_SUBTYPE].equalsIgnoreCase(\"lserver\"))\n            {\n                //create the cvsroot as the local socket cvsroot\n                cvsroot = tokens[POS_SCM_USERHOST] + \":\" + tokens[POS_SCM_PATH];\n            }\n            else\n            {\n                //create the cvsroot as the remote cvsroot\n                cvsroot =\n                    \":\"\n                        + tokens[POS_SCM_SUBTYPE]\n                        + \":\"\n                        + tokens[POS_SCM_USERHOST]\n                        + \":\"\n                        + tokens[POS_SCM_PATH];\n            }\n        }\n\n        subtype = tokens[POS_SCM_SUBTYPE];\n        user =\n            tokens[POS_SCM_USERHOST].substring(\n                0,\n                tokens[POS_SCM_USERHOST].indexOf(\"@\"));\n        host =\n            tokens[POS_SCM_USERHOST].substring(\n                tokens[POS_SCM_USERHOST].indexOf(\"@\") + 1);\n        path = tokens[POS_SCM_PATH];\n        module = tokens[POS_SCM_MODULE];\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.maven.scm.repository.Repository#getPassword()\n     */\n    public String getPassword()\n    {\n        return password;\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.maven.scm.repository.Repository#setPassword(java.lang.String)\n     */\n    public void setPassword(String password)\n    {\n        this.password = password;\n    }\n    \n\t/**\n\t * Splits an connection string into parts \n\t * @param connection\n\t * @return\n\t */\n    public String[] splitConnection() throws ScmException\n    {\n    \tif (getConnection() == null)\n    \t{\n\t\t\tthrow new ScmException(\"connection must be defined\");\n    \t}\n    \tif (getDelimiter() == null)\n    \t{\n\t\t\tthrow new ScmException(\"delimiter must be defined\");\n\t\t}\n\t\t\n\t\tEnhancedStringTokenizer tok = new EnhancedStringTokenizer(getConnection(), getDelimiter());\n\n\t\tString[] tokens = tokenizerToArray(tok);\n        \n\t\tif (tokens.length < 4)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"repository connection string contains less than four tokens\");\n\t\t}\n\n\t\tif (tokens.length > 4)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"repository connection string contains more than four tokens\");\n\t\t}\n\t\treturn tokens;\n\t}\n\n\t/**\n\t * Converts a tokenizer to an array of strings\n\t * @param tok\n\t * @return String[]\n\t */\n\tprivate static String[] tokenizerToArray(EnhancedStringTokenizer tok)\n\t{\n\t\tList l = new ArrayList();\n\t\twhile (tok.hasMoreTokens())\n\t\t{\n\t\t\tl.add(tok.nextToken());\n\t\t}\n\t\treturn (String[]) l.toArray(new String[l.size()]);\n\t}\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.repository.AbstractRepository;\nimport org.codehaus.plexus.util.cli.EnhancedStringTokenizer;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsRepository extends AbstractRepository\n{\n    public static final int POS_SCM_SUBTYPE = 0;\n    public static final int POS_SCM_USERHOST = 1;\n    public static final int POS_SCM_PATH = 2;\n    public static final int POS_SCM_MODULE = 3;\n\n    private final static String SUBTYPE_LOCAL = \"local\";\n    private final static String SUBTYPE_PSERVER = \"pserver\";\n    private final static String SUBTYPE_LSERVER = \"lserver\";\n    private final static String SUBTYPE_EXT = \"ext\";\n\n    private String cvsroot;\n    private String subtype;\n    private String user;\n    private String host;\n    private String path;\n    private String module;\n    private String password;\n\n    /**\n     * @return The cvsroot.\n     * @throws ScmException\n     */\n    public String getCvsRoot() throws ScmException\n    {\n        parseConnection();\n        return cvsroot;\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     * @throws ScmException\n     */\n    public String getSubType() throws ScmException\n    {\n        parseConnection();\n        return subtype;\n    }\n\n    /**\n     * @return The user.\n     * @throws ScmException\n     */\n    public String getUser() throws ScmException\n    {\n        parseConnection();\n        return user;\n    }\n\n    /**\n     * @return The host.\n     * @throws ScmException\n     */\n    public String getHost() throws ScmException\n    {\n        parseConnection();\n        return host;\n    }\n\n    /**\n     * @return The path.\n     * @throws ScmException\n     */\n    public String getPath() throws ScmException\n    {\n        parseConnection();\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     * @throws ScmException\n     */\n    public String getModule() throws ScmException\n    {\n        parseConnection();\n        return module;\n    }\n\n    public void parseConnection() throws ScmException\n    {\n        String[] tokens = splitConnection();\n\n        if ( tokens.length < 4 )\n        {\n            throw new ScmException(\"The connection string contains to few tokens.\");\n        }\n\n        if ( tokens[POS_SCM_SUBTYPE].equalsIgnoreCase( SUBTYPE_LOCAL ) )\n        {\n            // use the local repository directory eg. '/home/cvspublic'\n            cvsroot = tokens[POS_SCM_PATH];\n        }\n        else if ( tokens[POS_SCM_SUBTYPE].equalsIgnoreCase( SUBTYPE_LSERVER ) )\n        {\n            //create the cvsroot as the local socket cvsroot\n            cvsroot = tokens[POS_SCM_USERHOST] + \":\" + tokens[POS_SCM_PATH];\n        }\n        else\n        {\n            //create the cvsroot as the remote cvsroot\n            cvsroot =\n                \":\"\n                + tokens[POS_SCM_SUBTYPE]\n                + \":\"\n                + tokens[POS_SCM_USERHOST]\n                + \":\"\n                + tokens[POS_SCM_PATH];\n        }\n\n        subtype = tokens[POS_SCM_SUBTYPE];\n\n        if ( !subtype.equalsIgnoreCase( SUBTYPE_LOCAL ) )\n        {\n            String userhost = tokens[POS_SCM_USERHOST];\n    \n            int index = userhost.indexOf(\"@\");\n\n            if ( index == -1 )\n            {\n                throw new ScmException( \"The userhost part must be on the form: <username>@<hostname>.\" );\n            }\n    \n            user = userhost.substring( 0, index );\n    \n            host = userhost.substring( index + 1 );\n        }\n\n        path = tokens[POS_SCM_PATH];\n\n        module = tokens[POS_SCM_MODULE];\n    }\n\n    public String getPassword()\n    {\n        return password;\n    }\n\n    public void setPassword(String password)\n    {\n        this.password = password;\n    }\n\n\t/**\n\t * Splits an connection string into parts \n\t * @param connection\n\t * @return\n\t */\n    public String[] splitConnection() throws ScmException\n    {\n    \tif (getConnection() == null)\n    \t{\n\t\t\tthrow new ScmException(\"The connection must be defined\");\n    \t}\n    \tif (getDelimiter() == null)\n    \t{\n\t\t\tthrow new ScmException(\"The delimiter must be defined\");\n\t\t}\n\n\t\tEnhancedStringTokenizer tok = new EnhancedStringTokenizer(getConnection(), getDelimiter());\n\n\t\tString[] tokens = tokenizerToArray(tok);\n\n\t\treturn tokens;\n\t}\n\n\t/**\n\t * Converts a tokenizer to an array of strings\n\t * @param tok\n\t * @return String[]\n\t */\n\tprivate static String[] tokenizerToArray(EnhancedStringTokenizer tok)\n\t{\n\t\tList l = new ArrayList();\n\t\twhile (tok.hasMoreTokens())\n\t\t{\n\t\t\tl.add(tok.nextToken());\n\t\t}\n\t\treturn (String[]) l.toArray(new String[l.size()]);\n\t}\n}\n","lineNo":147}
{"Smelly Sample":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.repository.AbstractRepository;\nimport org.codehaus.plexus.util.cli.EnhancedStringTokenizer;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @version $Id$\n */\npublic class CvsRepository extends AbstractRepository\n{\n    public static final int POS_SCM_SUBTYPE = 0;\n    public static final int POS_SCM_USERHOST = 1;\n    public static final int POS_SCM_PATH = 2;\n    public static final int POS_SCM_MODULE = 3;\n\n    private String cvsroot;\n    private String subtype;\n    private String user;\n    private String host;\n    private String path;\n    private String module;\n    private String password;\n\n    /**\n     * @return The cvsroot.\n     * @throws ScmException\n     */\n    public String getCvsRoot() throws ScmException\n    {\n        parseConnection();\n        return cvsroot;\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     * @throws ScmException\n     */\n    public String getSubType() throws ScmException\n    {\n        parseConnection();\n        return subtype;\n    }\n\n    /**\n     * @return The user.\n     * @throws ScmException\n     */\n    public String getUser() throws ScmException\n    {\n        parseConnection();\n        return user;\n    }\n\n    /**\n     * @return The host.\n     * @throws ScmException\n     */\n    public String getHost() throws ScmException\n    {\n        parseConnection();\n        return host;\n    }\n\n    /**\n     * @return The path.\n     * @throws ScmException\n     */\n    public String getPath() throws ScmException\n    {\n        parseConnection();\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     * @throws ScmException\n     */\n    public String getModule() throws ScmException\n    {\n        parseConnection();\n        return module;\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.maven.scm.repository.Repository#parseConnection()\n     */\n    public void parseConnection() throws ScmException\n    {\n        String[] tokens = splitConnection();\n\n        if (tokens.length < 4)\n        {\n            throw new ScmException(\"connection string is too short.\");\n        }\n\n        if (tokens[POS_SCM_SUBTYPE].equalsIgnoreCase(\"local\"))\n        {\n            // use the local repository directory eg. '/home/cvspublic'\n            cvsroot = tokens[POS_SCM_PATH];\n        }\n        else\n        {\n            if (tokens[POS_SCM_SUBTYPE].equalsIgnoreCase(\"lserver\"))\n            {\n                //create the cvsroot as the local socket cvsroot\n                cvsroot = tokens[POS_SCM_USERHOST] + \":\" + tokens[POS_SCM_PATH];\n            }\n            else\n            {\n                //create the cvsroot as the remote cvsroot\n                cvsroot =\n                    \":\"\n                        + tokens[POS_SCM_SUBTYPE]\n                        + \":\"\n                        + tokens[POS_SCM_USERHOST]\n                        + \":\"\n                        + tokens[POS_SCM_PATH];\n            }\n        }\n\n        subtype = tokens[POS_SCM_SUBTYPE];\n        user =\n            tokens[POS_SCM_USERHOST].substring(\n                0,\n                tokens[POS_SCM_USERHOST].indexOf(\"@\"));\n        host =\n            tokens[POS_SCM_USERHOST].substring(\n                tokens[POS_SCM_USERHOST].indexOf(\"@\") + 1);\n        path = tokens[POS_SCM_PATH];\n        module = tokens[POS_SCM_MODULE];\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.maven.scm.repository.Repository#getPassword()\n     */\n    public String getPassword()\n    {\n        return password;\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.maven.scm.repository.Repository#setPassword(java.lang.String)\n     */\n    public void setPassword(String password)\n    {\n        this.password = password;\n    }\n    \n\t/**\n\t * Splits an connection string into parts \n\t * @param connection\n\t * @return\n\t */\n    public String[] splitConnection() throws ScmException\n    {\n    \tif (getConnection() == null)\n    \t{\n\t\t\tthrow new ScmException(\"connection must be defined\");\n    \t}\n    \tif (getDelimiter() == null)\n    \t{\n\t\t\tthrow new ScmException(\"delimiter must be defined\");\n\t\t}\n\t\t\n\t\tEnhancedStringTokenizer tok = new EnhancedStringTokenizer(getConnection(), getDelimiter());\n\n\t\tString[] tokens = tokenizerToArray(tok);\n        \n\t\tif (tokens.length < 4)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"repository connection string contains less than four tokens\");\n\t\t}\n\n\t\tif (tokens.length > 4)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"repository connection string contains more than four tokens\");\n\t\t}\n\t\treturn tokens;\n\t}\n\n\t/**\n\t * Converts a tokenizer to an array of strings\n\t * @param tok\n\t * @return String[]\n\t */\n\tprivate static String[] tokenizerToArray(EnhancedStringTokenizer tok)\n\t{\n\t\tList l = new ArrayList();\n\t\twhile (tok.hasMoreTokens())\n\t\t{\n\t\t\tl.add(tok.nextToken());\n\t\t}\n\t\treturn (String[]) l.toArray(new String[l.size()]);\n\t}\n}\n","Method after Refactoring":"package org.apache.maven.scm.provider.cvslib.repository;\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.repository.AbstractRepository;\nimport org.codehaus.plexus.util.cli.EnhancedStringTokenizer;\n\n/**\n * @author <a href=\"mailto:evenisse@apache.org\">Emmanuel Venisse<\/a>\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l<\/a>\n * @version $Id$\n */\npublic class CvsRepository extends AbstractRepository\n{\n    public static final int POS_SCM_SUBTYPE = 0;\n    public static final int POS_SCM_USERHOST = 1;\n    public static final int POS_SCM_PATH = 2;\n    public static final int POS_SCM_MODULE = 3;\n\n    private final static String SUBTYPE_LOCAL = \"local\";\n    private final static String SUBTYPE_PSERVER = \"pserver\";\n    private final static String SUBTYPE_LSERVER = \"lserver\";\n    private final static String SUBTYPE_EXT = \"ext\";\n\n    private String cvsroot;\n    private String subtype;\n    private String user;\n    private String host;\n    private String path;\n    private String module;\n    private String password;\n\n    /**\n     * @return The cvsroot.\n     * @throws ScmException\n     */\n    public String getCvsRoot() throws ScmException\n    {\n        parseConnection();\n        return cvsroot;\n    }\n\n    /**\n     * @return The subtype (like pserver).\n     * @throws ScmException\n     */\n    public String getSubType() throws ScmException\n    {\n        parseConnection();\n        return subtype;\n    }\n\n    /**\n     * @return The user.\n     * @throws ScmException\n     */\n    public String getUser() throws ScmException\n    {\n        parseConnection();\n        return user;\n    }\n\n    /**\n     * @return The host.\n     * @throws ScmException\n     */\n    public String getHost() throws ScmException\n    {\n        parseConnection();\n        return host;\n    }\n\n    /**\n     * @return The path.\n     * @throws ScmException\n     */\n    public String getPath() throws ScmException\n    {\n        parseConnection();\n        return path;\n    }\n\n    /**\n     * @return The module name.\n     * @throws ScmException\n     */\n    public String getModule() throws ScmException\n    {\n        parseConnection();\n        return module;\n    }\n\n    public void parseConnection() throws ScmException\n    {\n        String[] tokens = splitConnection();\n\n        if ( tokens.length < 4 )\n        {\n            throw new ScmException(\"The connection string contains to few tokens.\");\n        }\n\n        if ( tokens[POS_SCM_SUBTYPE].equalsIgnoreCase( SUBTYPE_LOCAL ) )\n        {\n            // use the local repository directory eg. '/home/cvspublic'\n            cvsroot = tokens[POS_SCM_PATH];\n        }\n        else if ( tokens[POS_SCM_SUBTYPE].equalsIgnoreCase( SUBTYPE_LSERVER ) )\n        {\n            //create the cvsroot as the local socket cvsroot\n            cvsroot = tokens[POS_SCM_USERHOST] + \":\" + tokens[POS_SCM_PATH];\n        }\n        else\n        {\n            //create the cvsroot as the remote cvsroot\n            cvsroot =\n                \":\"\n                + tokens[POS_SCM_SUBTYPE]\n                + \":\"\n                + tokens[POS_SCM_USERHOST]\n                + \":\"\n                + tokens[POS_SCM_PATH];\n        }\n\n        subtype = tokens[POS_SCM_SUBTYPE];\n\n        if ( !subtype.equalsIgnoreCase( SUBTYPE_LOCAL ) )\n        {\n            String userhost = tokens[POS_SCM_USERHOST];\n    \n            int index = userhost.indexOf(\"@\");\n\n            if ( index == -1 )\n            {\n                throw new ScmException( \"The userhost part must be on the form: <username>@<hostname>.\" );\n            }\n    \n            user = userhost.substring( 0, index );\n    \n            host = userhost.substring( index + 1 );\n        }\n\n        path = tokens[POS_SCM_PATH];\n\n        module = tokens[POS_SCM_MODULE];\n    }\n\n    public String getPassword()\n    {\n        return password;\n    }\n\n    public void setPassword(String password)\n    {\n        this.password = password;\n    }\n\n\t/**\n\t * Splits an connection string into parts \n\t * @param connection\n\t * @return\n\t */\n    public String[] splitConnection() throws ScmException\n    {\n    \tif (getConnection() == null)\n    \t{\n\t\t\tthrow new ScmException(\"The connection must be defined\");\n    \t}\n    \tif (getDelimiter() == null)\n    \t{\n\t\t\tthrow new ScmException(\"The delimiter must be defined\");\n\t\t}\n\n\t\tEnhancedStringTokenizer tok = new EnhancedStringTokenizer(getConnection(), getDelimiter());\n\n\t\tString[] tokens = tokenizerToArray(tok);\n\n\t\treturn tokens;\n\t}\n\n\t/**\n\t * Converts a tokenizer to an array of strings\n\t * @param tok\n\t * @return String[]\n\t */\n\tprivate static String[] tokenizerToArray(EnhancedStringTokenizer tok)\n\t{\n\t\tList l = new ArrayList();\n\t\twhile (tok.hasMoreTokens())\n\t\t{\n\t\t\tl.add(tok.nextToken());\n\t\t}\n\t\treturn (String[]) l.toArray(new String[l.size()]);\n\t}\n}\n","lineNo":149}
{"Smelly Sample":"/********************************************************************************\n * CruiseControl, a Continuous Integration Toolkit\n * Copyright (c) 2001-2003, ThoughtWorks, Inc.\n * 651 W Washington Ave. Suite 500\n * Chicago, IL 60661 USA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     + Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *\n *     + Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *     + Neither the name of ThoughtWorks, Inc., CruiseControl, nor the\n *       names of its contributors may be used to endorse or promote\n *       products derived from this software without specific prior\n *       written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ********************************************************************************/\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\npackage org.apache.maven.scm.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\nimport org.apache.maven.scm.ScmException;\n\n/**\n * Commandline objects help handling command lines specifying processes to\n * execute.\n *\n * The class can be used to define a command line as nested elements or as a\n * helper to define a command line by an application.\n * <p>\n * <code>\n * &lt;someelement&gt;<br>\n * &nbsp;&nbsp;&lt;acommandline executable=\"/executable/to/run\"&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 1\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line=\"argument_1 argument_2 argument_3\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 4\" /&gt;<br>\n * &nbsp;&nbsp;&lt;/acommandline&gt;<br>\n * &lt;/someelement&gt;<br>\n * <\/code>\n * The element <code>someelement<\/code> must provide a method\n * <code>createAcommandline<\/code> which returns an instance of this class.\n *\n * @author thomas.haas@softwired-inc.com\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig<\/a>\n */\npublic class Commandline implements Cloneable\n{\n    private Vector arguments = new Vector();\n    private String executable = null;\n    private File workingDir = null;\n\n    public Commandline( String toProcess )\n    {\n        super();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = translateCommandline( toProcess );\n        }\n        catch ( ScmException e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( tmp != null && tmp.length > 0 )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    public Commandline()\n    {\n        super();\n    }\n\n    /**\n     * Used for nested xml command line definitions.\n     */\n    public static class Argument\n    {\n\n        private String[] parts;\n\n        /**\n         * Sets a single commandline argument.\n         *\n         * @param value a single commandline argument.\n         */\n        public void setValue( String value )\n        {\n            parts = new String[]{value};\n        }\n\n        /**\n         * Line to split into several commandline arguments.\n         *\n         * @param line line to split into several commandline arguments\n         */\n        public void setLine( String line )\n        {\n            if ( line == null )\n            {\n                return;\n            }\n            try\n            {\n                parts = translateCommandline( line );\n            }\n            catch ( ScmException e )\n            {\n                System.err.println( \"Error translating Commandline.\" );\n            }\n        }\n\n        /**\n         * Sets a single commandline argument to the absolute filename\n         * of the given file.\n         *\n         * @param value a single commandline argument.\n         */\n        public void setFile( File value )\n        {\n            parts = new String[]{value.getAbsolutePath()};\n        }\n\n        /**\n         * Returns the parts this Argument consists of.\n         */\n        public String[] getParts()\n        {\n            return parts;\n        }\n    }\n\n    /**\n     * Class to keep track of the position of an Argument.\n     */\n    // <p>This class is there to support the srcfile and targetfile\n    // elements of &lt;execon&gt; and &lt;transform&gt; - don't know\n    // whether there might be additional use cases.<\/p> --SB\n    public class Marker\n    {\n\n        private int position;\n        private int realPos = -1;\n\n        Marker( int position )\n        {\n            this.position = position;\n        }\n\n        /**\n         * Return the number of arguments that preceeded this marker.\n         *\n         * <p>The name of the executable - if set - is counted as the\n         * very first argument.<\/p>\n         */\n        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( executable == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Argument arg = (Argument) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n    }\n\n    /**\n     * Creates an argument object.\n     *\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)<\/code>.<\/p>\n     *\n     * @see #createArgument(boolean)\n     * @return the argument object.\n     */\n    public Argument createArgument()\n    {\n        return this.createArgument( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     *\n     * <p>Each commandline object has at most one instance of the\n     * argument class.<\/p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     * beginning of the list of args, otherwise it is appended.\n     */\n    public Argument createArgument( boolean insertAtStart )\n    {\n        Argument argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        if ( executable == null || executable.length() == 0 )\n        {\n            return;\n        }\n        this.executable =\n            executable.replace( '/', File.separatorChar ).replace( '\\\\', File.separatorChar );\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n\n    public void addArguments( String[] line )\n    {\n        for ( int i = 0; i < line.length; i++ )\n        {\n            createArgument().setValue( line[i] );\n        }\n    }\n\n    /**\n     * Returns the executable and all defined arguments.\n     */\n    public String[] getCommandline()\n    {\n        final String[] args = getArguments();\n        if ( executable == null )\n        {\n            return args;\n        }\n        final String[] result = new String[args.length + 1];\n        result[0] = executable;\n        System.arraycopy( args, 0, result, 1, args.length );\n        return result;\n    }\n\n    /**\n     * Returns all arguments defined by <code>addLine<\/code>,\n     * <code>addValue<\/code> or the argument object.\n     */\n    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n\n    public String toString()\n    {\n        return toString( getCommandline() );\n    }\n\n    /**\n     * Put quotes around the given String if necessary.\n     *\n     * <p>If the argument doesn't include spaces or quotes, return it\n     * as is. If it contains double quotes, use single quotes - else\n     * surround the argument by double quotes.<\/p>\n     *\n     * @exception org.codehaus.plexus.continuum.ScmException if the argument contains both, single\n     *                           and double quotes.\n     */\n    public static String quoteArgument( String argument ) throws ScmException\n    {\n        if ( argument.indexOf( \"\\\"\" ) > -1 )\n        {\n            if ( argument.indexOf( \"\\'\" ) > -1 )\n            {\n                throw new ScmException( \"Can't handle single and double quotes in same argument\" );\n            }\n            else\n            {\n                return '\\'' + argument + '\\'';\n            }\n        }\n        else if ( argument.indexOf( \"\\'\" ) > -1 || argument.indexOf( \" \" ) > -1 )\n        {\n            return '\\\"' + argument + '\\\"';\n        }\n        else\n        {\n            return argument;\n        }\n    }\n\n    public static String toString( String[] line )\n    {\n        // empty path return empty string\n        if ( line == null || line.length == 0 )\n        {\n            return \"\";\n        }\n\n        // path containing one or more elements\n        final StringBuffer result = new StringBuffer();\n        for ( int i = 0; i < line.length; i++ )\n        {\n            if ( i > 0 )\n            {\n                result.append( ' ' );\n            }\n            try\n            {\n                result.append( quoteArgument( line[i] ) );\n            }\n            catch ( ScmException e )\n            {\n                System.err.println( \"Error quoting argument.\" );\n            }\n        }\n        return result.toString();\n    }\n\n    public static String[] translateCommandline( String toProcess ) throws ScmException\n    {\n        if ( toProcess == null || toProcess.length() == 0 )\n        {\n            return new String[0];\n        }\n\n        // parse with a simple finite state machine\n\n        final int normal = 0;\n        final int inQuote = 1;\n        final int inDoubleQuote = 2;\n        int state = normal;\n        StringTokenizer tok = new StringTokenizer( toProcess, \"\\\"\\' \", true );\n        Vector v = new Vector();\n        StringBuffer current = new StringBuffer();\n\n        while ( tok.hasMoreTokens() )\n        {\n            String nextTok = tok.nextToken();\n            switch ( state )\n            {\n                case inQuote:\n                    if ( \"\\'\".equals( nextTok ) )\n                    {\n                        state = normal;\n                    }\n                    else\n                    {\n                        current.append( nextTok );\n                    }\n                    break;\n                case inDoubleQuote:\n                    if ( \"\\\"\".equals( nextTok ) )\n                    {\n                        state = normal;\n                    }\n                    else\n                    {\n                        current.append( nextTok );\n                    }\n                    break;\n                default :\n                    if ( \"\\'\".equals( nextTok ) )\n                    {\n                        state = inQuote;\n                    }\n                    else if ( \"\\\"\".equals( nextTok ) )\n                    {\n                        state = inDoubleQuote;\n                    }\n                    else if ( \" \".equals( nextTok ) )\n                    {\n                        if ( current.length() != 0 )\n                        {\n                            v.addElement( current.toString() );\n                            current.setLength( 0 );\n                        }\n                    }\n                    else\n                    {\n                        current.append( nextTok );\n                    }\n                    break;\n            }\n        }\n\n        if ( current.length() != 0 )\n        {\n            v.addElement( current.toString() );\n        }\n\n        if ( state == inQuote || state == inDoubleQuote )\n        {\n            throw new ScmException( \"unbalanced quotes in \" + toProcess );\n        }\n\n        String[] args = new String[v.size()];\n        v.copyInto( args );\n        return args;\n    }\n\n    public int size()\n    {\n        return getCommandline().length;\n    }\n\n    public Object clone()\n    {\n        Commandline c = new Commandline();\n        c.setExecutable( executable );\n        c.addArguments( getArguments() );\n        return c;\n    }\n\n    /**\n     * Clear out the whole command line.  */\n    public void clear()\n    {\n        executable = null;\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Clear out the arguments but leave the executable in place for another operation.\n     */\n    public void clearArgs()\n    {\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Return a marker.\n     *\n     * <p>This marker can be used to locate a position on the\n     * commandline - to insert something for example - when all\n     * parameters have been set.<\/p>\n     */\n    public Marker createMarker()\n    {\n        return new Marker( arguments.size() );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path ) throws ScmException\n    {\n        if ( path != null )\n        {\n            File dir = new File( path );\n            if ( !dir.exists() )\n            {\n                throw new ScmException(\n                    \"Working directory \\\"\" + path + \"\\\" does not exist!\" );\n            }\n            else if ( !dir.isDirectory() )\n            {\n                throw new ScmException(\n                    \"Path \\\"\" + path + \"\\\" does not specify a directory.\" );\n            }\n            else\n            {\n                workingDir = dir;\n            }\n        }\n        else\n        {\n            workingDir = null;\n        }\n    }\n\n    public File getWorkingDirectory()\n    {\n        return workingDir;\n    }\n\n    /**\n     * Executes the command.\n     */\n    public Process execute() throws IOException\n    {\n        Process process = null;\n\n        if ( workingDir == null )\n        {\n            System.err.println( \"Executing \\\"\" + this + \"\\\"\" );\n            process = Runtime.getRuntime().exec( getCommandline() );\n        }\n        else\n        {\n            System.err.println(\n                \"Executing \\\"\"\n                + this\n                + \"\\\" in directory \"\n                + ( workingDir != null ? workingDir.getAbsolutePath() : null ) );\n            process = Runtime.getRuntime().exec( getCommandline(), null, workingDir );\n        }\n\n        return process;\n    }\n\n}\n","Method after Refactoring":"/********************************************************************************\n * CruiseControl, a Continuous Integration Toolkit\n * Copyright (c) 2001-2003, ThoughtWorks, Inc.\n * 651 W Washington Ave. Suite 500\n * Chicago, IL 60661 USA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     + Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *\n *     + Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *     + Neither the name of ThoughtWorks, Inc., CruiseControl, nor the\n *       names of its contributors may be used to endorse or promote\n *       products derived from this software without specific prior\n *       written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ********************************************************************************/\n\n/* ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\npackage org.apache.maven.scm.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\nimport org.apache.maven.scm.ScmException;\n\n/**\n * Commandline objects help handling command lines specifying processes to\n * execute.\n *\n * The class can be used to define a command line as nested elements or as a\n * helper to define a command line by an application.\n * <p>\n * <code>\n * &lt;someelement&gt;<br>\n * &nbsp;&nbsp;&lt;acommandline executable=\"/executable/to/run\"&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 1\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line=\"argument_1 argument_2 argument_3\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 4\" /&gt;<br>\n * &nbsp;&nbsp;&lt;/acommandline&gt;<br>\n * &lt;/someelement&gt;<br>\n * <\/code>\n * The element <code>someelement<\/code> must provide a method\n * <code>createAcommandline<\/code> which returns an instance of this class.\n *\n * @author thomas.haas@softwired-inc.com\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig<\/a>\n */\npublic class Commandline implements Cloneable\n{\n    \n    protected static final String OS_NAME = \"os.name\";\n    protected static final String WINDOWS = \"Windows\";\n\n    private String shell = null;\n    private Vector shellArgs = new Vector();\n    private String executable = null;\n    private Vector arguments = new Vector();\n    private File workingDir = null;\n\n    public Commandline( String toProcess )\n    {\n        super();\n        setDefaultShell();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = translateCommandline( toProcess );\n        }\n        catch ( ScmException e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( tmp != null && tmp.length > 0 )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    public Commandline()\n    {\n        super();\n        setDefaultShell();\n    }\n\n    /**\n     * Used for nested xml command line definitions.\n     */\n    public static class Argument\n    {\n\n        private String[] parts;\n\n        /**\n         * Sets a single commandline argument.\n         *\n         * @param value a single commandline argument.\n         */\n        public void setValue( String value )\n        {\n            parts = new String[]{value};\n        }\n\n        /**\n         * Line to split into several commandline arguments.\n         *\n         * @param line line to split into several commandline arguments\n         */\n        public void setLine( String line )\n        {\n            if ( line == null )\n            {\n                return;\n            }\n            try\n            {\n                parts = translateCommandline( line );\n            }\n            catch ( ScmException e )\n            {\n                System.err.println( \"Error translating Commandline.\" );\n            }\n        }\n\n        /**\n         * Sets a single commandline argument to the absolute filename\n         * of the given file.\n         *\n         * @param value a single commandline argument.\n         */\n        public void setFile( File value )\n        {\n            parts = new String[]{value.getAbsolutePath()};\n        }\n\n        /**\n         * Returns the parts this Argument consists of.\n         */\n        public String[] getParts()\n        {\n            return parts;\n        }\n    }\n\n    /**\n     * Class to keep track of the position of an Argument.\n     */\n    // <p>This class is there to support the srcfile and targetfile\n    // elements of &lt;execon&gt; and &lt;transform&gt; - don't know\n    // whether there might be additional use cases.<\/p> --SB\n    public class Marker\n    {\n\n        private int position;\n        private int realPos = -1;\n\n        Marker( int position )\n        {\n            this.position = position;\n        }\n\n        /**\n         * Return the number of arguments that preceeded this marker.\n         *\n         * <p>The name of the executable - if set - is counted as the\n         * very first argument.<\/p>\n         */\n        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( executable == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Argument arg = (Argument) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n    }\n\n\n    /**\n     * <p>Sets the shell or command-line interpretor for the detected operating system, \n     * and the shell arguments.<\/p>\n     */\n    private void setDefaultShell() {\n        String os = System.getProperty(OS_NAME);\n        \n        //If this is windows set the shell to command.com or cmd.exe with correct arguments. \n        if ( os.indexOf(WINDOWS) != -1 )\n        {\n            if (os.indexOf(\"95\") != -1 || os.indexOf(\"98\") != -1 || os.indexOf(\"Me\") != -1) \n            {\n                shell = \"COMMAND.COM\";\n                shellArgs.add(\"/C\"); \n            }\n            else\n            {\n                shell = \"CMD.EXE\";\n                shellArgs.add(\"/X\");\n                shellArgs.add(\"/C\");\n            }\n        }\n    }\n    \n    /**\n     * <p>Gets the shell or command-line interpretor for the detected operating system, \n     * and the shell arguments.<\/p>\n     */\n    public String getDefaultShell()\n    {\n        if ( shell != null )\n        {\n            String args = \"\";\n            for (Enumeration enum = shellArgs.elements(); enum.hasMoreElements(); )\n            {\n                args += (String)enum.nextElement() + \" \";\n            }\n            \n            return shell + \" \" + args;\n        }\n        else\n        {\n            return \"\";\n        }\n    }\n    \n    /**\n     * Creates an argument object.\n     *\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)<\/code>.<\/p>\n     *\n     * @see #createArgument(boolean)\n     * @return the argument object.\n     */\n    public Argument createArgument()\n    {\n        return this.createArgument( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     *\n     * <p>Each commandline object has at most one instance of the\n     * argument class.<\/p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     * beginning of the list of args, otherwise it is appended.\n     */\n    public Argument createArgument( boolean insertAtStart )\n    {\n        Argument argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        if ( executable == null || executable.length() == 0 )\n        {\n            return;\n        }\n        this.executable =\n            executable.replace( '/', File.separatorChar ).replace( '\\\\', File.separatorChar );\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n\n    public void addArguments( String[] line )\n    {\n        for ( int i = 0; i < line.length; i++ )\n        {\n            createArgument().setValue( line[i] );\n        }\n    }\n\n    /**\n     * Returns the shell, executable and all defined arguments.\n     */\n    public String[] getCommandline()\n    {\n        int shellCount = 0;\n        int arrayPos = 0;\n        if ( shell != null )\n        {\n            shellCount = 1;\n        }\n        shellCount += shellArgs.size();\n        final String[] args = getArguments();        \n        \n        String[] result = new String[shellCount + args.length + (( executable == null )? 0:1)];\n        //Build shell and arguments into result\n        if ( shell != null )\n        {\n            result[0] = shell;\n            arrayPos++;\n        }\n        System.arraycopy( shellArgs.toArray(), 0, result, arrayPos, shellArgs.size() );\n        arrayPos += shellArgs.size();\n        //Build excutable and arguments into result\n        if ( executable != null )\n        {\n            result[arrayPos] = executable;\n            arrayPos++;\n        }\n        System.arraycopy( args, 0, result, arrayPos, args.length );\n        return result;\n    }\n\n    /**\n     * Returns all arguments defined by <code>addLine<\/code>,\n     * <code>addValue<\/code> or the argument object.\n     */\n    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n\n    public String toString()\n    {\n        return toString( getCommandline() );\n    }\n\n    /**\n     * Put quotes around the given String if necessary.\n     *\n     * <p>If the argument doesn't include spaces or quotes, return it\n     * as is. If it contains double quotes, use single quotes - else\n     * surround the argument by double quotes.<\/p>\n     *\n     * @exception org.codehaus.plexus.continuum.ScmException if the argument contains both, single\n     *                           and double quotes.\n     */\n    public static String quoteArgument( String argument ) throws ScmException\n    {\n        if ( argument.indexOf( \"\\\"\" ) > -1 )\n        {\n            if ( argument.indexOf( \"\\'\" ) > -1 )\n            {\n                throw new ScmException( \"Can't handle single and double quotes in same argument\" );\n            }\n            else\n            {\n                return '\\'' + argument + '\\'';\n            }\n        }\n        else if ( argument.indexOf( \"\\'\" ) > -1 || argument.indexOf( \" \" ) > -1 )\n        {\n            return '\\\"' + argument + '\\\"';\n        }\n        else\n        {\n            return argument;\n        }\n    }\n\n    public static String toString( String[] line )\n    {\n        // empty path return empty string\n        if ( line == null || line.length == 0 )\n        {\n            return \"\";\n        }\n\n        // path containing one or more elements\n        final StringBuffer result = new StringBuffer();\n        for ( int i = 0; i < line.length; i++ )\n        {\n            if ( i > 0 )\n            {\n                result.append( ' ' );\n            }\n            try\n            {\n                result.append( quoteArgument( line[i] ) );\n            }\n            catch ( ScmException e )\n            {\n                System.err.println( \"Error quoting argument.\" );\n            }\n        }\n        return result.toString();\n    }\n\n    public static String[] translateCommandline( String toProcess ) throws ScmException\n    {\n        if ( toProcess == null || toProcess.length() == 0 )\n        {\n            return new String[0];\n        }\n\n        // parse with a simple finite state machine\n\n        final int normal = 0;\n        final int inQuote = 1;\n        final int inDoubleQuote = 2;\n        int state = normal;\n        StringTokenizer tok = new StringTokenizer( toProcess, \"\\\"\\' \", true );\n        Vector v = new Vector();\n        StringBuffer current = new StringBuffer();\n\n        while ( tok.hasMoreTokens() )\n        {\n            String nextTok = tok.nextToken();\n            switch ( state )\n            {\n                case inQuote:\n                    if ( \"\\'\".equals( nextTok ) )\n                    {\n                        state = normal;\n                    }\n                    else\n                    {\n                        current.append( nextTok );\n                    }\n                    break;\n                case inDoubleQuote:\n                    if ( \"\\\"\".equals( nextTok ) )\n                    {\n                        state = normal;\n                    }\n                    else\n                    {\n                        current.append( nextTok );\n                    }\n                    break;\n                default :\n                    if ( \"\\'\".equals( nextTok ) )\n                    {\n                        state = inQuote;\n                    }\n                    else if ( \"\\\"\".equals( nextTok ) )\n                    {\n                        state = inDoubleQuote;\n                    }\n                    else if ( \" \".equals( nextTok ) )\n                    {\n                        if ( current.length() != 0 )\n                        {\n                            v.addElement( current.toString() );\n                            current.setLength( 0 );\n                        }\n                    }\n                    else\n                    {\n                        current.append( nextTok );\n                    }\n                    break;\n            }\n        }\n\n        if ( current.length() != 0 )\n        {\n            v.addElement( current.toString() );\n        }\n\n        if ( state == inQuote || state == inDoubleQuote )\n        {\n            throw new ScmException( \"unbalanced quotes in \" + toProcess );\n        }\n\n        String[] args = new String[v.size()];\n        v.copyInto( args );\n        return args;\n    }\n\n    public int size()\n    {\n        return getCommandline().length;\n    }\n\n    public Object clone()\n    {\n        Commandline c = new Commandline();\n        c.setExecutable( executable );\n        c.addArguments( getArguments() );\n        return c;\n    }\n\n    /**\n     * Clear out the whole command line.  */\n    public void clear()\n    {\n        executable = null;\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Clear out the arguments but leave the executable in place for another operation.\n     */\n    public void clearArgs()\n    {\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Return a marker.\n     *\n     * <p>This marker can be used to locate a position on the\n     * commandline - to insert something for example - when all\n     * parameters have been set.<\/p>\n     */\n    public Marker createMarker()\n    {\n        return new Marker( arguments.size() );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path ) throws ScmException\n    {\n        if ( path != null )\n        {\n            File dir = new File( path );\n            if ( !dir.exists() )\n            {\n                throw new ScmException(\n                    \"Working directory \\\"\" + path + \"\\\" does not exist!\" );\n            }\n            else if ( !dir.isDirectory() )\n            {\n                throw new ScmException(\n                    \"Path \\\"\" + path + \"\\\" does not specify a directory.\" );\n            }\n            else\n            {\n                workingDir = dir;\n            }\n        }\n        else\n        {\n            workingDir = null;\n        }\n    }\n\n    public File getWorkingDirectory()\n    {\n        return workingDir;\n    }\n\n    /**\n     * Executes the command.\n     */\n    public Process execute() throws IOException\n    {\n        Process process = null;\n\n        if ( workingDir == null )\n        {\n            System.err.println( \"Executing \\\"\" + this + \"\\\"\" );\n            process = Runtime.getRuntime().exec( getCommandline() );\n        }\n        else\n        {\n            System.err.println(\n                \"Executing \\\"\"\n                + this\n                + \"\\\" in directory \"\n                + ( workingDir != null ? workingDir.getAbsolutePath() : null ) );\n            process = Runtime.getRuntime().exec( getCommandline(), null, workingDir );\n        }\n\n        return process;\n    }\n\n}\n","lineNo":342}
