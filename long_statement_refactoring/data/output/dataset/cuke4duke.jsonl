{"Smelly Sample":"package cuke4duke.internal.java;\n\nimport cuke4duke.annotation.After;\nimport cuke4duke.annotation.Before;\nimport cuke4duke.annotation.Order;\nimport cuke4duke.annotation.Transform;\nimport cuke4duke.internal.Utils;\nimport cuke4duke.internal.java.annotation.StepDef;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.jvmclass.ObjectFactory;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    private final MethodFormat methodFormat;\n\n    public JavaAnalyzer() {\n        this.methodFormat = new MethodFormat(System.getProperty(\"cuke4duke.methodFormat\", \"%c.%m(%a)\"));\n    }\n\n    public void populateStepDefinitionsAndHooks(ObjectFactory objectFactory, ClassLanguage classLanguage) throws Throwable {\n        for(Method method: getOrderedMethods(classLanguage)) {\n            registerBeforeMaybe(method, classLanguage);\n            registerAfterMaybe(method, classLanguage);\n            registerStepDefinitionsFromAnnotations(method, classLanguage);\n            registerTransformMaybe(method, classLanguage);\n        }\n    }\n\n    private void registerTransformMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Transform.class)) {\n            classLanguage.addTransform(method.getReturnType(), new JavaTransform(classLanguage, method));\n        }\n    }\n\n    public Class<?>[] alwaysLoad() {\n        return new Class<?>[0];\n    }\n\n    private List<Method> getOrderedMethods(ClassLanguage classLanguage) {\n        Set<Method> methods = new HashSet<Method>();\n        for(Class<?> clazz : classLanguage.getClasses()) {\n            methods.addAll(Arrays.asList(clazz.getMethods()));\n        }\n        List<Method> sortedMethods = new ArrayList<Method>(methods);\n        Collections.sort(sortedMethods, new Comparator<Method>() {\n            public int compare(Method m1, Method m2) {\n                return order(m1) - order(m2);\n            }\n\n            private int order(Method m) {\n                Order order = m.getAnnotation(Order.class);\n                return (order == null) ? Integer.MAX_VALUE : order.value();\n            }\n        });\n        return sortedMethods;\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Before.class)) {\n            classLanguage.addBeforeHook(new JavaHook(classLanguage, method, Arrays.asList(method.getAnnotation(Before.class).value())));\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(After.class)) {\n            classLanguage.addAfterHook(new JavaHook(classLanguage, method, Arrays.asList(method.getAnnotation(After.class).value())));\n        }\n    }\n\n    private void registerStepDefinitionsFromAnnotations(Method method, ClassLanguage classLanguage) throws Throwable {\n        for(Annotation annotation: method.getAnnotations()) {\n            if(annotation.annotationType().isAnnotationPresent(StepDef.class)) {\n                Locale locale = Utils.localeFor(annotation.annotationType().getAnnotation(StepDef.class).value());\n                Method regexpMethod = annotation.getClass().getMethod(\"value\");\n                String regexpString = (String) regexpMethod.invoke(annotation);\n                if (regexpString != null) {\n                    Pattern regexp = Pattern.compile(regexpString);\n                    classLanguage.addStepDefinition(new JavaStepDefinition(classLanguage, method, regexp, methodFormat, locale));\n                }\n            }\n        }\n    }\n}\n","Method after Refactoring":"package cuke4duke.internal.java;\n\nimport cuke4duke.annotation.After;\nimport cuke4duke.annotation.Before;\nimport cuke4duke.annotation.Order;\nimport cuke4duke.annotation.Transform;\nimport cuke4duke.internal.Utils;\nimport cuke4duke.internal.java.annotation.StepDef;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.jvmclass.ObjectFactory;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    private final MethodFormat methodFormat;\n    private static final String[] NO_TAGS = new String[0];\n\n    public JavaAnalyzer() {\n        this.methodFormat = new MethodFormat(System.getProperty(\"cuke4duke.methodFormat\", \"%c.%m(%a)\"));\n    }\n\n    public void populateStepDefinitionsAndHooks(ObjectFactory objectFactory, ClassLanguage classLanguage) throws Throwable {\n        for(Method method: getOrderedMethods(classLanguage)) {\n            registerBeforeMaybe(method, classLanguage);\n            registerAfterMaybe(method, classLanguage);\n            registerStepDefinitionsFromAnnotations(method, classLanguage);\n            registerTransformMaybe(method, classLanguage);\n        }\n    }\n\n    private void registerTransformMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Transform.class)) {\n            classLanguage.addTransform(method.getReturnType(), new JavaTransform(classLanguage, method));\n        }\n    }\n\n    public Class<?>[] alwaysLoad() {\n        return new Class<?>[0];\n    }\n\n    private List<Method> getOrderedMethods(ClassLanguage classLanguage) {\n        Set<Method> methods = new HashSet<Method>();\n        for(Class<?> clazz : classLanguage.getClasses()) {\n            methods.addAll(Arrays.asList(clazz.getMethods()));\n        }\n        List<Method> sortedMethods = new ArrayList<Method>(methods);\n        Collections.sort(sortedMethods, new Comparator<Method>() {\n            public int compare(Method m1, Method m2) {\n                return order(m1) - order(m2);\n            }\n\n            private int order(Method m) {\n                Order order = m.getAnnotation(Order.class);\n                return (order == null) ? Integer.MAX_VALUE : order.value();\n            }\n        });\n        return sortedMethods;\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Before.class)) {\n            String[] tagExpressions = method.getAnnotation(Before.class).value();\n            if(\"\".equals(tagExpressions[0])) {\n                tagExpressions = NO_TAGS;\n            }\n            classLanguage.addBeforeHook(new JavaHook(classLanguage, method, Arrays.asList(tagExpressions)));\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(After.class)) {\n            String[] tagExpressions = method.getAnnotation(After.class).value();\n            if(\"\".equals(tagExpressions[0])) {\n                tagExpressions = NO_TAGS;\n            }\n            classLanguage.addAfterHook(new JavaHook(classLanguage, method, Arrays.asList(tagExpressions)));\n        }\n    }\n\n    private void registerStepDefinitionsFromAnnotations(Method method, ClassLanguage classLanguage) throws Throwable {\n        for(Annotation annotation: method.getAnnotations()) {\n            if(annotation.annotationType().isAnnotationPresent(StepDef.class)) {\n                Locale locale = Utils.localeFor(annotation.annotationType().getAnnotation(StepDef.class).value());\n                Method regexpMethod = annotation.getClass().getMethod(\"value\");\n                String regexpString = (String) regexpMethod.invoke(annotation);\n                if (regexpString != null) {\n                    Pattern regexp = Pattern.compile(regexpString);\n                    classLanguage.addStepDefinition(new JavaStepDefinition(classLanguage, method, regexp, methodFormat, locale));\n                }\n            }\n        }\n    }\n}\n","lineNo":66}
{"Smelly Sample":"package cuke4duke.internal.java;\n\nimport cuke4duke.annotation.After;\nimport cuke4duke.annotation.Before;\nimport cuke4duke.annotation.Order;\nimport cuke4duke.annotation.Transform;\nimport cuke4duke.internal.Utils;\nimport cuke4duke.internal.java.annotation.StepDef;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.jvmclass.ObjectFactory;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    private final MethodFormat methodFormat;\n\n    public JavaAnalyzer() {\n        this.methodFormat = new MethodFormat(System.getProperty(\"cuke4duke.methodFormat\", \"%c.%m(%a)\"));\n    }\n\n    public void populateStepDefinitionsAndHooks(ObjectFactory objectFactory, ClassLanguage classLanguage) throws Throwable {\n        for(Method method: getOrderedMethods(classLanguage)) {\n            registerBeforeMaybe(method, classLanguage);\n            registerAfterMaybe(method, classLanguage);\n            registerStepDefinitionsFromAnnotations(method, classLanguage);\n            registerTransformMaybe(method, classLanguage);\n        }\n    }\n\n    private void registerTransformMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Transform.class)) {\n            classLanguage.addTransform(method.getReturnType(), new JavaTransform(classLanguage, method));\n        }\n    }\n\n    public Class<?>[] alwaysLoad() {\n        return new Class<?>[0];\n    }\n\n    private List<Method> getOrderedMethods(ClassLanguage classLanguage) {\n        Set<Method> methods = new HashSet<Method>();\n        for(Class<?> clazz : classLanguage.getClasses()) {\n            methods.addAll(Arrays.asList(clazz.getMethods()));\n        }\n        List<Method> sortedMethods = new ArrayList<Method>(methods);\n        Collections.sort(sortedMethods, new Comparator<Method>() {\n            public int compare(Method m1, Method m2) {\n                return order(m1) - order(m2);\n            }\n\n            private int order(Method m) {\n                Order order = m.getAnnotation(Order.class);\n                return (order == null) ? Integer.MAX_VALUE : order.value();\n            }\n        });\n        return sortedMethods;\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Before.class)) {\n            classLanguage.addBeforeHook(new JavaHook(classLanguage, method, Arrays.asList(method.getAnnotation(Before.class).value())));\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(After.class)) {\n            classLanguage.addAfterHook(new JavaHook(classLanguage, method, Arrays.asList(method.getAnnotation(After.class).value())));\n        }\n    }\n\n    private void registerStepDefinitionsFromAnnotations(Method method, ClassLanguage classLanguage) throws Throwable {\n        for(Annotation annotation: method.getAnnotations()) {\n            if(annotation.annotationType().isAnnotationPresent(StepDef.class)) {\n                Locale locale = Utils.localeFor(annotation.annotationType().getAnnotation(StepDef.class).value());\n                Method regexpMethod = annotation.getClass().getMethod(\"value\");\n                String regexpString = (String) regexpMethod.invoke(annotation);\n                if (regexpString != null) {\n                    Pattern regexp = Pattern.compile(regexpString);\n                    classLanguage.addStepDefinition(new JavaStepDefinition(classLanguage, method, regexp, methodFormat, locale));\n                }\n            }\n        }\n    }\n}\n","Method after Refactoring":"package cuke4duke.internal.java;\n\nimport cuke4duke.annotation.After;\nimport cuke4duke.annotation.Before;\nimport cuke4duke.annotation.Order;\nimport cuke4duke.annotation.Transform;\nimport cuke4duke.internal.Utils;\nimport cuke4duke.internal.java.annotation.StepDef;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.jvmclass.ObjectFactory;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    private final MethodFormat methodFormat;\n    private static final String[] NO_TAGS = new String[0];\n\n    public JavaAnalyzer() {\n        this.methodFormat = new MethodFormat(System.getProperty(\"cuke4duke.methodFormat\", \"%c.%m(%a)\"));\n    }\n\n    public void populateStepDefinitionsAndHooks(ObjectFactory objectFactory, ClassLanguage classLanguage) throws Throwable {\n        for(Method method: getOrderedMethods(classLanguage)) {\n            registerBeforeMaybe(method, classLanguage);\n            registerAfterMaybe(method, classLanguage);\n            registerStepDefinitionsFromAnnotations(method, classLanguage);\n            registerTransformMaybe(method, classLanguage);\n        }\n    }\n\n    private void registerTransformMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Transform.class)) {\n            classLanguage.addTransform(method.getReturnType(), new JavaTransform(classLanguage, method));\n        }\n    }\n\n    public Class<?>[] alwaysLoad() {\n        return new Class<?>[0];\n    }\n\n    private List<Method> getOrderedMethods(ClassLanguage classLanguage) {\n        Set<Method> methods = new HashSet<Method>();\n        for(Class<?> clazz : classLanguage.getClasses()) {\n            methods.addAll(Arrays.asList(clazz.getMethods()));\n        }\n        List<Method> sortedMethods = new ArrayList<Method>(methods);\n        Collections.sort(sortedMethods, new Comparator<Method>() {\n            public int compare(Method m1, Method m2) {\n                return order(m1) - order(m2);\n            }\n\n            private int order(Method m) {\n                Order order = m.getAnnotation(Order.class);\n                return (order == null) ? Integer.MAX_VALUE : order.value();\n            }\n        });\n        return sortedMethods;\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Before.class)) {\n            String[] tagExpressions = method.getAnnotation(Before.class).value();\n            if(\"\".equals(tagExpressions[0])) {\n                tagExpressions = NO_TAGS;\n            }\n            classLanguage.addBeforeHook(new JavaHook(classLanguage, method, Arrays.asList(tagExpressions)));\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(After.class)) {\n            String[] tagExpressions = method.getAnnotation(After.class).value();\n            if(\"\".equals(tagExpressions[0])) {\n                tagExpressions = NO_TAGS;\n            }\n            classLanguage.addAfterHook(new JavaHook(classLanguage, method, Arrays.asList(tagExpressions)));\n        }\n    }\n\n    private void registerStepDefinitionsFromAnnotations(Method method, ClassLanguage classLanguage) throws Throwable {\n        for(Annotation annotation: method.getAnnotations()) {\n            if(annotation.annotationType().isAnnotationPresent(StepDef.class)) {\n                Locale locale = Utils.localeFor(annotation.annotationType().getAnnotation(StepDef.class).value());\n                Method regexpMethod = annotation.getClass().getMethod(\"value\");\n                String regexpString = (String) regexpMethod.invoke(annotation);\n                if (regexpString != null) {\n                    Pattern regexp = Pattern.compile(regexpString);\n                    classLanguage.addStepDefinition(new JavaStepDefinition(classLanguage, method, regexp, methodFormat, locale));\n                }\n            }\n        }\n    }\n}\n","lineNo":76}
{"Smelly Sample":"package cuke4duke.internal.groovy;\n\nimport cuke4duke.GroovyDsl;\nimport cuke4duke.internal.language.AbstractProgrammingLanguage;\nimport cuke4duke.internal.language.LanguageMixin;\nimport groovy.lang.Binding;\nimport groovy.lang.Closure;\nimport groovy.lang.GroovyShell;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GroovyLanguage extends AbstractProgrammingLanguage {\n    private final List<String> groovyFiles = new ArrayList<String>();\n    private Object currentWorld;\n    private Closure worldFactory;\n\n    public GroovyLanguage(LanguageMixin languageMixin) {\n        super(languageMixin);\n        GroovyDsl.groovyLanguage = this;\n        GroovyDsl.languageMixin = languageMixin;\n    }\n\n    void invokeClosure(Closure body, Object[] args) {\n        body.setDelegate(currentWorld);\n        body.call(args);\n    }\n\n    public void begin_scenario(IRubyObject scenario) throws IOException {\n        clearHooksAndStepDefinitions();\n        worldFactory = null;\n        GroovyShell shell = new GroovyShell(new Binding());\n        for(String groovyFile : groovyFiles) {\n            shell.evaluate(new File(groovyFile));\n        }\n        currentWorld = worldFactory == null ? new Object() : worldFactory.call();\n    }\n\n    public void end_scenario() {\n    }\n\n    public void load_code_file(String groovyFile) throws ClassNotFoundException, IOException {\n        groovyFiles.add(groovyFile);\n    }\n\n    public void registerWorldFactory(Closure worldFactory) {\n        if(this.worldFactory != null) {\n            throw new RuntimeException(\"You can only define one World closure\");\n        }\n        this.worldFactory = worldFactory;\n    }\n}\n","Method after Refactoring":"package cuke4duke.internal.groovy;\n\nimport cuke4duke.GroovyDsl;\nimport cuke4duke.internal.language.AbstractProgrammingLanguage;\nimport cuke4duke.internal.language.LanguageMixin;\nimport groovy.lang.Binding;\nimport groovy.lang.Closure;\nimport groovy.lang.GroovyShell;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GroovyLanguage extends AbstractProgrammingLanguage {\n    private final List<String> groovyFiles = new ArrayList<String>();\n    private Object currentWorld;\n    private Closure worldFactory;\n\n    public GroovyLanguage(LanguageMixin languageMixin) {\n        super(languageMixin);\n        GroovyDsl.groovyLanguage = this;\n        GroovyDsl.languageMixin = languageMixin;\n    }\n\n    Object invokeClosure(Closure body, Object[] args) throws Throwable {\n        body.setDelegate(currentWorld);\n        Class[] classes = body.getParameterTypes();\n        Object[] transformedArgs = transform(args, classes);\n        return body.call(transformedArgs);\n    }\n\n    public void begin_scenario(IRubyObject scenario) throws IOException {\n        clearHooksAndStepDefinitions();\n        worldFactory = null;\n        GroovyShell shell = new GroovyShell(new Binding());\n        for(String groovyFile : groovyFiles) {\n            shell.evaluate(new File(groovyFile));\n        }\n        currentWorld = worldFactory == null ? new Object() : worldFactory.call();\n    }\n\n    public void end_scenario() {\n    }\n\n    @Override\n    protected Object customTransform(Object arg, Class<?> parameterType) {\n        return null;\n    }\n\n    public void load_code_file(String groovyFile) throws ClassNotFoundException, IOException {\n        groovyFiles.add(groovyFile);\n    }\n\n    public void registerWorldFactory(Closure worldFactory) {\n        if(this.worldFactory != null) {\n            throw new RuntimeException(\"You can only define one World closure\");\n        }\n        this.worldFactory = worldFactory;\n    }\n}\n","lineNo":30}
{"Smelly Sample":"package cuke4duke.internal.java;\n\nimport cuke4duke.*;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.jvmclass.ObjectFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    private final MethodFormat methodFormat;\n    private boolean needsHookRegistration = true;\n\n\n    public JavaAnalyzer() {\n        this.methodFormat = new MethodFormat(System.getProperty(\"cuke4duke.methodFormat\", \"%c.%m(%a)\"));\n    }\n\n    public void populateStepDefinitionsAndHooks(ObjectFactory objectFactory, ClassLanguage classLanguage) throws Throwable {\n        for(Method method: getOrderedMethods(classLanguage)) {\n            if(needsHookRegistration) {\n                registerBeforeMaybe(method, classLanguage, objectFactory);\n                registerAfterMaybe(method, classLanguage, objectFactory);\n            }\n            registerStepDefinitionMaybe(method, classLanguage, objectFactory);\n            registerTransformMaybe(method, classLanguage, objectFactory);\n        }\n        needsHookRegistration = false;\n    }\n\n    private void registerTransformMaybe(Method method, ClassLanguage classLanguage, ObjectFactory objectFactory) {\n        if (method.isAnnotationPresent(Transform.class)) {\n            classLanguage.addTransform(method.getReturnType(), new JavaTransform(method, objectFactory));\n        }\n    }\n\n    public Class<?>[] alwaysLoad() {\n        return new Class<?>[0];\n    }\n\n    public List<Method> getOrderedMethods(ClassLanguage classLanguage) {\n        List<Method> methods = new ArrayList<Method>();\n        for(Class<?> clazz :  classLanguage.getClasses()) {\n            methods.addAll(Arrays.asList(clazz.getMethods()));\n        }\n        Collections.sort(methods, new Comparator<Method>() {\n            public int compare(Method m1, Method m2) {\n                return order(m1) - order(m2);\n            }\n\n            private int order(Method m) {\n                Order order = m.getAnnotation(Order.class);\n                return (order == null) ? Integer.MAX_VALUE : order.value();\n            }\n        });\n        return methods;\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage, ObjectFactory objectFactory) {\n        if (method.isAnnotationPresent(Before.class)) {\n            classLanguage.addBeforeHook(new JavaHook(method.getAnnotation(Before.class).value(), method, objectFactory));\n        }\n    }\n\n    private void registerStepDefinitionMaybe(Method method, ClassLanguage classLanguage, ObjectFactory objectFactory) throws Throwable {\n        String regexpString = null;\n        if (method.isAnnotationPresent(Given.class)) {\n            regexpString = method.getAnnotation(Given.class).value();\n        } else if (method.isAnnotationPresent(When.class)) {\n            regexpString = method.getAnnotation(When.class).value();\n        } else if (method.isAnnotationPresent(Then.class)) {\n            regexpString = method.getAnnotation(Then.class).value();\n        }\n        if (regexpString != null) {\n            Pattern regexp = Pattern.compile(regexpString);\n            classLanguage.addStepDefinition(new JavaStepDefinition(classLanguage, objectFactory, method, regexp, methodFormat));\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage, ObjectFactory objectFactory) {\n        if (method.isAnnotationPresent(After.class)) {\n            classLanguage.addAfterHook(new JavaHook(method.getAnnotation(After.class).value(), method, objectFactory));\n        }\n    }\n\n}\n","Method after Refactoring":"package cuke4duke.internal.java;\n\nimport cuke4duke.*;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.jvmclass.ObjectFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    private final MethodFormat methodFormat;\n\n    public JavaAnalyzer() {\n        this.methodFormat = new MethodFormat(System.getProperty(\"cuke4duke.methodFormat\", \"%c.%m(%a)\"));\n    }\n\n    public void populateStepDefinitionsAndHooks(ObjectFactory objectFactory, ClassLanguage classLanguage) throws Throwable {\n        for(Method method: getOrderedMethods(classLanguage)) {\n            registerBeforeMaybe(method, classLanguage);\n            registerAfterMaybe(method, classLanguage);\n            registerStepDefinitionMaybe(method, classLanguage);\n            registerTransformMaybe(method, classLanguage);\n        }\n    }\n\n    private void registerTransformMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Transform.class)) {\n            classLanguage.addTransform(method.getReturnType(), new JavaTransform(classLanguage, method));\n        }\n    }\n\n    public Class<?>[] alwaysLoad() {\n        return new Class<?>[0];\n    }\n\n    private List<Method> getOrderedMethods(ClassLanguage classLanguage) {\n        Set<Method> methods = new HashSet<Method>();\n        for(Class<?> clazz : classLanguage.getClasses()) {\n            methods.addAll(Arrays.asList(clazz.getMethods()));\n        }\n        List<Method> sortedMethods = new ArrayList<Method>(methods);\n        Collections.sort(sortedMethods, new Comparator<Method>() {\n            public int compare(Method m1, Method m2) {\n                return order(m1) - order(m2);\n            }\n\n            private int order(Method m) {\n                Order order = m.getAnnotation(Order.class);\n                return (order == null) ? Integer.MAX_VALUE : order.value();\n            }\n        });\n        return sortedMethods;\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Before.class)) {\n            classLanguage.addBeforeHook(new JavaHook(classLanguage, method, method.getAnnotation(Before.class).value()));\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(After.class)) {\n            classLanguage.addAfterHook(new JavaHook(classLanguage, method, method.getAnnotation(After.class).value()));\n        }\n    }\n\n    private void registerStepDefinitionMaybe(Method method, ClassLanguage classLanguage) throws Throwable {\n        String regexpString = null;\n        if (method.isAnnotationPresent(Given.class)) {\n            regexpString = method.getAnnotation(Given.class).value();\n        } else if (method.isAnnotationPresent(When.class)) {\n            regexpString = method.getAnnotation(When.class).value();\n        } else if (method.isAnnotationPresent(Then.class)) {\n            regexpString = method.getAnnotation(Then.class).value();\n        }\n        if (regexpString != null) {\n            Pattern regexp = Pattern.compile(regexpString);\n            classLanguage.addStepDefinition(new JavaStepDefinition(classLanguage, method, regexp, methodFormat));\n        }\n    }\n}\n","lineNo":43}
{"Smelly Sample":"package cuke4duke.internal.jvmclass;\n\nimport cuke4duke.StepMother;\nimport cuke4duke.internal.JRuby;\nimport cuke4duke.internal.language.AbstractProgrammingLanguage;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\npublic class ClassLanguage extends AbstractProgrammingLanguage {\n    private final ObjectFactory objectFactory;\n    private final List<ClassAnalyzer> analyzers;\n    private Collection<Class<?>> classes = new ArrayList<Class<?>>();\n\n    public ClassLanguage(ClassLanguageMixin languageMixin, StepMother stepMother, List<ClassAnalyzer> analyzers) throws Throwable {\n        this(languageMixin, stepMother, analyzers, createObjectFactory());\n    }\n\n    public ClassLanguage(ClassLanguageMixin languageMixin, StepMother stepMother, List<ClassAnalyzer> analyzers, ObjectFactory objectFactory) throws Throwable {\n        super(languageMixin);\n        this.analyzers = analyzers;\n        this.objectFactory = objectFactory;\n        objectFactory.addStepMother(stepMother);\n        for (ClassAnalyzer analyzer : analyzers) {\n            for (Class<?> clazz : analyzer.alwaysLoad()) {\n                objectFactory.addClass(clazz);\n            }\n        }\n    }\n\n    @Override\n    public void load_code_file(String classFile) throws Throwable {\n        Class<?> clazz = loadClass(classFile);\n        addClass(clazz);\n    }\n\n    public void addClass(Class<?> clazz) {\n        if (!Modifier.isAbstract(clazz.getModifiers())) {\n            objectFactory.addClass(clazz);\n        }\n        classes.add(clazz);\n    }\n\n    public Collection<Class<?>> getClasses() {\n        return classes;\n    }\n\n    @Override\n    protected void begin_scenario(IRubyObject scenario) throws Throwable {\n        clearHooksAndStepDefinitions();\n        objectFactory.createObjects();\n        for (ClassAnalyzer analyzer : analyzers) {\n            analyzer.populateStepDefinitionsAndHooks(objectFactory, this);\n        }\n\n    }\n\n    @Override\n    public void end_scenario() throws Throwable {\n        objectFactory.disposeObjects();\n    }\n\n    private Class<?> loadClass(String classFile) throws ClassNotFoundException {\n        String withoutExt = classFile.substring(0, classFile.length() - \".class\".length());\n        String[] pathElements = withoutExt.split(\"\\\\/\");\n        String className = null;\n        for (int i = pathElements.length - 1; i >= 0; i--) {\n            if (className == null) {\n                className = pathElements[i];\n            } else {\n                className = pathElements[i] + \".\" + className;\n            }\n            try {\n                return JRuby.getRuntime().getJRubyClassLoader().loadClass(className);\n            } catch (ClassNotFoundException ignore) {\n            }\n        }\n        throw new ClassNotFoundException(\"Couldn't determine class from file: \" + classFile);\n    }\n\n    private static ObjectFactory createObjectFactory() throws Throwable {\n        String objectFactoryClassName = System.getProperty(\"cuke4duke.objectFactory\", \"cuke4duke.internal.jvmclass.PicoFactory\");\n        Class<?> ofc = JRuby.getRuntime().getJRubyClassLoader().loadClass(objectFactoryClassName);\n        Constructor<?> ctor = ofc.getConstructor();\n        try {\n            return (ObjectFactory) ctor.newInstance();\n        } catch (InvocationTargetException e) {\n            throw e.getTargetException();\n        }\n    }\n\n}\n","Method after Refactoring":"package cuke4duke.internal.jvmclass;\n\nimport cuke4duke.StepMother;\nimport cuke4duke.internal.JRuby;\nimport cuke4duke.internal.language.AbstractProgrammingLanguage;\nimport cuke4duke.internal.language.Transformable;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\npublic class ClassLanguage extends AbstractProgrammingLanguage {\n    private final ObjectFactory objectFactory;\n    private final List<ClassAnalyzer> analyzers;\n    private final Map<Class<?>, Transformable> transformers = new HashMap<Class<?>, Transformable>();\n\n    public ClassLanguage(ClassLanguageMixin languageMixin, StepMother stepMother, List<ClassAnalyzer> analyzers) throws Throwable {\n        this(languageMixin, stepMother, analyzers, createObjectFactory());\n    }\n\n    public ClassLanguage(ClassLanguageMixin languageMixin, StepMother stepMother, List<ClassAnalyzer> analyzers, ObjectFactory objectFactory) throws Throwable {\n        super(languageMixin);\n        this.analyzers = analyzers;\n        this.objectFactory = objectFactory;\n        objectFactory.addStepMother(stepMother);\n        for (ClassAnalyzer analyzer : analyzers) {\n            for (Class<?> clazz : analyzer.alwaysLoad()) {\n                objectFactory.addClass(clazz);\n            }\n        }\n    }\n\n    public void addTransform(Class<?> returnType, Transformable javaTransform) {\n        transformers.put(returnType, javaTransform);\n    }\n\n    @Override\n    protected Object customTransform(Object arg, Class<?> parameterType) throws Throwable {\n        Transformable transformer = transformers.get(parameterType);\n        return transformer == null ? null : transformer.transform(arg);\n    }\n\n    @Override\n    public void load_code_file(String classFile) throws Throwable {\n        Class<?> clazz = loadClass(classFile);\n        addClass(clazz);\n    }\n\n    public void addClass(Class<?> clazz) {\n        if (!Modifier.isAbstract(clazz.getModifiers())) {\n            objectFactory.addClass(clazz);\n        }\n    }\n\n    @Override\n    public void begin_scenario(IRubyObject scenario) throws Throwable {\n        clearHooksAndStepDefinitions();\n        objectFactory.createObjects();\n        for (ClassAnalyzer analyzer : analyzers) {\n            analyzer.populateStepDefinitionsAndHooks(objectFactory, this);\n        }\n    }\n\n    @Override\n    public void end_scenario() throws Throwable {\n        objectFactory.disposeObjects();\n    }\n\n    private Class<?> loadClass(String classFile) throws ClassNotFoundException {\n        String withoutExt = classFile.substring(0, classFile.length() - \".class\".length());\n        String[] pathElements = withoutExt.split(\"\\\\/\");\n        String className = null;\n        for (int i = pathElements.length - 1; i >= 0; i--) {\n            if (className == null) {\n                className = pathElements[i];\n            } else {\n                className = pathElements[i] + \".\" + className;\n            }\n            try {\n                return JRuby.getRuntime().getJRubyClassLoader().loadClass(className);\n            } catch (ClassNotFoundException ignore) {\n            }\n        }\n        throw new ClassNotFoundException(\"Couldn't determine class from file: \" + classFile);\n    }\n\n    private static ObjectFactory createObjectFactory() throws Throwable {\n        String objectFactoryClassName = System.getProperty(\"cuke4duke.objectFactory\", \"cuke4duke.internal.jvmclass.PicoFactory\");\n        Class<?> ofc = JRuby.getRuntime().getJRubyClassLoader().loadClass(objectFactoryClassName);\n        Constructor<?> ctor = ofc.getConstructor();\n        try {\n            return (ObjectFactory) ctor.newInstance();\n        } catch (InvocationTargetException e) {\n            throw e.getTargetException();\n        }\n    }\n\n    public Object invokeHook(Method method, IRubyObject scenario) throws Throwable {\n        Object[] args = new Object[0];\n        if(method.getParameterTypes().length == 1) {\n            args = new Object[]{scenario};\n        } else if(method.getParameterTypes().length > 1) {\n            throw JRuby.cucumberArityMismatchError(\"Hooks must take 0 or 1 arguments. \" + method);\n        }\n        return invoke(method, args);\n    }\n\n    public Object invoke(Method method, Object[] args) throws Throwable {\n        Object target = objectFactory.getComponent(method.getDeclaringClass());\n        Object[] transformedArgs = transform(args, method.getParameterTypes());\n        return methodInvoker.invoke(method, target, transformedArgs);\n    }\n\n    public List<Class<?>> getClasses() {\n        return objectFactory.getClasses();\n    }\n}\n","lineNo":113}
{"Smelly Sample":"package cuke4duke.internal.ik;\n\nimport cuke4duke.internal.language.AbstractStepDefinition;\nimport cuke4duke.internal.language.StepArgument;\nimport cuke4duke.internal.Utils;\nimport cuke4duke.Table;\nimport ioke.lang.IokeObject;\nimport ioke.lang.Message;\nimport ioke.lang.Runtime;\nimport ioke.lang.IokeData;\nimport ioke.lang.exceptions.ControlFlow;\n\nimport java.util.List;\n\npublic class IkStepDefinition extends AbstractStepDefinition {\n    private final Runtime ioke;\n    private final IokeObject iokeStepDefObject;\n    private String regexpSource;\n\n    public IkStepDefinition(IkLanguage ikLanguage, Runtime ioke, IokeObject iokeStepDefObject) throws Throwable {\n        super(ikLanguage);\n        this.ioke = ioke;\n        this.iokeStepDefObject = iokeStepDefObject;\n        register();\n    }\n\n    protected Class<?>[] getParameterTypes(Object[] args) {\n        return Utils.objectClassArray(args.length);\n    }\n\n    public void invokeWithJavaArgs(Object[] args) throws Throwable {\n        IokeObject msg = ioke.newMessage(\"invoke\");\n        Message invoke = (Message) IokeObject.data(msg);\n\n        // TODO: Change Cucumber API so that we get an additional argument\n        // telling us whether or not we have a multiline argument. Needed\n        // to support multiline Strings.\n        if(args[args.length-1] instanceof Table) {\n            invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, args[args.length-1]);\n        } else {\n            invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, IokeData.Nil);\n        }\n    }\n\n    public String regexp_source() throws Throwable {\n        if(regexpSource == null) findRegexpSource();\n        return regexpSource;\n    }\n\n    public String file_colon_line() throws Throwable {\n        return regexp_source();\n    }\n\n    public List<StepArgument> arguments_from(String stepName) throws Throwable {\n        IokeObject msg = ioke.newMessage(\"arguments_from\");\n        Message arguments_from = (Message) IokeObject.data(msg);\n        Object args = arguments_from.sendTo(msg, iokeStepDefObject, iokeStepDefObject, stepName);\n        if(args instanceof List) {\n            return (List<StepArgument>) args;\n        } else {\n            return null;\n        }\n    }\n\n    private void findRegexpSource() throws ControlFlow {\n        IokeObject msg = ioke.newMessage(\"regexp_source\");\n        Message regexp_source = (Message) IokeObject.data(msg);\n        regexpSource = regexp_source.sendTo(msg, iokeStepDefObject, iokeStepDefObject).toString();\n    }\n\n}\n","Method after Refactoring":"package cuke4duke.internal.ik;\n\nimport cuke4duke.internal.language.AbstractStepDefinition;\nimport cuke4duke.internal.language.StepArgument;\nimport cuke4duke.internal.Utils;\nimport cuke4duke.internal.JRuby;\nimport cuke4duke.Table;\nimport ioke.lang.IokeObject;\nimport ioke.lang.Message;\nimport ioke.lang.Runtime;\nimport ioke.lang.IokeData;\nimport ioke.lang.exceptions.ControlFlow;\n\nimport java.util.List;\n\npublic class IkStepDefinition extends AbstractStepDefinition {\n    private final Runtime ioke;\n    private final IokeObject iokeStepDefObject;\n    private String regexpSource;\n\n    public static void throwCucumberIokeException(String message) {\n        throw JRuby.error(\"IokeException\", message);\n    }\n\n    public IkStepDefinition(IkLanguage ikLanguage, Runtime ioke, IokeObject iokeStepDefObject) throws Throwable {\n        super(ikLanguage);\n        this.ioke = ioke;\n        this.iokeStepDefObject = iokeStepDefObject;\n        register();\n    }\n\n    protected Class<?>[] getParameterTypes(Object[] args) {\n        return Utils.objectClassArray(args.length);\n    }\n\n    public void invokeWithJavaArgs(Object[] args) throws Throwable {\n        IokeObject msg = ioke.newMessage(\"invoke\");\n        Message invoke = (Message) IokeObject.data(msg);\n        Object multilineArg;\n\n        // TODO: Change Cucumber API so that we get an additional argument\n        // telling us whether or not we have a multiline argument. Needed\n        // to support multiline Strings.\n        if(args[args.length-1] instanceof Table) {\n            multilineArg = args[args.length-1];\n        } else {\n            multilineArg = IokeData.Nil;\n        }\n        Object result = invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, multilineArg);\n        // Maybe look at result to figure out whether or not to throw an exception\n        // It would be really nice if the exception had a stacktrace going back to the Ioke\n        // code. Maybe throwCucumberIokeException() needs to be called from within Ioke to\n        // achieve that?\n        //\n        // throwCucumberIokeException(msg);\n    }\n\n    public String regexp_source() throws Throwable {\n        if(regexpSource == null) findRegexpSource();\n        return regexpSource;\n    }\n\n    public String file_colon_line() throws Throwable {\n        return regexp_source();\n    }\n\n    public List<StepArgument> arguments_from(String stepName) throws Throwable {\n        IokeObject msg = ioke.newMessage(\"arguments_from\");\n        Message arguments_from = (Message) IokeObject.data(msg);\n        Object args = arguments_from.sendTo(msg, iokeStepDefObject, iokeStepDefObject, stepName);\n        if(args instanceof List) {\n            return (List<StepArgument>) args;\n        } else {\n            return null;\n        }\n    }\n\n    private void findRegexpSource() throws ControlFlow {\n        IokeObject msg = ioke.newMessage(\"regexp_source\");\n        Message regexp_source = (Message) IokeObject.data(msg);\n        regexpSource = regexp_source.sendTo(msg, iokeStepDefObject, iokeStepDefObject).toString();\n    }\n\n}\n","lineNo":39}
{"Smelly Sample":"package cuke4duke.internal.java;\n\nimport cuke4duke.*;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.language.StepDefinition;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    public void registerHooksAndStepDefinitionsFor(Class<?> clazz, ClassLanguage classLanguage) {\n        for (Method method : clazz.getMethods()) {\n            registerStepDefinitionMaybe(method, classLanguage);\n            registerBeforeMaybe(method, classLanguage);\n            registerAfterMaybe(method, classLanguage);\n        }\n    }\n\n    private void registerStepDefinitionMaybe(Method method, ClassLanguage classLanguage) {\n        String regexpString = null;\n        if (method.isAnnotationPresent(Given.class)) {\n            regexpString = method.getAnnotation(Given.class).value();\n        } else if (method.isAnnotationPresent(When.class)) {\n            regexpString = method.getAnnotation(When.class).value();\n        } else if (method.isAnnotationPresent(Then.class)) {\n            regexpString = method.getAnnotation(Then.class).value();\n        }\n        if (regexpString != null) {\n            StepDefinition stepDefinition = new JavaStepDefinition(classLanguage, method, regexpString);\n            classLanguage.addStepDefinition(stepDefinition, this);\n        }\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Before.class)) {\n            List<String> tagNames = Arrays.asList(method.getAnnotation(Before.class).value().split(\",\"));\n            classLanguage.addHook(\"before\", new JavaHook(tagNames, method, classLanguage), this);\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(After.class)) {\n            List<String> tagNames = Arrays.asList(method.getAnnotation(After.class).value().split(\",\"));\n            classLanguage.addHook(\"after\", new JavaHook(tagNames, method, classLanguage), this);\n        }\n    }\n}\n","Method after Refactoring":"package cuke4duke.internal.java;\n\nimport cuke4duke.*;\nimport cuke4duke.internal.jvmclass.ClassAnalyzer;\nimport cuke4duke.internal.jvmclass.ClassLanguage;\nimport cuke4duke.internal.language.StepDefinition;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\npublic class JavaAnalyzer implements ClassAnalyzer {\n    public void registerHooksAndStepDefinitionsFor(Class<?> clazz, ClassLanguage classLanguage) {\n        for (Method method : clazz.getMethods()) {\n            registerStepDefinitionMaybe(method, classLanguage);\n            registerBeforeMaybe(method, classLanguage);\n            registerAfterMaybe(method, classLanguage);\n        }\n    }\n\n    private void registerStepDefinitionMaybe(Method method, ClassLanguage classLanguage) {\n        String regexpString = null;\n        if (method.isAnnotationPresent(Given.class)) {\n            regexpString = method.getAnnotation(Given.class).value();\n        } else if (method.isAnnotationPresent(When.class)) {\n            regexpString = method.getAnnotation(When.class).value();\n        } else if (method.isAnnotationPresent(Then.class)) {\n            regexpString = method.getAnnotation(Then.class).value();\n        }\n        if (regexpString != null) {\n            Pattern regexp = Pattern.compile(regexpString);\n            StepDefinition stepDefinition = new JavaStepDefinition(classLanguage, method, regexp);\n            classLanguage.addStepDefinition(stepDefinition, this);\n        }\n    }\n\n    private void registerBeforeMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(Before.class)) {\n            List<String> tagNames = Arrays.asList(method.getAnnotation(Before.class).value().split(\",\"));\n            classLanguage.addHook(\"before\", new JavaHook(tagNames, method, classLanguage), this);\n        }\n    }\n\n    private void registerAfterMaybe(Method method, ClassLanguage classLanguage) {\n        if (method.isAnnotationPresent(After.class)) {\n            List<String> tagNames = Arrays.asList(method.getAnnotation(After.class).value().split(\",\"));\n            classLanguage.addHook(\"after\", new JavaHook(tagNames, method, classLanguage), this);\n        }\n    }\n}\n","lineNo":32}
{"Smelly Sample":"package simple;\n\nimport cuke4duke.Given;\nimport cuke4duke.Table;\nimport cuke4duke.Then;\nimport cuke4duke.When;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n// TODO: This is just testing a Map. We should have some own code to test!!\npublic class StuffSteps {\n    private final Map<String,Integer> cukes = new HashMap<String,Integer>();\n\n    @Given(\"I have (\\\\d+) (.*) cukes\")\n    public void iHaveNCukes(int n, String color) {\n        this.cukes.put(color, n);\n    }\n\n    @When(\"I add a table\")\n    public void iAddATable(Table table) {\n        Map<String,String> hash = table.hashes().get(0);\n        assertEquals(\"1\", hash.get(\"a\"));\n        assertEquals(\"2\", hash.get(\"b\"));\n    }\n\n    @Then(\"I should have (\\\\d+) (.*) cukes\")\n    public void iShouldHaveNCukes(int n, String color) {\n        int number = cukes.get(color) != null ? cukes.get(color) : 0;\n\t\tassertEquals(n, number);\n    }\n\n    public void thisIsNotAStep() {}\n}\n","Method after Refactoring":"package simple;\n\nimport cuke4duke.Given;\nimport cuke4duke.Table;\nimport cuke4duke.Then;\nimport cuke4duke.When;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Arrays;\n\n// TODO: This is just testing a Map. We should have some own code to test!!\npublic class StuffSteps {\n    private final Map<String,Integer> cukes = new HashMap<String,Integer>();\n\n    @Given(\"I have (\\\\d+) (.*) cukes\")\n    public void iHaveNCukes(int n, String color) {\n        this.cukes.put(color, n);\n    }\n\n    @When(\"I add a table\")\n    public void iAddATable(Table table) {\n        table.diffLists(Arrays.asList(\n           Arrays.asList(\"a\", \"b\"),\n           Arrays.asList(\"1\", \"2\")\n        ));\n        List<Map<String, String>> hashes = new ArrayList(table.hashes());\n        Map<String, String> newRow = hashes.get(0);\n        hashes.add(newRow);\n        table.diffHashes(hashes, new HashMap(){{\n            put(\"surplus_row\", false);\n        }});\n    }\n\n    @Then(\"I should have (\\\\d+) (.*) cukes\")\n    public void iShouldHaveNCukes(int n, String color) {\n        int number = cukes.get(color) != null ? cukes.get(color) : 0;\n\t\tassertEquals(n, number);\n    }\n\n    public void thisIsNotAStep() {}\n}\n","lineNo":30}
{"Smelly Sample":"package cuke4duke.junit;\n\nimport cuke4duke.Given;\nimport cuke4duke.Then;\nimport cuke4duke.Steps;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Steps\npublic class JunitCukeSteps {\n    private final Map<String,Integer> cukes = new HashMap<String,Integer>();\n\n    @Given(\"I have (\\\\d+) (.*) cukes\")\n    public void iHaveNCukes(int n, String color) {\n        this.cukes.put(color, n);\n    }\n\n    @Then(\"I should have (\\\\d+) (.*) cukes\")\n    public void iShouldHaveNCukes(int n, String color) {\n        if(n != cukes.get(color)) {\n            throw new RuntimeException(\"Expected \" + n + \", got \" + cukes.get(color));\n        }\n    }\n\n    @Given(\"Longs: (\\\\d+)\")\n    public void longs(long n) {\n    }\n\n    public void thisIsNotAStep() {}\n}\n","Method after Refactoring":"package cuke4duke.junit;\n\nimport cuke4duke.*;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\n\n@Steps\npublic class JunitCukeSteps {\n    private final Map<String,Integer> cukes = new HashMap<String,Integer>();\n\n    @Given(\"I have (\\\\d+) (.*) cukes\")\n    public void iHaveNCukes(int n, String color) {\n        this.cukes.put(color, n);\n    }\n\n    @Then(\"I should have (\\\\d+) (.*) cukes\")\n    public void iShouldHaveNCukes(int n, String color) {\n        int cukesOfColor = cukes.get(color);\n        if(n != cukesOfColor) {\n            throw new RuntimeException(\"Expected \" + n + \", got \" + cukes.get(color));\n        }\n    }\n\n    @When(\"^I add a table$\")\n    public void aTable(Table table) {\n        assertEquals(1, table.hashes().size());\n    }\n\n    @Given(\"Longs: (\\\\d+)\")\n    public void longs(long n) {\n    }\n\n    public void thisIsNotAStep() {}\n}\n","lineNo":21}
{"Smelly Sample":"package cucumber.mojo;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.tools.ant.BuildEvent;\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.Java;\nimport org.apache.tools.ant.types.Commandline;\nimport org.apache.tools.ant.types.Environment;\nimport org.apache.tools.ant.types.Path;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Base for all JRuby mojos.\n *\n * @requiresDependencyResolution compile\n */\npublic abstract class AbstractJRubyMojo extends AbstractMojo {\n\n    protected boolean shouldFork = true;\n\n    /**\n     * @parameter expression=\"${project}\"\n     */\n    protected MavenProject mavenProject;\n\n    /**\n     * @parameter expression=\"${project.basedir}\"\n     * @required\n     */\n    protected File launchDirectory;\n\n    /**\n     * @parameter expression=\"${jruby.home}\"\n     */\n    protected String jrubyHome;\n\n    /**\n     * The amount of memory to use when forking JRuby. Default is \"384m\".\n     *\n     * @parameter expression=\"${jruby.launch.memory}\"\n     */\n    protected String jrubyLaunchMemory = \"384m\";\n\n    /**\n     * The project compile classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List compileClasspathElements;\n\n    /**\n     * The plugin dependencies.\n     *\n     * @parameter expression=\"${plugin.artifacts}\"\n     * @required\n     * @readonly\n     */\n    private List pluginArtifacts;\n\n    /**\n     * The project test classpath\n     *\n     * @parameter expression=\"${project.testClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List testClasspathElements;\n\n    protected Java jruby(List<String> args) throws MojoExecutionException {\n        launchDirectory.mkdirs();\n        Project project = null;\n        try {\n            project = getProject();\n        } catch (DependencyResolutionRequiredException e) {\n            throw new MojoExecutionException(\"error resolving dependencies\", e);\n        }\n\n        Java java = new Java();\n        java.setProject(project);\n        java.setClassname(\"org.jruby.Main\");\n        java.setFailonerror(true);\n\n        Commandline.Argument arg;\n\n        if (shouldFork) {\n            java.setFork(true);\n            java.setDir(launchDirectory);\n\n            arg = java.createJvmarg();\n            arg.setValue(\"-Xmx\" + jrubyLaunchMemory);\n            Environment.Variable classpath = new Environment.Variable();\n\n            Path p = new Path(java.getProject());\n            p.add((Path) project.getReference(\"maven.plugin.classpath\"));\n            p.add((Path) project.getReference(\"maven.compile.classpath\"));\n            p.add((Path) project.getReference(\"maven.test.classpath\"));\n            classpath.setKey(\"JRUBY_PARENT_CLASSPATH\");\n            classpath.setValue(p.toString());\n\n            java.addEnv(classpath);\n        }\n\n        if (jrubyHome != null) {\n            Environment.Variable v = new Environment.Variable();\n            v.setKey(\"jruby.home\");\n            v.setValue(jrubyHome);\n            java.addSysproperty(v);\n        }\n\n        Path p = java.createClasspath();\n        p.add((Path) project.getReference(\"maven.plugin.classpath\"));\n        p.add((Path) project.getReference(\"maven.compile.classpath\"));\n        p.add((Path) project.getReference(\"maven.test.classpath\"));\n        getLog().debug(\"java classpath: \" + p.toString());\n\n        for (String s : args) {\n            arg = java.createArg();\n            arg.setValue(s);\n        }\n\n        return java;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected void installGem(List<String> gem) throws MojoExecutionException {\n        List args = new ArrayList();\n        args.add(\"-S\");\n        // maybe_install_gems only takes a list of gems, no versions or sources\n        if (gem.size() > 1) {\n            args.add(\"gem\");\n            args.add(\"install\");\n        } else {\n            args.add(\"maybe_install_gems\");\n        }\n        args.addAll(gem);\n\n        Java jruby = jruby(args);\n        jruby.execute();\n    }\n\n    protected Project getProject() throws DependencyResolutionRequiredException {\n        Project project = new Project();\n        project.setBaseDir(mavenProject.getBasedir());\n        project.addBuildListener(new LogAdapter());\n        addReference(project, \"maven.compile.classpath\", compileClasspathElements);\n        addReference(project, \"maven.plugin.classpath\", pluginArtifacts);\n        addReference(project, \"maven.test.classpath\", testClasspathElements);\n        return project;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected void addReference(Project project, String reference, List artifacts)\n            throws DependencyResolutionRequiredException {\n        List list = new ArrayList(artifacts.size());\n\n        for (Object elem : artifacts) {\n            String path;\n            if (elem instanceof Artifact) {\n                Artifact a = (Artifact) elem;\n                File file = a.getFile();\n                if (file == null) {\n                    throw new DependencyResolutionRequiredException(a);\n                }\n                path = file.getPath();\n            } else {\n                path = elem.toString();\n            }\n            list.add(path);\n        }\n\n        Path p = new Path(project);\n        p.setPath(StringUtils.join(list.iterator(), File.pathSeparator));\n        project.addReference(reference, p);\n    }\n\n    public static <T> List<T> listify(T... objects) {\n        List<T> res = new ArrayList<T>();\n        res.addAll(Arrays.asList(objects));\n        return res;\n    }\n\n    public class LogAdapter implements BuildListener {\n        public void buildStarted(BuildEvent event) {\n            log(event);\n        }\n\n        public void buildFinished(BuildEvent event) {\n            log(event);\n        }\n\n        public void targetStarted(BuildEvent event) {\n            log(event);\n        }\n\n        public void targetFinished(BuildEvent event) {\n            log(event);\n        }\n\n        public void taskStarted(BuildEvent event) {\n            log(event);\n        }\n\n        public void taskFinished(BuildEvent event) {\n            log(event);\n        }\n\n        public void messageLogged(BuildEvent event) {\n            log(event);\n        }\n\n        private void log(BuildEvent event) {\n            int priority = event.getPriority();\n            Log log = getLog();\n            switch (priority) {\n                case Project.MSG_ERR:\n                    log.error(event.getMessage());\n                    break;\n\n                case Project.MSG_WARN:\n                    log.warn(event.getMessage());\n                    break;\n\n                case Project.MSG_INFO:\n                    log.info(event.getMessage());\n                    break;\n\n                case Project.MSG_VERBOSE:\n                    log.debug(event.getMessage());\n                    break;\n\n                case Project.MSG_DEBUG:\n                    log.debug(event.getMessage());\n                    break;\n\n                default:\n                    log.info(event.getMessage());\n                    break;\n            }\n        }\n    }\n}\n","Method after Refactoring":"package cucumber.mojo;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.tools.ant.BuildEvent;\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.Java;\nimport org.apache.tools.ant.types.Commandline;\nimport org.apache.tools.ant.types.Environment;\nimport org.apache.tools.ant.types.Path;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Base for all JRuby mojos.\n *\n * @requiresDependencyResolution compile\n */\npublic abstract class AbstractJRubyMojo extends AbstractMojo {\n\n    protected boolean shouldFork = true;\n\n    /**\n     * @parameter expression=\"${project}\"\n     */\n    protected MavenProject mavenProject;\n\n    /**\n     * @parameter expression=\"${project.basedir}\"\n     * @required\n     */\n    protected File launchDirectory;\n\n    /**\n     * @parameter expression=\"${jruby.home}\"\n     */\n    protected String jrubyHome;\n\n    /**\n     * The amount of memory to use when forking JRuby. Default is \"384m\".\n     *\n     * @parameter expression=\"${jruby.launch.memory}\"\n     */\n    protected String jrubyLaunchMemory = \"384m\";\n\n    /**\n     * The project compile classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List compileClasspathElements;\n\n    /**\n     * The plugin dependencies.\n     *\n     * @parameter expression=\"${plugin.artifacts}\"\n     * @required\n     * @readonly\n     */\n    private List pluginArtifacts;\n\n    /**\n     * The project test classpath\n     *\n     * @parameter expression=\"${project.testClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List testClasspathElements;\n\n    protected Java jruby(List<String> args) throws MojoExecutionException {\n        launchDirectory.mkdirs();\n        Project project = null;\n        try {\n            project = getProject();\n        } catch (DependencyResolutionRequiredException e) {\n            throw new MojoExecutionException(\"error resolving dependencies\", e);\n        }\n\n        Java java = new Java();\n        java.setProject(project);\n        java.setClassname(\"org.jruby.Main\");\n        java.setFailonerror(true);\n\n        Commandline.Argument arg;\n\n        if (shouldFork) {\n            java.setFork(true);\n            java.setDir(launchDirectory);\n\n            arg = java.createJvmarg();\n            arg.setValue(\"-Xmx\" + jrubyLaunchMemory);\n            Environment.Variable classpath = new Environment.Variable();\n\n            Path p = new Path(java.getProject());\n            p.add((Path) project.getReference(\"maven.plugin.classpath\"));\n            p.add((Path) project.getReference(\"maven.compile.classpath\"));\n            p.add((Path) project.getReference(\"maven.test.classpath\"));\n            classpath.setKey(\"JRUBY_PARENT_CLASSPATH\");\n            classpath.setValue(p.toString());\n\n            java.addEnv(classpath);\n        }\n\n        if (jrubyHome != null) {\n            Environment.Variable v = new Environment.Variable();\n            v.setKey(\"jruby.home\");\n            v.setValue(jrubyHome);\n            java.addSysproperty(v);\n        }\n\n        Path p = java.createClasspath();\n        p.add((Path) project.getReference(\"maven.plugin.classpath\"));\n        p.add((Path) project.getReference(\"maven.compile.classpath\"));\n        p.add((Path) project.getReference(\"maven.test.classpath\"));\n        getLog().debug(\"java classpath: \" + p.toString());\n\n        for (String s : args) {\n            arg = java.createArg();\n            arg.setValue(s);\n        }\n\n        return java;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected void installGem(List<String> gem) throws MojoExecutionException {\n        List args = new ArrayList();\n        args.add(\"-S\");\n        // maybe_install_gems only takes a list of gems, no versions or sources\n        if (gem.size() > 1) {\n            args.add(\"gem\");\n            args.add(\"install\");\n        } else {\n            args.add(\"maybe_install_gems\");\n        }\n        args.addAll(gem);\n\n        Java jruby = jruby(args);\n        jruby.execute();\n    }\n\n    protected Project getProject() throws DependencyResolutionRequiredException {\n        Project project = new Project();\n        project.setBaseDir(mavenProject.getBasedir());\n        project.addBuildListener(new LogAdapter());\n        addReference(project, \"maven.compile.classpath\", compileClasspathElements);\n        addReference(project, \"maven.plugin.classpath\", pluginArtifacts);\n        addReference(project, \"maven.test.classpath\", testClasspathElements);\n        return project;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected void addReference(Project project, String reference, List artifacts)\n            throws DependencyResolutionRequiredException {\n        List list = new ArrayList(artifacts.size());\n\n        for (Object elem : artifacts) {\n            String path;\n            if (elem instanceof Artifact) {\n                Artifact a = (Artifact) elem;\n                File file = a.getFile();\n                if (file == null) {\n                    throw new DependencyResolutionRequiredException(a);\n                }\n                path = file.getPath();\n            } else {\n                path = elem.toString();\n            }\n            list.add(path);\n        }\n\n        Path p = new Path(project);\n        p.setPath(StringUtils.join(list.iterator(), File.pathSeparator));\n        project.addReference(reference, p);\n    }\n\n    public static <T> List<T> listify(T... objects) {\n        List<T> res = new ArrayList<T>();\n        res.addAll(Arrays.asList(objects));\n        return res;\n    }\n\n    public class LogAdapter implements BuildListener {\n        public void buildStarted(BuildEvent event) {\n            log(event);\n        }\n\n        public void buildFinished(BuildEvent event) {\n            log(event);\n        }\n\n        public void targetStarted(BuildEvent event) {\n            log(event);\n        }\n\n        public void targetFinished(BuildEvent event) {\n            log(event);\n        }\n\n        public void taskStarted(BuildEvent event) {\n            log(event);\n        }\n\n        public void taskFinished(BuildEvent event) {\n            log(event);\n        }\n\n        public void messageLogged(BuildEvent event) {\n            log(event);\n        }\n\n        private void log(BuildEvent event) {\n            int priority = event.getPriority();\n            Log log = getLog();\n            String message = event.getMessage();\n            if (message.contains(\"nbb\")) return;\n\t\t\tswitch (priority) {\n                case Project.MSG_ERR:\n                    log.error(message);\n                    break;\n\n                case Project.MSG_WARN:\n                    log.warn(message);\n                    break;\n\n                case Project.MSG_INFO:\n                    log.info(message);\n                    break;\n\n                case Project.MSG_VERBOSE:\n                    log.debug(message);\n                    break;\n\n                case Project.MSG_DEBUG:\n                    log.debug(message);\n                    break;\n\n                default:\n                    log.info(message);\n                    break;\n            }\n        }\n    }\n}\n","lineNo":227}
