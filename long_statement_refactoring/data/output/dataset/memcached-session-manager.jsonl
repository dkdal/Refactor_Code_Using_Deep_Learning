{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.integration.TestUtils.STICKYNESS_PROVIDER;\nimport static de.javakaffee.web.msm.integration.TestUtils.createContext;\nimport static de.javakaffee.web.msm.integration.TestUtils.createSession;\nimport static org.mockito.Matchers.*;\nimport static org.mockito.Mockito.*;\nimport static org.testng.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport de.javakaffee.web.msm.storage.MemcachedStorageClient;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.internal.OperationFuture;\nimport net.spy.memcached.transcoders.Transcoder;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.core.StandardContext;\nimport org.mockito.ArgumentCaptor;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n\n/**\n * Test the {@link MemcachedSessionService}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class MemcachedSessionServiceTest {\n\n    private MemcachedSessionService _service;\n    private MemcachedClient _memcachedMock;\n    private ExecutorService _executor;\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeMethod\n    public void setup() throws Exception {\n\n        final StandardContext context = createContext();\n        context.setBackgroundProcessorDelay( 1 ); // needed for test of updateExpiration\n\n        final SessionManager manager = createSessionManager(context);\n\n        _service = manager.getMemcachedSessionService();\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.setSessionBackupAsync( false );\n        _service.setSticky( true );\n\n        _memcachedMock = mock( MemcachedClient.class );\n\n        final OperationFuture<Boolean> setResultMock = mock( OperationFuture.class );\n        when( setResultMock.get( ) ).thenReturn( Boolean.TRUE );\n        when( setResultMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE );\n        when( _memcachedMock.set( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( setResultMock );\n\n        final OperationFuture<Boolean> deleteResultMock = mock( OperationFuture.class );\n        when( deleteResultMock.get() ).thenReturn( Boolean.TRUE );\n        when( _memcachedMock.delete( anyString() ) ).thenReturn( deleteResultMock );\n\n\n        startInternal( manager, _memcachedMock );\n\n        _executor = Executors.newCachedThreadPool();\n\n    }\n\n    @AfterMethod\n    public void afterMethod() {\n        _executor.shutdown();\n    }\n\n    protected void startInternal( @Nonnull final SessionManager manager, @Nonnull final MemcachedClient memcachedMock ) throws LifecycleException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Nonnull\n    protected abstract SessionManager createSessionManager(Context context);\n\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211,n2:127.0.0.1:11212\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    @Test\n    public void testConfigurationFormatFailoverNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.setFailoverNodes( \"n1\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1 n2\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1,n2\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature105() throws LifecycleException {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), true);\n        _service.shutdown();\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), true);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456-n1\"), true);\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105() throws Exception {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.setSessionBackupAsync(false);\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get( ) ).thenThrow(new ExecutionException(new RuntimeException(\"Simulated exception.\")));\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenThrow(new ExecutionException(new RuntimeException(\"Simulated exception.\")));\n        when( _memcachedMock.set(  eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( futureMock );\n\n        final BackupResult backupResult = _service.backupSession( session.getIdInternal(), false, null ).get();\n        assertEquals(backupResult.getStatus(), BackupResultStatus.FAILURE);\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n    }\n\n    /**\n     * Test that sessions are only backuped if they are modified.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlySendModifiedSessions() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSession session = createSession( _service );\n\n        /* simulate the first request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the second request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        session.setAttribute( \"bar\", \"baz\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the third request, without session access\n         */\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if session attributes were accessed since the last backup.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        session.access();\n        session.endAccess();\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if the session and its attributes were accessed since the last backup/backup check.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedSessionsAndAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        session.access();\n        session.getAttribute( \"foo\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test for issue #68: External change of sessionId must be handled correctly.\n     *\n     * When the webapp is configured with BASIC auth the sessionId is changed on login since 6.0.21\n     * (AuthenticatorBase.register invokes manager.changeSessionId(session)).\n     * This change of the sessionId was not recognized by msm so that it might have happened that the\n     * session is removed from memcached under the old id but not sent to memcached (if the case the session\n     * was not accessed during this request at all, which is very unprobable but who knows).\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testChangeSessionId( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, TimeoutException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, \"foo\" ).get();\n\n        final String oldSessionId = session.getId();\n        _service.getManager().changeSessionId( session );\n\n        // on session backup we specify sessionIdChanged as false as we're not aware of this fact\n        _service.backupSession( session.getIdInternal(), false, \"foo\" );\n\n        // remove session with old id and add it with the new id\n        verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) );\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n        if ( !stickyness.isSticky() ) {\n            Thread.sleep(200l);\n            // check validity info\n            verify( _memcachedMock, times( 1 ) ).delete( eq( new SessionIdFormat().createValidityInfoKeyName( oldSessionId ) ) );\n            verify( _memcachedMock, times( 1 ) ).set( eq( new SessionIdFormat().createValidityInfoKeyName( session.getId() ) ), anyInt(), any(), any( Transcoder.class ) );\n        }\n\n    }\n\n    /**\n     * Test that sessions with a timeout of 0 or less are stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionTimeoutUnlimitedWithSessionLoaded( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, LifecycleException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n            _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n            _service.startInternal(new MemcachedStorageClient(_memcachedMock)); // we must put in our mock again\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n        session.setMaxInactiveInterval( -1 );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        final String sessionId = session.getId();\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any(), any( Transcoder.class ) );\n\n        if ( !stickyness.isSticky() ) {\n            // check validity info\n            final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n\n            // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n            // task is executed/finished.\n            _service.getLockingStrategy().getExecutorService().shutdown();\n\n            // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n            Thread.sleep(15);\n\n            final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupSessionKey ), eq( 0 ), any(), any( Transcoder.class ) );\n            final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n        }\n    }\n\n    /**\n     * Test that non-sticky sessions with a timeout of 0 or less that have not been loaded by a request\n     * the validity info is stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test\n    public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded() throws InterruptedException, ExecutionException, LifecycleException, TimeoutException {\n\n        _service.setStickyInternal( false );\n        _service.setLockingMode( LockingMode.NONE, null, false );\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock)); // we must put in our mock again\n\n        final String sessionId = \"someSessionNotLoaded-n1\";\n\n        // stub loading of validity info\n        final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId );\n        final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() );\n        when( _memcachedMock.get( eq( validityKey ), any ( Transcoder.class) ) ).thenReturn( validityData );\n\n        // stub session (backup) ping\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get() ).thenReturn( Boolean.FALSE );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE );\n        when( _memcachedMock.add( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( futureMock );\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        // update validity info\n        verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n\n        // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n        // task is executed/finished.\n        _service.getLockingStrategy().getExecutorService().shutdown();\n\n        // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n        Thread.sleep(15);\n\n        // ping session\n        verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any(), any( Transcoder.class ) );\n\n        // ping session backup\n        final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n        verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any(), any( Transcoder.class ) );\n\n        // update validity backup\n        final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n        verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: when excluded attributes are accessed/put the session should\n     * not be marked as touched.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testOnlyHashAttributesOfAccessedFilteredAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        verify( transcoderServiceMock, never() ).serializeAttributes( (MemcachedBackupSession)any(), (ConcurrentMap)any() );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedInSessionBackup() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized in updateExpirationInMemcached.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.updateExpirationInMemcached();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    @Test\n    public void testSessionsRefCountHandlingIssue111() throws Exception {\n        _service.setSticky(false);\n        _service.setLockingMode(LockingMode.ALL.name());\n\n        final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder());\n        _service.setTranscoderService( transcoderService );\n\n        _service.setStorageClient(new MemcachedStorageClient(_memcachedMock));\n        _service.startInternal();\n\n        @SuppressWarnings(\"unchecked\")\n        final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class);\n        when(addResultMock.get()).thenReturn(true);\n        when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true);\n        when(_memcachedMock.add(anyString(), anyInt(), any(), any(Transcoder.class))).thenReturn(addResultMock);\n\n        final MemcachedBackupSession session = createSession( _service );\n        // the session is now already added to the internal session map\n        assertNotNull(session.getId());\n\n        Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n        assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n\n        // start another request that loads the session from mc\n        final Request requestMock = mock(Request.class);\n        when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE);\n        _service.getTrackingHostValve().storeRequestThreadLocal(requestMock);\n\n        when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session));\n\n        final MemcachedBackupSession session2 = _service.findSession(session.getId());\n        assertTrue(session2.isLocked());\n        assertEquals(session2.getRefCount(), 1);\n        session2.setAttribute(\"foo\", \"bar\");\n\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n\n        // the session is now in the internal session map,\n        // now let's run a concurrent request\n        final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() {\n\n            @Override\n            public BackupResult call() throws Exception {\n                final MemcachedBackupSession session3 = _service.findSession(session.getId());\n                assertSame(session3, session2);\n                assertEquals(session3.getRefCount(), 2);\n                // let the other thread proceed (or wait)\n                barrier.await();\n                // and wait again so that the other thread can do some work\n                barrier.await();\n\n                final Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n                _service.getTrackingHostValve().resetRequestThreadLocal();\n\n                assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS);\n                // The session should be released now and no longer stored\n                assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n                // just some double checking on expectations...\n                assertEquals(session2.getRefCount(), 0);\n\n                return result.get();\n            }\n\n        });\n\n        barrier.await();\n\n        result = _service.backupSession(session.getId(), false, null);\n        _service.getTrackingHostValve().resetRequestThreadLocal();\n        assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED);\n        // This is the important point!\n        assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n        // just some double checking on expectations...\n        assertEquals(session2.getRefCount(), 1);\n\n        // now let the other thread proceed\n        barrier.await();\n\n        // and wait for the result, also to get exceptions/assertion errors.\n        request2.get();\n\n    }\n\n    @Test\n    public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception {\n\n        _service.setStickyInternal( false );\n        _service.setLockingMode( LockingMode.NONE, null, false );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock)); // we must put in our mock again\n\n        final String sessionId = \"nonStickySessionToTimeOut-n1\";\n\n        // For findSession needed\n        final Request requestMock = mock(Request.class);\n        when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE);\n        _service.getTrackingHostValve().storeRequestThreadLocal(requestMock);\n\n        final MemcachedBackupSession session = _service.findSession(sessionId);\n        assertNull(session);\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        // check that validity info is not loaded - this would trigger the\n        // WARNING: Found no validity info for session id ...\n        final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId );\n        verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.integration.TestUtils.STICKYNESS_PROVIDER;\nimport static de.javakaffee.web.msm.integration.TestUtils.createContext;\nimport static de.javakaffee.web.msm.integration.TestUtils.createSession;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.mockito.Matchers.*;\nimport static org.mockito.Mockito.*;\nimport static org.testng.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport de.javakaffee.web.msm.storage.MemcachedStorageClient;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.internal.OperationFuture;\nimport net.spy.memcached.transcoders.Transcoder;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.core.StandardContext;\nimport org.mockito.ArgumentCaptor;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n\n/**\n * Test the {@link MemcachedSessionService}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class MemcachedSessionServiceTest {\n\n    private MemcachedSessionService _service;\n    private MemcachedClient _memcachedMock;\n    private ExecutorService _executor;\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeMethod\n    public void setup() throws Exception {\n\n        final StandardContext context = createContext();\n        context.setBackgroundProcessorDelay( 1 ); // needed for test of updateExpiration\n\n        final SessionManager manager = createSessionManager(context);\n\n        _service = manager.getMemcachedSessionService();\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.setSessionBackupAsync( false );\n        _service.setSticky( true );\n\n        _memcachedMock = mock( MemcachedClient.class );\n\n        final OperationFuture<Boolean> setResultMock = mock( OperationFuture.class );\n        when( setResultMock.get( ) ).thenReturn( Boolean.TRUE );\n        when( setResultMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE );\n        when( _memcachedMock.set( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( setResultMock );\n\n        final OperationFuture<Boolean> deleteResultMock = mock( OperationFuture.class );\n        when( deleteResultMock.get() ).thenReturn( Boolean.TRUE );\n        when( _memcachedMock.delete( anyString() ) ).thenReturn( deleteResultMock );\n\n\n        startInternal( manager, _memcachedMock );\n\n        _executor = Executors.newCachedThreadPool();\n\n    }\n\n    @AfterMethod\n    public void afterMethod() {\n        _executor.shutdown();\n    }\n\n    protected void startInternal( @Nonnull final SessionManager manager, @Nonnull final MemcachedClient memcachedMock ) throws LifecycleException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Nonnull\n    protected abstract SessionManager createSessionManager(Context context);\n\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211,n2:127.0.0.1:11212\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    @Test\n    public void testConfigurationFormatFailoverNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.setFailoverNodes( \"n1\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1 n2\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1,n2\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature105() throws LifecycleException {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), true);\n        _service.shutdown();\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), true);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456-n1\"), true);\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105() throws Exception {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.setSessionBackupAsync(false);\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock));\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get( ) ).thenThrow(new ExecutionException(new RuntimeException(\"Simulated exception.\")));\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenThrow(new ExecutionException(new RuntimeException(\"Simulated exception.\")));\n        when( _memcachedMock.set(  eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( futureMock );\n\n        final BackupResult backupResult = _service.backupSession( session.getIdInternal(), false, null ).get();\n        assertEquals(backupResult.getStatus(), BackupResultStatus.FAILURE);\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n    }\n\n    /**\n     * Test that sessions are only backuped if they are modified.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlySendModifiedSessions() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSession session = createSession( _service );\n\n        /* simulate the first request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the second request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        session.setAttribute( \"bar\", \"baz\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the third request, without session access\n         */\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if session attributes were accessed since the last backup.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        session.access();\n        session.endAccess();\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if the session and its attributes were accessed since the last backup/backup check.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedSessionsAndAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        session.access();\n        session.getAttribute( \"foo\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test for issue #68: External change of sessionId must be handled correctly.\n     *\n     * When the webapp is configured with BASIC auth the sessionId is changed on login since 6.0.21\n     * (AuthenticatorBase.register invokes manager.changeSessionId(session)).\n     * This change of the sessionId was not recognized by msm so that it might have happened that the\n     * session is removed from memcached under the old id but not sent to memcached (if the case the session\n     * was not accessed during this request at all, which is very unprobable but who knows).\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testChangeSessionId( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, TimeoutException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, \"foo\" ).get();\n\n        final String oldSessionId = session.getId();\n        _service.getManager().changeSessionId( session );\n\n        // on session backup we specify sessionIdChanged as false as we're not aware of this fact\n        _service.backupSession( session.getIdInternal(), false, \"foo\" );\n\n        // remove session with old id and add it with the new id\n        verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) );\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) );\n\n        if ( !stickyness.isSticky() ) {\n            Thread.sleep(200l);\n            // check validity info\n            verify( _memcachedMock, times( 1 ) ).delete( eq( new SessionIdFormat().createValidityInfoKeyName( oldSessionId ) ) );\n            verify( _memcachedMock, times( 1 ) ).set( eq( new SessionIdFormat().createValidityInfoKeyName( session.getId() ) ), anyInt(), any(), any( Transcoder.class ) );\n        }\n\n    }\n\n    /**\n     * Test that sessions with a timeout of 0 or less are stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionTimeoutUnlimitedWithSessionLoaded( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, LifecycleException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n            _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n            _service.startInternal(new MemcachedStorageClient(_memcachedMock)); // we must put in our mock again\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n        session.setMaxInactiveInterval( -1 );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        final String sessionId = session.getId();\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any(), any( Transcoder.class ) );\n\n        if ( !stickyness.isSticky() ) {\n            // check validity info\n            final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n\n            // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n            // task is executed/finished.\n            ExecutorService executorService = _service.getLockingStrategy().getExecutorService();\n            executorService.shutdown();\n            executorService.awaitTermination(1, SECONDS);\n\n            // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n            Thread.sleep(15);\n\n            final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupSessionKey ), eq( 0 ), any(), any( Transcoder.class ) );\n            final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n        }\n    }\n\n    /**\n     * Test that non-sticky sessions with a timeout of 0 or less that have not been loaded by a request\n     * the validity info is stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test\n    public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded() throws InterruptedException, ExecutionException, LifecycleException, TimeoutException {\n\n        _service.setStickyInternal( false );\n        _service.setLockingMode( LockingMode.NONE, null, false );\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock)); // we must put in our mock again\n\n        final String sessionId = \"someSessionNotLoaded-n1\";\n\n        // stub loading of validity info\n        final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId );\n        final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() );\n        when( _memcachedMock.get( eq( validityKey ), any ( Transcoder.class) ) ).thenReturn( validityData );\n\n        // stub session (backup) ping\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get() ).thenReturn( Boolean.FALSE );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE );\n        when( _memcachedMock.add( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( futureMock );\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        // update validity info\n        verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n\n        // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n        // task is executed/finished.\n        _service.getLockingStrategy().getExecutorService().shutdown();\n\n        // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n        Thread.sleep(15);\n\n        // ping session\n        verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any(), any( Transcoder.class ) );\n\n        // ping session backup\n        final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n        verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any(), any( Transcoder.class ) );\n\n        // update validity backup\n        final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n        verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any(), any( Transcoder.class ) );\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: when excluded attributes are accessed/put the session should\n     * not be marked as touched.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testOnlyHashAttributesOfAccessedFilteredAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        verify( transcoderServiceMock, never() ).serializeAttributes( (MemcachedBackupSession)any(), (ConcurrentMap)any() );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedInSessionBackup() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized in updateExpirationInMemcached.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.updateExpirationInMemcached();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    @Test\n    public void testSessionsRefCountHandlingIssue111() throws Exception {\n        _service.setSticky(false);\n        _service.setLockingMode(LockingMode.ALL.name());\n\n        final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder());\n        _service.setTranscoderService( transcoderService );\n\n        _service.setStorageClient(new MemcachedStorageClient(_memcachedMock));\n        _service.startInternal();\n\n        @SuppressWarnings(\"unchecked\")\n        final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class);\n        when(addResultMock.get()).thenReturn(true);\n        when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true);\n        when(_memcachedMock.add(anyString(), anyInt(), any(), any(Transcoder.class))).thenReturn(addResultMock);\n\n        final MemcachedBackupSession session = createSession( _service );\n        // the session is now already added to the internal session map\n        assertNotNull(session.getId());\n\n        Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n        assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n\n        // start another request that loads the session from mc\n        final Request requestMock = mock(Request.class);\n        when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE);\n        _service.getTrackingHostValve().storeRequestThreadLocal(requestMock);\n\n        when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session));\n\n        final MemcachedBackupSession session2 = _service.findSession(session.getId());\n        assertTrue(session2.isLocked());\n        assertEquals(session2.getRefCount(), 1);\n        session2.setAttribute(\"foo\", \"bar\");\n\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n\n        // the session is now in the internal session map,\n        // now let's run a concurrent request\n        final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() {\n\n            @Override\n            public BackupResult call() throws Exception {\n                final MemcachedBackupSession session3 = _service.findSession(session.getId());\n                assertSame(session3, session2);\n                assertEquals(session3.getRefCount(), 2);\n                // let the other thread proceed (or wait)\n                barrier.await();\n                // and wait again so that the other thread can do some work\n                barrier.await();\n\n                final Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n                _service.getTrackingHostValve().resetRequestThreadLocal();\n\n                assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS);\n                // The session should be released now and no longer stored\n                assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n                // just some double checking on expectations...\n                assertEquals(session2.getRefCount(), 0);\n\n                return result.get();\n            }\n\n        });\n\n        barrier.await();\n\n        result = _service.backupSession(session.getId(), false, null);\n        _service.getTrackingHostValve().resetRequestThreadLocal();\n        assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED);\n        // This is the important point!\n        assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n        // just some double checking on expectations...\n        assertEquals(session2.getRefCount(), 1);\n\n        // now let the other thread proceed\n        barrier.await();\n\n        // and wait for the result, also to get exceptions/assertion errors.\n        request2.get();\n\n    }\n\n    @Test\n    public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception {\n\n        _service.setStickyInternal( false );\n        _service.setLockingMode( LockingMode.NONE, null, false );\n        _service.startInternal(new MemcachedStorageClient(_memcachedMock)); // we must put in our mock again\n\n        final String sessionId = \"nonStickySessionToTimeOut-n1\";\n\n        // For findSession needed\n        final Request requestMock = mock(Request.class);\n        when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE);\n        _service.getTrackingHostValve().storeRequestThreadLocal(requestMock);\n\n        final MemcachedBackupSession session = _service.findSession(sessionId);\n        assertNull(session);\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        // check that validity info is not loaded - this would trigger the\n        // WARNING: Found no validity info for session id ...\n        final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId );\n        verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) );\n    }\n\n}\n","lineNo":386}
{"Smelly Sample":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.kryo;\n\nimport com.esotericsoftware.kryo.*;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.esotericsoftware.kryo.pool.KryoFactory;\nimport com.esotericsoftware.kryo.pool.KryoPool;\nimport de.javakaffee.kryoserializers.*;\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.SessionAttributesTranscoder;\nimport de.javakaffee.web.msm.TranscoderDeserializationException;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.objenesis.strategy.StdInstantiatorStrategy;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * A {@link SessionAttributesTranscoder} that uses {@link Kryo} for serialization.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class KryoTranscoder implements SessionAttributesTranscoder {\n\n    private static final Log LOG = LogFactory.getLog( KryoTranscoder.class );\n    \n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 100 * 1024;\n    public static final int DEFAULT_MAX_BUFFER_SIZE = 2000 * 1024;\n    public static final String DEFAULT_SERIALIZER_FACTORY_CLASS = DefaultFieldSerializerFactory.class.getName();\n    \n    private final KryoPool _kryoPool;\n\n    private final int _initialBufferSize;\n    private final int _maxBufferSize;\n    private final KryoDefaultSerializerFactory _defaultSerializerFactory;\n\n    public KryoTranscoder() {\n        this( null, null, false );\n    }\n\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames, final boolean copyCollectionsForSerialization ) {\n        this( classLoader, customConverterClassNames, copyCollectionsForSerialization, DEFAULT_INITIAL_BUFFER_SIZE, DEFAULT_MAX_BUFFER_SIZE,\n                DEFAULT_SERIALIZER_FACTORY_CLASS );\n    }\n\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames,\n            final boolean copyCollectionsForSerialization, final int initialBufferSize, final int maxBufferSize,\n            final String defaultSerializerFactoryClass ) {\n        LOG.info( \"Starting with initialBufferSize \" + initialBufferSize + \", maxBufferSize \" + maxBufferSize +\n                \" and defaultSerializerFactory \" + defaultSerializerFactoryClass );\n        final KryoFactory kryoFactory = createKryoFactory(classLoader, customConverterClassNames, copyCollectionsForSerialization);\n        _kryoPool = new KryoPool.Builder(kryoFactory).softReferences().build();\n        _initialBufferSize = initialBufferSize;\n        _maxBufferSize = maxBufferSize;\n        _defaultSerializerFactory = loadDefaultSerializerFactory( classLoader, defaultSerializerFactoryClass );\n    }\n\n    protected KryoDefaultSerializerFactory loadDefaultSerializerFactory( final ClassLoader classLoader, final String defaultSerializerFactoryClass ) {\n         try {\n             final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n             final Class<?> clazz = Class.forName( defaultSerializerFactoryClass, true, loader );\n\n             return (KryoDefaultSerializerFactory) clazz.newInstance();\n        } catch ( final Exception e ) {\n            throw new RuntimeException(\"Could not load default serializer factory: \" + defaultSerializerFactoryClass, e );\n        }\n    }\n\n    private KryoFactory createKryoFactory(final ClassLoader classLoader,\n                                          final String[] customConverterClassNames,\n                                          final boolean copyCollectionsForSerialization) {\n\n        final KryoBuilder kryoBuilder = new KryoBuilder() {\n            @Override\n            protected Kryo createKryo(ClassResolver classResolver, ReferenceResolver referenceResolver, StreamFactory streamFactory) {\n                return KryoTranscoder.this.createKryo(classResolver, referenceResolver, streamFactory,\n                        classLoader, customConverterClassNames, copyCollectionsForSerialization);\n            }\n        }.withInstantiatorStrategy(new Kryo.DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));\n\n        final List<KryoBuilderConfiguration> builderConfigs = load(KryoBuilderConfiguration.class, customConverterClassNames, classLoader);\n        for(KryoBuilderConfiguration config : builderConfigs) {\n            config.configure(kryoBuilder);\n        }\n\n        return new KryoFactory() {\n            @Override\n            public Kryo create() {\n                Kryo kryo = kryoBuilder.build();\n\n                kryo.setDefaultSerializer(new KryoDefaultSerializerFactory.SerializerFactoryAdapter(_defaultSerializerFactory));\n\n                if ( classLoader != null ) {\n                    kryo.setClassLoader( classLoader );\n                }\n\n                // com.esotericsoftware.minlog.Log.TRACE = true;\n\n                kryo.setRegistrationRequired(false);\n                kryo.register( Arrays.asList( \"\" ).getClass(), new ArraysAsListSerializer() );\n                kryo.register(InvocationHandler.class, new JdkProxySerializer());\n                UnmodifiableCollectionsSerializer.registerSerializers(kryo);\n                SynchronizedCollectionsSerializer.registerSerializers(kryo);\n\n                kryo.addDefaultSerializer(EnumMap.class, EnumMapSerializer.class);\n                SubListSerializers.addDefaultSerializers(kryo);\n\n                final List<KryoCustomization> customizations = load(KryoCustomization.class, customConverterClassNames, classLoader, kryo);\n                if ( customizations != null ) {\n                    for( final KryoCustomization customization : customizations ) {\n                        try {\n                            LOG.info( \"Executing KryoCustomization \" + customization.getClass().getName() );\n                            customization.customize( kryo );\n                        } catch( final Throwable e ) {\n                            LOG.error( \"Could not execute customization \" + customization, e );\n                        }\n                    }\n                }\n\n                return kryo;\n            }\n        };\n    }\n\n    protected Kryo createKryo(final ClassResolver classResolver, final ReferenceResolver referenceResolver, final StreamFactory streamFactory,\n                              final ClassLoader classLoader, final String[] customConverterClassNames, final boolean copyCollectionsForSerialization) {\n        return new Kryo(classResolver, referenceResolver, streamFactory) {\n\n            private final List<SerializerFactory> serializerFactories = load(SerializerFactory.class, customConverterClassNames, classLoader, this);\n\n            @Override\n            @SuppressWarnings( { \"rawtypes\", \"unchecked\" } )\n            public Serializer getDefaultSerializer(final Class clazz) {\n                final Serializer customSerializer = loadCustomSerializer( clazz, serializerFactories );\n                if ( customSerializer != null ) {\n                    return customSerializer;\n                }\n                if ( copyCollectionsForSerialization ) {\n                    // could also be installed via addDefaultSerializer\n                    final Serializer copyCollectionSerializer = loadCopyCollectionSerializer( clazz );\n                    if ( copyCollectionSerializer != null ) {\n                        return copyCollectionSerializer;\n                    }\n                }\n                return super.getDefaultSerializer( clazz );\n            }\n\n            private Serializer loadCustomSerializer(final Class<?> clazz, List<SerializerFactory> serializerFactories) {\n                if ( serializerFactories != null ) {\n                    for (SerializerFactory serializerFactory : serializerFactories) {\n                        final Serializer serializer = serializerFactory.newSerializer(clazz);\n                        if (serializer != null) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Loading custom serializer \" + serializer.getClass().getName() + \" for class \" + clazz);\n                            }\n                            return serializer;\n                        }\n                    }\n                }\n                return null;\n            }\n\n        };\n    }\n    \n    private Serializer loadCopyCollectionSerializer( final Class<?> clazz ) {\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateCollectionSerializer for class \" + clazz );\n            }\n            return new CopyForIterateCollectionSerializer();\n        }\n        if ( Map.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateMapSerializer for class \" + clazz );\n            }\n            return new CopyForIterateMapSerializer();\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    public ConcurrentMap<String, Object> deserializeAttributes(final byte[] data ) {\n        final Kryo kryo = _kryoPool.borrow();\n        try {\n            return kryo.readObject(new Input(data), ConcurrentHashMap.class);\n        } catch ( final RuntimeException e ) {\n            throw new TranscoderDeserializationException( e );\n        } finally {\n            _kryoPool.release(kryo);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public byte[] serializeAttributes( final MemcachedBackupSession session, final ConcurrentMap<String, Object> attributes ) {\n        final Kryo kryo = _kryoPool.borrow();\n        try {\n            /**\n             * Creates an ObjectStream with an initial buffer size of 50KB and a maximum size of 1000KB.\n             */\n            Output out = new Output(_initialBufferSize, _maxBufferSize);\n            kryo.writeObject(out, attributes);\n            return out.toBytes();\n        } catch ( final RuntimeException e ) {\n            throw new TranscoderDeserializationException( e );\n        } finally {\n            _kryoPool.release(kryo);\n        }\n    }\n\n    private <T> List<T> load( Class<T> type, final String[] customConverterClassNames, final ClassLoader classLoader) {\n        return load(type, customConverterClassNames, classLoader, null);\n    }\n\n    private <T> List<T> load( Class<T> type, final String[] customConverterClassNames, final ClassLoader classLoader, final Kryo kryo) {\n        if (customConverterClassNames == null || customConverterClassNames.length == 0 ) {\n            return Collections.emptyList();\n        }\n        final List<T> result = new ArrayList<T>();\n        final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n        for (final String element : customConverterClassNames) {\n            try {\n                final Class<?> clazz = Class.forName( element, true, loader );\n                if ( type.isAssignableFrom( clazz ) ) {\n                    LOG.info(\"Loading \" + type.getSimpleName() + \" \" + element);\n                    final T item = createInstance(clazz.asSubclass(type), kryo);\n                    result.add( item );\n                }\n            } catch (final Exception e) {\n                LOG.error(\"Could not instantiate \" + element + \", omitting this \"+ type.getSimpleName() +\".\", e);\n                throw new RuntimeException(\"Could not load \"+ type.getSimpleName() +\" \" + element, e);\n            }\n        }\n        return result;\n    }\n\n    private static <T> T createInstance( final Class<? extends T> clazz, final Kryo kryo ) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException {\n        try {\n            final Constructor<? extends T> constructor = clazz.getConstructor( Kryo.class );\n            return constructor.newInstance( kryo );\n        } catch ( final NoSuchMethodException nsme ) {\n            final Constructor<? extends T> constructor = clazz.getConstructor();\n            return constructor.newInstance();\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.kryo;\n\nimport com.esotericsoftware.kryo.*;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.esotericsoftware.kryo.pool.KryoFactory;\nimport com.esotericsoftware.kryo.pool.KryoPool;\nimport de.javakaffee.kryoserializers.*;\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.SessionAttributesTranscoder;\nimport de.javakaffee.web.msm.TranscoderDeserializationException;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.objenesis.strategy.StdInstantiatorStrategy;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * A {@link SessionAttributesTranscoder} that uses {@link Kryo} for serialization.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class KryoTranscoder implements SessionAttributesTranscoder {\n\n    private static final Log LOG = LogFactory.getLog( KryoTranscoder.class );\n    \n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 100 * 1024;\n    public static final int DEFAULT_MAX_BUFFER_SIZE = 2000 * 1024;\n    public static final String DEFAULT_SERIALIZER_FACTORY_CLASS = DefaultFieldSerializerFactory.class.getName();\n    \n    private final KryoPool _kryoPool;\n\n    private final int _initialBufferSize;\n    private final int _maxBufferSize;\n    private final KryoDefaultSerializerFactory _defaultSerializerFactory;\n\n    public KryoTranscoder() {\n        this( null, null, false );\n    }\n\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames, final boolean copyCollectionsForSerialization ) {\n        this( classLoader, customConverterClassNames, copyCollectionsForSerialization, DEFAULT_INITIAL_BUFFER_SIZE, DEFAULT_MAX_BUFFER_SIZE,\n                DEFAULT_SERIALIZER_FACTORY_CLASS );\n    }\n\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames,\n            final boolean copyCollectionsForSerialization, final int initialBufferSize, final int maxBufferSize,\n            final String defaultSerializerFactoryClass ) {\n        LOG.info( \"Starting with initialBufferSize \" + initialBufferSize + \", maxBufferSize \" + maxBufferSize +\n                \" and defaultSerializerFactory \" + defaultSerializerFactoryClass );\n        final KryoFactory kryoFactory = createKryoFactory(classLoader, customConverterClassNames, copyCollectionsForSerialization);\n        _kryoPool = new KryoPool.Builder(kryoFactory).softReferences().build();\n        _initialBufferSize = initialBufferSize;\n        _maxBufferSize = maxBufferSize;\n        _defaultSerializerFactory = loadDefaultSerializerFactory( classLoader, defaultSerializerFactoryClass );\n    }\n\n    protected KryoDefaultSerializerFactory loadDefaultSerializerFactory( final ClassLoader classLoader, final String defaultSerializerFactoryClass ) {\n         try {\n             final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n             final Class<?> clazz = Class.forName( defaultSerializerFactoryClass, true, loader );\n\n             return (KryoDefaultSerializerFactory) clazz.newInstance();\n        } catch ( final Exception e ) {\n            throw new RuntimeException(\"Could not load default serializer factory: \" + defaultSerializerFactoryClass, e );\n        }\n    }\n\n    private KryoFactory createKryoFactory(final ClassLoader classLoader,\n                                          final String[] customConverterClassNames,\n                                          final boolean copyCollectionsForSerialization) {\n\n        KryoBuilder kryoBuilder = new KryoBuilder() {\n            @Override\n            protected Kryo createKryo(ClassResolver classResolver, ReferenceResolver referenceResolver, StreamFactory streamFactory) {\n                return KryoTranscoder.this.createKryo(classResolver, referenceResolver, streamFactory,\n                        classLoader, customConverterClassNames, copyCollectionsForSerialization);\n            }\n        }.withInstantiatorStrategy(new Kryo.DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));\n\n        final List<KryoBuilderConfiguration> builderConfigs = load(KryoBuilderConfiguration.class, customConverterClassNames, classLoader);\n        for(KryoBuilderConfiguration config : builderConfigs) {\n            kryoBuilder = config.configure(kryoBuilder);\n        }\n\n        final KryoBuilder finalKryoBuilder = kryoBuilder;\n        return new KryoFactory() {\n            @Override\n            public Kryo create() {\n                Kryo kryo = finalKryoBuilder.build();\n\n                kryo.setDefaultSerializer(new KryoDefaultSerializerFactory.SerializerFactoryAdapter(_defaultSerializerFactory));\n\n                if ( classLoader != null ) {\n                    kryo.setClassLoader( classLoader );\n                }\n\n                // com.esotericsoftware.minlog.Log.TRACE = true;\n\n                kryo.setRegistrationRequired(false);\n                kryo.register( Arrays.asList( \"\" ).getClass(), new ArraysAsListSerializer() );\n                kryo.register(InvocationHandler.class, new JdkProxySerializer());\n                UnmodifiableCollectionsSerializer.registerSerializers(kryo);\n                SynchronizedCollectionsSerializer.registerSerializers(kryo);\n\n                kryo.addDefaultSerializer(EnumMap.class, EnumMapSerializer.class);\n                SubListSerializers.addDefaultSerializers(kryo);\n\n                final List<KryoCustomization> customizations = load(KryoCustomization.class, customConverterClassNames, classLoader, kryo);\n                if ( customizations != null ) {\n                    for( final KryoCustomization customization : customizations ) {\n                        try {\n                            LOG.info( \"Executing KryoCustomization \" + customization.getClass().getName() );\n                            customization.customize( kryo );\n                        } catch( final Throwable e ) {\n                            LOG.error( \"Could not execute customization \" + customization, e );\n                        }\n                    }\n                }\n\n                return kryo;\n            }\n        };\n    }\n\n    protected Kryo createKryo(final ClassResolver classResolver, final ReferenceResolver referenceResolver, final StreamFactory streamFactory,\n                              final ClassLoader classLoader, final String[] customConverterClassNames, final boolean copyCollectionsForSerialization) {\n        return new Kryo(classResolver, referenceResolver, streamFactory) {\n\n            private final List<SerializerFactory> serializerFactories = load(SerializerFactory.class, customConverterClassNames, classLoader, this);\n\n            @Override\n            @SuppressWarnings( { \"rawtypes\", \"unchecked\" } )\n            public Serializer getDefaultSerializer(final Class clazz) {\n                final Serializer customSerializer = loadCustomSerializer( clazz, serializerFactories );\n                if ( customSerializer != null ) {\n                    return customSerializer;\n                }\n                if ( copyCollectionsForSerialization ) {\n                    // could also be installed via addDefaultSerializer\n                    final Serializer copyCollectionSerializer = loadCopyCollectionSerializer( clazz );\n                    if ( copyCollectionSerializer != null ) {\n                        return copyCollectionSerializer;\n                    }\n                }\n                return super.getDefaultSerializer( clazz );\n            }\n\n            private Serializer loadCustomSerializer(final Class<?> clazz, List<SerializerFactory> serializerFactories) {\n                if ( serializerFactories != null ) {\n                    for (SerializerFactory serializerFactory : serializerFactories) {\n                        final Serializer serializer = serializerFactory.newSerializer(clazz);\n                        if (serializer != null) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Loading custom serializer \" + serializer.getClass().getName() + \" for class \" + clazz);\n                            }\n                            return serializer;\n                        }\n                    }\n                }\n                return null;\n            }\n\n        };\n    }\n    \n    private Serializer loadCopyCollectionSerializer( final Class<?> clazz ) {\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateCollectionSerializer for class \" + clazz );\n            }\n            return new CopyForIterateCollectionSerializer();\n        }\n        if ( Map.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateMapSerializer for class \" + clazz );\n            }\n            return new CopyForIterateMapSerializer();\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    public ConcurrentMap<String, Object> deserializeAttributes(final byte[] data ) {\n        final Kryo kryo = _kryoPool.borrow();\n        try {\n            return kryo.readObject(new Input(data), ConcurrentHashMap.class);\n        } catch ( final RuntimeException e ) {\n            throw new TranscoderDeserializationException( e );\n        } finally {\n            _kryoPool.release(kryo);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public byte[] serializeAttributes( final MemcachedBackupSession session, final ConcurrentMap<String, Object> attributes ) {\n        final Kryo kryo = _kryoPool.borrow();\n        try {\n            /**\n             * Creates an ObjectStream with an initial buffer size of 50KB and a maximum size of 1000KB.\n             */\n            Output out = new Output(_initialBufferSize, _maxBufferSize);\n            kryo.writeObject(out, attributes);\n            return out.toBytes();\n        } catch ( final RuntimeException e ) {\n            throw new TranscoderDeserializationException( e );\n        } finally {\n            _kryoPool.release(kryo);\n        }\n    }\n\n    private <T> List<T> load( Class<T> type, final String[] customConverterClassNames, final ClassLoader classLoader) {\n        return load(type, customConverterClassNames, classLoader, null);\n    }\n\n    private <T> List<T> load( Class<T> type, final String[] customConverterClassNames, final ClassLoader classLoader, final Kryo kryo) {\n        if (customConverterClassNames == null || customConverterClassNames.length == 0 ) {\n            return Collections.emptyList();\n        }\n        final List<T> result = new ArrayList<T>();\n        final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n        for (final String element : customConverterClassNames) {\n            try {\n                final Class<?> clazz = Class.forName( element, true, loader );\n                if ( type.isAssignableFrom( clazz ) ) {\n                    LOG.info(\"Loading \" + type.getSimpleName() + \" \" + element);\n                    final T item = createInstance(clazz.asSubclass(type), kryo);\n                    result.add( item );\n                }\n            } catch (final Exception e) {\n                LOG.error(\"Could not instantiate \" + element + \", omitting this \"+ type.getSimpleName() +\".\", e);\n                throw new RuntimeException(\"Could not load \"+ type.getSimpleName() +\" \" + element, e);\n            }\n        }\n        return result;\n    }\n\n    private static <T> T createInstance( final Class<? extends T> clazz, final Kryo kryo ) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException {\n        try {\n            final Constructor<? extends T> constructor = clazz.getConstructor( Kryo.class );\n            return constructor.newInstance( kryo );\n        } catch ( final NoSuchMethodException nsme ) {\n            final Constructor<? extends T> constructor = clazz.getConstructor();\n            return constructor.newInstance();\n        }\n    }\n\n}\n","lineNo":107}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.assertDeepEquals;\nimport static de.javakaffee.web.msm.integration.TestUtils.createSession;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotNull;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.authenticator.SavedRequest;\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.realm.GenericPrincipal;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\n\n\n/**\n * Test the {@link TranscoderService}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class TranscoderServiceTest {\n\n    protected static SessionManager _manager;\n\n    @BeforeMethod\n    public void setup() throws LifecycleException, ClassNotFoundException, IOException {\n\n        _manager = mock( SessionManager.class );\n\n        when( _manager.getContext() ).thenReturn( new StandardContext() ); // needed for createSession\n        when( _manager.newMemcachedBackupSession() ).thenAnswer(new Answer<MemcachedBackupSession>() {\n            @Override\n            public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable {\n                return  newMemcachedBackupSession( _manager );\n            }\n        });\n\n        final MemcachedSessionService service = new DummyMemcachedSessionService<SessionManager>( _manager );\n        when( _manager.createSession( anyString() ) ).thenAnswer(new Answer<MemcachedBackupSession>() {\n            @Override\n            public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable {\n                return createSession(service);\n            }\n        });\n\n        when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() );\n        when( _manager.getMemcachedSessionService() ).thenReturn( service );\n\n    }\n\n    @Nonnull\n    protected MemcachedBackupSession newMemcachedBackupSession( @Nullable final SessionManager manager ) {\n        return new MemcachedBackupSession( manager );\n    }\n\n    @Test\n    public void testSerializeSessionFieldsIncludesFormPrincipalNote() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        final Principal saved = createPrincipal();\n        session.setNote(Constants.FORM_PRINCIPAL_NOTE, saved);\n\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields(data, _manager ).getSession();\n\n        final Principal actual = (Principal) deserialized.getNote(Constants.FORM_PRINCIPAL_NOTE);\n        assertNotNull(actual);\n        assertDeepEquals(actual, saved);\n    }\n\n    @Test\n    public void testSerializeSessionFieldsIncludesFormRequestNote() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        final SavedRequest saved = new SavedRequest();\n        saved.setQueryString(\"foo=bar\");\n        saved.setRequestURI(\"http://www.foo.org\");\n        session.setNote(Constants.FORM_REQUEST_NOTE, saved);\n\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields(data, _manager ).getSession();\n\n        final SavedRequest actual = (SavedRequest) deserialized.getNote(Constants.FORM_REQUEST_NOTE);\n        assertNotNull(actual);\n        assertDeepEquals(actual, saved);\n    }\n\n    @Test\n    public void testVersionUpgrade() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        final byte[] data = TranscoderService.serializeSessionFields( session, TranscoderService.VERSION_1 );\n        final byte[] attributesData = TranscoderService.deserializeSessionFields(data, _manager ).getAttributesData();\n\n        // we just check that data is read (w/o) bounds issues and no data\n        // is left (we just passed data in, w/o added attributesData appended)\n        assertEquals(attributesData.length, 0);\n    }\n\n    @Test\n    public void testSerializeSessionFields() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n        session.setLastBackupTime( System.currentTimeMillis() );\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields(data, _manager ).getSession();\n\n        assertSessionFields( session, deserialized );\n    }\n\n    @Test\n    public void testSerializeSessionFieldsWithAuthenticatedPrincipal() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        session.setAuthType( HttpServletRequest.FORM_AUTH );\n        session.setPrincipal( createPrincipal() );\n\n        session.setLastBackupTime( System.currentTimeMillis() );\n\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields( data, _manager ).getSession();\n\n        assertSessionFields( session, deserialized );\n    }\n\n    @Nonnull\n    protected abstract GenericPrincipal createPrincipal();\n\n    @Test\n    public void testSerializeSessionWithoutAttributes() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        session.setLastBackupTime( System.currentTimeMillis() );\n\n        final TranscoderService transcoderService = new TranscoderService( new JavaSerializationTranscoder( _manager ) );\n        final byte[] data = transcoderService.serialize( session );\n        final MemcachedBackupSession deserialized = transcoderService.deserialize( data, _manager );\n\n        assertSessionFields( session, deserialized );\n    }\n\n    @Test\n    public void testSerializeSessionWithAttributes() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n        final TranscoderService transcoderService = new TranscoderService( new JavaSerializationTranscoder( _manager ) );\n\n        final String value = \"bar\";\n        session.setAttribute( \"foo\", value );\n\n        session.setLastBackupTime( System.currentTimeMillis() );\n\n        final byte[] data = transcoderService.serialize( session );\n        final MemcachedBackupSession deserialized = transcoderService.deserialize( data, _manager );\n\n        assertSessionFields( session, deserialized );\n        Assert.assertEquals( value, deserialized.getAttribute( \"foo\" ) );\n\n    }\n\n    private void assertSessionFields( final MemcachedBackupSession session, final MemcachedBackupSession deserialized ) {\n        Assert.assertEquals( session.getCreationTimeInternal(), deserialized.getCreationTimeInternal() );\n        Assert.assertEquals( session.getLastAccessedTimeInternal(), deserialized.getLastAccessedTimeInternal() );\n        Assert.assertEquals( session.getMaxInactiveInterval(), deserialized.getMaxInactiveInterval() );\n        Assert.assertEquals( session.isNewInternal(), deserialized.isNewInternal() );\n        Assert.assertEquals( session.isValidInternal(), deserialized.isValidInternal() );\n        Assert.assertEquals( session.getThisAccessedTimeInternal(), deserialized.getThisAccessedTimeInternal() );\n        Assert.assertEquals( session.getLastBackupTime(), deserialized.getLastBackupTime() );\n        Assert.assertEquals( session.getIdInternal(), deserialized.getIdInternal() );\n        Assert.assertEquals( session.getAuthType(), deserialized.getAuthType() );\n        assertDeepEquals( session.getPrincipal(), deserialized.getPrincipal() );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.assertDeepEquals;\nimport static de.javakaffee.web.msm.integration.TestUtils.createSession;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotNull;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.authenticator.SavedRequest;\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.realm.GenericPrincipal;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\n\n\n/**\n * Test the {@link TranscoderService}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class TranscoderServiceTest {\n\n    protected static SessionManager _manager;\n\n    @BeforeMethod\n    public void setup() throws LifecycleException, ClassNotFoundException, IOException {\n\n        _manager = mock( SessionManager.class );\n\n        final Context context = new StandardContext();\n        when( _manager.getContext() ).thenReturn( context ); // needed for createSession\n        when( _manager.getContainer() ).thenReturn( context ); // needed for createSession\n        when( _manager.newMemcachedBackupSession() ).thenAnswer(new Answer<MemcachedBackupSession>() {\n            @Override\n            public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable {\n                return  newMemcachedBackupSession( _manager );\n            }\n        });\n\n        final MemcachedSessionService service = new DummyMemcachedSessionService<SessionManager>( _manager );\n        when( _manager.createSession( anyString() ) ).thenAnswer(new Answer<MemcachedBackupSession>() {\n            @Override\n            public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable {\n                return createSession(service);\n            }\n        });\n\n        when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() );\n        when( _manager.getMemcachedSessionService() ).thenReturn( service );\n        when( _manager.willAttributeDistribute(anyString(), any())).thenReturn(true);\n\n    }\n\n    @Nonnull\n    protected MemcachedBackupSession newMemcachedBackupSession( @Nullable final SessionManager manager ) {\n        return new MemcachedBackupSession( manager );\n    }\n\n    @Test\n    public void testSerializeSessionFieldsIncludesFormPrincipalNote() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        final Principal saved = createPrincipal();\n        session.setNote(Constants.FORM_PRINCIPAL_NOTE, saved);\n\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields(data, _manager ).getSession();\n\n        final Principal actual = (Principal) deserialized.getNote(Constants.FORM_PRINCIPAL_NOTE);\n        assertNotNull(actual);\n        assertDeepEquals(actual, saved);\n    }\n\n    @Test\n    public void testSerializeSessionFieldsIncludesFormRequestNote() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        final SavedRequest saved = new SavedRequest();\n        saved.setQueryString(\"foo=bar\");\n        saved.setRequestURI(\"http://www.foo.org\");\n        session.setNote(Constants.FORM_REQUEST_NOTE, saved);\n\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields(data, _manager ).getSession();\n\n        final SavedRequest actual = (SavedRequest) deserialized.getNote(Constants.FORM_REQUEST_NOTE);\n        assertNotNull(actual);\n        assertDeepEquals(actual, saved);\n    }\n\n    @Test\n    public void testVersionUpgrade() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        final byte[] data = TranscoderService.serializeSessionFields( session, TranscoderService.VERSION_1 );\n        final byte[] attributesData = TranscoderService.deserializeSessionFields(data, _manager ).getAttributesData();\n\n        // we just check that data is read (w/o) bounds issues and no data\n        // is left (we just passed data in, w/o added attributesData appended)\n        assertEquals(attributesData.length, 0);\n    }\n\n    @Test\n    public void testSerializeSessionFields() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n        session.setLastBackupTime( System.currentTimeMillis() );\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields(data, _manager ).getSession();\n\n        assertSessionFields( session, deserialized );\n    }\n\n    @Test\n    public void testSerializeSessionFieldsWithAuthenticatedPrincipal() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        session.setAuthType( HttpServletRequest.FORM_AUTH );\n        session.setPrincipal( createPrincipal() );\n\n        session.setLastBackupTime( System.currentTimeMillis() );\n\n        final byte[] data = TranscoderService.serializeSessionFields( session );\n        final MemcachedBackupSession deserialized = TranscoderService.deserializeSessionFields( data, _manager ).getSession();\n\n        assertSessionFields( session, deserialized );\n    }\n\n    @Nonnull\n    protected abstract GenericPrincipal createPrincipal();\n\n    @Test\n    public void testSerializeSessionWithoutAttributes() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n\n        session.setLastBackupTime( System.currentTimeMillis() );\n\n        final TranscoderService transcoderService = new TranscoderService( new JavaSerializationTranscoder( _manager ) );\n        final byte[] data = transcoderService.serialize( session );\n        final MemcachedBackupSession deserialized = transcoderService.deserialize( data, _manager );\n\n        assertSessionFields( session, deserialized );\n    }\n\n    @Test\n    public void testSerializeSessionWithAttributes() {\n        final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null );\n        final TranscoderService transcoderService = new TranscoderService( new JavaSerializationTranscoder( _manager ) );\n\n        final String value = \"bar\";\n        session.setAttribute( \"foo\", value );\n\n        session.setLastBackupTime( System.currentTimeMillis() );\n\n        final byte[] data = transcoderService.serialize( session );\n        final MemcachedBackupSession deserialized = transcoderService.deserialize( data, _manager );\n\n        assertSessionFields( session, deserialized );\n        Assert.assertEquals( value, deserialized.getAttribute( \"foo\" ) );\n\n    }\n\n    private void assertSessionFields( final MemcachedBackupSession session, final MemcachedBackupSession deserialized ) {\n        Assert.assertEquals( session.getCreationTimeInternal(), deserialized.getCreationTimeInternal() );\n        Assert.assertEquals( session.getLastAccessedTimeInternal(), deserialized.getLastAccessedTimeInternal() );\n        Assert.assertEquals( session.getMaxInactiveInterval(), deserialized.getMaxInactiveInterval() );\n        Assert.assertEquals( session.isNewInternal(), deserialized.isNewInternal() );\n        Assert.assertEquals( session.isValidInternal(), deserialized.isValidInternal() );\n        Assert.assertEquals( session.getThisAccessedTimeInternal(), deserialized.getThisAccessedTimeInternal() );\n        Assert.assertEquals( session.getLastBackupTime(), deserialized.getLastBackupTime() );\n        Assert.assertEquals( session.getIdInternal(), deserialized.getIdInternal() );\n        Assert.assertEquals( session.getAuthType(), deserialized.getAuthType() );\n        assertDeepEquals( session.getPrincipal(), deserialized.getPrincipal() );\n    }\n\n}\n","lineNo":65}
{"Smelly Sample":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.hibernate;\n\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.MemcachedSessionService;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.SessionAttributesTranscoder;\nimport de.javakaffee.web.msm.TranscoderService;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.hibernate.*;\nimport org.hibernate.annotations.AttributeAccessor;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.criterion.Restrictions;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.Test;\n\nimport javax.annotation.Nonnull;\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createContext;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Test for serialization/deserialization of hibernate collection mappings.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class AbstractHibernateCollectionsTest {\n\n    private static final Log LOG = LogFactory.getLog( AbstractHibernateCollectionsTest.class );\n\n    private SessionFactory _sessionFactory;\n\n    @BeforeTest\n    protected void beforeTest() {\n        Configuration configuration = new Configuration()\n                .addAnnotatedClass(Person.class)\n                .addAnnotatedClass(Animal.class)\n                .configure();\n        StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()\n                .applySettings( configuration.getProperties() )\n                .build();\n        _sessionFactory = configuration.buildSessionFactory(serviceRegistry);\n    }\n\n    @Test( enabled = true )\n    public void testDeserializeHibernateCollection() {\n\n        final SessionManager manager = createSessionManager();\n        manager.setContainer( createContext() );\n\n        final Set<Animal> animals = new HashSet<Animal>( Arrays.asList( new Animal( \"cat\" ) ) );\n        final Person person = new Person( \"foo bar\", animals );\n\n        final Long personId = createPerson( person );\n        final Person foundPerson = findPerson( personId );\n        LOG.info( \"person: \" + person.toString() );\n        LOG.info( \"found: \" + foundPerson.toString() );\n        TestUtils.assertDeepEquals( person, foundPerson );\n\n        final TranscoderService transcoderService = new TranscoderService( createTranscoder( manager ) );\n\n        final MemcachedBackupSession session = createSession( manager, \"123456789\" );\n        session.setAttribute( \"person\", foundPerson );\n\n        final byte[] data = transcoderService.serialize( session );\n        final MemcachedBackupSession deserialized = transcoderService.deserialize( data, manager );\n\n        final Person deserializedPerson = (Person) deserialized.getAttribute( \"person\" );\n        TestUtils.assertDeepEquals( foundPerson, deserializedPerson );\n\n    }\n\n    protected abstract SessionAttributesTranscoder createTranscoder( SessionManager manager );\n\n    private Person findPerson( final Long personId ) {\n        final Person foundPerson = withSession( new Callback<Person>() {\n\n            @Override\n            public Person execute( final Session session ) {\n\n                final Criteria crit = session.createCriteria( Person.class ).add( Restrictions.idEq( personId ) );\n                @SuppressWarnings( \"unchecked\" )\n                final List<Person> list = crit.list();\n                Assert.assertEquals( list.size(), 1 );\n                final Person result = list.get( 0 );\n                Hibernate.initialize( result.animals );\n                return result;\n            }\n\n        });\n        return foundPerson;\n    }\n\n    private Long createPerson( final Person person ) {\n        final Long personId = withSession( new Callback<Long>() {\n\n            @Override\n            public Long execute( final Session session ) {\n                return (Long) session.save( person );\n            }\n\n        });\n        return personId;\n    }\n\n    @Entity(name = \"persons\")\n    @AttributeAccessor(\"field\")\n    @SuppressWarnings( \"serial\" )\n    static class Person implements Serializable {\n\n        @Id\n        @GeneratedValue(strategy=GenerationType.IDENTITY)\n        public Long id;\n        public String name;\n\n        @OneToMany( cascade = CascadeType.ALL )\n        public Set<Animal> animals;\n\n        public Person() {\n        }\n        public Person( final String name, final Set<Animal> animals ) {\n            this.name = name;\n            this.animals = animals;\n        }\n\n        @Override\n        public String toString() {\n            return \"Person [id=\" + id + \", name=\" + name + \", animals=\" + animals + \"]\";\n        }\n\n    }\n\n    @Entity(name = \"animals\")\n    @AttributeAccessor( \"field\" )\n    @SuppressWarnings( \"serial\" )\n    static class Animal implements Serializable {\n\n        @Id\n        @GeneratedValue(strategy=GenerationType.IDENTITY)\n        public Long id;\n        public String name;\n\n        public Animal() {\n        }\n        public Animal( final String name ) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Animal [id=\" + id + \", name=\" + name + \"]\";\n        }\n\n    }\n\n    static interface Callback<T> {\n\n        T execute(Session session);\n\n    }\n\n    <T> T withSession( final Callback<T> callback ) {\n        final Session session = _sessionFactory.openSession();\n        Transaction transaction = null;\n        try {\n            transaction = session.beginTransaction();\n            final T result = callback.execute( session );\n            transaction.commit();\n            return result;\n        } catch ( final HibernateException e ) {\n            if(transaction != null) {\n                transaction.rollback();\n            }\n            throw new RuntimeException( e );\n        } finally {\n            session.close();\n        }\n    }\n\n    @Nonnull\n    protected SessionManager createSessionManager() {\n        final SessionManager manager = mock( SessionManager.class );\n        when( manager.getContext() ).thenReturn( new StandardContext() ); // needed for createSession\n        when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager));\n        when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) );\n        return manager;\n    }\n\n    protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) {\n        return new MemcachedSessionService(manager);\n    }\n\n    private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) {\n        final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession();\n        session.setId( id );\n        session.setValid( true );\n        return session;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.hibernate;\n\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.MemcachedSessionService;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.SessionAttributesTranscoder;\nimport de.javakaffee.web.msm.TranscoderService;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.hibernate.*;\nimport org.hibernate.annotations.AttributeAccessor;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.criterion.Restrictions;\nimport org.mockito.Matchers;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.Test;\n\nimport javax.annotation.Nonnull;\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createContext;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.anyObject;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Test for serialization/deserialization of hibernate collection mappings.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class AbstractHibernateCollectionsTest {\n\n    private static final Log LOG = LogFactory.getLog( AbstractHibernateCollectionsTest.class );\n\n    private SessionFactory _sessionFactory;\n\n    @BeforeTest\n    protected void beforeTest() {\n        Configuration configuration = new Configuration()\n                .addAnnotatedClass(Person.class)\n                .addAnnotatedClass(Animal.class)\n                .configure();\n        StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()\n                .applySettings( configuration.getProperties() )\n                .build();\n        _sessionFactory = configuration.buildSessionFactory(serviceRegistry);\n    }\n\n    @Test( enabled = true )\n    public void testDeserializeHibernateCollection() {\n\n        final SessionManager manager = createSessionManager();\n        manager.setContainer( createContext() );\n\n        final Set<Animal> animals = new HashSet<Animal>( Arrays.asList( new Animal( \"cat\" ) ) );\n        final Person person = new Person( \"foo bar\", animals );\n\n        final Long personId = createPerson( person );\n        final Person foundPerson = findPerson( personId );\n        LOG.info( \"person: \" + person.toString() );\n        LOG.info( \"found: \" + foundPerson.toString() );\n        TestUtils.assertDeepEquals( person, foundPerson );\n\n        final TranscoderService transcoderService = new TranscoderService( createTranscoder( manager ) );\n\n        final MemcachedBackupSession session = createSession( manager, \"123456789\" );\n        session.setAttribute( \"person\", foundPerson );\n\n        final byte[] data = transcoderService.serialize( session );\n        final MemcachedBackupSession deserialized = transcoderService.deserialize( data, manager );\n\n        final Person deserializedPerson = (Person) deserialized.getAttribute( \"person\" );\n        TestUtils.assertDeepEquals( foundPerson, deserializedPerson );\n\n    }\n\n    protected abstract SessionAttributesTranscoder createTranscoder( SessionManager manager );\n\n    private Person findPerson( final Long personId ) {\n        final Person foundPerson = withSession( new Callback<Person>() {\n\n            @Override\n            public Person execute( final Session session ) {\n\n                final Criteria crit = session.createCriteria( Person.class ).add( Restrictions.idEq( personId ) );\n                @SuppressWarnings( \"unchecked\" )\n                final List<Person> list = crit.list();\n                Assert.assertEquals( list.size(), 1 );\n                final Person result = list.get( 0 );\n                Hibernate.initialize( result.animals );\n                return result;\n            }\n\n        });\n        return foundPerson;\n    }\n\n    private Long createPerson( final Person person ) {\n        final Long personId = withSession( new Callback<Long>() {\n\n            @Override\n            public Long execute( final Session session ) {\n                return (Long) session.save( person );\n            }\n\n        });\n        return personId;\n    }\n\n    @Entity(name = \"persons\")\n    @AttributeAccessor(\"field\")\n    @SuppressWarnings( \"serial\" )\n    static class Person implements Serializable {\n\n        @Id\n        @GeneratedValue(strategy=GenerationType.IDENTITY)\n        public Long id;\n        public String name;\n\n        @OneToMany( cascade = CascadeType.ALL )\n        public Set<Animal> animals;\n\n        public Person() {\n        }\n        public Person( final String name, final Set<Animal> animals ) {\n            this.name = name;\n            this.animals = animals;\n        }\n\n        @Override\n        public String toString() {\n            return \"Person [id=\" + id + \", name=\" + name + \", animals=\" + animals + \"]\";\n        }\n\n    }\n\n    @Entity(name = \"animals\")\n    @AttributeAccessor( \"field\" )\n    @SuppressWarnings( \"serial\" )\n    static class Animal implements Serializable {\n\n        @Id\n        @GeneratedValue(strategy=GenerationType.IDENTITY)\n        public Long id;\n        public String name;\n\n        public Animal() {\n        }\n        public Animal( final String name ) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Animal [id=\" + id + \", name=\" + name + \"]\";\n        }\n\n    }\n\n    static interface Callback<T> {\n\n        T execute(Session session);\n\n    }\n\n    <T> T withSession( final Callback<T> callback ) {\n        final Session session = _sessionFactory.openSession();\n        Transaction transaction = null;\n        try {\n            transaction = session.beginTransaction();\n            final T result = callback.execute( session );\n            transaction.commit();\n            return result;\n        } catch ( final HibernateException e ) {\n            if(transaction != null) {\n                transaction.rollback();\n            }\n            throw new RuntimeException( e );\n        } finally {\n            session.close();\n        }\n    }\n\n    @Nonnull\n    protected SessionManager createSessionManager() {\n        final SessionManager manager = mock( SessionManager.class );\n        final StandardContext context = new StandardContext();\n        when( manager.getContext() ).thenReturn(context); // needed for createSession\n        when( manager.getContainer() ).thenReturn(context); // needed for createSession\n        when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager));\n        when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) );\n        when( manager.willAttributeDistribute(anyString(), anyObject())).thenReturn(true);\n        return manager;\n    }\n\n    protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) {\n        return new MemcachedSessionService(manager);\n    }\n\n    private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) {\n        final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession();\n        session.setId( id );\n        session.setValid( true );\n        return session;\n    }\n\n}\n","lineNo":214}
{"Smelly Sample":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.kryo;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.ObjectBuffer;\nimport com.esotericsoftware.kryo.SerializationException;\nimport com.esotericsoftware.kryo.Serializer;\nimport com.esotericsoftware.kryo.serialize.BigDecimalSerializer;\nimport com.esotericsoftware.kryo.serialize.BigIntegerSerializer;\n\nimport de.javakaffee.kryoserializers.ArraysAsListSerializer;\nimport de.javakaffee.kryoserializers.ClassSerializer;\nimport de.javakaffee.kryoserializers.CollectionsEmptyListSerializer;\nimport de.javakaffee.kryoserializers.CollectionsEmptyMapSerializer;\nimport de.javakaffee.kryoserializers.CollectionsEmptySetSerializer;\nimport de.javakaffee.kryoserializers.CollectionsSingletonListSerializer;\nimport de.javakaffee.kryoserializers.CollectionsSingletonMapSerializer;\nimport de.javakaffee.kryoserializers.CollectionsSingletonSetSerializer;\nimport de.javakaffee.kryoserializers.CopyForIterateCollectionSerializer;\nimport de.javakaffee.kryoserializers.CopyForIterateMapSerializer;\nimport de.javakaffee.kryoserializers.CurrencySerializer;\nimport de.javakaffee.kryoserializers.DateSerializer;\nimport de.javakaffee.kryoserializers.EnumMapSerializer;\nimport de.javakaffee.kryoserializers.EnumSetSerializer;\nimport de.javakaffee.kryoserializers.GregorianCalendarSerializer;\nimport de.javakaffee.kryoserializers.JdkProxySerializer;\nimport de.javakaffee.kryoserializers.KryoReflectionFactorySupport;\nimport de.javakaffee.kryoserializers.LocaleSerializer;\nimport de.javakaffee.kryoserializers.StringBufferSerializer;\nimport de.javakaffee.kryoserializers.StringBuilderSerializer;\nimport de.javakaffee.kryoserializers.SubListSerializer;\nimport de.javakaffee.kryoserializers.SynchronizedCollectionsSerializer;\nimport de.javakaffee.kryoserializers.UnmodifiableCollectionsSerializer;\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.SessionAttributesTranscoder;\nimport de.javakaffee.web.msm.TranscoderDeserializationException;\n\n/**\n * A {@link SessionAttributesTranscoder} that uses {@link Kryo} for serialization.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class KryoTranscoder implements SessionAttributesTranscoder {\n\n    private static final Log LOG = LogFactory.getLog( KryoTranscoder.class );\n    \n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 100 * 1024;\n    public static final int DEFAULT_MAX_BUFFER_SIZE = 2000 * 1024;\n    public static final String DEFAULT_SERIALIZER_FACTORY_CLASS = ReferenceFieldSerializerFactory.class.getName();\n    \n    private final Kryo _kryo;\n    private final SerializerFactory[] _serializerFactories;\n    private final UnregisteredClassHandler[] _unregisteredClassHandlers;\n\n    private final int _initialBufferSize;\n    private final int _maxBufferSize;\n    private final KryoDefaultSerializerFactory _defaultSerializerFactory;\n\n    /**\n     * \n     */\n    public KryoTranscoder() {\n        this( null, null, false );\n    }\n    \n    /**\n     * @param classLoader\n     * @param copyCollectionsForSerialization \n     * @param customConverterClassNames \n     */\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames, final boolean copyCollectionsForSerialization ) {\n        this( classLoader, customConverterClassNames, copyCollectionsForSerialization, DEFAULT_INITIAL_BUFFER_SIZE, DEFAULT_MAX_BUFFER_SIZE,\n                DEFAULT_SERIALIZER_FACTORY_CLASS );\n    }\n    \n    /**\n     * @param classLoader\n     * @param copyCollectionsForSerialization \n     * @param customConverterClassNames \n     */\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames,\n            final boolean copyCollectionsForSerialization, final int initialBufferSize, final int maxBufferSize,\n            final String defaultSerializerFactoryClass ) {\n        LOG.info( \"Starting with initialBufferSize \" + initialBufferSize + \", maxBufferSize \" + maxBufferSize +\n                \" and defaultSerializerFactory \" + defaultSerializerFactoryClass );\n        final Triple<Kryo, SerializerFactory[], UnregisteredClassHandler[]> triple = createKryo( classLoader, customConverterClassNames, copyCollectionsForSerialization );\n        _kryo = triple.a;\n        _serializerFactories = triple.b;\n        _unregisteredClassHandlers = triple.c;\n        _initialBufferSize = initialBufferSize;\n        _maxBufferSize = maxBufferSize;\n        _defaultSerializerFactory = loadDefaultSerializerFactory( classLoader, defaultSerializerFactoryClass );\n    }\n\n    protected KryoDefaultSerializerFactory loadDefaultSerializerFactory( final ClassLoader classLoader, final String defaultSerializerFactoryClass ) {\n         try {\n             final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n             final Class<?> clazz = Class.forName( defaultSerializerFactoryClass, true, loader );\n\n             return (KryoDefaultSerializerFactory) clazz.newInstance();\n        } catch ( final Exception e ) {\n            throw new RuntimeException(\"Could not load default serializer factory: \" + defaultSerializerFactoryClass, e );\n        }\n    }\n\n    private Triple<Kryo, SerializerFactory[], UnregisteredClassHandler[]> createKryo( final ClassLoader classLoader,\n            final String[] customConverterClassNames, final boolean copyCollectionsForSerialization ) {\n        \n        final Kryo kryo = new KryoReflectionFactorySupport() {\n            \n            @Override\n            @SuppressWarnings( { \"rawtypes\", \"unchecked\" } )\n            public Serializer newSerializer(final Class clazz) {\n                final Serializer customSerializer = loadCustomSerializer( clazz );\n                if ( customSerializer != null ) {\n                    return customSerializer;\n                }\n                if ( EnumSet.class.isAssignableFrom( clazz ) ) {\n                    return new EnumSetSerializer( this );\n                }\n                if ( EnumMap.class.isAssignableFrom( clazz ) ) {\n                    return new EnumMapSerializer( this );\n                }\n                if ( SubListSerializer.canSerialize( clazz ) ) {\n                    return new SubListSerializer( this, clazz );\n                }\n                if ( copyCollectionsForSerialization ) {\n                    final Serializer copyCollectionSerializer = loadCopyCollectionSerializer( clazz, this );\n                    if ( copyCollectionSerializer != null ) {\n                        return copyCollectionSerializer;\n                    }\n                }\n                if ( Date.class.isAssignableFrom( clazz ) ) {\n                    return new DateSerializer( clazz );\n                }\n                return super.newSerializer( clazz );\n            }\n            \n            @SuppressWarnings( { \"rawtypes\" } )\n            @Override\n            protected void handleUnregisteredClass( final Class clazz ) {\n                if ( _unregisteredClassHandlers != null ) {\n                    for( int i = 0; i < _unregisteredClassHandlers.length; i++ ) {\n                        final boolean handled = _unregisteredClassHandlers[i].handleUnregisteredClass( clazz );\n                        if ( handled ) {\n                            if ( LOG.isDebugEnabled() ) {\n                                LOG.debug( \"UnregisteredClassHandler \" + _unregisteredClassHandlers[i].getClass().getName() + \" handled class \" + clazz );\n                            }\n                            return;\n                        }\n                    }\n                }\n                super.handleUnregisteredClass( clazz );\n            }\n            \n            @Override\n            protected Serializer newDefaultSerializer( @SuppressWarnings( \"rawtypes\" ) final Class type ) {\n                return _defaultSerializerFactory.newDefaultSerializer( this, type );\n            }\n\n        };\n        \n        if ( classLoader != null ) {\n            kryo.setClassLoader( classLoader );\n        }\n        \n        // com.esotericsoftware.minlog.Log.TRACE = true;\n        \n        kryo.setRegistrationOptional( true );\n        kryo.register( ArrayList.class );\n        kryo.register( LinkedList.class );\n        kryo.register( HashSet.class );\n        kryo.register( HashMap.class );\n        kryo.register( Arrays.asList( \"\" ).getClass(), new ArraysAsListSerializer( kryo ) );\n        kryo.register( Currency.class, new CurrencySerializer( kryo ) );\n        kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) );\n        kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) );\n        kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() );\n        kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() );\n        kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() );\n        kryo.register( Collections.singletonList( \"\" ).getClass(), new CollectionsSingletonListSerializer( kryo ) );\n        kryo.register( Collections.singleton( \"\" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) );\n        kryo.register( Collections.singletonMap( \"\", \"\" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) );\n        kryo.register( Class.class, new ClassSerializer( kryo ) );\n        kryo.register( BigDecimal.class, new BigDecimalSerializer() );\n        kryo.register( BigInteger.class, new BigIntegerSerializer() );\n        kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() );\n        kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) );\n        UnmodifiableCollectionsSerializer.registerSerializers( kryo );\n        SynchronizedCollectionsSerializer.registerSerializers( kryo );\n        kryo.register( Locale.class, new LocaleSerializer() );\n        \n        final Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> pair = loadCustomConverter( customConverterClassNames,\n                classLoader, kryo );\n        \n        final KryoCustomization[] customizations = pair.a;\n        if ( customizations != null ) {\n            for( final KryoCustomization customization : customizations ) {\n                try {\n                    LOG.info( \"Executing KryoCustomization \" + customization.getClass().getName() );\n                    customization.customize( kryo );\n                } catch( final Throwable e ) {\n                    LOG.error( \"Could not execute customization \" + customization, e );\n                }\n            }\n        }\n        \n        return Triple.create( kryo, pair.b, pair.c );\n    }\n    \n    private Serializer loadCustomSerializer( final Class<?> clazz ) {\n        if ( _serializerFactories != null ) {\n            for( int i = 0; i < _serializerFactories.length; i++ ) {\n                final Serializer serializer = _serializerFactories[i].newSerializer( clazz );\n                if ( serializer != null ) {\n                    if ( LOG.isDebugEnabled() ) {\n                        LOG.debug( \"Loading custom serializer \" + serializer.getClass().getName() + \" for class \" + clazz );\n                    }\n                    return serializer;\n                }\n            }\n        }\n        return null;\n    }\n    \n    private Serializer loadCopyCollectionSerializer( final Class<?> clazz, final Kryo kryo ) {\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateCollectionSerializer for class \" + clazz );\n            }\n            return new CopyForIterateCollectionSerializer( kryo );\n        }\n        if ( Map.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateMapSerializer for class \" + clazz );\n            }\n            return new CopyForIterateMapSerializer( kryo );\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    public Map<String, Object> deserializeAttributes( final byte[] data ) {\n        try {\n            return new ObjectBuffer( _kryo ).readObject( data, ConcurrentHashMap.class );\n        } catch ( final SerializationException e ) {\n            throw new TranscoderDeserializationException( e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public byte[] serializeAttributes( final MemcachedBackupSession session, final Map<String, Object> attributes ) {\n        /**\n         * Creates an ObjectStream with an initial buffer size of 50KB and a maximum size of 1000KB.\n         */\n        return new ObjectBuffer( _kryo, _initialBufferSize, _maxBufferSize  ).writeObject( attributes );\n    }\n\n    private Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> loadCustomConverter( final String[] customConverterClassNames, final ClassLoader classLoader,\n            final Kryo kryo ) {\n        if ( customConverterClassNames == null || customConverterClassNames.length == 0 ) {\n            return Triple.empty();\n        }\n        final List<KryoCustomization> customizations = new ArrayList<KryoCustomization>();\n        final List<SerializerFactory> serializerFactories = new ArrayList<SerializerFactory>();\n        final List<UnregisteredClassHandler> unregisteredClassHandlers = new ArrayList<UnregisteredClassHandler>();\n        final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n        for ( int i = 0; i < customConverterClassNames.length; i++ ) {\n            final String element = customConverterClassNames[i];\n            try {\n                processElement( element, customizations, serializerFactories, unregisteredClassHandlers, kryo, loader );\n            } catch ( final Exception e ) {\n                LOG.error( \"Could not instantiate \" + element + \", omitting this KryoCustomization/SerializerFactory.\", e );\n                throw new RuntimeException( \"Could not load serializer \" + element, e );\n            }\n        }\n        final KryoCustomization[] customizationsArray = customizations.toArray( new KryoCustomization[customizations.size()] );\n        final SerializerFactory[] serializerFactoriesArray = serializerFactories.toArray( new SerializerFactory[serializerFactories.size()] );\n        final UnregisteredClassHandler[] unregisteredClassHandlersArray = unregisteredClassHandlers.toArray( new UnregisteredClassHandler[unregisteredClassHandlers.size()] );\n        return Triple.create( customizationsArray, serializerFactoriesArray, unregisteredClassHandlersArray );\n    }\n\n    private void processElement( final String element, final List<KryoCustomization> customizations,\n            final List<SerializerFactory> serializerFactories, final List<UnregisteredClassHandler> unregisteredClassHandlers, final Kryo kryo, final ClassLoader loader )\n        throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException,\n        InvocationTargetException {\n        final Class<?> clazz = Class.forName( element, true, loader );\n        if ( KryoCustomization.class.isAssignableFrom( clazz ) ) {\n            LOG.info( \"Loading KryoCustomization \" + element );\n            final KryoCustomization customization = createInstance( clazz.asSubclass( KryoCustomization.class ), kryo );\n            customizations.add( customization );\n            if ( customization instanceof SerializerFactory ) {\n                serializerFactories.add( (SerializerFactory) customization );\n            }\n        }\n        if ( SerializerFactory.class.isAssignableFrom( clazz ) ) {\n            LOG.info( \"Loading SerializerFactory \" + element );\n            final SerializerFactory factory = createInstance( clazz.asSubclass( SerializerFactory.class ), kryo );\n            serializerFactories.add( factory );\n        }\n        if ( UnregisteredClassHandler.class.isAssignableFrom( clazz ) ) {\n            LOG.info( \"Loading UnregisteredClassHandler \" + element );\n            final UnregisteredClassHandler handler = createInstance( clazz.asSubclass( UnregisteredClassHandler.class ), kryo );\n            unregisteredClassHandlers.add( handler );\n        }\n    }\n\n    private static <T> T createInstance( final Class<? extends T> clazz, final Kryo kryo ) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException {\n        try {\n            final Constructor<? extends T> constructor = clazz.getConstructor( Kryo.class );\n            return constructor.newInstance( kryo );\n        } catch ( final NoSuchMethodException nsme ) {\n            final Constructor<? extends T> constructor = clazz.getConstructor();\n            return constructor.newInstance();\n        }\n    }\n    \n    private static class Triple<A,B,C> {\n        private static final Triple<?, ?, ?> EMPTY = Triple.create( null, null, null );\n        private final A a;\n        private final B b;\n        private final C c;\n        public Triple( final A a, final B b, final C c ) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n        public static <A, B, C> Triple<A, B, C> create( final A a, final B b, final C c ) {\n            return new Triple<A, B, C>( a, b, c );\n        }\n        @SuppressWarnings( \"unchecked\" )\n        public static <A, B, C> Triple<A, B, C> empty() {\n            return (Triple<A, B, C>) EMPTY;\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.kryo;\n\nimport com.esotericsoftware.kryo.*;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.esotericsoftware.kryo.pool.KryoFactory;\nimport com.esotericsoftware.kryo.pool.KryoPool;\nimport de.javakaffee.kryoserializers.*;\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.SessionAttributesTranscoder;\nimport de.javakaffee.web.msm.TranscoderDeserializationException;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.objenesis.strategy.StdInstantiatorStrategy;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * A {@link SessionAttributesTranscoder} that uses {@link Kryo} for serialization.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class KryoTranscoder implements SessionAttributesTranscoder {\n\n    private static final Log LOG = LogFactory.getLog( KryoTranscoder.class );\n    \n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 100 * 1024;\n    public static final int DEFAULT_MAX_BUFFER_SIZE = 2000 * 1024;\n    public static final String DEFAULT_SERIALIZER_FACTORY_CLASS = DefaultFieldSerializerFactory.class.getName();\n    \n    private final KryoPool _kryoPool;\n\n    private final int _initialBufferSize;\n    private final int _maxBufferSize;\n    private final KryoDefaultSerializerFactory _defaultSerializerFactory;\n\n    public KryoTranscoder() {\n        this( null, null, false );\n    }\n\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames, final boolean copyCollectionsForSerialization ) {\n        this( classLoader, customConverterClassNames, copyCollectionsForSerialization, DEFAULT_INITIAL_BUFFER_SIZE, DEFAULT_MAX_BUFFER_SIZE,\n                DEFAULT_SERIALIZER_FACTORY_CLASS );\n    }\n\n    public KryoTranscoder( final ClassLoader classLoader, final String[] customConverterClassNames,\n            final boolean copyCollectionsForSerialization, final int initialBufferSize, final int maxBufferSize,\n            final String defaultSerializerFactoryClass ) {\n        LOG.info( \"Starting with initialBufferSize \" + initialBufferSize + \", maxBufferSize \" + maxBufferSize +\n                \" and defaultSerializerFactory \" + defaultSerializerFactoryClass );\n        final KryoFactory kryoFactory = createKryoFactory(classLoader, customConverterClassNames, copyCollectionsForSerialization);\n        _kryoPool = new KryoPool.Builder(kryoFactory).softReferences().build();\n        _initialBufferSize = initialBufferSize;\n        _maxBufferSize = maxBufferSize;\n        _defaultSerializerFactory = loadDefaultSerializerFactory( classLoader, defaultSerializerFactoryClass );\n    }\n\n    protected KryoDefaultSerializerFactory loadDefaultSerializerFactory( final ClassLoader classLoader, final String defaultSerializerFactoryClass ) {\n         try {\n             final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n             final Class<?> clazz = Class.forName( defaultSerializerFactoryClass, true, loader );\n\n             return (KryoDefaultSerializerFactory) clazz.newInstance();\n        } catch ( final Exception e ) {\n            throw new RuntimeException(\"Could not load default serializer factory: \" + defaultSerializerFactoryClass, e );\n        }\n    }\n\n    private KryoFactory createKryoFactory(final ClassLoader classLoader,\n                                          final String[] customConverterClassNames,\n                                          final boolean copyCollectionsForSerialization) {\n\n        final KryoBuilder kryoBuilder = new KryoBuilder() {\n            @Override\n            protected Kryo createKryo(ClassResolver classResolver, ReferenceResolver referenceResolver, StreamFactory streamFactory) {\n                return KryoTranscoder.this.createKryo(classResolver, referenceResolver, streamFactory,\n                        classLoader, customConverterClassNames, copyCollectionsForSerialization);\n            }\n        }.withInstantiatorStrategy(new Kryo.DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));\n\n        final List<KryoBuilderConfiguration> builderConfigs = load(KryoBuilderConfiguration.class, customConverterClassNames, classLoader);\n        for(KryoBuilderConfiguration config : builderConfigs) {\n            config.configure(kryoBuilder);\n        }\n\n        return new KryoFactory() {\n            @Override\n            public Kryo create() {\n                Kryo kryo = kryoBuilder.build();\n\n                kryo.setDefaultSerializer(new KryoDefaultSerializerFactory.SerializerFactoryAdapter(_defaultSerializerFactory));\n\n                if ( classLoader != null ) {\n                    kryo.setClassLoader( classLoader );\n                }\n\n                // com.esotericsoftware.minlog.Log.TRACE = true;\n\n                kryo.setRegistrationRequired(false);\n                kryo.register( Arrays.asList( \"\" ).getClass(), new ArraysAsListSerializer() );\n                kryo.register(InvocationHandler.class, new JdkProxySerializer());\n                UnmodifiableCollectionsSerializer.registerSerializers(kryo);\n                SynchronizedCollectionsSerializer.registerSerializers(kryo);\n\n                kryo.addDefaultSerializer(EnumMap.class, EnumMapSerializer.class);\n                SubListSerializers.addDefaultSerializers(kryo);\n\n                final List<KryoCustomization> customizations = load(KryoCustomization.class, customConverterClassNames, classLoader, kryo);\n                if ( customizations != null ) {\n                    for( final KryoCustomization customization : customizations ) {\n                        try {\n                            LOG.info( \"Executing KryoCustomization \" + customization.getClass().getName() );\n                            customization.customize( kryo );\n                        } catch( final Throwable e ) {\n                            LOG.error( \"Could not execute customization \" + customization, e );\n                        }\n                    }\n                }\n\n                return kryo;\n            }\n        };\n    }\n\n    protected Kryo createKryo(final ClassResolver classResolver, final ReferenceResolver referenceResolver, final StreamFactory streamFactory,\n                              final ClassLoader classLoader, final String[] customConverterClassNames, final boolean copyCollectionsForSerialization) {\n        return new Kryo(classResolver, referenceResolver, streamFactory) {\n\n            private final List<SerializerFactory> serializerFactories = load(SerializerFactory.class, customConverterClassNames, classLoader, this);\n\n            @Override\n            @SuppressWarnings( { \"rawtypes\", \"unchecked\" } )\n            public Serializer getDefaultSerializer(final Class clazz) {\n                final Serializer customSerializer = loadCustomSerializer( clazz, serializerFactories );\n                if ( customSerializer != null ) {\n                    return customSerializer;\n                }\n                if ( copyCollectionsForSerialization ) {\n                    // could also be installed via addDefaultSerializer\n                    final Serializer copyCollectionSerializer = loadCopyCollectionSerializer( clazz );\n                    if ( copyCollectionSerializer != null ) {\n                        return copyCollectionSerializer;\n                    }\n                }\n                return super.getDefaultSerializer( clazz );\n            }\n\n            private Serializer loadCustomSerializer(final Class<?> clazz, List<SerializerFactory> serializerFactories) {\n                if ( serializerFactories != null ) {\n                    for (SerializerFactory serializerFactory : serializerFactories) {\n                        final Serializer serializer = serializerFactory.newSerializer(clazz);\n                        if (serializer != null) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Loading custom serializer \" + serializer.getClass().getName() + \" for class \" + clazz);\n                            }\n                            return serializer;\n                        }\n                    }\n                }\n                return null;\n            }\n\n        };\n    }\n    \n    private Serializer loadCopyCollectionSerializer( final Class<?> clazz ) {\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateCollectionSerializer for class \" + clazz );\n            }\n            return new CopyForIterateCollectionSerializer();\n        }\n        if ( Map.class.isAssignableFrom( clazz ) ) {\n            if ( LOG.isDebugEnabled() ) {\n                LOG.debug( \"Loading CopyForIterateMapSerializer for class \" + clazz );\n            }\n            return new CopyForIterateMapSerializer();\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    public Map<String, Object> deserializeAttributes( final byte[] data ) {\n        final Kryo kryo = _kryoPool.borrow();\n        try {\n            return kryo.readObject(new Input(data), ConcurrentHashMap.class);\n        } catch ( final RuntimeException e ) {\n            throw new TranscoderDeserializationException( e );\n        } finally {\n            _kryoPool.release(kryo);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public byte[] serializeAttributes( final MemcachedBackupSession session, final Map<String, Object> attributes ) {\n        final Kryo kryo = _kryoPool.borrow();\n        try {\n            /**\n             * Creates an ObjectStream with an initial buffer size of 50KB and a maximum size of 1000KB.\n             */\n            Output out = new Output(_initialBufferSize, _maxBufferSize);\n            kryo.writeObject(out, attributes);\n            return out.toBytes();\n        } catch ( final RuntimeException e ) {\n            throw new TranscoderDeserializationException( e );\n        } finally {\n            _kryoPool.release(kryo);\n        }\n    }\n\n    private <T> List<T> load( Class<T> type, final String[] customConverterClassNames, final ClassLoader classLoader) {\n        return load(type, customConverterClassNames, classLoader, null);\n    }\n\n    private <T> List<T> load( Class<T> type, final String[] customConverterClassNames, final ClassLoader classLoader, final Kryo kryo) {\n        if (customConverterClassNames == null || customConverterClassNames.length == 0 ) {\n            return Collections.emptyList();\n        }\n        final List<T> result = new ArrayList<T>();\n        final ClassLoader loader = classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();\n        for (final String element : customConverterClassNames) {\n            try {\n                final Class<?> clazz = Class.forName( element, true, loader );\n                if ( type.isAssignableFrom( clazz ) ) {\n                    LOG.info(\"Loading \" + type.getSimpleName() + \" \" + element);\n                    final T item = createInstance(clazz.asSubclass(type), kryo);\n                    result.add( item );\n                }\n            } catch (final Exception e) {\n                LOG.error(\"Could not instantiate \" + element + \", omitting this \"+ type.getSimpleName() +\".\", e);\n                throw new RuntimeException(\"Could not load \"+ type.getSimpleName() +\" \" + element, e);\n            }\n        }\n        return result;\n    }\n\n    private static <T> T createInstance( final Class<? extends T> clazz, final Kryo kryo ) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException {\n        try {\n            final Constructor<? extends T> constructor = clazz.getConstructor( Kryo.class );\n            return constructor.newInstance( kryo );\n        } catch ( final NoSuchMethodException nsme ) {\n            final Constructor<? extends T> constructor = clazz.getConstructor();\n            return constructor.newInstance();\n        }\n    }\n\n}\n","lineNo":247}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.Configurations.MAX_RECONNECT_DELAY_KEY;\nimport static de.javakaffee.web.msm.Configurations.getSystemProperty;\nimport static de.javakaffee.web.msm.Statistics.StatsType.DELETE_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.LOAD_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.SESSION_DESERIALIZATION;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\n\n/**\n * This is the core of memcached session manager, managing sessions in memcached.\n * A {@link SessionManager} interface represents the dependency to tomcats session manager\n * (which normally keeps sessions in memory). This {@link SessionManager} has to be subclassed\n * for a concrete major tomcat version (e.g. for 7.x.x) and configured in the context.xml\n * as manager (see <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SetupAndConfiguration\">SetupAndConfiguration<\/a>)\n * for more. The {@link SessionManager} then has to pass configuration settings to this\n * {@link MemcachedSessionService}. Relevant lifecycle methods are {@link #startInternal()}\n * and {@link #shutdown()}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class MemcachedSessionService {\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    public static final String PROTOCOL_TEXT = \"text\";\n    public static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n    /**\n     * Used to store the id for a new session in a request note. This is needed\n     * for a context configured with cookie=\"false\" as in this case there's no\n     * set-cookie header with the session id. When the request came in with a\n     * requestedSessionId this will be changed in the case of a tomcat/memcached\n     * failover (via request.changeSessionId, called by the contextValve) so in\n     * this case we don't need to note the new/changed session id.\n     */\n    protected static final String NEW_SESSION_ID = \"msm.session.id\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * The pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private String _sessionAttributeFilter = null;\n\n    /**\n     * The compiled pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private Pattern _sessionAttributePattern = null;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private String _username;\n    private String _password;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     *\n     * this cache is also used to track sessions that are not existing in memcached\n     * or that got invalidated, to be able to handle backupSession (in non-sticky mode) correctly.\n     */\n    private final LRUCache<String, Boolean> _invalidSessionsCache = new LRUCache<String, Boolean>( 2000, 5000 );\n\n\tprivate MemcachedNodesManager _memcachedNodesManager;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n    private long _operationTimeout = 1000;\n\n    private CurrentRequest _currentRequest;\n    private RequestTrackingHostValve _trackingHostValve;\n    private RequestTrackingContextValve _trackingContextValve;\n\n    protected final SessionManager _manager;\n\tprivate final MemcachedClientCallback _memcachedClientCallback = createMemcachedClientCallback();\n\n    public MemcachedSessionService( final SessionManager manager ) {\n        _manager = manager;\n    }\n\n    /**\n     * Returns the tomcat session manager.\n     * @return the session manager\n     */\n    @Nonnull\n    public SessionManager getManager() {\n        return _manager;\n    }\n\n    public static interface SessionManager extends Manager {\n\n        /**\n         * Must return the configured session cookie name.\n         * @return the session cookie name.\n         */\n        @Nonnull\n        String getSessionCookieName();\n\n        /**\n         * Reads the Set-Cookie header(s) from the given response.\n         */\n        String[] getSetCookieHeaders(Response response);\n\n        String generateSessionId();\n        void expireSession( final String sessionId );\n        MemcachedBackupSession getSessionInternal( String sessionId );\n        Map<String, Session> getSessionsInternal();\n\n        String getJvmRoute();\n\n        /**\n          * Get a string from the underlying resource bundle or return\n          * null if the String is not found.\n          * @param key to desired resource String\n          * @return resource String matching <i>key<\/i> from underlying\n          *         bundle or null if not found.\n          * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(String key);\n\n        /**\n         * Get a string from the underlying resource bundle and format\n         * it with the given set of arguments.\n         *\n         * @param key to desired resource String\n         * @param args args for placeholders in the string\n         * @return resource String matching <i>key<\/i> from underlying\n         *         bundle or null if not found.\n         * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(final String key, final Object... args);\n\n        int getMaxActiveSessions();\n        void incrementSessionCounter();\n        void incrementRejectedSessions();\n\n        /**\n         * Remove this Session from the active Sessions for this Manager without\n         * removing it from memcached.\n         *\n         * @param session   Session to be removed\n         * @param update    Should the expiration statistics be updated (since tomcat7)\n         */\n        void removeInternal( final Session session, final boolean update );\n\n        /**\n         * Must return the initialized status. Must return <code>true<\/code> if this manager\n         * has already been started.\n         * @return the initialized status\n         */\n        boolean isInitialized();\n\n        @Nonnull\n        MemcachedSessionService getMemcachedSessionService();\n\n        /**\n         * Return the Container with which this Manager is associated.\n         */\n        @Override\n        @Nonnull\n        Container getContainer();\n\n        /**\n         * Return the Context with which this Manager is associated.\n         */\n        @Nonnull\n        ClassLoader getContainerClassLoader();\n\n        /**\n         * Reads the Principal from the given OIS.\n         * @param ois the object input stream to read from. Will be closed by the caller.\n         * @return the deserialized principal\n         * @throws ClassNotFoundException expected to be declared by the implementation.\n         * @throws IOException expected to be declared by the implementation.\n         */\n        @Nonnull\n        Principal readPrincipal( @Nonnull ObjectInputStream ois ) throws ClassNotFoundException, IOException;\n\n        /**\n         * Determines if the context has a security contraint with form based login.\n         */\n        boolean contextHasFormBasedSecurityConstraint();\n\n        // --------------------- setters for testing\n        /**\n         * Sets the sticky mode, must be provided for tests at least.\n         * @param sticky the stickyness.\n         */\n        void setSticky( boolean sticky );\n        void setEnabled( boolean b );\n        void setOperationTimeout(long operationTimeout);\n\n        /**\n         * Set the manager checks frequency in seconds.\n         * @param processExpiresFrequency the new manager checks frequency\n         */\n        void setProcessExpiresFrequency( int processExpiresFrequency );\n        void setMemcachedNodes( @Nonnull String memcachedNodes );\n        void setFailoverNodes( String failoverNodes );\n        void setLockingMode( @Nullable final String lockingMode );\n        void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup );\n        void setUsername(String username);\n        void setPassword(String password);\n\n        /**\n         * Creates a new instance of {@link MemcachedBackupSession} (needed so that it's possible to\n         * create specialized {@link MemcachedBackupSession} instances).\n         */\n        @Nonnull\n        MemcachedBackupSession newMemcachedBackupSession();\n\n        /**\n         * Frequency of the session expiration, and related manager operations.\n         * Manager operations will be done once for the specified amount of\n         * backgrondProcess calls (ie, the lower the amount, the most often the\n         * checks will occur).\n         */\n        int getProcessExpiresFrequency();\n    }\n\n    public void shutdown() {\n        _log.info( \"Stopping services.\" );\n        _manager.getContainer().getParent().getPipeline().removeValve(_trackingHostValve);\n        _manager.getContainer().getPipeline().removeValve(_trackingContextValve);\n        _backupSessionService.shutdown();\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.shutdown();\n        }\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n            _memcached = null;\n        }\n        _transcoderFactory = null;\n        _invalidSessionsCache.clear();\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _memcached = memcachedClient;\n        startInternal();\n    }\n\n    /**\n     * Initialize this manager.\n     */\n    void startInternal() throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        _memcachedNodesManager = createMemcachedNodesManager( _memcachedNodes, _failoverNodes);\n\n        if(_memcached == null) {\n            _memcached = createMemcachedClient( _memcachedNodesManager, _statistics );\n        }\n\n        final String sessionCookieName = _manager.getSessionCookieName();\n        _currentRequest = new CurrentRequest();\n        _trackingHostValve = createRequestTrackingHostValve(sessionCookieName, _currentRequest);\n        _manager.getContainer().getParent().getPipeline().addValve(_trackingHostValve);\n        _trackingContextValve = createRequestTrackingContextValve(sessionCookieName);\n        _manager.getContainer().getPipeline().addValve( _trackingContextValve );\n\n        initNonStickyLockingMode( _memcachedNodesManager );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, sticky \"+ _sticky + \", operation timeout \" + _operationTimeout +\", with node ids \" +\n        \t\t_memcachedNodesManager.getPrimaryNodeIds() + \" and failover node ids \" + _memcachedNodesManager.getFailoverNodeIds() );\n\n    }\n\n    protected RequestTrackingContextValve createRequestTrackingContextValve(final String sessionCookieName) {\n        return new RequestTrackingContextValve(sessionCookieName, this);\n    }\n\n    protected RequestTrackingHostValve createRequestTrackingHostValve(final String sessionCookieName, final CurrentRequest currentRequest) {\n        return new RequestTrackingHostValve(_requestUriIgnorePattern, sessionCookieName, this, _statistics, _enabled, currentRequest) {\n            @Override\n            protected String[] getSetCookieHeaders(final Response response) {\n                return _manager.getSetCookieHeaders(response);\n            }\n        };\n    }\n\n\tprotected MemcachedClientCallback createMemcachedClientCallback() {\n\t\treturn new MemcachedClientCallback() {\n\t\t\t@Override\n\t\t\tpublic Object get(final String key) {\n\t\t\t\treturn _memcached.get(key);\n\t\t\t}\n\t\t};\n\t}\n\n    protected MemcachedNodesManager createMemcachedNodesManager(final String memcachedNodes, final String failoverNodes) {\n\t\treturn MemcachedNodesManager.createFor( memcachedNodes, failoverNodes, _memcachedClientCallback );\n\t}\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( _manager ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final MemcachedNodesManager memcachedNodesManager,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n\n        final long maxReconnectDelay = getSystemProperty(MAX_RECONNECT_DELAY_KEY, DefaultConnectionFactory.DEFAULT_MAX_RECONNECT_DELAY);\n        return new MemcachedClientFactory().createMemcachedClient(memcachedNodesManager, _memcachedProtocol, _username, _password, _operationTimeout,\n                maxReconnectDelay, statistics);\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = _manager.getContainerClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String newSessionId( @Nonnull final String sessionId ) {\n        return _memcachedNodesManager.createSessionId( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    public MemcachedBackupSession findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = _manager.getSessionInternal( id );\n        if ( result != null ) {\n            // TODO: document ignoring requests and container managed authentication\n            // -> with container managed auth protected resources should not be ignored\n            // TODO: check ignored resource also below\n            if (!_sticky && !_trackingHostValve.isIgnoredRequest() && !isContainerSessionLookup()) {\n                result.registerReference();\n            }\n        }\n        else if ( canHitMemcached( id ) && _invalidSessionsCache.get( id ) == null ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            // or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based\n            // constraint needs the session to get the authenticated principal)\n            if ( !_sticky && isContainerSessionLookup()\n                    && !_manager.contextHasFormBasedSecurityConstraint() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // If no current request is set (RequestTrackerHostValve was not passed) we got invoked\n            // by CoyoteAdapter.parseSessionCookiesId - here we can just return null, the requestedSessionId\n            // will be accepted anyway\n            if(!_sticky && _currentRequest.get() == null) {\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                if(!_sticky) {\n                    // synchronized to have correct refcounts\n                    synchronized (_manager.getSessionsInternal()) {\n                        // in the meantime another request might have loaded and added the session,\n                        // and we must ensure to have a single session instance per id to have\n                        // correct refcounts (otherwise a session might be removed from the map at\n                        // the end of #backupSession\n                        if(_manager.getSessionInternal(id) != null) {\n                            result = _manager.getSessionInternal(id);\n                        }\n                        else {\n                            addValidLoadedSession(result);\n                        }\n                        result.registerReference();\n                        // _log.info(\"Registering reference, isContainerSessionLookup(): \" + isContainerSessionLookup(), new RuntimeException(\"foo\"));\n                    }\n                }\n                else {\n                    addValidLoadedSession(result);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    private boolean isContainerSessionLookup() {\n        return !_trackingContextValve.wasInvokedWith(_currentRequest.get());\n    }\n\n    private void addValidLoadedSession(final MemcachedBackupSession result) {\n        // When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver\n        // (due to a tomcat failover) we don't want to notify listeners via session.activate for the\n        // old sessionId but do that later (in handleSessionTakeOver)\n        // See also http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        String jvmRoute;\n        final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null\n            && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( result.getId() ) );\n\n        final boolean activate = !sessionIdWillBeChanged;\n        addValidLoadedSession( result, activate );\n    }\n\n    private void addValidLoadedSession( final StandardSession session, final boolean activate ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        _manager.add( session );\n        if ( activate ) {\n            session.activate();\n        }\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        final MemcachedBackupSession session = createEmptySession();\n        session.setNew( true );\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() );\n\n        if ( sessionId == null || !_memcachedNodesManager.canHitMemcached( sessionId ) ) {\n            sessionId = _manager.generateSessionId();\n        }\n\n        session.setId( sessionId );\n\n        final Request request = _currentRequest.get();\n        if(request != null) {\n            request.setNote(NEW_SESSION_ID, sessionId);\n        }\n\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Created new session with id \" + session.getId() );\n        }\n\n        _manager.incrementSessionCounter();\n\n        return session;\n\n    }\n\n    /**\n     * Is invoked when a session was removed from the manager, e.g. because the\n     * session has been invalidated.\n     *\n     * Is used to release a lock if the non-stick session was locked\n     *\n     * It's also used to keep track of such sessions in non-sticky mode, so that\n     * lockingStrategy.onBackupWithoutLoadedSession is not invoked (see issue 116).\n     *\n     * @param session the removed session.\n     */\n    public void sessionRemoved(final MemcachedBackupSession session) {\n        if(!_sticky) {\n            if(session.isLocked()) {\n                _lockingStrategy.releaseLock(session.getIdInternal());\n                session.releaseLock();\n            }\n            _invalidSessionsCache.put(session.getIdInternal(), Boolean.TRUE);\n        }\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _manager.getMaxActiveSessions() >= 0 && _manager.getSessionsInternal().size() >= _manager.getMaxActiveSessions() ) {\n            _manager.incrementRejectedSessions();\n            throw new IllegalStateException\n                (_manager.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = _manager.newMemcachedBackupSession();\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    /**\n     * Check if the given session id does not belong to this tomcat (according to the\n     * local jvmRoute and the jvmRoute in the session id). If the session contains a\n     * different jvmRoute load if from memcached. If the session was found in memcached and\n     * if it's valid it must be associated with this tomcat and therefore the session id has to\n     * be changed. The new session id must be returned if it was changed.\n     * <p>\n     * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n     * always be returned.\n     * <\/p>\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session is taken over and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = _manager.getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( getSessionIdFormat().extractJvmRoute( requestedSessionId ) ) ) {\n\n            // the session might have been loaded already (by some valve), so let's check our session map\n            MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n            if ( session == null ) {\n                session = loadFromMemcachedWithCheck( requestedSessionId );\n            }\n\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    @Nonnull\n\tprivate SessionIdFormat getSessionIdFormat() {\n\t\treturn _memcachedNodesManager.getSessionIdFormat();\n\t}\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _memcachedNodesManager.changeSessionIdForTomcatFailover(session.getIdInternal(), _manager.getJvmRoute());\n\n        // If this session was already loaded we need to remove it from the session map\n        // See http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        if ( _manager.getSessionsInternal().containsKey( origSessionId ) ) {\n            _manager.getSessionsInternal().remove( origSessionId );\n        }\n\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session, true );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _memcachedNodesManager.isValidForMemcached( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId ).get();\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * Check if the valid session associated with the provided\n     * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n     * and change the session id to the new one (containing the new memcached node). The\n     * new session id must be returned if the session will be relocated and the id was changed.\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session will be relocated and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n    \tif ( !_memcachedNodesManager.isEncodeNodeIdInSessionId() ) {\n    \t\treturn null;\n    \t}\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                \tfinal String newSessionId = _memcachedNodesManager.getNewSessionIdIfNodeFromSessionIdUnavailable( session.getId() );\n                    if ( newSessionId != null ) {\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            } else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _memcachedNodesManager.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                _log.info( \"Session needs to be relocated as node \"+ nodeId +\" is not available, loading backup session for \" + requestedSessionId );\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    _log.debug( \"Loaded backup session for \" + requestedSessionId + \", adding locally with \"+ backupSession.getIdInternal() +\".\" );\n                    addValidLoadedSession( backupSession, true );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final RuntimeException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n        if ( nodeId == null ) {\n            _log.info( \"Cannot load backupSession for sessionId without nodeId: \"+ requestedSessionId );\n            return null;\n        }\n\n        final String newNodeId = _memcachedNodesManager.getNextAvailableNodeId(nodeId);\n        if ( newNodeId == null ) {\n            _log.info( \"No next available node found for nodeId \"+ nodeId );\n            return null;\n        }\n\n        MemcachedBackupSession result = loadBackupSession(requestedSessionId, newNodeId);\n        String nextNodeId = nodeId;\n        // if we didn't find the backup in the next node, let's go through other nodes\n        // to see if the backup is there. For this we have to fake the session id so that\n        // the SuffixBasedNodeLocator selects another backup node.\n        while(result == null\n                && (nextNodeId = _memcachedNodesManager.getNextAvailableNodeId(nextNodeId)) != null\n                && !nextNodeId.equals(nodeId)) {\n            final String newSessionId = getSessionIdFormat().createNewSessionId(requestedSessionId, nextNodeId);\n            result = loadBackupSession(newSessionId, newNodeId);\n        }\n\n        if ( result == null ) {\n            _log.info( \"No backup found for sessionId \" + requestedSessionId );\n            return null;\n        }\n\n        return result;\n    }\n\n    private MemcachedBackupSession loadBackupSession(final String requestedSessionId, final String newNodeId) {\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( getSessionIdFormat().createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, _manager );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n            final String newSessionId = getSessionIdFormat().createNewSessionId( requestedSessionId, newNodeId );\n            _log.info( \"Session backup loaded from secondary memcached for \"+ requestedSessionId +\" (will be relocated),\" +\n            \t\t\" setting new id \"+ newSessionId +\" on session...\" );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n            return null;\n        }\n    }\n\n    /**\n     * Is invoked for requests matching {@link #setRequestUriIgnorePattern(String)} at the end\n     * of the request. Any acquired resources should be freed.\n     * @param sessionId the sessionId, must not be null.\n     * @param requestId the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     */\n    public void requestFinished(final String sessionId, final String requestId) {\n        if(!_sticky) {\n            final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n            if ( msmSession == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No session found in session map for \" + sessionId );\n                return;\n            }\n\n            if ( !msmSession.isValidInternal() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"Non valid session found in session map for \" + sessionId );\n                return;\n            }\n\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return;\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n\n            if(msmSession.isLocked()) {\n                _lockingStrategy.releaseLock(sessionId);\n                msmSession.releaseLock();\n                _lockingStrategy.registerReadonlyRequest(requestId);\n            }\n\n        }\n    }\n\n    /**\n     * Backup the session for the provided session id in memcached if the session was modified or\n     * if the session needs to be relocated. In non-sticky session-mode the session should not be\n     * loaded from memcached for just storing it again but only metadata should be updated.\n     *\n     * @param sessionId\n     *            the if of the session to backup\n     * @param sessionIdChanged\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri of the request for that the session backup shall be performed.\n     *\n     * @return a {@link Future} providing the {@link BackupResultStatus}.\n     */\n    public Future<BackupResult> backupSession( final String sessionId, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n        if ( msmSession == null ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"No session found in session map for \" + sessionId );\n            if ( !_sticky ) {\n                // Issue 116/137: Only notify the lockingStrategy if the session was loaded and has not been removed/invalidated\n                if(!_invalidSessionsCache.containsKey(sessionId)) {\n                    _lockingStrategy.onBackupWithoutLoadedSession( sessionId, requestId, _backupSessionService );\n                }\n            }\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !msmSession.isValidInternal() ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"Non valid session found in session map for \" + sessionId );\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !_sticky ) {\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= msmSession.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) || _invalidSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId can access memcached.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _memcachedNodesManager.canHitMemcached( sessionId );\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n        }\n\n        LockStatus lockStatus = null;\n        try {\n\n            if ( !_sticky ) {\n                lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n            }\n\n            final long start = System.currentTimeMillis();\n\n            /* In the previous version (<1.2) the session was completely serialized by\n             * custom Transcoder implementations.\n             * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n             * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n             * specializations.\n             */\n            final Object object = _memcached.get( sessionId );\n            _memcachedNodesManager.onLoadFromMemcachedSuccess( sessionId );\n\n            if ( object != null ) {\n                if ( !(object instanceof byte[]) ) {\n                    throw new RuntimeException( \"The loaded object for sessionId \" + sessionId + \" is not of required type byte[], but \" + object.getClass().getName() );\n                }\n                final long startDeserialization = System.currentTimeMillis();\n                final MemcachedBackupSession result = _transcoderService.deserialize( (byte[]) object, _manager );\n                _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                result.setSticky( _sticky );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                }\n\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Found session with id \" + sessionId );\n                }\n                return result;\n            }\n            else {\n                releaseIfLocked( sessionId, lockStatus );\n                _invalidSessionsCache.put( sessionId, Boolean.TRUE );\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                }\n                return null;\n            }\n        } catch ( final TranscoderDeserializationException e ) {\n            _log.warn( \"Could not deserialize session with id \" + sessionId + \" from memcached, session will be purged from storage.\", e );\n            releaseIfLocked( sessionId, lockStatus );\n            _memcached.delete( sessionId );\n            _invalidSessionsCache.put( sessionId, Boolean.TRUE );\n        } catch ( final Exception e ) {\n            _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            releaseIfLocked( sessionId, lockStatus );\n        } finally {\n        }\n        return null;\n    }\n\n    protected void releaseIfLocked( final String sessionId, LockStatus lockStatus ) {\n        if ( lockStatus == LockStatus.LOCKED ) {\n            _lockingStrategy.releaseLock( sessionId );\n        }\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + memcachedNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedNodesManager reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( memcachedNodesManager, _statistics );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, memcachedNodesManager, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _memcachedNodesManager = memcachedNodesManager;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( memcachedNodesManager );\n\n        return memcachedNodesManager;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + failoverNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * Return the compiled pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributePattern\n     */\n    @CheckForNull\n    Pattern getSessionAttributePattern() {\n        return _sessionAttributePattern;\n    }\n\n    /**\n     * Return the string pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributeFilter\n     */\n    @CheckForNull\n    public String getSessionAttributeFilter() {\n        return _sessionAttributeFilter;\n    }\n\n    /**\n     * Set the pattern used for including session attributes to a session-backup.\n     * If not set, all session attributes will be part of the session-backup.\n     * <p>\n     * E.g. <code>^(userName|sessionHistory)$<\/code>\n     * <\/p>\n     *\n     * @param sessionAttributeFilter\n     *            the sessionAttributeNames to set\n     */\n    public void setSessionAttributeFilter( @Nullable final String sessionAttributeFilter ) {\n        if ( sessionAttributeFilter == null || sessionAttributeFilter.trim().equals(\"\") ) {\n            _sessionAttributeFilter = null;\n            _sessionAttributePattern = null;\n        }\n        else {\n            _sessionAttributeFilter = sessionAttributeFilter;\n            _sessionAttributePattern = Pattern.compile( sessionAttributeFilter );\n        }\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && _manager.isInitialized() ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && _manager.isInitialized() ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && _manager.getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + _manager.getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( @Nullable final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode != null && lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( _manager.isInitialized() ) {\n            initNonStickyLockingMode( createMemcachedNodesManager( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n\tprivate void initNonStickyLockingMode( @Nonnull final MemcachedNodesManager config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        if ( _sessionAttributeFilter != null ) {\n            _log.warn( \"There's a sessionAttributesFilter configured ('\" + _sessionAttributeFilter + \"'),\" +\n                    \" all other session attributes will be lost after the request due to non-sticky configuration!\" );\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1 && !config.isCouchbaseBucketConfig();\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _memcachedNodesManager,\n                _invalidSessionsCache, storeSecondaryBackup, _statistics, _currentRequest );\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = _manager.findSessions();\n            final int delay = _manager.getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMaxInactiveInterval() > 0 // for <= 0 the session was stored in memcached with expiration 0\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && _manager.isInitialized() ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout from {@link #getSessionBackupTimeout()} is\n     * evaluated.\n     */\n    public boolean isSessionBackupAsync() {\n        return _sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed when {@link #getSessionBackupAsync()}) is <code>false<\/code>.\n     */\n    public long getSessionBackupTimeout() {\n        return _sessionBackupTimeout;\n    }\n\n    public Statistics getStatistics() {\n        return _statistics;\n    }\n\n\tpublic long getOperationTimeout() {\n\t\treturn _operationTimeout;\n\t}\n\n\tpublic void setOperationTimeout(final long operationTimeout ) {\n\t\t_operationTimeout = operationTimeout;\n\t}\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n    }\n\n    /**\n     * Return the memcached nodes manager.\n     */\n    @Nonnull\n    MemcachedNodesManager getMemcachedNodesManager() {\n        return _memcachedNodesManager;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _memcachedNodesManager.getPrimaryNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _memcachedNodesManager.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    public MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    void setMemcachedClient(final MemcachedClient memcachedClient) {\n        _memcached = memcachedClient;\n    }\n\n    RequestTrackingHostValve getTrackingHostValve() {\n        return _trackingHostValve;\n    }\n\n    /**\n     * The currently set locking strategy.\n     */\n    @Nullable\n    LockingStrategy getLockingStrategy() {\n        return _lockingStrategy;\n    }\n\n    public void setUsername(final String username) {\n        _username = username;\n    }\n\n    /**\n     * username required for SASL Connection types\n     * @return\n     */\n    public String getUsername() {\n        return _username;\n    }\n\n    public void setPassword(final String password) {\n       _password = password;\n    }\n\n    /**\n     * password required for SASL Connection types\n     * @return\n     */\n    public String getPassword() {\n        return _password;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.Configurations.MAX_RECONNECT_DELAY_KEY;\nimport static de.javakaffee.web.msm.Configurations.getSystemProperty;\nimport static de.javakaffee.web.msm.Statistics.StatsType.DELETE_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.LOAD_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.SESSION_DESERIALIZATION;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\n\n/**\n * This is the core of memcached session manager, managing sessions in memcached.\n * A {@link SessionManager} interface represents the dependency to tomcats session manager\n * (which normally keeps sessions in memory). This {@link SessionManager} has to be subclassed\n * for a concrete major tomcat version (e.g. for 7.x.x) and configured in the context.xml\n * as manager (see <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SetupAndConfiguration\">SetupAndConfiguration<\/a>)\n * for more. The {@link SessionManager} then has to pass configuration settings to this\n * {@link MemcachedSessionService}. Relevant lifecycle methods are {@link #startInternal()}\n * and {@link #shutdown()}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class MemcachedSessionService {\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    public static final String PROTOCOL_TEXT = \"text\";\n    public static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n    /**\n     * Used to store the id for a new session in a request note. This is needed\n     * for a context configured with cookie=\"false\" as in this case there's no\n     * set-cookie header with the session id. When the request came in with a\n     * requestedSessionId this will be changed in the case of a tomcat/memcached\n     * failover (via request.changeSessionId, called by the contextValve) so in\n     * this case we don't need to note the new/changed session id.\n     */\n    protected static final String NEW_SESSION_ID = \"msm.session.id\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * The pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private String _sessionAttributeFilter = null;\n\n    /**\n     * The compiled pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private Pattern _sessionAttributePattern = null;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private String _username;\n    private String _password;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    private String _storageKeyPrefix = StorageKeyFormat.WEBAPP_VERSION;\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     *\n     * this cache is also used to track sessions that are not existing in memcached\n     * or that got invalidated, to be able to handle backupSession (in non-sticky mode) correctly.\n     */\n    private final LRUCache<String, Boolean> _invalidSessionsCache = new LRUCache<String, Boolean>( 2000, 5000 );\n\n\tprivate MemcachedNodesManager _memcachedNodesManager;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n    private long _operationTimeout = 1000;\n\n    private CurrentRequest _currentRequest;\n    private RequestTrackingHostValve _trackingHostValve;\n    private RequestTrackingContextValve _trackingContextValve;\n\n    protected final SessionManager _manager;\n\tprivate final MemcachedClientCallback _memcachedClientCallback = createMemcachedClientCallback();\n\n    public MemcachedSessionService( final SessionManager manager ) {\n        _manager = manager;\n    }\n\n    /**\n     * Returns the tomcat session manager.\n     * @return the session manager\n     */\n    @Nonnull\n    public SessionManager getManager() {\n        return _manager;\n    }\n\n    public static interface SessionManager extends Manager {\n\n        /**\n         * Must return the configured session cookie name.\n         * @return the session cookie name.\n         */\n        @Nonnull\n        String getSessionCookieName();\n\n        /**\n         * Reads the Set-Cookie header(s) from the given response.\n         */\n        String[] getSetCookieHeaders(Response response);\n\n        String generateSessionId();\n        void expireSession( final String sessionId );\n        MemcachedBackupSession getSessionInternal( String sessionId );\n        Map<String, Session> getSessionsInternal();\n\n        String getJvmRoute();\n\n        /**\n          * Get a string from the underlying resource bundle or return\n          * null if the String is not found.\n          * @param key to desired resource String\n          * @return resource String matching <i>key<\/i> from underlying\n          *         bundle or null if not found.\n          * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(String key);\n\n        /**\n         * Get a string from the underlying resource bundle and format\n         * it with the given set of arguments.\n         *\n         * @param key to desired resource String\n         * @param args args for placeholders in the string\n         * @return resource String matching <i>key<\/i> from underlying\n         *         bundle or null if not found.\n         * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(final String key, final Object... args);\n\n        int getMaxActiveSessions();\n        void incrementSessionCounter();\n        void incrementRejectedSessions();\n\n        /**\n         * Remove this Session from the active Sessions for this Manager without\n         * removing it from memcached.\n         *\n         * @param session   Session to be removed\n         * @param update    Should the expiration statistics be updated (since tomcat7)\n         */\n        void removeInternal( final Session session, final boolean update );\n\n        /**\n         * Must return the initialized status. Must return <code>true<\/code> if this manager\n         * has already been started.\n         * @return the initialized status\n         */\n        boolean isInitialized();\n\n        @Nonnull\n        MemcachedSessionService getMemcachedSessionService();\n\n        /**\n         * Return the Container with which this Manager is associated.\n         */\n        @Override\n        @Nonnull\n        Container getContainer();\n\n        /**\n         * Return the Context with which this Manager is associated.\n         */\n        @Nonnull\n        ClassLoader getContainerClassLoader();\n\n        /**\n         * Reads the Principal from the given OIS.\n         * @param ois the object input stream to read from. Will be closed by the caller.\n         * @return the deserialized principal\n         * @throws ClassNotFoundException expected to be declared by the implementation.\n         * @throws IOException expected to be declared by the implementation.\n         */\n        @Nonnull\n        Principal readPrincipal( @Nonnull ObjectInputStream ois ) throws ClassNotFoundException, IOException;\n\n        /**\n         * Determines if the context has a security contraint with form based login.\n         */\n        boolean contextHasFormBasedSecurityConstraint();\n\n        // --------------------- setters for testing\n        /**\n         * Sets the sticky mode, must be provided for tests at least.\n         * @param sticky the stickyness.\n         */\n        void setSticky( boolean sticky );\n        void setEnabled( boolean b );\n        void setOperationTimeout(long operationTimeout);\n\n        /**\n         * Set the manager checks frequency in seconds.\n         * @param processExpiresFrequency the new manager checks frequency\n         */\n        void setProcessExpiresFrequency( int processExpiresFrequency );\n        void setMemcachedNodes( @Nonnull String memcachedNodes );\n        void setFailoverNodes( String failoverNodes );\n        void setLockingMode( @Nullable final String lockingMode );\n        void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup );\n        void setUsername(String username);\n        void setPassword(String password);\n\n        /**\n         * Creates a new instance of {@link MemcachedBackupSession} (needed so that it's possible to\n         * create specialized {@link MemcachedBackupSession} instances).\n         */\n        @Nonnull\n        MemcachedBackupSession newMemcachedBackupSession();\n\n        /**\n         * Frequency of the session expiration, and related manager operations.\n         * Manager operations will be done once for the specified amount of\n         * backgrondProcess calls (ie, the lower the amount, the most often the\n         * checks will occur).\n         */\n        int getProcessExpiresFrequency();\n    }\n\n    public void shutdown() {\n        _log.info( \"Stopping services.\" );\n        _manager.getContainer().getParent().getPipeline().removeValve(_trackingHostValve);\n        _manager.getContainer().getPipeline().removeValve(_trackingContextValve);\n        _backupSessionService.shutdown();\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.shutdown();\n        }\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n            _memcached = null;\n        }\n        _transcoderFactory = null;\n        _invalidSessionsCache.clear();\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _memcached = memcachedClient;\n        startInternal();\n    }\n\n    /**\n     * Initialize this manager.\n     */\n    void startInternal() throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        _memcachedNodesManager = createMemcachedNodesManager( _memcachedNodes, _failoverNodes);\n\n        if(_memcached == null) {\n            _memcached = createMemcachedClient( _memcachedNodesManager, _statistics );\n        }\n\n        final String sessionCookieName = _manager.getSessionCookieName();\n        _currentRequest = new CurrentRequest();\n        _trackingHostValve = createRequestTrackingHostValve(sessionCookieName, _currentRequest);\n        final Context context = (Context) _manager.getContainer();\n        context.getParent().getPipeline().addValve(_trackingHostValve);\n        _trackingContextValve = createRequestTrackingContextValve(sessionCookieName);\n        context.getPipeline().addValve( _trackingContextValve );\n\n        initNonStickyLockingMode( _memcachedNodesManager );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n\n        _log.info( \"--------\\n- \" + getClass().getSimpleName() + \" finished initialization:\" +\n                \"\\n- sticky: \"+ _sticky +\n                \"\\n- operation timeout: \" + _operationTimeout +\n                \"\\n- node ids: \" + _memcachedNodesManager.getPrimaryNodeIds() +\n                \"\\n- failover node ids: \" + _memcachedNodesManager.getFailoverNodeIds() +\n                \"\\n- storage key prefix: \" + _memcachedNodesManager.getStorageKeyFormat().prefix +\n                \"\\n--------\");\n\n    }\n\n    protected RequestTrackingContextValve createRequestTrackingContextValve(final String sessionCookieName) {\n        return new RequestTrackingContextValve(sessionCookieName, this);\n    }\n\n    protected RequestTrackingHostValve createRequestTrackingHostValve(final String sessionCookieName, final CurrentRequest currentRequest) {\n        return new RequestTrackingHostValve(_requestUriIgnorePattern, sessionCookieName, this, _statistics, _enabled, currentRequest) {\n            @Override\n            protected String[] getSetCookieHeaders(final Response response) {\n                return _manager.getSetCookieHeaders(response);\n            }\n        };\n    }\n\n\tprotected MemcachedClientCallback createMemcachedClientCallback() {\n\t\treturn new MemcachedClientCallback() {\n\t\t\t@Override\n\t\t\tpublic Object get(final String key) {\n\t\t\t\treturn _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key ));\n\t\t\t}\n\t\t};\n\t}\n\n    protected MemcachedNodesManager createMemcachedNodesManager(final String memcachedNodes, final String failoverNodes) {\n        final Context context = (Context) _manager.getContainer();\n        final String webappVersion = Reflections.invoke(context, \"getWebappVersion\", null);\n        final StorageKeyFormat storageKeyFormat = StorageKeyFormat.of(_storageKeyPrefix, context.getParent().getName(), context.getName(), webappVersion);\n\t\treturn MemcachedNodesManager.createFor( memcachedNodes, failoverNodes, storageKeyFormat, _memcachedClientCallback );\n\t}\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( _manager ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final MemcachedNodesManager memcachedNodesManager,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n\n        final long maxReconnectDelay = getSystemProperty(MAX_RECONNECT_DELAY_KEY, DefaultConnectionFactory.DEFAULT_MAX_RECONNECT_DELAY);\n        return new MemcachedClientFactory().createMemcachedClient(memcachedNodesManager, _memcachedProtocol, _username, _password, _operationTimeout,\n                maxReconnectDelay, statistics);\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = _manager.getContainerClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String newSessionId( @Nonnull final String sessionId ) {\n        return _memcachedNodesManager.createSessionId( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    public MemcachedBackupSession findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = _manager.getSessionInternal( id );\n        if ( result != null ) {\n            // TODO: document ignoring requests and container managed authentication\n            // -> with container managed auth protected resources should not be ignored\n            // TODO: check ignored resource also below\n            if (!_sticky && !_trackingHostValve.isIgnoredRequest() && !isContainerSessionLookup()) {\n                result.registerReference();\n            }\n        }\n        else if ( canHitMemcached( id ) && _invalidSessionsCache.get( id ) == null ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            // or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based\n            // constraint needs the session to get the authenticated principal)\n            if ( !_sticky && isContainerSessionLookup()\n                    && !_manager.contextHasFormBasedSecurityConstraint() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // If no current request is set (RequestTrackerHostValve was not passed) we got invoked\n            // by CoyoteAdapter.parseSessionCookiesId - here we can just return null, the requestedSessionId\n            // will be accepted anyway\n            if(!_sticky && _currentRequest.get() == null) {\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                if(!_sticky) {\n                    // synchronized to have correct refcounts\n                    synchronized (_manager.getSessionsInternal()) {\n                        // in the meantime another request might have loaded and added the session,\n                        // and we must ensure to have a single session instance per id to have\n                        // correct refcounts (otherwise a session might be removed from the map at\n                        // the end of #backupSession\n                        if(_manager.getSessionInternal(id) != null) {\n                            result = _manager.getSessionInternal(id);\n                        }\n                        else {\n                            addValidLoadedSession(result);\n                        }\n                        result.registerReference();\n                        // _log.info(\"Registering reference, isContainerSessionLookup(): \" + isContainerSessionLookup(), new RuntimeException(\"foo\"));\n                    }\n                }\n                else {\n                    addValidLoadedSession(result);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    private boolean isContainerSessionLookup() {\n        return !_trackingContextValve.wasInvokedWith(_currentRequest.get());\n    }\n\n    private void addValidLoadedSession(final MemcachedBackupSession result) {\n        // When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver\n        // (due to a tomcat failover) we don't want to notify listeners via session.activate for the\n        // old sessionId but do that later (in handleSessionTakeOver)\n        // See also http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        String jvmRoute;\n        final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null\n            && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( result.getId() ) );\n\n        final boolean activate = !sessionIdWillBeChanged;\n        addValidLoadedSession( result, activate );\n    }\n\n    private void addValidLoadedSession( final StandardSession session, final boolean activate ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        _manager.add( session );\n        if ( activate ) {\n            session.activate();\n        }\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        final MemcachedBackupSession session = createEmptySession();\n        session.setNew( true );\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() );\n\n        if ( sessionId == null || !_memcachedNodesManager.canHitMemcached( sessionId ) ) {\n            sessionId = _manager.generateSessionId();\n        }\n\n        session.setId( sessionId );\n\n        final Request request = _currentRequest.get();\n        if(request != null) {\n            request.setNote(NEW_SESSION_ID, sessionId);\n        }\n\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Created new session with id \" + session.getId() );\n        }\n\n        _manager.incrementSessionCounter();\n\n        return session;\n\n    }\n\n    /**\n     * Is invoked when a session was removed from the manager, e.g. because the\n     * session has been invalidated.\n     *\n     * Is used to release a lock if the non-stick session was locked\n     *\n     * It's also used to keep track of such sessions in non-sticky mode, so that\n     * lockingStrategy.onBackupWithoutLoadedSession is not invoked (see issue 116).\n     *\n     * @param session the removed session.\n     */\n    public void sessionRemoved(final MemcachedBackupSession session) {\n        if(!_sticky) {\n            if(session.isLocked()) {\n                _lockingStrategy.releaseLock(session.getIdInternal());\n                session.releaseLock();\n            }\n            _invalidSessionsCache.put(session.getIdInternal(), Boolean.TRUE);\n        }\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _manager.getMaxActiveSessions() >= 0 && _manager.getSessionsInternal().size() >= _manager.getMaxActiveSessions() ) {\n            _manager.incrementRejectedSessions();\n            throw new IllegalStateException\n                (_manager.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = _manager.newMemcachedBackupSession();\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    /**\n     * Check if the given session id does not belong to this tomcat (according to the\n     * local jvmRoute and the jvmRoute in the session id). If the session contains a\n     * different jvmRoute load if from memcached. If the session was found in memcached and\n     * if it's valid it must be associated with this tomcat and therefore the session id has to\n     * be changed. The new session id must be returned if it was changed.\n     * <p>\n     * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n     * always be returned.\n     * <\/p>\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session is taken over and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = _manager.getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( getSessionIdFormat().extractJvmRoute( requestedSessionId ) ) ) {\n\n            // the session might have been loaded already (by some valve), so let's check our session map\n            MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n            if ( session == null ) {\n                session = loadFromMemcachedWithCheck( requestedSessionId );\n            }\n\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    @Nonnull\n\tprivate SessionIdFormat getSessionIdFormat() {\n\t\treturn _memcachedNodesManager.getSessionIdFormat();\n\t}\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _memcachedNodesManager.changeSessionIdForTomcatFailover(session.getIdInternal(), _manager.getJvmRoute());\n\n        // If this session was already loaded we need to remove it from the session map\n        // See http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        if ( _manager.getSessionsInternal().containsKey( origSessionId ) ) {\n            _manager.getSessionsInternal().remove( origSessionId );\n        }\n\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session, true );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _memcachedNodesManager.isValidForMemcached( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( _memcachedNodesManager.getStorageKeyFormat().format(sessionId) ).get();\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * Check if the valid session associated with the provided\n     * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n     * and change the session id to the new one (containing the new memcached node). The\n     * new session id must be returned if the session will be relocated and the id was changed.\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session will be relocated and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n    \tif ( !_memcachedNodesManager.isEncodeNodeIdInSessionId() ) {\n    \t\treturn null;\n    \t}\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                \tfinal String newSessionId = _memcachedNodesManager.getNewSessionIdIfNodeFromSessionIdUnavailable( session.getId() );\n                    if ( newSessionId != null ) {\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            } else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _memcachedNodesManager.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                _log.info( \"Session needs to be relocated as node \"+ nodeId +\" is not available, loading backup session for \" + requestedSessionId );\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    _log.debug( \"Loaded backup session for \" + requestedSessionId + \", adding locally with \"+ backupSession.getIdInternal() +\".\" );\n                    addValidLoadedSession( backupSession, true );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final RuntimeException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n        if ( nodeId == null ) {\n            _log.info( \"Cannot load backupSession for sessionId without nodeId: \"+ requestedSessionId );\n            return null;\n        }\n\n        final String newNodeId = _memcachedNodesManager.getNextAvailableNodeId(nodeId);\n        if ( newNodeId == null ) {\n            _log.info( \"No next available node found for nodeId \"+ nodeId );\n            return null;\n        }\n\n        MemcachedBackupSession result = loadBackupSession(requestedSessionId, newNodeId);\n        String nextNodeId = nodeId;\n        // if we didn't find the backup in the next node, let's go through other nodes\n        // to see if the backup is there. For this we have to fake the session id so that\n        // the SuffixBasedNodeLocator selects another backup node.\n        while(result == null\n                && (nextNodeId = _memcachedNodesManager.getNextAvailableNodeId(nextNodeId)) != null\n                && !nextNodeId.equals(nodeId)) {\n            final String newSessionId = getSessionIdFormat().createNewSessionId(requestedSessionId, nextNodeId);\n            result = loadBackupSession(newSessionId, newNodeId);\n        }\n\n        if ( result == null ) {\n            _log.info( \"No backup found for sessionId \" + requestedSessionId );\n            return null;\n        }\n\n        return result;\n    }\n\n    private MemcachedBackupSession loadBackupSession(final String requestedSessionId, final String newNodeId) {\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( getSessionIdFormat().createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, _manager );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n            final String newSessionId = getSessionIdFormat().createNewSessionId( requestedSessionId, newNodeId );\n            _log.info( \"Session backup loaded from secondary memcached for \"+ requestedSessionId +\" (will be relocated),\" +\n            \t\t\" setting new id \"+ newSessionId +\" on session...\" );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n            return null;\n        }\n    }\n\n    /**\n     * Is invoked for requests matching {@link #setRequestUriIgnorePattern(String)} at the end\n     * of the request. Any acquired resources should be freed.\n     * @param sessionId the sessionId, must not be null.\n     * @param requestId the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     */\n    public void requestFinished(final String sessionId, final String requestId) {\n        if(!_sticky) {\n            final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n            if ( msmSession == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No session found in session map for \" + sessionId );\n                return;\n            }\n\n            if ( !msmSession.isValidInternal() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"Non valid session found in session map for \" + sessionId );\n                return;\n            }\n\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return;\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n\n            if(msmSession.isLocked()) {\n                _lockingStrategy.releaseLock(sessionId);\n                msmSession.releaseLock();\n                _lockingStrategy.registerReadonlyRequest(requestId);\n            }\n\n        }\n    }\n\n    /**\n     * Backup the session for the provided session id in memcached if the session was modified or\n     * if the session needs to be relocated. In non-sticky session-mode the session should not be\n     * loaded from memcached for just storing it again but only metadata should be updated.\n     *\n     * @param sessionId\n     *            the if of the session to backup\n     * @param sessionIdChanged\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri of the request for that the session backup shall be performed.\n     *\n     * @return a {@link Future} providing the {@link BackupResultStatus}.\n     */\n    public Future<BackupResult> backupSession( final String sessionId, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n        if ( msmSession == null ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"No session found in session map for \" + sessionId );\n            if ( !_sticky ) {\n                // Issue 116/137: Only notify the lockingStrategy if the session was loaded and has not been removed/invalidated\n                if(!_invalidSessionsCache.containsKey(sessionId)) {\n                    _lockingStrategy.onBackupWithoutLoadedSession( sessionId, requestId, _backupSessionService );\n                }\n            }\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !msmSession.isValidInternal() ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"Non valid session found in session map for \" + sessionId );\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !_sticky ) {\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= msmSession.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) || _invalidSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId can access memcached.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _memcachedNodesManager.canHitMemcached( sessionId );\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n        }\n\n        LockStatus lockStatus = null;\n        try {\n\n            if ( !_sticky ) {\n                lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n            }\n\n            final long start = System.currentTimeMillis();\n\n            /* In the previous version (<1.2) the session was completely serialized by\n             * custom Transcoder implementations.\n             * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n             * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n             * specializations.\n             */\n            final Object object = _memcached.get( _memcachedNodesManager.getStorageKeyFormat().format( sessionId ) );\n            _memcachedNodesManager.onLoadFromMemcachedSuccess( sessionId );\n\n            if ( object != null ) {\n                if ( !(object instanceof byte[]) ) {\n                    throw new RuntimeException( \"The loaded object for sessionId \" + sessionId + \" is not of required type byte[], but \" + object.getClass().getName() );\n                }\n                final long startDeserialization = System.currentTimeMillis();\n                final MemcachedBackupSession result = _transcoderService.deserialize( (byte[]) object, _manager );\n                _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                result.setSticky( _sticky );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                }\n\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Found session with id \" + sessionId );\n                }\n                return result;\n            }\n            else {\n                releaseIfLocked( sessionId, lockStatus );\n                _invalidSessionsCache.put( sessionId, Boolean.TRUE );\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                }\n                return null;\n            }\n        } catch ( final TranscoderDeserializationException e ) {\n            _log.warn( \"Could not deserialize session with id \" + sessionId + \" from memcached, session will be purged from storage.\", e );\n            releaseIfLocked( sessionId, lockStatus );\n            _memcached.delete( _memcachedNodesManager.getStorageKeyFormat().format(sessionId) );\n            _invalidSessionsCache.put( sessionId, Boolean.TRUE );\n        } catch ( final Exception e ) {\n            _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            releaseIfLocked( sessionId, lockStatus );\n        } finally {\n        }\n        return null;\n    }\n\n    protected void releaseIfLocked( final String sessionId, final LockStatus lockStatus ) {\n        if ( lockStatus == LockStatus.LOCKED ) {\n            _lockingStrategy.releaseLock( sessionId );\n        }\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + memcachedNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedNodesManager reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( memcachedNodesManager, _statistics );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, memcachedNodesManager, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _memcachedNodesManager = memcachedNodesManager;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( memcachedNodesManager );\n\n        return memcachedNodesManager;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + failoverNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * Return the compiled pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributePattern\n     */\n    @CheckForNull\n    Pattern getSessionAttributePattern() {\n        return _sessionAttributePattern;\n    }\n\n    /**\n     * Return the string pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributeFilter\n     */\n    @CheckForNull\n    public String getSessionAttributeFilter() {\n        return _sessionAttributeFilter;\n    }\n\n    /**\n     * Set the pattern used for including session attributes to a session-backup.\n     * If not set, all session attributes will be part of the session-backup.\n     * <p>\n     * E.g. <code>^(userName|sessionHistory)$<\/code>\n     * <\/p>\n     *\n     * @param sessionAttributeFilter\n     *            the sessionAttributeNames to set\n     */\n    public void setSessionAttributeFilter( @Nullable final String sessionAttributeFilter ) {\n        if ( sessionAttributeFilter == null || sessionAttributeFilter.trim().equals(\"\") ) {\n            _sessionAttributeFilter = null;\n            _sessionAttributePattern = null;\n        }\n        else {\n            _sessionAttributeFilter = sessionAttributeFilter;\n            _sessionAttributePattern = Pattern.compile( sessionAttributeFilter );\n        }\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && _manager.isInitialized() ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && _manager.isInitialized() ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && _manager.getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + _manager.getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( @Nullable final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode != null && lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( _manager.isInitialized() ) {\n            initNonStickyLockingMode( createMemcachedNodesManager( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n\tprivate void initNonStickyLockingMode( @Nonnull final MemcachedNodesManager config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        if ( _sessionAttributeFilter != null ) {\n            _log.warn( \"There's a sessionAttributesFilter configured ('\" + _sessionAttributeFilter + \"'),\" +\n                    \" all other session attributes will be lost after the request due to non-sticky configuration!\" );\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1 && !config.isCouchbaseBucketConfig();\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _memcachedNodesManager,\n                _invalidSessionsCache, storeSecondaryBackup, _statistics, _currentRequest );\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = _manager.findSessions();\n            final int delay = _manager.getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMaxInactiveInterval() > 0 // for <= 0 the session was stored in memcached with expiration 0\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && _manager.isInitialized() ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout from {@link #getSessionBackupTimeout()} is\n     * evaluated.\n     */\n    public boolean isSessionBackupAsync() {\n        return _sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed when {@link #getSessionBackupAsync()}) is <code>false<\/code>.\n     */\n    public long getSessionBackupTimeout() {\n        return _sessionBackupTimeout;\n    }\n\n    public Statistics getStatistics() {\n        return _statistics;\n    }\n\n\tpublic long getOperationTimeout() {\n\t\treturn _operationTimeout;\n\t}\n\n\tpublic void setOperationTimeout(final long operationTimeout ) {\n\t\t_operationTimeout = operationTimeout;\n\t}\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n    }\n\n    /**\n     * Return the memcached nodes manager.\n     */\n    @Nonnull\n    MemcachedNodesManager getMemcachedNodesManager() {\n        return _memcachedNodesManager;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _memcachedNodesManager.getPrimaryNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _memcachedNodesManager.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    public MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    void setMemcachedClient(final MemcachedClient memcachedClient) {\n        _memcached = memcachedClient;\n    }\n\n    RequestTrackingHostValve getTrackingHostValve() {\n        return _trackingHostValve;\n    }\n\n    /**\n     * The currently set locking strategy.\n     */\n    @Nullable\n    LockingStrategy getLockingStrategy() {\n        return _lockingStrategy;\n    }\n\n    public void setUsername(final String username) {\n        _username = username;\n    }\n\n    /**\n     * username required for SASL Connection types\n     * @return\n     */\n    public String getUsername() {\n        return _username;\n    }\n\n    public void setPassword(final String password) {\n       _password = password;\n    }\n\n    /**\n     * password required for SASL Connection types\n     * @return\n     */\n    public String getPassword() {\n        return _password;\n    }\n\n    public String getStorageKeyPrefix() {\n        return _storageKeyPrefix;\n    }\n\n    /**\n     * Configure the storage key prefix, this is prepended to the session id in e.g. memcached.\n     *\n     * The configuration has the form <code>$token,$token<\/code>\n     *\n     * Some examples which config would create which output for the key / session id \"foo\" with context path \"ctxt\",\n     * host \"hst\" and webappVersion \"001\" (webappVersion as specified for parallel deployment):\n     * <dl>\n     * <dt>static:x<\/dt><dd>x_foo<\/dd>\n     * <dt>host<\/dt><dd>hst_foo<\/dd>\n     * <dt>host.hash<\/dt><dd>e93c085e_foo<\/dd>\n     * <dt>context<\/dt><dd>ctxt_foo<\/dd>\n     * <dt>context.hash<\/dt><dd>45e6345f_foo<\/dd>\n     * <dt>host,context<\/dt><dd>hst:ctxt_foo<\/dd>\n     * <dt>webappVersion<\/dt><dd>001_foo<\/dd>\n     * <dt>host.hash,context.hash,webappVersion<\/dt><dd>e93c085e:45e6345f:001_foo<\/dd>\n     * <\/dl>\n     *\n     * @param storageKeyPrefix\n     */\n    public void setStorageKeyPrefix(final String storageKeyPrefix) {\n        _storageKeyPrefix = storageKeyPrefix;\n    }\n\n}\n","lineNo":432}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.DELETE_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.LOAD_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.SESSION_DESERIALIZATION;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.BinaryConnectionFactory;\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.ConnectionFactoryBuilder;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.auth.AuthDescriptor;\nimport net.spy.memcached.auth.PlainCallbackHandler;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport com.couchbase.client.CouchbaseClient;\nimport com.couchbase.client.CouchbaseConnectionFactoryBuilder;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport net.spy.memcached.FailureMode;\n\n/**\n * This is the core of memcached session manager, managing sessions in memcached.\n * A {@link SessionManager} interface represents the dependency to tomcats session manager\n * (which normally keeps sessions in memory). This {@link SessionManager} has to be subclassed\n * for a concrete major tomcat version (e.g. for 7.x.x) and configured in the context.xml\n * as manager (see <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SetupAndConfiguration\">SetupAndConfiguration<\/a>)\n * for more. The {@link SessionManager} then has to pass configuration settings to this\n * {@link MemcachedSessionService}. Relevant lifecycle methods are {@link #startInternal()}\n * and {@link #shutdown()}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class MemcachedSessionService {\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    static class ConnectionType {\n\n        private final boolean couchbaseBucketConfig;\n        private final String username;\n        private final String password;\n        public ConnectionType(final boolean couchbaseBucketConfig, final String username, final String password) {\n            this.couchbaseBucketConfig = couchbaseBucketConfig;\n            this.username = username;\n            this.password = password;\n        }\n        public static ConnectionType valueOf(final boolean couchbaseBucketConfig, final String username, final String password) {\n            return new ConnectionType(couchbaseBucketConfig, username, password);\n        }\n        boolean isCouchbaseBucketConfig() {\n            return couchbaseBucketConfig;\n        }\n        boolean isSASL() {\n            return !couchbaseBucketConfig && !isBlank(username) && !isBlank(password);\n        }\n        boolean isDefault() {\n            return !isCouchbaseBucketConfig() && !isSASL();\n        }\n\n        boolean isBlank(final String value) {\n            return value == null || value.trim().length() == 0;\n        }\n    }\n\n    public static final String PROTOCOL_TEXT = \"text\";\n    public static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n    /**\n     * Used to store the id for a new session in a request note. This is needed\n     * for a context configured with cookie=\"false\" as in this case there's no\n     * set-cookie header with the session id. When the request came in with a\n     * requestedSessionId this will be changed in the case of a tomcat/memcached\n     * failover (via request.changeSessionId, called by the contextValve) so in\n     * this case we don't need to note the new/changed session id.\n     */\n    protected static final String NEW_SESSION_ID = \"msm.session.id\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * The pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private String _sessionAttributeFilter = null;\n\n    /**\n     * The compiled pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private Pattern _sessionAttributePattern = null;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private String _username;\n    private String _password;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n\tprivate MemcachedNodesManager _memcachedNodesManager;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n    private long _operationTimeout = 1000;\n\n    private CurrentRequest _currentRequest;\n    private RequestTrackingHostValve _trackingHostValve;\n    private RequestTrackingContextValve _trackingContextValve;\n\n    private Boolean _contextHasFormBasedSecurityConstraint;\n\n    private final SessionManager _manager;\n\tprivate final MemcachedClientCallback _memcachedClientCallback = createMemcachedClientCallback();\n\n    private final LRUCache<String, Object> _removedSessions = new LRUCache<String, Object>( 2000, 5000 );\n\n    public MemcachedSessionService( final SessionManager manager ) {\n        _manager = manager;\n    }\n\n    /**\n     * Returns the tomcat session manager.\n     * @return the session manager\n     */\n    @Nonnull\n    public SessionManager getManager() {\n        return _manager;\n    }\n\n    public static interface SessionManager extends Manager {\n\n        /**\n         * Must return the configured session cookie name.\n         * @return the session cookie name.\n         */\n        @Nonnull\n        String getSessionCookieName();\n\n        String generateSessionId();\n        void expireSession( final String sessionId );\n        MemcachedBackupSession getSessionInternal( String sessionId );\n        Map<String, Session> getSessionsInternal();\n\n        String getJvmRoute();\n\n        /**\n          * Get a string from the underlying resource bundle or return\n          * null if the String is not found.\n          * @param key to desired resource String\n          * @return resource String matching <i>key<\/i> from underlying\n          *         bundle or null if not found.\n          * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(String key);\n\n        /**\n         * Get a string from the underlying resource bundle and format\n         * it with the given set of arguments.\n         *\n         * @param key to desired resource String\n         * @param args args for placeholders in the string\n         * @return resource String matching <i>key<\/i> from underlying\n         *         bundle or null if not found.\n         * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(final String key, final Object... args);\n\n        int getMaxActiveSessions();\n        void incrementSessionCounter();\n        void incrementRejectedSessions();\n\n        /**\n         * Remove this Session from the active Sessions for this Manager without\n         * removing it from memcached.\n         *\n         * @param session   Session to be removed\n         * @param update    Should the expiration statistics be updated (since tomcat7)\n         */\n        void removeInternal( final Session session, final boolean update );\n\n        /**\n         * Must return the initialized status. Must return <code>true<\/code> if this manager\n         * has already been started.\n         * @return the initialized status\n         */\n        boolean isInitialized();\n\n        @Nonnull\n        MemcachedSessionService getMemcachedSessionService();\n\n        /**\n         * Return the Container with which this Manager is associated.\n         */\n        @Override\n        @Nonnull\n        Container getContainer();\n\n        /**\n         * Reads the Principal from the given OIS.\n         * @param ois the object input stream to read from. Will be closed by the caller.\n         * @return the deserialized principal\n         * @throws ClassNotFoundException expected to be declared by the implementation.\n         * @throws IOException expected to be declared by the implementation.\n         */\n        @Nonnull\n        Principal readPrincipal( @Nonnull ObjectInputStream ois ) throws ClassNotFoundException, IOException;\n\n        // --------------------- setters for testing\n        /**\n         * Sets the sticky mode, must be provided for tests at least.\n         * @param sticky the stickyness.\n         */\n        void setSticky( boolean sticky );\n        void setEnabled( boolean b );\n        void setOperationTimeout(long operationTimeout);\n\n        /**\n         * Set the manager checks frequency in seconds.\n         * @param processExpiresFrequency the new manager checks frequency\n         */\n        void setProcessExpiresFrequency( int processExpiresFrequency );\n        void setMemcachedNodes( @Nonnull String memcachedNodes );\n        void setFailoverNodes( String failoverNodes );\n        void setLockingMode( @Nullable final String lockingMode );\n        void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup );\n        void setUsername(String username);\n        void setPassword(String password);\n\n        /**\n         * Creates a new instance of {@link MemcachedBackupSession} (needed so that it's possible to\n         * create specialized {@link MemcachedBackupSession} instances).\n         */\n        @Nonnull\n        MemcachedBackupSession newMemcachedBackupSession();\n    }\n\n    public void shutdown() {\n        _log.info( \"Stopping services.\" );\n        _manager.getContainer().getParent().getPipeline().removeValve(_trackingHostValve);\n        _manager.getContainer().getPipeline().removeValve(_trackingContextValve);\n        _backupSessionService.shutdown();\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.shutdown();\n        }\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n            _memcached = null;\n        }\n        _transcoderFactory = null;\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _memcached = memcachedClient;\n        startInternal();\n    }\n\n    /**\n     * Initialize this manager.\n     */\n    void startInternal() throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        _memcachedNodesManager = createMemcachedNodesManager( _memcachedNodes, _failoverNodes);\n\n        if(_memcached == null) {\n            _memcached = createMemcachedClient( _memcachedNodesManager, _statistics );\n        }\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        final String sessionCookieName = _manager.getSessionCookieName();\n        _currentRequest = new CurrentRequest();\n        _trackingHostValve = new RequestTrackingHostValve(_requestUriIgnorePattern, sessionCookieName, this, _statistics, _enabled, _currentRequest);\n        _manager.getContainer().getParent().getPipeline().addValve(_trackingHostValve);\n        _trackingContextValve = new RequestTrackingContextValve(sessionCookieName, this);\n        _manager.getContainer().getPipeline().addValve( _trackingContextValve );\n\n        initNonStickyLockingMode( _memcachedNodesManager );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, sticky \"+ _sticky + \", operation timeout \" + _operationTimeout +\", with node ids \" +\n        \t\t_memcachedNodesManager.getPrimaryNodeIds() + \" and failover node ids \" + _memcachedNodesManager.getFailoverNodeIds() );\n\n    }\n\n\tprotected MemcachedClientCallback createMemcachedClientCallback() {\n\t\treturn new MemcachedClientCallback() {\n\t\t\t@Override\n\t\t\tpublic Object get(final String key) {\n\t\t\t\treturn _memcached.get(key);\n\t\t\t}\n\t\t};\n\t}\n\n    protected MemcachedNodesManager createMemcachedNodesManager(final String memcachedNodes, final String failoverNodes) {\n\t\treturn MemcachedNodesManager.createFor( memcachedNodes, failoverNodes, _memcachedClientCallback );\n\t}\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( _manager ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final MemcachedNodesManager memcachedNodesManager,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionType connectionType = ConnectionType.valueOf(memcachedNodesManager.isCouchbaseBucketConfig(), _username, _password);\n            if (connectionType.isCouchbaseBucketConfig()) {\n            \t// For membase connectivity: http://docs.couchbase.org/membase-sdk-java-api-reference/membase-sdk-java-started.html\n            \t// And: http://code.google.com/p/spymemcached/wiki/Examples#Establishing_a_Membase_Connection\n                final CouchbaseConnectionFactoryBuilder factory = new CouchbaseConnectionFactoryBuilder();\n                factory.setOpTimeout(_operationTimeout);\n                factory.setFailureMode(FailureMode.Redistribute);\n                return new CouchbaseClient(factory.buildCouchbaseConnection(memcachedNodesManager.getCouchbaseBucketURIs(), _username, _password));\n            }\n            final ConnectionFactory connectionFactory = createConnectionFactory(memcachedNodesManager, connectionType, statistics);\n            return new MemcachedClient(connectionFactory, memcachedNodesManager.getAllMemcachedAddresses());\n        } catch (final Exception e) {\n            throw new RuntimeException(\"Could not create memcached client\", e);\n        }\n    }\n\n    protected ConnectionFactory createConnectionFactory(final MemcachedNodesManager memcachedNodesManager,\n            final ConnectionType connectionType, final Statistics statistics ) {\n        if (PROTOCOL_BINARY.equals( _memcachedProtocol )) {\n            if (connectionType.isSASL()) {\n                final AuthDescriptor authDescriptor = new AuthDescriptor(new String[]{\"PLAIN\"}, new PlainCallbackHandler(_username, _password));\n                return memcachedNodesManager.isEncodeNodeIdInSessionId()\n                        ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                                memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout,\n                                authDescriptor)\n                        : new ConnectionFactoryBuilder().setProtocol(ConnectionFactoryBuilder.Protocol.BINARY)\n                                .setAuthDescriptor(authDescriptor)\n                                .setOpTimeout(_operationTimeout).build();\n            }\n            else {\n                return memcachedNodesManager.isEncodeNodeIdInSessionId() ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                        memcachedNodesManager.getSessionIdFormat(),\n                        statistics, _operationTimeout ) : new BinaryConnectionFactory();\n            }\n        }\n        return memcachedNodesManager.isEncodeNodeIdInSessionId()\n        \t\t? new SuffixLocatorConnectionFactory( memcachedNodesManager, memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout )\n        \t\t: new DefaultConnectionFactory();\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = _manager.getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String newSessionId( @Nonnull final String sessionId ) {\n        return _memcachedNodesManager.createSessionId( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    public MemcachedBackupSession findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = _manager.getSessionInternal( id );\n        if ( result != null ) {\n            // TODO: document ignoring requests and container managed authentication\n            // -> with container managed auth protected resources should not be ignored\n            // TODO: check ignored resource also below\n            if (!_sticky && !_trackingHostValve.isIgnoredRequest() && !isContainerSessionLookup()) {\n                result.registerReference();\n            }\n        }\n        else if ( canHitMemcached( id ) && _missingSessionsCache.get( id ) == null ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            // or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based\n            // constraint needs the session to get the authenticated principal)\n            if ( !_sticky && isContainerSessionLookup()\n                    && !contextHasFormBasedSecurityConstraint() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // If no current request is set (RequestTrackerHostValve was not passed) we got invoked\n            // by CoyoteAdapter.parseSessionCookiesId - here we can just return null, the requestedSessionId\n            // will be accepted anyway\n            if(!_sticky && _currentRequest.get() == null) {\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                if(!_sticky) {\n                    // synchronized to have correct refcounts\n                    synchronized (_manager.getSessionsInternal()) {\n                        // in the meantime another request might have loaded and added the session,\n                        // and we must ensure to have a single session instance per id to have\n                        // correct refcounts (otherwise a session might be removed from the map at\n                        // the end of #backupSession\n                        if(_manager.getSessionInternal(id) != null) {\n                            result = _manager.getSessionInternal(id);\n                        }\n                        else {\n                            addValidLoadedSession(result);\n                        }\n                        result.registerReference();\n                        // _log.info(\"Registering reference, isContainerSessionLookup(): \" + isContainerSessionLookup(), new RuntimeException(\"foo\"));\n                    }\n                }\n                else {\n                    addValidLoadedSession(result);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    private boolean isContainerSessionLookup() {\n        return !_trackingContextValve.wasInvokedWith(_currentRequest.get());\n    }\n\n    private void addValidLoadedSession(final MemcachedBackupSession result) {\n        // When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver\n        // (due to a tomcat failover) we don't want to notify listeners via session.activate for the\n        // old sessionId but do that later (in handleSessionTakeOver)\n        // See also http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        String jvmRoute;\n        final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null\n            && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( result.getId() ) );\n\n        final boolean activate = !sessionIdWillBeChanged;\n        addValidLoadedSession( result, activate );\n    }\n\n    private boolean contextHasFormBasedSecurityConstraint() {\n        if(_contextHasFormBasedSecurityConstraint != null) {\n            return _contextHasFormBasedSecurityConstraint.booleanValue();\n        }\n        final Context context = (Context)_manager.getContainer();\n        final SecurityConstraint[] constraints = context.findConstraints();\n        final LoginConfig loginConfig = context.getLoginConfig();\n        _contextHasFormBasedSecurityConstraint = constraints != null && constraints.length > 0\n                && loginConfig != null && Constants.FORM_METHOD.equals( loginConfig.getAuthMethod() );\n        return _contextHasFormBasedSecurityConstraint;\n    }\n\n    private void addValidLoadedSession( final StandardSession session, final boolean activate ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        _manager.add( session );\n        if ( activate ) {\n            session.activate();\n        }\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        final MemcachedBackupSession session = createEmptySession();\n        session.setNew( true );\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() );\n\n        if ( sessionId == null || !_memcachedNodesManager.canHitMemcached( sessionId ) ) {\n            sessionId = _manager.generateSessionId();\n        }\n\n        session.setId( sessionId );\n\n        final Request request = _currentRequest.get();\n        if(request != null) {\n            request.setNote(NEW_SESSION_ID, sessionId);\n        }\n\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Created new session with id \" + session.getId() );\n        }\n\n        _manager.incrementSessionCounter();\n\n        return session;\n\n    }\n\n    /**\n     * Is invoked when a session was removed from the manager, e.g. because the\n     * session has been invalidated.\n     *\n     * Is used to release a lock if the non-stick session was locked\n     *\n     * It's also used to keep track of such sessions in non-sticky mode, so that\n     * lockingStrategy.onBackupWithoutLoadedSession is not invoked (see issue 116).\n     *\n     * @param session the removed session.\n     */\n    public void sessionRemoved(final MemcachedBackupSession session) {\n        if(!_sticky) {\n            if(session.isLocked()) {\n                _lockingStrategy.releaseLock(session.getIdInternal());\n                session.releaseLock();\n            }\n            _removedSessions.put(session.getIdInternal(), \"unused\");\n        }\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _manager.getMaxActiveSessions() >= 0 && _manager.getSessionsInternal().size() >= _manager.getMaxActiveSessions() ) {\n            _manager.incrementRejectedSessions();\n            throw new IllegalStateException\n                (_manager.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = _manager.newMemcachedBackupSession();\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    /**\n     * Check if the given session id does not belong to this tomcat (according to the\n     * local jvmRoute and the jvmRoute in the session id). If the session contains a\n     * different jvmRoute load if from memcached. If the session was found in memcached and\n     * if it's valid it must be associated with this tomcat and therefore the session id has to\n     * be changed. The new session id must be returned if it was changed.\n     * <p>\n     * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n     * always be returned.\n     * <\/p>\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session is taken over and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = _manager.getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( getSessionIdFormat().extractJvmRoute( requestedSessionId ) ) ) {\n\n            // the session might have been loaded already (by some valve), so let's check our session map\n            MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n            if ( session == null ) {\n                session = loadFromMemcachedWithCheck( requestedSessionId );\n            }\n\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    @Nonnull\n\tprivate SessionIdFormat getSessionIdFormat() {\n\t\treturn _memcachedNodesManager.getSessionIdFormat();\n\t}\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = getSessionIdFormat().changeJvmRoute( session.getIdInternal(), _manager.getJvmRoute() );\n\n        // If this session was already loaded we need to remove it from the session map\n        // See http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        if ( _manager.getSessionsInternal().containsKey( origSessionId ) ) {\n            _manager.getSessionsInternal().remove( origSessionId );\n        }\n\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session, true );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _memcachedNodesManager.isValidForMemcached( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId ).get();\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * Check if the valid session associated with the provided\n     * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n     * and change the session id to the new one (containing the new memcached node). The\n     * new session id must be returned if the session will be relocated and the id was changed.\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session will be relocated and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n    \tif ( !_memcachedNodesManager.isEncodeNodeIdInSessionId() ) {\n    \t\treturn null;\n    \t}\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                \tfinal String newSessionId = _memcachedNodesManager.getNewSessionIdIfNodeFromSessionIdUnavailable( session.getId() );\n                    if ( newSessionId != null ) {\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            } else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _memcachedNodesManager.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                _log.info( \"Session needs to be relocated as node \"+ nodeId +\" is not available, loading backup session for \" + requestedSessionId );\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    _log.debug( \"Loaded backup session for \" + requestedSessionId + \", adding locally with \"+ backupSession.getIdInternal() +\".\" );\n                    addValidLoadedSession( backupSession, true );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final RuntimeException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n        if ( nodeId == null ) {\n            _log.info( \"Cannot load backupSession for sessionId without nodeId: \"+ requestedSessionId );\n            return null;\n        }\n\n        final String newNodeId = _memcachedNodesManager.getNextAvailableNodeId(nodeId);\n        if ( newNodeId == null ) {\n            _log.info( \"No next available node found for nodeId \"+ nodeId );\n            return null;\n        }\n\n        MemcachedBackupSession result = loadBackupSession(requestedSessionId, newNodeId);\n        String nextNodeId = nodeId;\n        // if we didn't find the backup in the next node, let's go through other nodes\n        // to see if the backup is there. For this we have to fake the session id so that\n        // the SuffixBasedNodeLocator selects another backup node.\n        while(result == null\n                && (nextNodeId = _memcachedNodesManager.getNextAvailableNodeId(nextNodeId)) != null\n                && !nextNodeId.equals(nodeId)) {\n            final String newSessionId = getSessionIdFormat().createNewSessionId(requestedSessionId, nextNodeId);\n            result = loadBackupSession(newSessionId, newNodeId);\n        }\n\n        if ( result == null ) {\n            _log.info( \"No backup found for sessionId \" + requestedSessionId );\n            return null;\n        }\n\n        return result;\n    }\n\n    private MemcachedBackupSession loadBackupSession(final String requestedSessionId, final String newNodeId) {\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( getSessionIdFormat().createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, _manager );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n            final String newSessionId = getSessionIdFormat().createNewSessionId( requestedSessionId, newNodeId );\n            _log.info( \"Session backup loaded from secondary memcached for \"+ requestedSessionId +\" (will be relocated),\" +\n            \t\t\" setting new id \"+ newSessionId +\" on session...\" );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n            return null;\n        }\n    }\n\n    /**\n     * Is invoked for requests matching {@link #setRequestUriIgnorePattern(String)} at the end\n     * of the request. Any acquired resources should be freed.\n     * @param sessionId the sessionId, must not be null.\n     * @param requestId the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     */\n    public void requestFinished(final String sessionId, final String requestId) {\n        if(!_sticky) {\n            final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n            if ( msmSession == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No session found in session map for \" + sessionId );\n                return;\n            }\n\n            if ( !msmSession.isValidInternal() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"Non valid session found in session map for \" + sessionId );\n                return;\n            }\n\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return;\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n\n            if(msmSession.isLocked()) {\n                _lockingStrategy.releaseLock(sessionId);\n                msmSession.releaseLock();\n                _lockingStrategy.registerReadonlyRequest(requestId);\n            }\n\n        }\n    }\n\n    /**\n     * Backup the session for the provided session id in memcached if the session was modified or\n     * if the session needs to be relocated. In non-sticky session-mode the session should not be\n     * loaded from memcached for just storing it again but only metadata should be updated.\n     *\n     * @param sessionId\n     *            the if of the session to backup\n     * @param sessionIdChanged\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri of the request for that the session backup shall be performed.\n     *\n     * @return a {@link Future} providing the {@link BackupResultStatus}.\n     */\n    public Future<BackupResult> backupSession( final String sessionId, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n        if ( msmSession == null ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"No session found in session map for \" + sessionId );\n            if ( !_sticky ) {\n                // Issue 116: Only notify the lockingStrategy if the session has not been removed/invalidated\n                if(_removedSessions.remove(sessionId) == null) {\n                    _lockingStrategy.onBackupWithoutLoadedSession( sessionId, requestId, _backupSessionService );\n                }\n            }\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !msmSession.isValidInternal() ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"Non valid session found in session map for \" + sessionId );\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !_sticky ) {\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= msmSession.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId can access memcached.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _memcachedNodesManager.canHitMemcached( sessionId );\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n        }\n\n        LockStatus lockStatus = null;\n        try {\n\n            if ( !_sticky ) {\n                lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n            }\n\n            final long start = System.currentTimeMillis();\n\n            /* In the previous version (<1.2) the session was completely serialized by\n             * custom Transcoder implementations.\n             * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n             * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n             * specializations.\n             */\n            final Object object = _memcached.get( sessionId );\n            _memcachedNodesManager.onLoadFromMemcachedSuccess( sessionId );\n\n            if ( object != null ) {\n                if ( !(object instanceof byte[]) ) {\n                    throw new RuntimeException( \"The loaded object for sessionId \" + sessionId + \" is not of required type byte[], but \" + object.getClass().getName() );\n                }\n                final long startDeserialization = System.currentTimeMillis();\n                final MemcachedBackupSession result = _transcoderService.deserialize( (byte[]) object, _manager );\n                _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                result.setSticky( _sticky );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                }\n\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Found session with id \" + sessionId );\n                }\n                return result;\n            }\n            else {\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n                _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                }\n                return null;\n            }\n\n        } catch ( final Exception e ) {\n            _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            if ( lockStatus == LockStatus.LOCKED ) {\n                _lockingStrategy.releaseLock( sessionId );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + memcachedNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedNodesManager reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( memcachedNodesManager, _statistics );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, memcachedNodesManager, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _memcachedNodesManager = memcachedNodesManager;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( memcachedNodesManager );\n\n        return memcachedNodesManager;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + failoverNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * Return the compiled pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributePattern\n     */\n    @CheckForNull\n    Pattern getSessionAttributePattern() {\n        return _sessionAttributePattern;\n    }\n\n    /**\n     * Return the string pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributeFilter\n     */\n    @CheckForNull\n    public String getSessionAttributeFilter() {\n        return _sessionAttributeFilter;\n    }\n\n    /**\n     * Set the pattern used for including session attributes to a session-backup.\n     * If not set, all session attributes will be part of the session-backup.\n     * <p>\n     * E.g. <code>^(userName|sessionHistory)$<\/code>\n     * <\/p>\n     *\n     * @param sessionAttributeFilter\n     *            the sessionAttributeNames to set\n     */\n    public void setSessionAttributeFilter( @Nullable final String sessionAttributeFilter ) {\n        if ( sessionAttributeFilter == null || sessionAttributeFilter.trim().equals(\"\") ) {\n            _sessionAttributeFilter = null;\n            _sessionAttributePattern = null;\n        }\n        else {\n            _sessionAttributeFilter = sessionAttributeFilter;\n            _sessionAttributePattern = Pattern.compile( sessionAttributeFilter );\n        }\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && _manager.isInitialized() ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && _manager.isInitialized() ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && _manager.getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + _manager.getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( @Nullable final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode != null && lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( _manager.isInitialized() ) {\n            initNonStickyLockingMode( createMemcachedNodesManager( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n\tprivate void initNonStickyLockingMode( @Nonnull final MemcachedNodesManager config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        if ( _sessionAttributeFilter != null ) {\n            _log.warn( \"There's a sessionAttributesFilter configured ('\" + _sessionAttributeFilter + \"'),\" +\n                    \" all other session attributes will be lost after the request due to non-sticky configuration!\" );\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1 && !config.isCouchbaseBucketConfig();\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _memcachedNodesManager,\n                _missingSessionsCache, storeSecondaryBackup, _statistics, _currentRequest );\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = _manager.findSessions();\n            final int delay = _manager.getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMaxInactiveInterval() > 0 // for <= 0 the session was stored in memcached with expiration 0\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && _manager.isInitialized() ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout from {@link #getSessionBackupTimeout()} is\n     * evaluated.\n     */\n    public boolean isSessionBackupAsync() {\n        return _sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed when {@link #getSessionBackupAsync()}) is <code>false<\/code>.\n     */\n    public long getSessionBackupTimeout() {\n        return _sessionBackupTimeout;\n    }\n\n    public Statistics getStatistics() {\n        return _statistics;\n    }\n\n\tpublic long getOperationTimeout() {\n\t\treturn _operationTimeout;\n\t}\n\n\tpublic void setOperationTimeout(final long operationTimeout ) {\n\t\t_operationTimeout = operationTimeout;\n\t}\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n    }\n\n    /**\n     * Return the memcached nodes manager.\n     */\n    @Nonnull\n    MemcachedNodesManager getMemcachedNodesManager() {\n        return _memcachedNodesManager;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _memcachedNodesManager.getPrimaryNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _memcachedNodesManager.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    public MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    void setMemcachedClient(final MemcachedClient memcachedClient) {\n        _memcached = memcachedClient;\n    }\n\n    RequestTrackingHostValve getTrackingHostValve() {\n        return _trackingHostValve;\n    }\n\n    /**\n     * The currently set locking strategy.\n     */\n    @Nullable\n    LockingStrategy getLockingStrategy() {\n        return _lockingStrategy;\n    }\n\n    public void setUsername(final String username) {\n        _username = username;\n    }\n\n    /**\n     * username required for SASL Connection types\n     * @return\n     */\n    public String getUsername() {\n        return _username;\n    }\n\n    public void setPassword(final String password) {\n       _password = password;\n    }\n\n    /**\n     * password required for SASL Connection types\n     * @return\n     */\n    public String getPassword() {\n        return _password;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.DELETE_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.LOAD_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.SESSION_DESERIALIZATION;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.BinaryConnectionFactory;\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.ConnectionFactoryBuilder;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.FailureMode;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.auth.AuthDescriptor;\nimport net.spy.memcached.auth.PlainCallbackHandler;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport com.couchbase.client.CouchbaseClient;\nimport com.couchbase.client.CouchbaseConnectionFactoryBuilder;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\n\n/**\n * This is the core of memcached session manager, managing sessions in memcached.\n * A {@link SessionManager} interface represents the dependency to tomcats session manager\n * (which normally keeps sessions in memory). This {@link SessionManager} has to be subclassed\n * for a concrete major tomcat version (e.g. for 7.x.x) and configured in the context.xml\n * as manager (see <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SetupAndConfiguration\">SetupAndConfiguration<\/a>)\n * for more. The {@link SessionManager} then has to pass configuration settings to this\n * {@link MemcachedSessionService}. Relevant lifecycle methods are {@link #startInternal()}\n * and {@link #shutdown()}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class MemcachedSessionService {\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    static class ConnectionType {\n\n        private final boolean couchbaseBucketConfig;\n        private final String username;\n        private final String password;\n        public ConnectionType(final boolean couchbaseBucketConfig, final String username, final String password) {\n            this.couchbaseBucketConfig = couchbaseBucketConfig;\n            this.username = username;\n            this.password = password;\n        }\n        public static ConnectionType valueOf(final boolean couchbaseBucketConfig, final String username, final String password) {\n            return new ConnectionType(couchbaseBucketConfig, username, password);\n        }\n        boolean isCouchbaseBucketConfig() {\n            return couchbaseBucketConfig;\n        }\n        boolean isSASL() {\n            return !couchbaseBucketConfig && !isBlank(username) && !isBlank(password);\n        }\n        boolean isDefault() {\n            return !isCouchbaseBucketConfig() && !isSASL();\n        }\n\n        boolean isBlank(final String value) {\n            return value == null || value.trim().length() == 0;\n        }\n    }\n\n    public static final String PROTOCOL_TEXT = \"text\";\n    public static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n    /**\n     * Used to store the id for a new session in a request note. This is needed\n     * for a context configured with cookie=\"false\" as in this case there's no\n     * set-cookie header with the session id. When the request came in with a\n     * requestedSessionId this will be changed in the case of a tomcat/memcached\n     * failover (via request.changeSessionId, called by the contextValve) so in\n     * this case we don't need to note the new/changed session id.\n     */\n    protected static final String NEW_SESSION_ID = \"msm.session.id\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * The pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private String _sessionAttributeFilter = null;\n\n    /**\n     * The compiled pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private Pattern _sessionAttributePattern = null;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private String _username;\n    private String _password;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n\tprivate MemcachedNodesManager _memcachedNodesManager;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n    private long _operationTimeout = 1000;\n\n    private CurrentRequest _currentRequest;\n    private RequestTrackingHostValve _trackingHostValve;\n    private RequestTrackingContextValve _trackingContextValve;\n\n    private Boolean _contextHasFormBasedSecurityConstraint;\n\n    private final SessionManager _manager;\n\tprivate final MemcachedClientCallback _memcachedClientCallback = createMemcachedClientCallback();\n\n    private final LRUCache<String, Object> _removedSessions = new LRUCache<String, Object>( 2000, 5000 );\n\n    public MemcachedSessionService( final SessionManager manager ) {\n        _manager = manager;\n    }\n\n    /**\n     * Returns the tomcat session manager.\n     * @return the session manager\n     */\n    @Nonnull\n    public SessionManager getManager() {\n        return _manager;\n    }\n\n    public static interface SessionManager extends Manager {\n\n        /**\n         * Must return the configured session cookie name.\n         * @return the session cookie name.\n         */\n        @Nonnull\n        String getSessionCookieName();\n\n        String generateSessionId();\n        void expireSession( final String sessionId );\n        MemcachedBackupSession getSessionInternal( String sessionId );\n        Map<String, Session> getSessionsInternal();\n\n        String getJvmRoute();\n\n        /**\n          * Get a string from the underlying resource bundle or return\n          * null if the String is not found.\n          * @param key to desired resource String\n          * @return resource String matching <i>key<\/i> from underlying\n          *         bundle or null if not found.\n          * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(String key);\n\n        /**\n         * Get a string from the underlying resource bundle and format\n         * it with the given set of arguments.\n         *\n         * @param key to desired resource String\n         * @param args args for placeholders in the string\n         * @return resource String matching <i>key<\/i> from underlying\n         *         bundle or null if not found.\n         * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(final String key, final Object... args);\n\n        int getMaxActiveSessions();\n        void incrementSessionCounter();\n        void incrementRejectedSessions();\n\n        /**\n         * Remove this Session from the active Sessions for this Manager without\n         * removing it from memcached.\n         *\n         * @param session   Session to be removed\n         * @param update    Should the expiration statistics be updated (since tomcat7)\n         */\n        void removeInternal( final Session session, final boolean update );\n\n        /**\n         * Must return the initialized status. Must return <code>true<\/code> if this manager\n         * has already been started.\n         * @return the initialized status\n         */\n        boolean isInitialized();\n\n        @Nonnull\n        MemcachedSessionService getMemcachedSessionService();\n\n        /**\n         * Return the Container with which this Manager is associated.\n         */\n        @Override\n        @Nonnull\n        Container getContainer();\n\n        /**\n         * Reads the Principal from the given OIS.\n         * @param ois the object input stream to read from. Will be closed by the caller.\n         * @return the deserialized principal\n         * @throws ClassNotFoundException expected to be declared by the implementation.\n         * @throws IOException expected to be declared by the implementation.\n         */\n        @Nonnull\n        Principal readPrincipal( @Nonnull ObjectInputStream ois ) throws ClassNotFoundException, IOException;\n\n        // --------------------- setters for testing\n        /**\n         * Sets the sticky mode, must be provided for tests at least.\n         * @param sticky the stickyness.\n         */\n        void setSticky( boolean sticky );\n        void setEnabled( boolean b );\n        void setOperationTimeout(long operationTimeout);\n\n        /**\n         * Set the manager checks frequency in seconds.\n         * @param processExpiresFrequency the new manager checks frequency\n         */\n        void setProcessExpiresFrequency( int processExpiresFrequency );\n        void setMemcachedNodes( @Nonnull String memcachedNodes );\n        void setFailoverNodes( String failoverNodes );\n        void setLockingMode( @Nullable final String lockingMode );\n        void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup );\n        void setUsername(String username);\n        void setPassword(String password);\n\n        /**\n         * Creates a new instance of {@link MemcachedBackupSession} (needed so that it's possible to\n         * create specialized {@link MemcachedBackupSession} instances).\n         */\n        @Nonnull\n        MemcachedBackupSession newMemcachedBackupSession();\n    }\n\n    public void shutdown() {\n        _log.info( \"Stopping services.\" );\n        _manager.getContainer().getParent().getPipeline().removeValve(_trackingHostValve);\n        _manager.getContainer().getPipeline().removeValve(_trackingContextValve);\n        _backupSessionService.shutdown();\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.shutdown();\n        }\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n            _memcached = null;\n        }\n        _transcoderFactory = null;\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _memcached = memcachedClient;\n        startInternal();\n    }\n\n    /**\n     * Initialize this manager.\n     */\n    void startInternal() throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        _memcachedNodesManager = createMemcachedNodesManager( _memcachedNodes, _failoverNodes);\n\n        if(_memcached == null) {\n            _memcached = createMemcachedClient( _memcachedNodesManager, _statistics );\n        }\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        final String sessionCookieName = _manager.getSessionCookieName();\n        _currentRequest = new CurrentRequest();\n        _trackingHostValve = new RequestTrackingHostValve(_requestUriIgnorePattern, sessionCookieName, this, _statistics, _enabled, _currentRequest);\n        _manager.getContainer().getParent().getPipeline().addValve(_trackingHostValve);\n        _trackingContextValve = new RequestTrackingContextValve(sessionCookieName, this);\n        _manager.getContainer().getPipeline().addValve( _trackingContextValve );\n\n        initNonStickyLockingMode( _memcachedNodesManager );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, sticky \"+ _sticky + \", operation timeout \" + _operationTimeout +\", with node ids \" +\n        \t\t_memcachedNodesManager.getPrimaryNodeIds() + \" and failover node ids \" + _memcachedNodesManager.getFailoverNodeIds() );\n\n    }\n\n\tprotected MemcachedClientCallback createMemcachedClientCallback() {\n\t\treturn new MemcachedClientCallback() {\n\t\t\t@Override\n\t\t\tpublic Object get(final String key) {\n\t\t\t\treturn _memcached.get(key);\n\t\t\t}\n\t\t};\n\t}\n\n    protected MemcachedNodesManager createMemcachedNodesManager(final String memcachedNodes, final String failoverNodes) {\n\t\treturn MemcachedNodesManager.createFor( memcachedNodes, failoverNodes, _memcachedClientCallback );\n\t}\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( _manager ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final MemcachedNodesManager memcachedNodesManager,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final String password = _password == null ? \"\" : _password;\n            final ConnectionType connectionType = ConnectionType.valueOf(memcachedNodesManager.isCouchbaseBucketConfig(), _username, password);\n            if (connectionType.isCouchbaseBucketConfig()) {\n            \t// For membase connectivity: http://docs.couchbase.org/membase-sdk-java-api-reference/membase-sdk-java-started.html\n            \t// And: http://code.google.com/p/spymemcached/wiki/Examples#Establishing_a_Membase_Connection\n                final CouchbaseConnectionFactoryBuilder factory = new CouchbaseConnectionFactoryBuilder();\n                factory.setOpTimeout(_operationTimeout);\n                factory.setFailureMode(FailureMode.Redistribute);\n                return new CouchbaseClient(factory.buildCouchbaseConnection(memcachedNodesManager.getCouchbaseBucketURIs(), _username, password));\n            }\n            final ConnectionFactory connectionFactory = createConnectionFactory(memcachedNodesManager, connectionType, statistics);\n            return new MemcachedClient(connectionFactory, memcachedNodesManager.getAllMemcachedAddresses());\n        } catch (final Exception e) {\n            throw new RuntimeException(\"Could not create memcached client\", e);\n        }\n    }\n\n    protected ConnectionFactory createConnectionFactory(final MemcachedNodesManager memcachedNodesManager,\n            final ConnectionType connectionType, final Statistics statistics ) {\n        if (PROTOCOL_BINARY.equals( _memcachedProtocol )) {\n            if (connectionType.isSASL()) {\n                final AuthDescriptor authDescriptor = new AuthDescriptor(new String[]{\"PLAIN\"},\n                        new PlainCallbackHandler(_username, _password == null ? \"\" : _password));\n                return memcachedNodesManager.isEncodeNodeIdInSessionId()\n                        ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                                memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout,\n                                authDescriptor)\n                        : new ConnectionFactoryBuilder().setProtocol(ConnectionFactoryBuilder.Protocol.BINARY)\n                                .setAuthDescriptor(authDescriptor)\n                                .setOpTimeout(_operationTimeout).build();\n            }\n            else {\n                return memcachedNodesManager.isEncodeNodeIdInSessionId() ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                        memcachedNodesManager.getSessionIdFormat(),\n                        statistics, _operationTimeout ) : new BinaryConnectionFactory();\n            }\n        }\n        return memcachedNodesManager.isEncodeNodeIdInSessionId()\n        \t\t? new SuffixLocatorConnectionFactory( memcachedNodesManager, memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout )\n        \t\t: new DefaultConnectionFactory();\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = _manager.getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String newSessionId( @Nonnull final String sessionId ) {\n        return _memcachedNodesManager.createSessionId( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    public MemcachedBackupSession findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = _manager.getSessionInternal( id );\n        if ( result != null ) {\n            // TODO: document ignoring requests and container managed authentication\n            // -> with container managed auth protected resources should not be ignored\n            // TODO: check ignored resource also below\n            if (!_sticky && !_trackingHostValve.isIgnoredRequest() && !isContainerSessionLookup()) {\n                result.registerReference();\n            }\n        }\n        else if ( canHitMemcached( id ) && _missingSessionsCache.get( id ) == null ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            // or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based\n            // constraint needs the session to get the authenticated principal)\n            if ( !_sticky && isContainerSessionLookup()\n                    && !contextHasFormBasedSecurityConstraint() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // If no current request is set (RequestTrackerHostValve was not passed) we got invoked\n            // by CoyoteAdapter.parseSessionCookiesId - here we can just return null, the requestedSessionId\n            // will be accepted anyway\n            if(!_sticky && _currentRequest.get() == null) {\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                if(!_sticky) {\n                    // synchronized to have correct refcounts\n                    synchronized (_manager.getSessionsInternal()) {\n                        // in the meantime another request might have loaded and added the session,\n                        // and we must ensure to have a single session instance per id to have\n                        // correct refcounts (otherwise a session might be removed from the map at\n                        // the end of #backupSession\n                        if(_manager.getSessionInternal(id) != null) {\n                            result = _manager.getSessionInternal(id);\n                        }\n                        else {\n                            addValidLoadedSession(result);\n                        }\n                        result.registerReference();\n                        // _log.info(\"Registering reference, isContainerSessionLookup(): \" + isContainerSessionLookup(), new RuntimeException(\"foo\"));\n                    }\n                }\n                else {\n                    addValidLoadedSession(result);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    private boolean isContainerSessionLookup() {\n        return !_trackingContextValve.wasInvokedWith(_currentRequest.get());\n    }\n\n    private void addValidLoadedSession(final MemcachedBackupSession result) {\n        // When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver\n        // (due to a tomcat failover) we don't want to notify listeners via session.activate for the\n        // old sessionId but do that later (in handleSessionTakeOver)\n        // See also http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        String jvmRoute;\n        final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null\n            && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( result.getId() ) );\n\n        final boolean activate = !sessionIdWillBeChanged;\n        addValidLoadedSession( result, activate );\n    }\n\n    private boolean contextHasFormBasedSecurityConstraint() {\n        if(_contextHasFormBasedSecurityConstraint != null) {\n            return _contextHasFormBasedSecurityConstraint.booleanValue();\n        }\n        final Context context = (Context)_manager.getContainer();\n        final SecurityConstraint[] constraints = context.findConstraints();\n        final LoginConfig loginConfig = context.getLoginConfig();\n        _contextHasFormBasedSecurityConstraint = constraints != null && constraints.length > 0\n                && loginConfig != null && Constants.FORM_METHOD.equals( loginConfig.getAuthMethod() );\n        return _contextHasFormBasedSecurityConstraint;\n    }\n\n    private void addValidLoadedSession( final StandardSession session, final boolean activate ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        _manager.add( session );\n        if ( activate ) {\n            session.activate();\n        }\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        final MemcachedBackupSession session = createEmptySession();\n        session.setNew( true );\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() );\n\n        if ( sessionId == null || !_memcachedNodesManager.canHitMemcached( sessionId ) ) {\n            sessionId = _manager.generateSessionId();\n        }\n\n        session.setId( sessionId );\n\n        final Request request = _currentRequest.get();\n        if(request != null) {\n            request.setNote(NEW_SESSION_ID, sessionId);\n        }\n\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Created new session with id \" + session.getId() );\n        }\n\n        _manager.incrementSessionCounter();\n\n        return session;\n\n    }\n\n    /**\n     * Is invoked when a session was removed from the manager, e.g. because the\n     * session has been invalidated.\n     *\n     * Is used to release a lock if the non-stick session was locked\n     *\n     * It's also used to keep track of such sessions in non-sticky mode, so that\n     * lockingStrategy.onBackupWithoutLoadedSession is not invoked (see issue 116).\n     *\n     * @param session the removed session.\n     */\n    public void sessionRemoved(final MemcachedBackupSession session) {\n        if(!_sticky) {\n            if(session.isLocked()) {\n                _lockingStrategy.releaseLock(session.getIdInternal());\n                session.releaseLock();\n            }\n            _removedSessions.put(session.getIdInternal(), \"unused\");\n        }\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _manager.getMaxActiveSessions() >= 0 && _manager.getSessionsInternal().size() >= _manager.getMaxActiveSessions() ) {\n            _manager.incrementRejectedSessions();\n            throw new IllegalStateException\n                (_manager.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = _manager.newMemcachedBackupSession();\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    /**\n     * Check if the given session id does not belong to this tomcat (according to the\n     * local jvmRoute and the jvmRoute in the session id). If the session contains a\n     * different jvmRoute load if from memcached. If the session was found in memcached and\n     * if it's valid it must be associated with this tomcat and therefore the session id has to\n     * be changed. The new session id must be returned if it was changed.\n     * <p>\n     * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n     * always be returned.\n     * <\/p>\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session is taken over and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = _manager.getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( getSessionIdFormat().extractJvmRoute( requestedSessionId ) ) ) {\n\n            // the session might have been loaded already (by some valve), so let's check our session map\n            MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n            if ( session == null ) {\n                session = loadFromMemcachedWithCheck( requestedSessionId );\n            }\n\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    @Nonnull\n\tprivate SessionIdFormat getSessionIdFormat() {\n\t\treturn _memcachedNodesManager.getSessionIdFormat();\n\t}\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = getSessionIdFormat().changeJvmRoute( session.getIdInternal(), _manager.getJvmRoute() );\n\n        // If this session was already loaded we need to remove it from the session map\n        // See http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        if ( _manager.getSessionsInternal().containsKey( origSessionId ) ) {\n            _manager.getSessionsInternal().remove( origSessionId );\n        }\n\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session, true );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _memcachedNodesManager.isValidForMemcached( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId ).get();\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * Check if the valid session associated with the provided\n     * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n     * and change the session id to the new one (containing the new memcached node). The\n     * new session id must be returned if the session will be relocated and the id was changed.\n     *\n     * @param requestedSessionId\n     *            the sessionId that was requested.\n     *\n     * @return the new session id if the session will be relocated and the id was changed.\n     *          Otherwise <code>null<\/code>.\n     *\n     * @see Request#getRequestedSessionId()\n     */\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n    \tif ( !_memcachedNodesManager.isEncodeNodeIdInSessionId() ) {\n    \t\treturn null;\n    \t}\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                \tfinal String newSessionId = _memcachedNodesManager.getNewSessionIdIfNodeFromSessionIdUnavailable( session.getId() );\n                    if ( newSessionId != null ) {\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            } else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _memcachedNodesManager.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                _log.info( \"Session needs to be relocated as node \"+ nodeId +\" is not available, loading backup session for \" + requestedSessionId );\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    _log.debug( \"Loaded backup session for \" + requestedSessionId + \", adding locally with \"+ backupSession.getIdInternal() +\".\" );\n                    addValidLoadedSession( backupSession, true );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final RuntimeException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n        if ( nodeId == null ) {\n            _log.info( \"Cannot load backupSession for sessionId without nodeId: \"+ requestedSessionId );\n            return null;\n        }\n\n        final String newNodeId = _memcachedNodesManager.getNextAvailableNodeId(nodeId);\n        if ( newNodeId == null ) {\n            _log.info( \"No next available node found for nodeId \"+ nodeId );\n            return null;\n        }\n\n        MemcachedBackupSession result = loadBackupSession(requestedSessionId, newNodeId);\n        String nextNodeId = nodeId;\n        // if we didn't find the backup in the next node, let's go through other nodes\n        // to see if the backup is there. For this we have to fake the session id so that\n        // the SuffixBasedNodeLocator selects another backup node.\n        while(result == null\n                && (nextNodeId = _memcachedNodesManager.getNextAvailableNodeId(nextNodeId)) != null\n                && !nextNodeId.equals(nodeId)) {\n            final String newSessionId = getSessionIdFormat().createNewSessionId(requestedSessionId, nextNodeId);\n            result = loadBackupSession(newSessionId, newNodeId);\n        }\n\n        if ( result == null ) {\n            _log.info( \"No backup found for sessionId \" + requestedSessionId );\n            return null;\n        }\n\n        return result;\n    }\n\n    private MemcachedBackupSession loadBackupSession(final String requestedSessionId, final String newNodeId) {\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( getSessionIdFormat().createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, _manager );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n            final String newSessionId = getSessionIdFormat().createNewSessionId( requestedSessionId, newNodeId );\n            _log.info( \"Session backup loaded from secondary memcached for \"+ requestedSessionId +\" (will be relocated),\" +\n            \t\t\" setting new id \"+ newSessionId +\" on session...\" );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n            return null;\n        }\n    }\n\n    /**\n     * Is invoked for requests matching {@link #setRequestUriIgnorePattern(String)} at the end\n     * of the request. Any acquired resources should be freed.\n     * @param sessionId the sessionId, must not be null.\n     * @param requestId the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     */\n    public void requestFinished(final String sessionId, final String requestId) {\n        if(!_sticky) {\n            final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n            if ( msmSession == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No session found in session map for \" + sessionId );\n                return;\n            }\n\n            if ( !msmSession.isValidInternal() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"Non valid session found in session map for \" + sessionId );\n                return;\n            }\n\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return;\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n\n            if(msmSession.isLocked()) {\n                _lockingStrategy.releaseLock(sessionId);\n                msmSession.releaseLock();\n                _lockingStrategy.registerReadonlyRequest(requestId);\n            }\n\n        }\n    }\n\n    /**\n     * Backup the session for the provided session id in memcached if the session was modified or\n     * if the session needs to be relocated. In non-sticky session-mode the session should not be\n     * loaded from memcached for just storing it again but only metadata should be updated.\n     *\n     * @param sessionId\n     *            the if of the session to backup\n     * @param sessionIdChanged\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri of the request for that the session backup shall be performed.\n     *\n     * @return a {@link Future} providing the {@link BackupResultStatus}.\n     */\n    public Future<BackupResult> backupSession( final String sessionId, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n        if ( msmSession == null ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"No session found in session map for \" + sessionId );\n            if ( !_sticky ) {\n                // Issue 116: Only notify the lockingStrategy if the session has not been removed/invalidated\n                if(_removedSessions.remove(sessionId) == null) {\n                    _lockingStrategy.onBackupWithoutLoadedSession( sessionId, requestId, _backupSessionService );\n                }\n            }\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !msmSession.isValidInternal() ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"Non valid session found in session map for \" + sessionId );\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !_sticky ) {\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= msmSession.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId can access memcached.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _memcachedNodesManager.canHitMemcached( sessionId );\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n        }\n\n        LockStatus lockStatus = null;\n        try {\n\n            if ( !_sticky ) {\n                lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n            }\n\n            final long start = System.currentTimeMillis();\n\n            /* In the previous version (<1.2) the session was completely serialized by\n             * custom Transcoder implementations.\n             * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n             * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n             * specializations.\n             */\n            final Object object = _memcached.get( sessionId );\n            _memcachedNodesManager.onLoadFromMemcachedSuccess( sessionId );\n\n            if ( object != null ) {\n                if ( !(object instanceof byte[]) ) {\n                    throw new RuntimeException( \"The loaded object for sessionId \" + sessionId + \" is not of required type byte[], but \" + object.getClass().getName() );\n                }\n                final long startDeserialization = System.currentTimeMillis();\n                final MemcachedBackupSession result = _transcoderService.deserialize( (byte[]) object, _manager );\n                _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                result.setSticky( _sticky );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                }\n\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Found session with id \" + sessionId );\n                }\n                return result;\n            }\n            else {\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n                _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                }\n                return null;\n            }\n\n        } catch ( final Exception e ) {\n            _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            if ( lockStatus == LockStatus.LOCKED ) {\n                _lockingStrategy.releaseLock( sessionId );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + memcachedNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedNodesManager reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( memcachedNodesManager, _statistics );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, memcachedNodesManager, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _memcachedNodesManager = memcachedNodesManager;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( memcachedNodesManager );\n\n        return memcachedNodesManager;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + failoverNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * Return the compiled pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributePattern\n     */\n    @CheckForNull\n    Pattern getSessionAttributePattern() {\n        return _sessionAttributePattern;\n    }\n\n    /**\n     * Return the string pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributeFilter\n     */\n    @CheckForNull\n    public String getSessionAttributeFilter() {\n        return _sessionAttributeFilter;\n    }\n\n    /**\n     * Set the pattern used for including session attributes to a session-backup.\n     * If not set, all session attributes will be part of the session-backup.\n     * <p>\n     * E.g. <code>^(userName|sessionHistory)$<\/code>\n     * <\/p>\n     *\n     * @param sessionAttributeFilter\n     *            the sessionAttributeNames to set\n     */\n    public void setSessionAttributeFilter( @Nullable final String sessionAttributeFilter ) {\n        if ( sessionAttributeFilter == null || sessionAttributeFilter.trim().equals(\"\") ) {\n            _sessionAttributeFilter = null;\n            _sessionAttributePattern = null;\n        }\n        else {\n            _sessionAttributeFilter = sessionAttributeFilter;\n            _sessionAttributePattern = Pattern.compile( sessionAttributeFilter );\n        }\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && _manager.isInitialized() ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && _manager.isInitialized() ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && _manager.getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + _manager.getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( @Nullable final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode != null && lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( _manager.isInitialized() ) {\n            initNonStickyLockingMode( createMemcachedNodesManager( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n\tprivate void initNonStickyLockingMode( @Nonnull final MemcachedNodesManager config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        if ( _sessionAttributeFilter != null ) {\n            _log.warn( \"There's a sessionAttributesFilter configured ('\" + _sessionAttributeFilter + \"'),\" +\n                    \" all other session attributes will be lost after the request due to non-sticky configuration!\" );\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1 && !config.isCouchbaseBucketConfig();\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _memcachedNodesManager,\n                _missingSessionsCache, storeSecondaryBackup, _statistics, _currentRequest );\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = _manager.findSessions();\n            final int delay = _manager.getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMaxInactiveInterval() > 0 // for <= 0 the session was stored in memcached with expiration 0\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && _manager.isInitialized() ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout from {@link #getSessionBackupTimeout()} is\n     * evaluated.\n     */\n    public boolean isSessionBackupAsync() {\n        return _sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed when {@link #getSessionBackupAsync()}) is <code>false<\/code>.\n     */\n    public long getSessionBackupTimeout() {\n        return _sessionBackupTimeout;\n    }\n\n    public Statistics getStatistics() {\n        return _statistics;\n    }\n\n\tpublic long getOperationTimeout() {\n\t\treturn _operationTimeout;\n\t}\n\n\tpublic void setOperationTimeout(final long operationTimeout ) {\n\t\t_operationTimeout = operationTimeout;\n\t}\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n    }\n\n    /**\n     * Return the memcached nodes manager.\n     */\n    @Nonnull\n    MemcachedNodesManager getMemcachedNodesManager() {\n        return _memcachedNodesManager;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _memcachedNodesManager.getPrimaryNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _memcachedNodesManager.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    public MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    void setMemcachedClient(final MemcachedClient memcachedClient) {\n        _memcached = memcachedClient;\n    }\n\n    RequestTrackingHostValve getTrackingHostValve() {\n        return _trackingHostValve;\n    }\n\n    /**\n     * The currently set locking strategy.\n     */\n    @Nullable\n    LockingStrategy getLockingStrategy() {\n        return _lockingStrategy;\n    }\n\n    public void setUsername(final String username) {\n        _username = username;\n    }\n\n    /**\n     * username required for SASL Connection types\n     * @return\n     */\n    public String getUsername() {\n        return _username;\n    }\n\n    public void setPassword(final String password) {\n       _password = password;\n    }\n\n    /**\n     * password required for SASL Connection types\n     * @return\n     */\n    public String getPassword() {\n        return _password;\n    }\n\n}\n","lineNo":498}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.valves.ValveBase;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\n/**\n * This valve is used for tracking requests for that the session must be sent to\n * memcached, on host level. This encapsulates/surrounds als container request\n * processing like e.g. authentication and ServletRequestListener notification.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class RequestTrackingHostValve extends ValveBase {\n\n    private static final String REQUEST_IGNORED = \"de.javakaffee.msm.request.ignored\";\n\n    public static final String REQUEST_PROCESS = \"de.javakaffee.msm.request.process\";\n\n    public static final String SESSION_ID_CHANGED = \"de.javakaffee.msm.sessionIdChanged\";\n\n    public static final String REQUEST_PROCESSED = \"de.javakaffee.msm.request.processed\";\n\n    static final String RELOCATE = \"session.relocate\";\n\n    protected static final Log _log = LogFactory.getLog( RequestTrackingHostValve.class );\n\n    private final Pattern _ignorePattern;\n    private final MemcachedSessionService _sessionBackupService;\n    private final Statistics _statistics;\n    private final AtomicBoolean _enabled;\n    protected final String _sessionCookieName;\n    private @CheckForNull LockingStrategy _lockingStrategy;\n\n    private static final String MSM_REQUEST_ID = \"msm.requestId\";\n\n\tprivate static final boolean IS_TOMCAT_6;\n\tstatic {\n\t\tMethod getHeaderValues = null;\n\t\ttry {\n\t\t\tgetHeaderValues = Response.class.getMethod(\"getHeaderValues\", String.class);\n\t\t} catch(final NoSuchMethodException e) {\n\t\t\t//Do nothing\n\t\t}\n\n\t\tIS_TOMCAT_6 = (getHeaderValues != null);\n\t}\n\n    /**\n     * Creates a new instance with the given ignore pattern and\n     * {@link SessionBackupService}.\n     *\n     * @param ignorePattern\n     *            the regular expression for request uris to ignore\n     * @param context\n     *            the catalina context of this valve\n     * @param sessionBackupService\n     *            the service that actually backups sessions\n     * @param statistics\n     *            used to store statistics\n     * @param enabled\n     *            specifies if memcached-session-manager is enabled or not.\n     *            If <code>false<\/code>, each request is just processed without doing anything further.\n     */\n    public RequestTrackingHostValve( @Nullable final String ignorePattern, @Nonnull final String sessionCookieName,\n            @Nonnull final MemcachedSessionService sessionBackupService,\n            @Nonnull final Statistics statistics,\n            @Nonnull final AtomicBoolean enabled ) {\n        if ( ignorePattern != null ) {\n            _log.info( \"Setting ignorePattern to \" + ignorePattern );\n            _ignorePattern = Pattern.compile( ignorePattern );\n        } else {\n            _ignorePattern = null;\n        }\n        _sessionCookieName = sessionCookieName;\n        _sessionBackupService = sessionBackupService;\n        _statistics = statistics;\n        _enabled = enabled;\n    }\n\n    /**\n     * Returns the actually used name for the session cookie.\n     * @return the cookie name, never null.\n     */\n    protected String getSessionCookieName() {\n        return _sessionCookieName;\n    }\n\n    public boolean isIgnoredRequest() {\n        final Request request = _lockingStrategy == null ? null : _lockingStrategy.getCurrentRequest();\n        return request != null && request.getNote(REQUEST_IGNORED) == Boolean.TRUE;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke( final Request request, final Response response ) throws IOException, ServletException {\n\n        final String requestId = getURIWithQueryString( request );\n        if(!_enabled.get()) {\n            getNext().invoke( request, response );\n        } else if ( _ignorePattern != null && _ignorePattern.matcher( requestId ).matches() ) {\n            if(_log.isDebugEnabled()) {\n                _log.debug( \">>>>>> Ignoring: \" + requestId + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n            }\n\n            try {\n                storeRequestThreadLocal( request );\n                request.setNote(REQUEST_IGNORED, Boolean.TRUE);\n                getNext().invoke( request, response );\n            } finally {\n                if(request.getNote(REQUEST_PROCESSED) == Boolean.TRUE) {\n                    final String sessionId = getSessionId(request, response);\n                    if(sessionId != null) {\n                        _sessionBackupService.requestFinished(sessionId, requestId);\n                    }\n                }\n                resetRequestThreadLocal();\n            }\n            if(_log.isDebugEnabled()) {\n                _log.debug( \"<<<<<< Ignored: \" + requestId + \" ==================\" );\n            }\n        } else {\n\n            request.setNote(REQUEST_PROCESS, Boolean.TRUE);\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \">>>>>> Request starting: \" + requestId + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n            }\n\n            try {\n                storeRequestThreadLocal( request );\n                getNext().invoke( request, response );\n            } finally {\n                final Boolean sessionIdChanged = (Boolean) request.getNote(SESSION_ID_CHANGED);\n                backupSession( request, response, sessionIdChanged == null ? false : sessionIdChanged.booleanValue() );\n                resetRequestThreadLocal();\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                logDebugRequestSessionCookie( request );\n                logDebugResponseCookie( response );\n                _log.debug( \"<<<<<< Request finished: \" + requestId + \" ==================\" );\n            }\n\n        }\n    }\n\n    protected void logDebugRequestSessionCookie( final Request request ) {\n        final Cookie[] cookies = request.getCookies();\n        if ( cookies == null ) {\n            return;\n        }\n        for( final javax.servlet.http.Cookie cookie : cookies ) {\n            if ( cookie.getName().equals( _sessionCookieName ) ) {\n                _log.debug( \"Have request session cookie: domain=\" + cookie.getDomain() + \", maxAge=\" + cookie.getMaxAge() +\n                        \", path=\" + cookie.getPath() + \", value=\" + cookie.getValue() +\n                        \", version=\" + cookie.getVersion() + \", secure=\" + cookie.getSecure() );\n            }\n        }\n    }\n\n    @Nonnull\n    protected static String getURIWithQueryString( @Nonnull final Request request ) {\n        final Object note = request.getNote(MSM_REQUEST_ID);\n        if(note != null) {\n            // we have a string and want to save cast\n            return note.toString();\n        }\n        final StringBuilder sb = new StringBuilder(30);\n        sb.append(request.getMethod())\n        .append(' ')\n        .append(request.getRequestURI());\n        if(!isPostMethod(request) && request.getQueryString() != null) {\n            sb.append('?').append(request.getQueryString());\n        }\n        final String result = sb.toString();\n        request.setNote(MSM_REQUEST_ID, result);\n        return result;\n    }\n\n\tprotected static boolean isPostMethod(final Request request) {\n\t\tfinal String method = request.getMethod();\n\t\tif ( method == null && _log.isDebugEnabled() ) {\n\t\t\t_log.debug(\"No method set for request \" + request.getRequestURI() +\n\t\t\t\t\t(request.getQueryString() != null ? \"?\" + request.getQueryString() : \"\"));\n\t\t}\n\t\treturn method != null ? method.toLowerCase().equals( \"post\" ) : false;\n\t}\n\n    private void resetRequestThreadLocal() {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestFinished();\n        }\n    }\n\n    private void storeRequestThreadLocal( @Nonnull final Request request ) {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestStart( request );\n        }\n    }\n\n    private void backupSession( final Request request, final Response response, final boolean sessionIdChanged ) {\n\n        /*\n         * Do we have a session?\n         */\n        final String sessionId = getSessionId(request, response);\n        if ( sessionId != null ) {\n            _statistics.requestWithSession();\n            _sessionBackupService.backupSession( sessionId, sessionIdChanged, getURIWithQueryString( request ) );\n        }\n        else {\n            _statistics.requestWithoutSession();\n        }\n\n    }\n\n    private String getSessionId(final Request request, final Response response) {\n        final String sessionId = getSessionIdFromResponseSessionCookie( response );\n        return sessionId != null ? sessionId : request.getRequestedSessionId();\n    }\n\n    private String getSessionIdFromResponseSessionCookie(final Response response) {\n        final String[] headers = getResponseSetCookieHeaders(response);\n        if (headers == null) {\n            return null;\n        }\n        for (final String header : headers) {\n            if (header != null && header.contains(_sessionCookieName)) {\n                final String sessionIdPrefix = _sessionCookieName + \"=\";\n                final int idxNameStart = header.indexOf(sessionIdPrefix);\n                final int idxValueStart = idxNameStart + sessionIdPrefix.length();\n                int idxValueEnd = header.indexOf(';', idxNameStart);\n                if (idxValueEnd == -1) {\n                    idxValueEnd = header.indexOf(' ', idxValueStart);\n                }\n                if (idxValueEnd == -1) {\n                    idxValueEnd = header.length();\n                }\n                return header.substring(idxValueStart, idxValueEnd);\n            }\n        }\n        return null;\n    }\n\n    private String[] getResponseSetCookieHeaders(final Response response) {\n        try {\n            if (IS_TOMCAT_6) {\n                final Method getHeaderValues = response.getClass().getMethod(\"getHeaderValues\", String.class);\n                final String[] result = (String[]) getHeaderValues.invoke(response, \"Set-Cookie\");\n                return result;\n            } else {\n                final Method getHeaders = response.getClass().getMethod(\"getHeaders\", String.class);\n                @SuppressWarnings(\"unchecked\")\n                final\n                Collection<String> result = (Collection<String>) getHeaders.invoke(response, \"Set-Cookie\");\n                return result.toArray(new String[result.size()]);\n            }\n        } catch (final Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void logDebugResponseCookie( final Response response ) {\n        final String header = response.getHeader(\"Set-Cookie\");\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            _log.debug( \"Request finished, with Set-Cookie header: \" + header );\n        }\n    }\n\n    public void setLockingStrategy( @Nullable final LockingStrategy lockingStrategy ) {\n        _lockingStrategy = lockingStrategy;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Host;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.valves.ValveBase;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\n/**\n * This valve is used for tracking requests for that the session must be sent to\n * memcached, on host level. This encapsulates/surrounds als container request\n * processing like e.g. authentication and ServletRequestListener notification.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class RequestTrackingHostValve extends ValveBase {\n\n    private static final String REQUEST_IGNORED = \"de.javakaffee.msm.request.ignored\";\n\n    public static final String REQUEST_PROCESS = \"de.javakaffee.msm.request.process\";\n\n    public static final String SESSION_ID_CHANGED = \"de.javakaffee.msm.sessionIdChanged\";\n\n    public static final String REQUEST_PROCESSED = \"de.javakaffee.msm.request.processed\";\n\n    static final String RELOCATE = \"session.relocate\";\n\n    protected static final Log _log = LogFactory.getLog( RequestTrackingHostValve.class );\n\n    private final Pattern _ignorePattern;\n    private final MemcachedSessionService _sessionBackupService;\n    private final Statistics _statistics;\n    private final AtomicBoolean _enabled;\n    protected final String _sessionCookieName;\n    private @CheckForNull LockingStrategy _lockingStrategy;\n\n    private static final String MSM_REQUEST_ID = \"msm.requestId\";\n\n\tprivate static final boolean IS_TOMCAT_6;\n\tstatic {\n\t\tMethod getHeaderValues = null;\n\t\ttry {\n\t\t\tgetHeaderValues = Response.class.getMethod(\"getHeaderValues\", String.class);\n\t\t} catch(final NoSuchMethodException e) {\n\t\t\t//Do nothing\n\t\t}\n\n\t\tIS_TOMCAT_6 = (getHeaderValues != null);\n\t}\n\n    /**\n     * Creates a new instance with the given ignore pattern and\n     * {@link SessionBackupService}.\n     *\n     * @param ignorePattern\n     *            the regular expression for request uris to ignore\n     * @param context\n     *            the catalina context of this valve\n     * @param sessionBackupService\n     *            the service that actually backups sessions\n     * @param statistics\n     *            used to store statistics\n     * @param enabled\n     *            specifies if memcached-session-manager is enabled or not.\n     *            If <code>false<\/code>, each request is just processed without doing anything further.\n     */\n    public RequestTrackingHostValve( @Nullable final String ignorePattern, @Nonnull final String sessionCookieName,\n            @Nonnull final MemcachedSessionService sessionBackupService,\n            @Nonnull final Statistics statistics,\n            @Nonnull final AtomicBoolean enabled ) {\n        if ( ignorePattern != null ) {\n            _log.info( \"Setting ignorePattern to \" + ignorePattern );\n            _ignorePattern = Pattern.compile( ignorePattern );\n        } else {\n            _ignorePattern = null;\n        }\n        _sessionCookieName = sessionCookieName;\n        _sessionBackupService = sessionBackupService;\n        _statistics = statistics;\n        _enabled = enabled;\n    }\n\n    /**\n     * Returns the actually used name for the session cookie.\n     * @return the cookie name, never null.\n     */\n    protected String getSessionCookieName() {\n        return _sessionCookieName;\n    }\n\n    public boolean isIgnoredRequest() {\n        final Request request = _lockingStrategy == null ? null : _lockingStrategy.getCurrentRequest();\n        return request != null && request.getNote(REQUEST_IGNORED) == Boolean.TRUE;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke( final Request request, final Response response ) throws IOException, ServletException {\n\n        final String requestId = getURIWithQueryString( request );\n        Context context = (Context) _sessionBackupService.getManager().getContainer();\n        Host host = (Host) _sessionBackupService.getManager().getContainer().getParent();\n        if(!_enabled.get() || !container.equals(host) || !request.getRequestURI().startsWith(context.getPath())) {\n            getNext().invoke( request, response );\n        } else if ( _ignorePattern != null && _ignorePattern.matcher( requestId ).matches() ) {\n            if(_log.isDebugEnabled()) {\n                _log.debug( \">>>>>> Ignoring: \" + requestId + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n            }\n\n            try {\n                storeRequestThreadLocal( request );\n                request.setNote(REQUEST_IGNORED, Boolean.TRUE);\n                getNext().invoke( request, response );\n            } finally {\n                if(request.getNote(REQUEST_PROCESSED) == Boolean.TRUE) {\n                    final String sessionId = getSessionId(request, response);\n                    if(sessionId != null) {\n                        _sessionBackupService.requestFinished(sessionId, requestId);\n                    }\n                }\n                resetRequestThreadLocal();\n            }\n            if(_log.isDebugEnabled()) {\n                _log.debug( \"<<<<<< Ignored: \" + requestId + \" ==================\" );\n            }\n        } else {\n\n            request.setNote(REQUEST_PROCESS, Boolean.TRUE);\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \">>>>>> Request starting: \" + requestId + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n            }\n\n            try {\n                storeRequestThreadLocal( request );\n                getNext().invoke( request, response );\n            } finally {\n                final Boolean sessionIdChanged = (Boolean) request.getNote(SESSION_ID_CHANGED);\n                backupSession( request, response, sessionIdChanged == null ? false : sessionIdChanged.booleanValue() );\n                resetRequestThreadLocal();\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                logDebugRequestSessionCookie( request );\n                logDebugResponseCookie( response );\n                _log.debug( \"<<<<<< Request finished: \" + requestId + \" ==================\" );\n            }\n\n        }\n    }\n\n    protected void logDebugRequestSessionCookie( final Request request ) {\n        final Cookie[] cookies = request.getCookies();\n        if ( cookies == null ) {\n            return;\n        }\n        for( final javax.servlet.http.Cookie cookie : cookies ) {\n            if ( cookie.getName().equals( _sessionCookieName ) ) {\n                _log.debug( \"Have request session cookie: domain=\" + cookie.getDomain() + \", maxAge=\" + cookie.getMaxAge() +\n                        \", path=\" + cookie.getPath() + \", value=\" + cookie.getValue() +\n                        \", version=\" + cookie.getVersion() + \", secure=\" + cookie.getSecure() );\n            }\n        }\n    }\n\n    @Nonnull\n    protected static String getURIWithQueryString( @Nonnull final Request request ) {\n        final Object note = request.getNote(MSM_REQUEST_ID);\n        if(note != null) {\n            // we have a string and want to save cast\n            return note.toString();\n        }\n        final StringBuilder sb = new StringBuilder(30);\n        sb.append(request.getMethod())\n        .append(' ')\n        .append(request.getRequestURI());\n        if(!isPostMethod(request) && request.getQueryString() != null) {\n            sb.append('?').append(request.getQueryString());\n        }\n        final String result = sb.toString();\n        request.setNote(MSM_REQUEST_ID, result);\n        return result;\n    }\n\n\tprotected static boolean isPostMethod(final Request request) {\n\t\tfinal String method = request.getMethod();\n\t\tif ( method == null && _log.isDebugEnabled() ) {\n\t\t\t_log.debug(\"No method set for request \" + request.getRequestURI() +\n\t\t\t\t\t(request.getQueryString() != null ? \"?\" + request.getQueryString() : \"\"));\n\t\t}\n\t\treturn method != null ? method.toLowerCase().equals( \"post\" ) : false;\n\t}\n\n    private void resetRequestThreadLocal() {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestFinished();\n        }\n    }\n\n    private void storeRequestThreadLocal( @Nonnull final Request request ) {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestStart( request );\n        }\n    }\n\n    private void backupSession( final Request request, final Response response, final boolean sessionIdChanged ) {\n\n        /*\n         * Do we have a session?\n         */\n        final String sessionId = getSessionId(request, response);\n        if ( sessionId != null ) {\n            _statistics.requestWithSession();\n            _sessionBackupService.backupSession( sessionId, sessionIdChanged, getURIWithQueryString( request ) );\n        }\n        else {\n            _statistics.requestWithoutSession();\n        }\n\n    }\n\n    private String getSessionId(final Request request, final Response response) {\n        final String sessionId = getSessionIdFromResponseSessionCookie( response );\n        return sessionId != null ? sessionId : request.getRequestedSessionId();\n    }\n\n    private String getSessionIdFromResponseSessionCookie(final Response response) {\n        final String[] headers = getResponseSetCookieHeaders(response);\n        if (headers == null) {\n            return null;\n        }\n        for (final String header : headers) {\n            if (header != null && header.contains(_sessionCookieName)) {\n                final String sessionIdPrefix = _sessionCookieName + \"=\";\n                final int idxNameStart = header.indexOf(sessionIdPrefix);\n                final int idxValueStart = idxNameStart + sessionIdPrefix.length();\n                int idxValueEnd = header.indexOf(';', idxNameStart);\n                if (idxValueEnd == -1) {\n                    idxValueEnd = header.indexOf(' ', idxValueStart);\n                }\n                if (idxValueEnd == -1) {\n                    idxValueEnd = header.length();\n                }\n                return header.substring(idxValueStart, idxValueEnd);\n            }\n        }\n        return null;\n    }\n\n    private String[] getResponseSetCookieHeaders(final Response response) {\n        try {\n            if (IS_TOMCAT_6) {\n                final Method getHeaderValues = response.getClass().getMethod(\"getHeaderValues\", String.class);\n                final String[] result = (String[]) getHeaderValues.invoke(response, \"Set-Cookie\");\n                return result;\n            } else {\n                final Method getHeaders = response.getClass().getMethod(\"getHeaders\", String.class);\n                @SuppressWarnings(\"unchecked\")\n                final\n                Collection<String> result = (Collection<String>) getHeaders.invoke(response, \"Set-Cookie\");\n                return result.toArray(new String[result.size()]);\n            }\n        } catch (final Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void logDebugResponseCookie( final Response response ) {\n        final String header = response.getHeader(\"Set-Cookie\");\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            _log.debug( \"Request finished, with Set-Cookie header: \" + header );\n        }\n    }\n\n    public void setLockingStrategy( @Nullable final LockingStrategy lockingStrategy ) {\n        _lockingStrategy = lockingStrategy;\n    }\n\n}\n","lineNo":134}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.integration.TestServlet.PARAM_REMOVE;\nimport static de.javakaffee.web.msm.integration.TestServlet.PATH_INVALIDATE;\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private static final String GROUP_WITHOUT_NODE_ID = \"withoutNodeId\";\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private final String _memcachedNodeId = \"n1\";\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n\n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n\t\t@Override\n\t\tpublic Object get(final String key) {\n\t\t\treturn _memcached.get(key);\n\t\t}\n\t};\n\n    @BeforeMethod\n    public void setUp(final Method testMethod) throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        final String[] testGroups = testMethod.getAnnotation(Test.class).groups();\n        final String nodePrefix = testGroups.length == 0 || !GROUP_WITHOUT_NODE_ID.equals(testGroups[0]) ? _memcachedNodeId + \":\" : \"\";\n\n        final String memcachedNodes = nodePrefix + \"localhost:\" + _memcachedPort;\n\n        try {\n            System.setProperty( \"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\", \"true\" );\n            _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( memcachedNodes, address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final String memcachedNodes, final InetSocketAddress address ) throws IOException, InterruptedException {\n    \tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(memcachedNodes, null, _memcachedClientCallback);\n        final ConnectionFactory cf = nodesManager.isEncodeNodeIdInSessionId()\n            ? new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create(), 1000 )\n            : new DefaultConnectionFactory();\n        final MemcachedClient result = new MemcachedClient( cf, Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    /**\n     * Test for issue 106: Session not updated in memcached when only a session attribute was removed\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=106\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionUpdatedInMemcachedWhenSessionAttributeIsRemovedIssue106( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, _portTomcat1, null, key, value ).getSessionId();\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        Response response = get( _httpClient, _portTomcat1, sessionId1 );\n        assertEquals( response.getSessionId(), sessionId1 );\n        assertEquals( response.get( key ), value );\n\n        final Map<String, String> params = asMap( PARAM_REMOVE, key );\n        response = get( _httpClient, _portTomcat1, \"/\", sessionId1, params );\n        assertEquals( response.getSessionId(), sessionId1 );\n        assertNull( response.get( key ) );\n\n        // also the next request must not include this session attribute\n        response = get( _httpClient, _portTomcat1, sessionId1 );\n        assertEquals( response.getSessionId(), sessionId1 );\n        assertNull( response.get( key ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): this shall be possible\n     * and the generated session id must not contain a node id.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID )\n    public void testSessionIdIsNotChangedIfSingleNodeWithNoMemcachedNodeIdConfigured() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) == -1 );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): the session must be\n     * found on a second request.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, _portTomcat1, null, key, value ).getSessionId();\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        final Response response = get( _httpClient, _portTomcat1, sessionId1 );\n        final String sessionId2 = response.getSessionId();\n\n        assertEquals( sessionId2, sessionId1 );\n\n        /* check session attributes could be read\n         */\n        final String actualValue = response.get( key );\n        assertEquals( value, actualValue );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    private void setStickyness(final SessionAffinityMode sessionAffinity) {\n        if(!sessionAffinity.isSticky()) {\n            getEngine(_tomcat1).setJvmRoute(null);\n        }\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidatedSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        final Response response = get( _httpClient, _portTomcat1, PATH_INVALIDATE, sessionId1 );\n        assertNull( response.getResponseSessionId() );\n        assertEquals(_daemon.getCache().getGetMisses(), 1); // 1 is ok\n\n        assertNull( _memcached.get( sessionId1 ), \"Invalidated session still existing in memcached\" );\n        if(!sessionAffinity.isSticky()) {\n            assertNull( _memcached.get(createValidityInfoKeyName( sessionId1 )), \"ValidityInfo for invalidated session still exists in memcached.\" );\n        }\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // Wait some time for reconfiguration\n        waitForReconnect(manager.getMemcachedSessionService().getMemcached(), 1, 500);\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    public static void waitForReconnect( final MemcachedClient client, final int expectedNumServers, final long timeToWait )\n            throws InterruptedException, RuntimeException {\n        final long start = System.currentTimeMillis();\n        while( System.currentTimeMillis() < start + timeToWait ) {\n            if ( client.getAvailableServers().size() >= expectedNumServers ) {\n                return;\n            }\n            Thread.sleep( 20 );\n        }\n        throw new RuntimeException( \"MemcachedClient did not reconnect after \" + timeToWait + \" millis.\" );\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedSessionService#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n\n    abstract TestUtils getTestUtils();\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).getMemcachedSessionService().isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final SessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.getMemcachedSessionService().isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.integration.TestServlet.PARAM_REMOVE;\nimport static de.javakaffee.web.msm.integration.TestServlet.PATH_INVALIDATE;\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private static final String GROUP_WITHOUT_NODE_ID = \"withoutNodeId\";\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private final String _memcachedNodeId = \"n1\";\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n\n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n\t\t@Override\n\t\tpublic Object get(final String key) {\n\t\t\treturn _memcached.get(key);\n\t\t}\n\t};\n\n    @BeforeMethod\n    public void setUp(final Method testMethod) throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        final String[] testGroups = testMethod.getAnnotation(Test.class).groups();\n        final String nodePrefix = testGroups.length == 0 || !GROUP_WITHOUT_NODE_ID.equals(testGroups[0]) ? _memcachedNodeId + \":\" : \"\";\n\n        final String memcachedNodes = nodePrefix + \"localhost:\" + _memcachedPort;\n\n        try {\n            System.setProperty( \"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\", \"true\" );\n            _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( memcachedNodes, address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final String memcachedNodes, final InetSocketAddress address ) throws IOException, InterruptedException {\n    \tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(memcachedNodes, null, _memcachedClientCallback);\n        final ConnectionFactory cf = nodesManager.isEncodeNodeIdInSessionId()\n            ? new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create(), 1000 )\n            : new DefaultConnectionFactory();\n        final MemcachedClient result = new MemcachedClient( cf, Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    /**\n     * Test for issue 106: Session not updated in memcached when only a session attribute was removed\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=106\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionUpdatedInMemcachedWhenSessionAttributeIsRemovedIssue106( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, _portTomcat1, null, key, value ).getSessionId();\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        Response response = get( _httpClient, _portTomcat1, sessionId1 );\n        assertEquals( response.getSessionId(), sessionId1 );\n        assertEquals( response.get( key ), value );\n\n        final Map<String, String> params = asMap( PARAM_REMOVE, key );\n        response = get( _httpClient, _portTomcat1, \"/\", sessionId1, params );\n        assertEquals( response.getSessionId(), sessionId1 );\n        assertNull( response.get( key ) );\n\n        // also the next request must not include this session attribute\n        response = get( _httpClient, _portTomcat1, sessionId1 );\n        assertEquals( response.getSessionId(), sessionId1 );\n        assertNull( response.get( key ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): this shall be possible\n     * and the generated session id must not contain a node id.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID )\n    public void testSessionIdIsNotChangedIfSingleNodeWithNoMemcachedNodeIdConfigured() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) == -1 );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): the session must be\n     * found on a second request.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, _portTomcat1, null, key, value ).getSessionId();\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        final Response response = get( _httpClient, _portTomcat1, sessionId1 );\n        final String sessionId2 = response.getSessionId();\n\n        assertEquals( sessionId2, sessionId1 );\n\n        /* check session attributes could be read\n         */\n        final String actualValue = response.get( key );\n        assertEquals( value, actualValue );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    private void setStickyness(final SessionAffinityMode sessionAffinity) {\n        if(!sessionAffinity.isSticky()) {\n            getEngine(_tomcat1).setJvmRoute(null);\n        }\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( sessionAffinity.isSticky() );\n\n        try {\n            waitForReconnect(manager.getMemcachedSessionService().getMemcached(), 1, 500);\n        } catch (final InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidatedSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        final Response response = get( _httpClient, _portTomcat1, PATH_INVALIDATE, sessionId1 );\n        assertNull( response.getResponseSessionId() );\n        assertEquals(_daemon.getCache().getGetMisses(), 1); // 1 is ok\n\n        assertNull( _memcached.get( sessionId1 ), \"Invalidated session still existing in memcached\" );\n        if(!sessionAffinity.isSticky()) {\n            assertNull( _memcached.get(createValidityInfoKeyName( sessionId1 )), \"ValidityInfo for invalidated session still exists in memcached.\" );\n        }\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        setStickyness(sessionAffinity);\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        setStickyness(stickyness);\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    public static void waitForReconnect( final MemcachedClient client, final int expectedNumServers, final long timeToWait )\n            throws InterruptedException, RuntimeException {\n        final long start = System.currentTimeMillis();\n        while( System.currentTimeMillis() < start + timeToWait ) {\n            if ( client.getAvailableServers().size() >= expectedNumServers ) {\n                return;\n            }\n            Thread.sleep( 20 );\n        }\n        throw new RuntimeException( \"MemcachedClient did not reconnect after \" + timeToWait + \" millis.\" );\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedSessionService#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n\n    abstract TestUtils getTestUtils();\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).getMemcachedSessionService().isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final SessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.getMemcachedSessionService().isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","lineNo":253}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.catalina.Session;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.valves.ValveBase;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\n\n/**\n * This valve is used for tracking requests for that the session must be sent to\n * memcached.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class SessionTrackerValve extends ValveBase {\n\n    private static final String REQUEST_IGNORED = \"de.javakaffee.msm.request.ignored\";\n\n    public static final String REQUEST_PROCESS = \"de.javakaffee.msm.request.process\";\n\n    public static final String SESSION_ID_CHANGED = \"de.javakaffee.msm.sessionIdChanged\";\n\n    public static final String REQUEST_PROCESSED = \"de.javakaffee.msm.request.processed\";\n\n    static final String RELOCATE = \"session.relocate\";\n\n    protected static final Log _log = LogFactory.getLog( SessionTrackerValve.class );\n\n    private final Pattern _ignorePattern;\n    private final MemcachedSessionService _sessionBackupService;\n    private final Statistics _statistics;\n    private final AtomicBoolean _enabled;\n    protected final String _sessionCookieName;\n    private @CheckForNull LockingStrategy _lockingStrategy;\n\n    /**\n     * Creates a new instance with the given ignore pattern and\n     * {@link SessionBackupService}.\n     *\n     * @param ignorePattern\n     *            the regular expression for request uris to ignore\n     * @param context\n     *            the catalina context of this valve\n     * @param sessionBackupService\n     *            the service that actually backups sessions\n     * @param statistics\n     *            used to store statistics\n     * @param enabled\n     *            specifies if memcached-session-manager is enabled or not.\n     *            If <code>false<\/code>, each request is just processed without doing anything further.\n     */\n    public SessionTrackerValve( @Nullable final String ignorePattern, @Nonnull final String sessionCookieName,\n            @Nonnull final MemcachedSessionService sessionBackupService,\n            @Nonnull final Statistics statistics,\n            @Nonnull final AtomicBoolean enabled ) {\n        if ( ignorePattern != null ) {\n            _log.info( \"Setting ignorePattern to \" + ignorePattern );\n            _ignorePattern = Pattern.compile( ignorePattern );\n        } else {\n            _ignorePattern = null;\n        }\n        _sessionCookieName = sessionCookieName;\n        _sessionBackupService = sessionBackupService;\n        _statistics = statistics;\n        _enabled = enabled;\n    }\n\n    /**\n     * Returns the actually used name for the session cookie.\n     * @return the cookie name, never null.\n     */\n    protected String getSessionCookieName() {\n        return _sessionCookieName;\n    }\n\n    public boolean isIgnoredRequest() {\n        final Request request = _lockingStrategy == null ? null : _lockingStrategy.getCurrentRequest();\n        return request != null && request.getNote(REQUEST_IGNORED) == Boolean.TRUE;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke( final Request request, final Response response ) throws IOException, ServletException {\n\n        if(!_enabled.get()) {\n            getNext().invoke( request, response );\n        }\n        else if ( _ignorePattern != null && _ignorePattern.matcher( getURIWithQueryString( request ) ).matches() ) {\n            _log.debug( \">>>>>> Ignoring: \" + getURIWithQueryString( request ) + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n\n            try {\n                storeRequestThreadLocal( request );\n                request.setNote(REQUEST_IGNORED, Boolean.TRUE);\n                getNext().invoke( request, response );\n            } finally {\n                if(request.getNote(REQUEST_PROCESSED) == Boolean.TRUE) {\n                    final String sessionId = getSessionId(request, response);\n                    if(sessionId != null) {\n                        _sessionBackupService.requestFinished(sessionId, getURIWithQueryString( request ));\n                    }\n                }\n                resetRequestThreadLocal();\n            }\n            _log.debug( \"<<<<<< Ignored: \" + getURIWithQueryString( request ) + \" ==================\" );\n        } else {\n\n            request.setNote(REQUEST_PROCESS, Boolean.TRUE);\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \">>>>>> Request starting: \" + getURIWithQueryString( request ) + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n            }\n\n            try {\n                storeRequestThreadLocal( request );\n                // sessionIdChanged = changeRequestedSessionId( request, response );\n                getNext().invoke( request, response );\n            } finally {\n                // if(request.getNote(REQUEST_PROCESSED) == Boolean.TRUE) {\n                    final Boolean sessionIdChanged = (Boolean) request.getNote(SESSION_ID_CHANGED);\n                    backupSession( request, response, sessionIdChanged == null ? false : sessionIdChanged.booleanValue() );\n                // }\n                resetRequestThreadLocal();\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                logDebugRequestSessionCookie( request );\n                logDebugResponseCookie( response );\n                _log.debug( \"<<<<<< Request finished: \" + getURIWithQueryString( request ) + \" ==================\" );\n            }\n\n        }\n\n    }\n\n    protected void logDebugRequestSessionCookie( final Request request ) {\n        final Cookie[] cookies = request.getCookies();\n        if ( cookies == null ) {\n            return;\n        }\n        for( final javax.servlet.http.Cookie cookie : cookies ) {\n            if ( cookie.getName().equals( _sessionCookieName ) ) {\n                _log.debug( \"Have request session cookie: domain=\" + cookie.getDomain() + \", maxAge=\" + cookie.getMaxAge() +\n                        \", path=\" + cookie.getPath() + \", value=\" + cookie.getValue() +\n                        \", version=\" + cookie.getVersion() + \", secure=\" + cookie.getSecure() );\n            }\n        }\n    }\n\n    @Nonnull\n    protected static String getURIWithQueryString( @Nonnull final Request request ) {\n        final String uri = request.getRequestURI();\n        final String qs = isPostMethod(request) ? null : request.getQueryString();\n        return qs != null ? uri + \"?\" + qs : uri;\n    }\n\n\tprotected static boolean isPostMethod(final Request request) {\n\t\tfinal String method = request.getMethod();\n\t\tif ( method == null && _log.isDebugEnabled() ) {\n\t\t\t_log.debug(\"No method set for request \" + request.getRequestURI() +\n\t\t\t\t\t(request.getQueryString() != null ? \"?\" + request.getQueryString() : \"\"));\n\t\t}\n\t\treturn method != null ? method.toLowerCase().equals( \"post\" ) : false;\n\t}\n\n    private void resetRequestThreadLocal() {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestFinished();\n        }\n    }\n\n    private void storeRequestThreadLocal( @Nonnull final Request request ) {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestStart( request );\n        }\n    }\n\n    private void backupSession( final Request request, final Response response, final boolean sessionIdChanged ) {\n\n        /*\n         * Do we have a session?\n         */\n        final String sessionId = getSessionId(request, response);\n        if ( sessionId != null ) {\n            _statistics.requestWithSession();\n            _sessionBackupService.backupSession( sessionId, sessionIdChanged, getURIWithQueryString( request ) );\n        }\n        else {\n            _statistics.requestWithoutSession();\n        }\n\n    }\n\n    private String getSessionId(final Request request, final Response response) {\n        final String sessionId = getSessionIdFromResponseSessionCookie( response );\n        return sessionId != null ? sessionId : request.getRequestedSessionId();\n    }\n\n    private String getSessionIdFromResponseSessionCookie( final Response response ) {\n        final String header = response.getHeader( \"Set-Cookie\" );\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            final String sessionIdPrefix = _sessionCookieName + \"=\";\n            final int idxNameStart = header.indexOf( sessionIdPrefix );\n            final int idxValueStart = idxNameStart + sessionIdPrefix.length();\n            int idxValueEnd = header.indexOf( ';', idxNameStart );\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.indexOf( ' ', idxValueStart );\n            }\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.length();\n            }\n            return header.substring( idxValueStart, idxValueEnd );\n        }\n        return null;\n    }\n\n    private void logDebugResponseCookie( final Response response ) {\n        final String header = response.getHeader(\"Set-Cookie\");\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            _log.debug( \"Request finished, with Set-Cookie header: \" + header );\n        }\n    }\n\n    /**\n     * The service that stores session backups in memcached.\n     */\n    public static interface SessionBackupService {\n\n        /**\n         * Check if the given session id does not belong to this tomcat (according to the\n         * local jvmRoute and the jvmRoute in the session id). If the session contains a\n         * different jvmRoute load if from memcached. If the session was found in memcached and\n         * if it's valid it must be associated with this tomcat and therefore the session id has to\n         * be changed. The new session id must be returned if it was changed.\n         * <p>\n         * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n         * always be returned.\n         * <\/p>\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session is taken over and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnTomcatFailover( final String requestedSessionId );\n\n        /**\n         * Check if the valid session associated with the provided\n         * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n         * and change the session id to the new one (containing the new memcached node). The\n         * new session id must be returned if the session will be relocated and the id was changed.\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session will be relocated and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnMemcachedFailover( final String requestedSessionId );\n\n        /**\n         * Backup the session for the provided session id in memcached if the session was modified or\n         * if the session needs to be relocated. In non-sticky session-mode the session should not be\n         * loaded from memcached for just storing it again but only metadata should be updated.\n         *\n         * @param sessionId\n         *            the if of the session to backup\n         * @param sessionIdChanged\n         *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n         * @param requestId\n         *            the uri of the request for that the session backup shall be performed.\n         *\n         * @return a {@link Future} providing the {@link BackupResultStatus}.\n         */\n        Future<BackupResult> backupSession( @Nonnull String sessionId, boolean sessionIdChanged, String requestId );\n\n        /**\n         * The enumeration of possible backup results.\n         */\n        static enum BackupResultStatus {\n                /**\n                 * The session was successfully stored in the sessions default memcached node.\n                 * This status is also used, if a session was relocated to another memcached node.\n                 */\n                SUCCESS,\n                /**\n                 * The session could not be stored in any memcached node.\n                 */\n                FAILURE,\n                /**\n                 * The session was not modified and therefore the backup was skipped.\n                 */\n                SKIPPED\n        }\n\n    }\n\n    public void setLockingStrategy( @Nullable final LockingStrategy lockingStrategy ) {\n        _lockingStrategy = lockingStrategy;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.catalina.Session;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.valves.ValveBase;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\n\n/**\n * This valve is used for tracking requests for that the session must be sent to\n * memcached.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class SessionTrackerValve extends ValveBase {\n\n    private static final String REQUEST_IGNORED = \"de.javakaffee.msm.request.ignored\";\n\n    public static final String REQUEST_PROCESS = \"de.javakaffee.msm.request.process\";\n\n    public static final String SESSION_ID_CHANGED = \"de.javakaffee.msm.sessionIdChanged\";\n\n    public static final String REQUEST_PROCESSED = \"de.javakaffee.msm.request.processed\";\n\n    static final String RELOCATE = \"session.relocate\";\n\n    protected static final Log _log = LogFactory.getLog( SessionTrackerValve.class );\n\n    private final Pattern _ignorePattern;\n    private final MemcachedSessionService _sessionBackupService;\n    private final Statistics _statistics;\n    private final AtomicBoolean _enabled;\n    protected final String _sessionCookieName;\n    private @CheckForNull LockingStrategy _lockingStrategy;\n\n    private static final String MSM_REQUEST_ID = \"msm.requestId\";\n\n    /**\n     * Creates a new instance with the given ignore pattern and\n     * {@link SessionBackupService}.\n     *\n     * @param ignorePattern\n     *            the regular expression for request uris to ignore\n     * @param context\n     *            the catalina context of this valve\n     * @param sessionBackupService\n     *            the service that actually backups sessions\n     * @param statistics\n     *            used to store statistics\n     * @param enabled\n     *            specifies if memcached-session-manager is enabled or not.\n     *            If <code>false<\/code>, each request is just processed without doing anything further.\n     */\n    public SessionTrackerValve( @Nullable final String ignorePattern, @Nonnull final String sessionCookieName,\n            @Nonnull final MemcachedSessionService sessionBackupService,\n            @Nonnull final Statistics statistics,\n            @Nonnull final AtomicBoolean enabled ) {\n        if ( ignorePattern != null ) {\n            _log.info( \"Setting ignorePattern to \" + ignorePattern );\n            _ignorePattern = Pattern.compile( ignorePattern );\n        } else {\n            _ignorePattern = null;\n        }\n        _sessionCookieName = sessionCookieName;\n        _sessionBackupService = sessionBackupService;\n        _statistics = statistics;\n        _enabled = enabled;\n    }\n\n    /**\n     * Returns the actually used name for the session cookie.\n     * @return the cookie name, never null.\n     */\n    protected String getSessionCookieName() {\n        return _sessionCookieName;\n    }\n\n    public boolean isIgnoredRequest() {\n        final Request request = _lockingStrategy == null ? null : _lockingStrategy.getCurrentRequest();\n        return request != null && request.getNote(REQUEST_IGNORED) == Boolean.TRUE;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke( final Request request, final Response response ) throws IOException, ServletException {\n\n        final String requestId = getURIWithQueryString( request );\n        if(!_enabled.get()) {\n            getNext().invoke( request, response );\n        } else if ( _ignorePattern != null && _ignorePattern.matcher( requestId ).matches() ) {\n            if(_log.isDebugEnabled()) {\n                _log.debug( \">>>>>> Ignoring: \" + requestId + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n            }\n\n            try {\n                storeRequestThreadLocal( request );\n                request.setNote(REQUEST_IGNORED, Boolean.TRUE);\n                getNext().invoke( request, response );\n            } finally {\n                if(request.getNote(REQUEST_PROCESSED) == Boolean.TRUE) {\n                    final String sessionId = getSessionId(request, response);\n                    if(sessionId != null) {\n                        _sessionBackupService.requestFinished(sessionId, requestId);\n                    }\n                }\n                resetRequestThreadLocal();\n            }\n            if(_log.isDebugEnabled()) {\n                _log.debug( \"<<<<<< Ignored: \" + requestId + \" ==================\" );\n            }\n        } else {\n\n            request.setNote(REQUEST_PROCESS, Boolean.TRUE);\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \">>>>>> Request starting: \" + requestId + \" (requestedSessionId \"+ request.getRequestedSessionId() +\") ==================\" );\n            }\n\n            try {\n                storeRequestThreadLocal( request );\n                getNext().invoke( request, response );\n            } finally {\n                final Boolean sessionIdChanged = (Boolean) request.getNote(SESSION_ID_CHANGED);\n                backupSession( request, response, sessionIdChanged == null ? false : sessionIdChanged.booleanValue() );\n                resetRequestThreadLocal();\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                logDebugRequestSessionCookie( request );\n                logDebugResponseCookie( response );\n                _log.debug( \"<<<<<< Request finished: \" + requestId + \" ==================\" );\n            }\n\n        }\n    }\n\n    protected void logDebugRequestSessionCookie( final Request request ) {\n        final Cookie[] cookies = request.getCookies();\n        if ( cookies == null ) {\n            return;\n        }\n        for( final javax.servlet.http.Cookie cookie : cookies ) {\n            if ( cookie.getName().equals( _sessionCookieName ) ) {\n                _log.debug( \"Have request session cookie: domain=\" + cookie.getDomain() + \", maxAge=\" + cookie.getMaxAge() +\n                        \", path=\" + cookie.getPath() + \", value=\" + cookie.getValue() +\n                        \", version=\" + cookie.getVersion() + \", secure=\" + cookie.getSecure() );\n            }\n        }\n    }\n\n    @Nonnull\n    protected static String getURIWithQueryString( @Nonnull final Request request ) {\n        final Object note = request.getNote(MSM_REQUEST_ID);\n        if(note != null) {\n            // we have a string and want to save cast\n            return note.toString();\n        }\n        final StringBuilder sb = new StringBuilder(30);\n        sb.append(request.getMethod())\n        .append(' ')\n        .append(request.getRequestURI());\n        if(!isPostMethod(request) && request.getQueryString() != null) {\n            sb.append('?').append(request.getQueryString());\n        }\n        final String result = sb.toString();\n        request.setNote(MSM_REQUEST_ID, result);\n        return result;\n    }\n\n\tprotected static boolean isPostMethod(final Request request) {\n\t\tfinal String method = request.getMethod();\n\t\tif ( method == null && _log.isDebugEnabled() ) {\n\t\t\t_log.debug(\"No method set for request \" + request.getRequestURI() +\n\t\t\t\t\t(request.getQueryString() != null ? \"?\" + request.getQueryString() : \"\"));\n\t\t}\n\t\treturn method != null ? method.toLowerCase().equals( \"post\" ) : false;\n\t}\n\n    private void resetRequestThreadLocal() {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestFinished();\n        }\n    }\n\n    private void storeRequestThreadLocal( @Nonnull final Request request ) {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestStart( request );\n        }\n    }\n\n    private void backupSession( final Request request, final Response response, final boolean sessionIdChanged ) {\n\n        /*\n         * Do we have a session?\n         */\n        final String sessionId = getSessionId(request, response);\n        if ( sessionId != null ) {\n            _statistics.requestWithSession();\n            _sessionBackupService.backupSession( sessionId, sessionIdChanged, getURIWithQueryString( request ) );\n        }\n        else {\n            _statistics.requestWithoutSession();\n        }\n\n    }\n\n    private String getSessionId(final Request request, final Response response) {\n        final String sessionId = getSessionIdFromResponseSessionCookie( response );\n        return sessionId != null ? sessionId : request.getRequestedSessionId();\n    }\n\n    private String getSessionIdFromResponseSessionCookie( final Response response ) {\n        final String header = response.getHeader( \"Set-Cookie\" );\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            final String sessionIdPrefix = _sessionCookieName + \"=\";\n            final int idxNameStart = header.indexOf( sessionIdPrefix );\n            final int idxValueStart = idxNameStart + sessionIdPrefix.length();\n            int idxValueEnd = header.indexOf( ';', idxNameStart );\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.indexOf( ' ', idxValueStart );\n            }\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.length();\n            }\n            return header.substring( idxValueStart, idxValueEnd );\n        }\n        return null;\n    }\n\n    private void logDebugResponseCookie( final Response response ) {\n        final String header = response.getHeader(\"Set-Cookie\");\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            _log.debug( \"Request finished, with Set-Cookie header: \" + header );\n        }\n    }\n\n    /**\n     * The service that stores session backups in memcached.\n     */\n    public static interface SessionBackupService {\n\n        /**\n         * Check if the given session id does not belong to this tomcat (according to the\n         * local jvmRoute and the jvmRoute in the session id). If the session contains a\n         * different jvmRoute load if from memcached. If the session was found in memcached and\n         * if it's valid it must be associated with this tomcat and therefore the session id has to\n         * be changed. The new session id must be returned if it was changed.\n         * <p>\n         * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n         * always be returned.\n         * <\/p>\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session is taken over and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnTomcatFailover( final String requestedSessionId );\n\n        /**\n         * Check if the valid session associated with the provided\n         * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n         * and change the session id to the new one (containing the new memcached node). The\n         * new session id must be returned if the session will be relocated and the id was changed.\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session will be relocated and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnMemcachedFailover( final String requestedSessionId );\n\n        /**\n         * Backup the session for the provided session id in memcached if the session was modified or\n         * if the session needs to be relocated. In non-sticky session-mode the session should not be\n         * loaded from memcached for just storing it again but only metadata should be updated.\n         *\n         * @param sessionId\n         *            the if of the session to backup\n         * @param sessionIdChanged\n         *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n         * @param requestId\n         *            the uri of the request for that the session backup shall be performed.\n         *\n         * @return a {@link Future} providing the {@link BackupResultStatus}.\n         */\n        Future<BackupResult> backupSession( @Nonnull String sessionId, boolean sessionIdChanged, String requestId );\n\n        /**\n         * The enumeration of possible backup results.\n         */\n        static enum BackupResultStatus {\n                /**\n                 * The session was successfully stored in the sessions default memcached node.\n                 * This status is also used, if a session was relocated to another memcached node.\n                 */\n                SUCCESS,\n                /**\n                 * The session could not be stored in any memcached node.\n                 */\n                FAILURE,\n                /**\n                 * The session was not modified and therefore the backup was skipped.\n                 */\n                SKIPPED\n        }\n\n    }\n\n    public void setLockingStrategy( @Nullable final LockingStrategy lockingStrategy ) {\n        _lockingStrategy = lockingStrategy;\n    }\n\n}\n","lineNo":120}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.integration.TestUtils.STICKYNESS_PROVIDER;\nimport static de.javakaffee.web.msm.integration.TestUtils.createContext;\nimport static de.javakaffee.web.msm.integration.TestUtils.createSession;\nimport static org.mockito.Matchers.*;\nimport static org.mockito.Mockito.*;\nimport static org.testng.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.internal.OperationFuture;\n\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.core.StandardContext;\nimport org.mockito.ArgumentCaptor;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n\n/**\n * Test the {@link MemcachedSessionService}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class MemcachedSessionServiceTest {\n\n    private MemcachedSessionService _service;\n    private MemcachedClient _memcachedMock;\n    private ExecutorService _executor;\n\n    @BeforeMethod\n    public void setup() throws Exception {\n\n        final SessionManager manager = createSessionManager();\n\n        _service = manager.getMemcachedSessionService();\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.setSessionBackupAsync( false );\n        _service.setSticky( true );\n\n        final StandardContext context = createContext();\n        context.setBackgroundProcessorDelay( 1 ); // needed for test of updateExpiration\n        manager.setContainer( context );\n\n        _memcachedMock = mock( MemcachedClient.class );\n\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE );\n        when( _memcachedMock.set(  any( String.class ), anyInt(), any() ) ).thenReturn( futureMock );\n\n        startInternal( manager, _memcachedMock );\n\n        _executor = Executors.newCachedThreadPool();\n\n    }\n\n    @AfterMethod\n    public void afterMethod() {\n        _executor.shutdown();\n    }\n\n    protected void startInternal( @Nonnull final SessionManager manager, @Nonnull final MemcachedClient memcachedMock ) throws LifecycleException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Nonnull\n    protected abstract SessionManager createSessionManager();\n\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211,n2:127.0.0.1:11212\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    @Test\n    public void testConfigurationFormatFailoverNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.setFailoverNodes( \"n1\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1 n2\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1,n2\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature105() throws LifecycleException {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.startInternal(_memcachedMock);\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), true);\n        _service.shutdown();\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(_memcachedMock);\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), true);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456-n1\"), true);\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105() throws Exception {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.setSessionBackupAsync(false);\n        _service.startInternal(_memcachedMock);\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenThrow(new ExecutionException(new RuntimeException(\"Simulated exception.\")));\n        when( _memcachedMock.set(  eq( session.getId() ), anyInt(), any() ) ).thenReturn( futureMock );\n\n        final BackupResult backupResult = _service.backupSession( session.getIdInternal(), false, null ).get();\n        assertEquals(backupResult.getStatus(), BackupResultStatus.FAILURE);\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() );\n    }\n\n    /**\n     * Test that sessions are only backuped if they are modified.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlySendModifiedSessions() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSession session = createSession( _service );\n\n        /* simulate the first request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the second request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        session.setAttribute( \"bar\", \"baz\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the third request, without session access\n         */\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if session attributes were accessed since the last backup.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        session.access();\n        session.endAccess();\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if the session and its attributes were accessed since the last backup/backup check.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedSessionsAndAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        session.access();\n        session.getAttribute( \"foo\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test for issue #68: External change of sessionId must be handled correctly.\n     *\n     * When the webapp is configured with BASIC auth the sessionId is changed on login since 6.0.21\n     * (AuthenticatorBase.register invokes manager.changeSessionId(session)).\n     * This change of the sessionId was not recognized by msm so that it might have happened that the\n     * session is removed from memcached under the old id but not sent to memcached (if the case the session\n     * was not accessed during this request at all, which is very unprobable but who knows).\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testChangeSessionId( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, TimeoutException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, \"foo\" ).get();\n\n        final String oldSessionId = session.getId();\n        _service.getManager().changeSessionId( session );\n\n        // on session backup we specify sessionIdChanged as false as we're not aware of this fact\n        _service.backupSession( session.getIdInternal(), false, \"foo\" );\n\n        // remove session with old id and add it with the new id\n        verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) );\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n        if ( !stickyness.isSticky() ) {\n            // check validity info\n            verify( _memcachedMock, times( 1 ) ).delete( eq( createValidityInfoKeyName( oldSessionId ) ) );\n            verify( _memcachedMock, times( 1 ) ).set( eq( createValidityInfoKeyName( session.getId() ) ), anyInt(), any() );\n        }\n\n    }\n\n    /**\n     * Test that sessions with a timeout of 0 or less are stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionTimeoutUnlimitedWithSessionLoaded( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, LifecycleException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n            _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n            _service.startInternal(_memcachedMock); // we must put in our mock again\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n        session.setMaxInactiveInterval( -1 );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        final String sessionId = session.getId();\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any() );\n\n        if ( !stickyness.isSticky() ) {\n            // check validity info\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() );\n\n            // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n            // task is executed/finished.\n            _service.getLockingStrategy().getExecutorService().shutdown();\n\n            // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n            Thread.sleep(15);\n\n            final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupSessionKey ), eq( 0 ), any() );\n            final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() );\n        }\n    }\n\n    /**\n     * Test that non-sticky sessions with a timeout of 0 or less that have not been loaded by a request\n     * the validity info is stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test\n    public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded() throws InterruptedException, ExecutionException, LifecycleException, TimeoutException {\n\n        _service.setStickyInternal( false );\n        _service.setLockingMode( LockingMode.NONE, null, false );\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n        _service.startInternal(_memcachedMock); // we must put in our mock again\n\n        final String sessionId = \"someSessionNotLoaded-n1\";\n\n        // stub loading of validity info\n        final String validityKey = createValidityInfoKeyName( sessionId );\n        final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() );\n        when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData );\n\n        // stub session (backup) ping\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get() ).thenReturn( Boolean.FALSE );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE );\n        when( _memcachedMock.add(  any( String.class ), anyInt(), any() ) ).thenReturn( futureMock );\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        // update validity info\n        verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() );\n\n        // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n        // task is executed/finished.\n        _service.getLockingStrategy().getExecutorService().shutdown();\n\n        // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n        Thread.sleep(15);\n\n        // ping session\n        verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() );\n\n        // ping session backup\n        final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n        verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() );\n\n        // update validity backup\n        final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n        verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() );\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: when excluded attributes are accessed/put the session should\n     * not be marked as touched.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testOnlyHashAttributesOfAccessedFilteredAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        verify( transcoderServiceMock, never() ).serializeAttributes( (MemcachedBackupSession)any(), anyMap() );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedInSessionBackup() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized in updateExpirationInMemcached.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.updateExpirationInMemcached();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    @Test\n    public void testSessionsRefCountHandlingIssue111() throws Exception {\n        _service.setSticky(false);\n        _service.setLockingMode(LockingMode.ALL.name());\n\n        final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder());\n        _service.setTranscoderService( transcoderService );\n\n        _service.setMemcachedClient(_memcachedMock);\n        _service.startInternal();\n\n        @SuppressWarnings(\"unchecked\")\n        final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class);\n        when(addResultMock.get()).thenReturn(true);\n        when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true);\n        when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock);\n\n        final MemcachedBackupSession session = createSession( _service );\n        // the session is now already added to the internal session map\n        assertNotNull(session.getId());\n\n        Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n        assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n\n        // start another request that loads the session from mc\n        _service.getLockingStrategy().onRequestStart(mock(Request.class));\n\n        when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session));\n\n        final MemcachedBackupSession session2 = _service.findSession(session.getId());\n        assertTrue(session2.isLocked());\n        assertEquals(session2.getRefCount(), 1);\n        session2.setAttribute(\"foo\", \"bar\");\n\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n\n        // the session is now in the internal session map,\n        // now let's run a concurrent request\n        final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() {\n\n            @Override\n            public BackupResult call() throws Exception {\n                final MemcachedBackupSession session3 = _service.findSession(session.getId());\n                assertSame(session3, session2);\n                assertEquals(session3.getRefCount(), 2);\n                // let the other thread proceed (or wait)\n                barrier.await();\n                // and wait again so that the other thread can do some work\n                barrier.await();\n\n                final Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n                _service.getLockingStrategy().onRequestFinished();\n\n                assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS);\n                // The session should be released now and no longer stored\n                assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n                // just some double checking on expectations...\n                assertEquals(session2.getRefCount(), 0);\n\n                return result.get();\n            }\n\n        });\n\n        barrier.await();\n\n        result = _service.backupSession(session.getId(), false, null);\n        _service.getLockingStrategy().onRequestFinished();\n        assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED);\n        // This is the important point!\n        assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n        // just some double checking on expectations...\n        assertEquals(session2.getRefCount(), 1);\n\n        // now let the other thread proceed\n        barrier.await();\n\n        // and wait for the result, also to get exceptions/assertion errors.\n        request2.get();\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.integration.TestUtils.STICKYNESS_PROVIDER;\nimport static de.javakaffee.web.msm.integration.TestUtils.createContext;\nimport static de.javakaffee.web.msm.integration.TestUtils.createSession;\nimport static org.mockito.Matchers.*;\nimport static org.mockito.Mockito.*;\nimport static org.testng.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.internal.OperationFuture;\n\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.core.StandardContext;\nimport org.mockito.ArgumentCaptor;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n\n/**\n * Test the {@link MemcachedSessionService}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class MemcachedSessionServiceTest {\n\n    private MemcachedSessionService _service;\n    private MemcachedClient _memcachedMock;\n    private ExecutorService _executor;\n\n    @BeforeMethod\n    public void setup() throws Exception {\n\n        final SessionManager manager = createSessionManager();\n\n        _service = manager.getMemcachedSessionService();\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.setSessionBackupAsync( false );\n        _service.setSticky( true );\n\n        final StandardContext context = createContext();\n        context.setBackgroundProcessorDelay( 1 ); // needed for test of updateExpiration\n        manager.setContainer( context );\n\n        _memcachedMock = mock( MemcachedClient.class );\n\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE );\n        when( _memcachedMock.set(  any( String.class ), anyInt(), any() ) ).thenReturn( futureMock );\n\n        startInternal( manager, _memcachedMock );\n\n        _executor = Executors.newCachedThreadPool();\n\n    }\n\n    @AfterMethod\n    public void afterMethod() {\n        _executor.shutdown();\n    }\n\n    protected void startInternal( @Nonnull final SessionManager manager, @Nonnull final MemcachedClient memcachedMock ) throws LifecycleException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Nonnull\n    protected abstract SessionManager createSessionManager();\n\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211,n2:127.0.0.1:11212\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    @Test\n    public void testConfigurationFormatFailoverNodesFeature44() throws LifecycleException {\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" );\n        _service.setFailoverNodes( \"n1\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1 n2\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213\" );\n        _service.setFailoverNodes( \"n1,n2\" );\n        _service.startInternal(_memcachedMock);\n        Assert.assertEquals( _service.getFailoverNodeIds(), Arrays.asList( \"n1\", \"n2\" ) );\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testConfigurationFormatMemcachedNodesFeature105() throws LifecycleException {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.startInternal(_memcachedMock);\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), true);\n        _service.shutdown();\n\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211\" );\n        _service.startInternal(_memcachedMock);\n        assertEquals(_service.getMemcachedNodesManager().getCountNodes(), 1);\n        assertEquals(_service.getMemcachedNodesManager().isEncodeNodeIdInSessionId(), true);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456\"), false);\n        assertEquals(_service.getMemcachedNodesManager().isValidForMemcached(\"123456-n1\"), true);\n    }\n\n    /**\n     * Test for issue #105: Make memcached node optional for single-node setup\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=105\n     */\n    @Test\n    public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105() throws Exception {\n        _service.setMemcachedNodes( \"127.0.0.1:11211\" );\n        _service.setSessionBackupAsync(false);\n        _service.startInternal(_memcachedMock);\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenThrow(new ExecutionException(new RuntimeException(\"Simulated exception.\")));\n        when( _memcachedMock.set(  eq( session.getId() ), anyInt(), any() ) ).thenReturn( futureMock );\n\n        final BackupResult backupResult = _service.backupSession( session.getIdInternal(), false, null ).get();\n        assertEquals(backupResult.getStatus(), BackupResultStatus.FAILURE);\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() );\n    }\n\n    /**\n     * Test that sessions are only backuped if they are modified.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlySendModifiedSessions() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSession session = createSession( _service );\n\n        /* simulate the first request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the second request, with session access\n         */\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        session.setAttribute( \"bar\", \"baz\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        /* simulate the third request, without session access\n         */\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if session attributes were accessed since the last backup.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        session.access();\n        session.endAccess();\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test that session attribute serialization and hash calculation is only\n     * performed if the session and its attributes were accessed since the last backup/backup check.\n     * Otherwise this computing time shall be saved for a better world :-)\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOnlyHashAttributesOfAccessedSessionsAndAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        @SuppressWarnings( \"unchecked\" )\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        session.access();\n        session.getAttribute( \"foo\" );\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n        // we need some millis between last backup and next access (due to check in BackupSessionService)\n        Thread.sleep(5L);\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n        verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) );\n\n    }\n\n    /**\n     * Test for issue #68: External change of sessionId must be handled correctly.\n     *\n     * When the webapp is configured with BASIC auth the sessionId is changed on login since 6.0.21\n     * (AuthenticatorBase.register invokes manager.changeSessionId(session)).\n     * This change of the sessionId was not recognized by msm so that it might have happened that the\n     * session is removed from memcached under the old id but not sent to memcached (if the case the session\n     * was not accessed during this request at all, which is very unprobable but who knows).\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testChangeSessionId( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, TimeoutException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n\n        session.setAttribute( \"foo\", \"bar\" );\n        _service.backupSession( session.getIdInternal(), false, \"foo\" ).get();\n\n        final String oldSessionId = session.getId();\n        _service.getManager().changeSessionId( session );\n\n        // on session backup we specify sessionIdChanged as false as we're not aware of this fact\n        _service.backupSession( session.getIdInternal(), false, \"foo\" );\n\n        // remove session with old id and add it with the new id\n        verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) );\n        verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() );\n\n        if ( !stickyness.isSticky() ) {\n            // check validity info\n            verify( _memcachedMock, times( 1 ) ).delete( eq( createValidityInfoKeyName( oldSessionId ) ) );\n            verify( _memcachedMock, times( 1 ) ).set( eq( createValidityInfoKeyName( session.getId() ) ), anyInt(), any() );\n        }\n\n    }\n\n    /**\n     * Test that sessions with a timeout of 0 or less are stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test( dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionTimeoutUnlimitedWithSessionLoaded( final SessionAffinityMode stickyness ) throws InterruptedException, ExecutionException, LifecycleException {\n\n        _service.setStickyInternal( stickyness.isSticky() );\n        if ( !stickyness.isSticky() ) {\n            _service.setLockingMode( LockingMode.NONE, null, false );\n            _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n            _service.startInternal(_memcachedMock); // we must put in our mock again\n        }\n\n        final MemcachedBackupSession session = createSession( _service );\n        session.setMaxInactiveInterval( -1 );\n\n        session.access();\n        session.endAccess();\n        session.setAttribute( \"foo\", \"bar\" );\n        final String sessionId = session.getId();\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any() );\n\n        if ( !stickyness.isSticky() ) {\n            // check validity info\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() );\n\n            // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n            // task is executed/finished.\n            _service.getLockingStrategy().getExecutorService().shutdown();\n\n            // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n            Thread.sleep(15);\n\n            final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupSessionKey ), eq( 0 ), any() );\n            final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n            verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() );\n        }\n    }\n\n    /**\n     * Test that non-sticky sessions with a timeout of 0 or less that have not been loaded by a request\n     * the validity info is stored in memcached with unlimited\n     * expiration time (0) also (see http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).\n     * For non-sticky sessions that must hold true for all related items stored in memcached (validation,\n     * backup etc.)\n     *\n     * This is the test for issue #88 \"Support session-timeout of 0 or less (no session expiration)\"\n     * http://code.google.com/p/memcached-session-manager/issues/detail?id=88\n     */\n    @Test\n    public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded() throws InterruptedException, ExecutionException, LifecycleException, TimeoutException {\n\n        _service.setStickyInternal( false );\n        _service.setLockingMode( LockingMode.NONE, null, false );\n        _service.setMemcachedNodes( \"n1:127.0.0.1:11211 n2:127.0.0.1:11212\" ); // for backup support\n        _service.startInternal(_memcachedMock); // we must put in our mock again\n\n        final String sessionId = \"someSessionNotLoaded-n1\";\n\n        // stub loading of validity info\n        final String validityKey = createValidityInfoKeyName( sessionId );\n        final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() );\n        when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData );\n\n        // stub session (backup) ping\n        @SuppressWarnings( \"unchecked\" )\n        final OperationFuture<Boolean> futureMock = mock( OperationFuture.class );\n        when( futureMock.get() ).thenReturn( Boolean.FALSE );\n        when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE );\n        when( _memcachedMock.add(  any( String.class ), anyInt(), any() ) ).thenReturn( futureMock );\n\n        _service.backupSession( sessionId, false, null ).get();\n\n        // update validity info\n        verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() );\n\n        // As the backup is done asynchronously, we shutdown the executor so that we know the backup\n        // task is executed/finished.\n        _service.getLockingStrategy().getExecutorService().shutdown();\n\n        // On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux)\n        Thread.sleep(15);\n\n        // ping session\n        verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() );\n\n        // ping session backup\n        final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId );\n        verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() );\n\n        // update validity backup\n        final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey );\n        verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() );\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: when excluded attributes are accessed/put the session should\n     * not be marked as touched.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Test\n    public void testOnlyHashAttributesOfAccessedFilteredAttributes() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        verify( transcoderServiceMock, never() ).serializeAttributes( (MemcachedBackupSession)any(), anyMap() );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedInSessionBackup() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        _service.backupSession( session.getIdInternal(), false, null ).get();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    /**\n     * Tests sessionAttributeFilter attribute: only filtered/allowed attributes must be serialized in updateExpirationInMemcached.\n     */\n    @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n    @Test\n    public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException {\n\n        final TranscoderService transcoderServiceMock = mock( TranscoderService.class );\n        final Map<String, Object> anyMap = any( Map.class );\n        when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] );\n        _service.setTranscoderService( transcoderServiceMock );\n\n        final MemcachedBackupSession session = createSession( _service );\n        _service.setSessionAttributeFilter( \"^(foo|bar)$\" );\n\n        session.setAttribute( \"foo\", \"foo\" );\n        session.setAttribute( \"bar\", \"bar\" );\n        session.setAttribute( \"baz\", \"baz\" );\n\n        session.access();\n        session.endAccess();\n\n        _service.updateExpirationInMemcached();\n\n        // capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher).\n        final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class );\n        verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() );\n\n        // the serialized attributes must only contain allowed ones\n        assertTrue( model.getValue().containsKey( \"foo\" ) );\n        assertTrue( model.getValue().containsKey( \"bar\" ) );\n        assertFalse( model.getValue().containsKey( \"baz\" ) );\n\n    }\n\n    @Test\n    public void testSessionsRefCountHandlingIssue111() throws Exception {\n        _service.setSticky(false);\n        _service.setLockingMode(LockingMode.ALL.name());\n\n        final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder());\n        _service.setTranscoderService( transcoderService );\n\n        _service.setMemcachedClient(_memcachedMock);\n        _service.startInternal();\n\n        @SuppressWarnings(\"unchecked\")\n        final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class);\n        when(addResultMock.get()).thenReturn(true);\n        when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true);\n        when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock);\n\n        final MemcachedBackupSession session = createSession( _service );\n        // the session is now already added to the internal session map\n        assertNotNull(session.getId());\n\n        Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n        assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n\n        // start another request that loads the session from mc\n        final Request requestMock = mock(Request.class);\n        when(requestMock.getNote(eq(SessionTrackerValve2.INVOKED))).thenReturn(Boolean.TRUE);\n        _service.getLockingStrategy().onRequestStart(requestMock);\n\n        when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session));\n\n        final MemcachedBackupSession session2 = _service.findSession(session.getId());\n        assertTrue(session2.isLocked());\n        assertEquals(session2.getRefCount(), 1);\n        session2.setAttribute(\"foo\", \"bar\");\n\n        final CyclicBarrier barrier = new CyclicBarrier(2);\n\n        // the session is now in the internal session map,\n        // now let's run a concurrent request\n        final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() {\n\n            @Override\n            public BackupResult call() throws Exception {\n                final MemcachedBackupSession session3 = _service.findSession(session.getId());\n                assertSame(session3, session2);\n                assertEquals(session3.getRefCount(), 2);\n                // let the other thread proceed (or wait)\n                barrier.await();\n                // and wait again so that the other thread can do some work\n                barrier.await();\n\n                final Future<BackupResult> result = _service.backupSession(session.getId(), false, null);\n                _service.getLockingStrategy().onRequestFinished();\n\n                assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS);\n                // The session should be released now and no longer stored\n                assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n                // just some double checking on expectations...\n                assertEquals(session2.getRefCount(), 0);\n\n                return result.get();\n            }\n\n        });\n\n        barrier.await();\n\n        result = _service.backupSession(session.getId(), false, null);\n        _service.getLockingStrategy().onRequestFinished();\n        assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED);\n        // This is the important point!\n        assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId()));\n        // just some double checking on expectations...\n        assertEquals(session2.getRefCount(), 1);\n\n        // now let the other thread proceed\n        barrier.await();\n\n        // and wait for the result, also to get exceptions/assertion errors.\n        request2.get();\n\n    }\n\n}\n","lineNo":562}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.DELETE_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.LOAD_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.SESSION_DESERIALIZATION;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.BinaryConnectionFactory;\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.ConnectionFactoryBuilder;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.auth.AuthDescriptor;\nimport net.spy.memcached.auth.PlainCallbackHandler;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This is the core of memcached session manager, managing sessions in memcached.\n * A {@link SessionManager} interface represents the dependency to tomcats session manager\n * (which normally keeps sessions in memory). This {@link SessionManager} has to be subclassed\n * for a concrete major tomcat version (e.g. for 7.x.x) and configured in the context.xml\n * as manager (see <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SetupAndConfiguration\">SetupAndConfiguration<\/a>)\n * for more. The {@link SessionManager} then has to pass configuration settings to this\n * {@link MemcachedSessionService}. Relevant lifecycle methods are {@link #startInternal()}\n * and {@link #shutdown()}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class MemcachedSessionService implements SessionBackupService {\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    static class ConnectionType {\n\n        private final boolean membaseBucketConfig;\n        private final String username;\n        private final String password;\n        public ConnectionType(final boolean membaseBucketConfig, final String username, final String password) {\n            this.membaseBucketConfig = membaseBucketConfig;\n            this.username = username;\n            this.password = password;\n        }\n        public static ConnectionType valueOf(final boolean membaseBucketConfig, final String username, final String password) {\n            return new ConnectionType(membaseBucketConfig, username, password);\n        }\n        boolean isMembaseBucketConfig() {\n            return membaseBucketConfig;\n        }\n        boolean isSASL() {\n            return !membaseBucketConfig && !isBlank(username) && !isBlank(password);\n        }\n        boolean isDefault() {\n            return !isMembaseBucketConfig() && !isSASL();\n        }\n\n        boolean isBlank(final String value) {\n            return value == null || value.trim().length() == 0;\n        }\n    }\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * The pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private String _sessionAttributeFilter = null;\n\n    /**\n     * The compiled pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private Pattern _sessionAttributePattern = null;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private String _username;\n    private String _password;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n\tprivate MemcachedNodesManager _memcachedNodesManager;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n    private long _operationTimeout = 1000;\n\n    private SessionTrackerValve _sessionTrackerValve;\n\n    private final SessionManager _manager;\n\tprivate final MemcachedClientCallback _memcachedClientCallback = createMemcachedClientCallback();\n\n    private final LRUCache<String, Object> _removedSessions = new LRUCache<String, Object>( 2000, 5000 );\n\n    public MemcachedSessionService( final SessionManager manager ) {\n        _manager = manager;\n    }\n\n    /**\n     * Returns the tomcat session manager.\n     * @return the session manager\n     */\n    @Nonnull\n    public SessionManager getManager() {\n        return _manager;\n    }\n\n    public static interface SessionManager extends Manager {\n        SessionTrackerValve createSessionTrackerValve(\n                @Nullable final String requestUriIgnorePattern,\n                @Nonnull final Statistics statistics,\n                @Nonnull final AtomicBoolean enabled );\n        String generateSessionId();\n        void expireSession( final String sessionId );\n        MemcachedBackupSession getSessionInternal( String sessionId );\n        Map<String, Session> getSessionsInternal();\n\n        String getJvmRoute();\n\n        /**\n          * Get a string from the underlying resource bundle or return\n          * null if the String is not found.\n          * @param key to desired resource String\n          * @return resource String matching <i>key<\/i> from underlying\n          *         bundle or null if not found.\n          * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(String key);\n\n        /**\n         * Get a string from the underlying resource bundle and format\n         * it with the given set of arguments.\n         *\n         * @param key to desired resource String\n         * @param args args for placeholders in the string\n         * @return resource String matching <i>key<\/i> from underlying\n         *         bundle or null if not found.\n         * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(final String key, final Object... args);\n\n        int getMaxActiveSessions();\n        void incrementSessionCounter();\n        void incrementRejectedSessions();\n\n        /**\n         * Remove this Session from the active Sessions for this Manager without\n         * removing it from memcached.\n         *\n         * @param session   Session to be removed\n         * @param update    Should the expiration statistics be updated (since tomcat7)\n         */\n        void removeInternal( final Session session, final boolean update );\n\n        /**\n         * Must return the initialized status. Must return <code>true<\/code> if this manager\n         * has already been started.\n         * @return the initialized status\n         */\n        boolean isInitialized();\n\n        @Nonnull\n        MemcachedSessionService getMemcachedSessionService();\n\n        /**\n         * Return the Container with which this Manager is associated.\n         */\n        @Override\n        @Nonnull\n        Container getContainer();\n\n        /**\n         * Reads the Principal from the given OIS.\n         * @param ois the object input stream to read from. Will be closed by the caller.\n         * @return the deserialized principal\n         * @throws ClassNotFoundException expected to be declared by the implementation.\n         * @throws IOException expected to be declared by the implementation.\n         */\n        @Nonnull\n        Principal readPrincipal( @Nonnull ObjectInputStream ois ) throws ClassNotFoundException, IOException;\n\n        // --------------------- setters for testing\n        /**\n         * Sets the sticky mode, must be provided for tests at least.\n         * @param sticky the stickyness.\n         */\n        void setSticky( boolean sticky );\n        void setEnabled( boolean b );\n        void setOperationTimeout(long operationTimeout);\n\n        /**\n         * Set the manager checks frequency in seconds.\n         * @param processExpiresFrequency the new manager checks frequency\n         */\n        void setProcessExpiresFrequency( int processExpiresFrequency );\n        void setMemcachedNodes( @Nonnull String memcachedNodes );\n        void setFailoverNodes( String failoverNodes );\n        void setLockingMode( @Nullable final String lockingMode );\n        void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup );\n        void setUsername(String username);\n        void setPassword(String password);\n\n        /**\n         * Creates a new instance of {@link MemcachedBackupSession} (needed so that it's possible to\n         * create specialized {@link MemcachedBackupSession} instances).\n         */\n        @Nonnull\n        MemcachedBackupSession newMemcachedBackupSession();\n    }\n\n    public void shutdown() {\n        _log.info( \"Stopping services.\" );\n        _backupSessionService.shutdown();\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.shutdown();\n        }\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _memcached = memcachedClient;\n        startInternal();\n    }\n\n    /**\n     * Initialize this manager.\n     */\n    void startInternal() throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        _memcachedNodesManager = createMemcachedNodesManager( _memcachedNodes, _failoverNodes);\n\n        if(_memcached == null) {\n            _memcached = createMemcachedClient( _memcachedNodesManager, _statistics );\n        }\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _sessionTrackerValve = _manager.createSessionTrackerValve( _requestUriIgnorePattern,  _statistics, _enabled );\n        _manager.getContainer().getPipeline().addValve( _sessionTrackerValve );\n\n        initNonStickyLockingMode( _memcachedNodesManager );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, sticky \"+ _sticky + \", operation timeout \" + _operationTimeout +\", with node ids \" +\n        \t\t_memcachedNodesManager.getPrimaryNodeIds() + \" and failover node ids \" + _memcachedNodesManager.getFailoverNodeIds() );\n\n    }\n\n\tprotected MemcachedClientCallback createMemcachedClientCallback() {\n\t\treturn new MemcachedClientCallback() {\n\t\t\t@Override\n\t\t\tpublic Object get(final String key) {\n\t\t\t\treturn _memcached.get(key);\n\t\t\t}\n\t\t};\n\t}\n\n    protected MemcachedNodesManager createMemcachedNodesManager(final String memcachedNodes, final String failoverNodes) {\n\t\treturn MemcachedNodesManager.createFor( memcachedNodes, failoverNodes, _memcachedClientCallback );\n\t}\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( _manager ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final MemcachedNodesManager memcachedNodesManager,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionType connectionType = ConnectionType.valueOf(memcachedNodesManager.isMembaseBucketConfig(), _username, _password);\n            final ConnectionFactory connectionFactory = createConnectionFactory(memcachedNodesManager, connectionType, statistics);\n            if (connectionType.isMembaseBucketConfig()) {\n            \t// For membase connectivity: http://docs.couchbase.org/membase-sdk-java-api-reference/membase-sdk-java-started.html\n            \t// And: http://code.google.com/p/spymemcached/wiki/Examples#Establishing_a_Membase_Connection\n                return new MemcachedClient(memcachedNodesManager.getMembaseBucketURIs(), _username, _password);\n            }\n            return new MemcachedClient(connectionFactory, memcachedNodesManager.getAllMemcachedAddresses());\n        } catch (final Exception e) {\n            throw new RuntimeException(\"Could not create memcached client\", e);\n        }\n    }\n\n    protected ConnectionFactory createConnectionFactory(final MemcachedNodesManager memcachedNodesManager,\n            final ConnectionType connectionType, final Statistics statistics ) {\n        if (PROTOCOL_BINARY.equals( _memcachedProtocol )) {\n            if (connectionType.isSASL()) {\n                // FIXME: CF with AuthDescriptor is only used if nodeIdIsNotEncodedInSessionId.\n                // Shouldn't the AuthDescriptor also be used if !nodeIdIsNotEncodedInSessionId?\n                return memcachedNodesManager.isEncodeNodeIdInSessionId()\n                        ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                                memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout )\n                        : new ConnectionFactoryBuilder().setProtocol(ConnectionFactoryBuilder.Protocol.BINARY)\n                                .setAuthDescriptor(new AuthDescriptor(new String[]{\"PLAIN\"},\n                                        new PlainCallbackHandler(_username, _password)))\n                                .setOpTimeout(_operationTimeout).build();\n            }\n            else if (connectionType.isMembaseBucketConfig()) {\n                return new ConnectionFactoryBuilder()\n                    .setProtocol(ConnectionFactoryBuilder.Protocol.BINARY)\n                    .setOpTimeout(_operationTimeout).build();\n            }\n            else {\n                return memcachedNodesManager.isEncodeNodeIdInSessionId() ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                        memcachedNodesManager.getSessionIdFormat(),\n                        statistics, _operationTimeout ) : new BinaryConnectionFactory();\n            }\n        }\n        return memcachedNodesManager.isEncodeNodeIdInSessionId()\n        \t\t? new SuffixLocatorConnectionFactory( memcachedNodesManager, memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout )\n        \t\t: new DefaultConnectionFactory();\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = _manager.getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String newSessionId( @Nonnull final String sessionId ) {\n        return _memcachedNodesManager.createSessionId( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    public MemcachedBackupSession findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = _manager.getSessionInternal( id );\n        if ( result != null ) {\n            if (!_sticky && !_lockingStrategy.isContainerSessionLookup()) {\n                result.registerReference();\n            }\n        }\n        else if ( canHitMemcached( id ) && _missingSessionsCache.get( id ) == null ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            // or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based\n            // constraint needs the session to get the authenticated principal)\n            if ( !_sticky && _lockingStrategy.isContainerSessionLookup()\n                    && !contextHasFormBasedSecurityConstraint() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                if(!_sticky) {\n                    // synchronized to have correct refcounts\n                    synchronized (_manager.getSessionsInternal()) {\n                        // in the meantime another request might have loaded and added the session,\n                        // and we must ensure to have a single session instance per id to have\n                        // correct refcounts (otherwise a session might be removed from the map at\n                        // the end of #backupSession\n                        if(_manager.getSessionInternal(id) != null) {\n                            result = _manager.getSessionInternal(id);\n                        }\n                        else {\n                            addValidLoadedSession(result);\n                        }\n                        result.registerReference();\n                    }\n                }\n                else {\n                    addValidLoadedSession(result);\n                }\n            }\n        }\n        return result;\n    }\n\n    private void addValidLoadedSession(final MemcachedBackupSession result) {\n        // When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver\n        // (due to a tomcat failover) we don't want to notify listeners via session.activate for the\n        // old sessionId but do that later (in handleSessionTakeOver)\n        // See also http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        String jvmRoute;\n        final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null\n            && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( result.getId() ) );\n\n        final boolean activate = !sessionIdWillBeChanged;\n        addValidLoadedSession( result, activate );\n    }\n\n    private boolean contextHasFormBasedSecurityConstraint() {\n        final Context context = (Context)_manager.getContainer();\n        final SecurityConstraint[] constraints = context.findConstraints();\n        final LoginConfig loginConfig = context.getLoginConfig();\n        return constraints != null && constraints.length > 0\n                && loginConfig != null && Constants.FORM_METHOD.equals( loginConfig.getAuthMethod() );\n    }\n\n    private void addValidLoadedSession( final StandardSession session, final boolean activate ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        _manager.add( session );\n        if ( activate ) {\n            session.activate();\n        }\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        MemcachedBackupSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcachedWithCheck( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session, true );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() );\n\n            if ( sessionId == null || !_memcachedNodesManager.canHitMemcached( sessionId ) ) {\n                sessionId = _manager.generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        _manager.incrementSessionCounter();\n\n        return session;\n\n    }\n\n    /**\n     * Is invoked when a session was removed from the manager, e.g. because the\n     * session has been invalidated. Is used to keep track of such sessions in\n     * non-sticky mode, so that lockingStrategy.onBackupWithoutLoadedSession is not\n     * invoked.\n     *\n     * Motivated by issue 116.\n     *\n     * @param id the id of the removed session.\n     */\n    public void sessionRemoved(final String id) {\n        if(!_sticky) {\n            _removedSessions.put(id, \"unused\");\n        }\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _manager.getMaxActiveSessions() >= 0 && _manager.getSessionsInternal().size() >= _manager.getMaxActiveSessions() ) {\n            _manager.incrementRejectedSessions();\n            throw new IllegalStateException\n                (_manager.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = _manager.newMemcachedBackupSession();\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = _manager.getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( getSessionIdFormat().extractJvmRoute( requestedSessionId ) ) ) {\n\n            // the session might have been loaded already (by some valve), so let's check our session map\n            MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n            if ( session == null ) {\n                session = loadFromMemcachedWithCheck( requestedSessionId );\n            }\n\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    @Nonnull\n\tprivate SessionIdFormat getSessionIdFormat() {\n\t\treturn _memcachedNodesManager.getSessionIdFormat();\n\t}\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = getSessionIdFormat().changeJvmRoute( session.getIdInternal(), _manager.getJvmRoute() );\n\n        // If this session was already loaded we need to remove it from the session map\n        // See http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        if ( _manager.getSessionsInternal().containsKey( origSessionId ) ) {\n            _manager.getSessionsInternal().remove( origSessionId );\n        }\n\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session, true );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _memcachedNodesManager.isValidForMemcached( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId );\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n    \tif ( !_memcachedNodesManager.isEncodeNodeIdInSessionId() ) {\n    \t\treturn null;\n    \t}\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                \tfinal String newSessionId = _memcachedNodesManager.getNewSessionIdIfNodeFromSessionIdUnavailable( session.getId() );\n                    if ( newSessionId != null ) {\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            } else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _memcachedNodesManager.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                _log.info( \"Session needs to be relocated as node \"+ nodeId +\" is not available, loading backup session for \" + requestedSessionId );\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    _log.debug( \"Loaded backup session for \" + requestedSessionId + \", adding locally with \"+ backupSession.getIdInternal() +\".\" );\n                    addValidLoadedSession( backupSession, true );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final RuntimeException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n        if ( nodeId == null ) {\n            _log.info( \"Cannot load backupSession for sessionId without nodeId: \"+ requestedSessionId );\n            return null;\n        }\n\n        final String newNodeId = _memcachedNodesManager.getNextAvailableNodeId(nodeId);\n        if ( newNodeId == null ) {\n            _log.info( \"No next available node found for nodeId \"+ nodeId );\n            return null;\n        }\n\n        MemcachedBackupSession result = loadBackupSession(requestedSessionId, newNodeId);\n        String nextNodeId = nodeId;\n        // if we didn't find the backup in the next node, let's go through other nodes\n        // to see if the backup is there. For this we have to fake the session id so that\n        // the SuffixBasedNodeLocator selects another backup node.\n        while(result == null\n                && (nextNodeId = _memcachedNodesManager.getNextAvailableNodeId(nextNodeId)) != null\n                && !nextNodeId.equals(nodeId)) {\n            final String newSessionId = getSessionIdFormat().createNewSessionId(requestedSessionId, nextNodeId);\n            result = loadBackupSession(newSessionId, newNodeId);\n        }\n\n        if ( result == null ) {\n            _log.info( \"No backup found for sessionId \" + requestedSessionId );\n            return null;\n        }\n\n        return result;\n    }\n\n    private MemcachedBackupSession loadBackupSession(final String requestedSessionId, final String newNodeId) {\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( getSessionIdFormat().createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, _manager );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n            final String newSessionId = getSessionIdFormat().createNewSessionId( requestedSessionId, newNodeId );\n            _log.info( \"Session backup loaded from secondary memcached for \"+ requestedSessionId +\" (will be relocated),\" +\n            \t\t\" setting new id \"+ newSessionId +\" on session...\" );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n            return null;\n        }\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param sessionId\n     *            the id of the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    @Override\n    public Future<BackupResult> backupSession( final String sessionId, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n        if ( msmSession == null ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"No session found in session map for \" + sessionId );\n            if ( !_sticky ) {\n                // Issue 116: Only notify the lockingStrategy if the session has not been removed/invalidated\n                if(_removedSessions.remove(sessionId) == null) {\n                    _lockingStrategy.onBackupWithoutLoadedSession( sessionId, requestId, _backupSessionService );\n                }\n            }\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !msmSession.isValidInternal() ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"Non valid session found in session map for \" + sessionId );\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !_sticky ) {\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= msmSession.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId can access memcached.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _memcachedNodesManager.canHitMemcached( sessionId );\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n        }\n\n        LockStatus lockStatus = null;\n        try {\n\n            if ( !_sticky ) {\n                lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n            }\n\n            final long start = System.currentTimeMillis();\n\n            /* In the previous version (<1.2) the session was completely serialized by\n             * custom Transcoder implementations.\n             * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n             * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n             * specializations.\n             */\n            final Object object = _memcached.get( sessionId );\n            _memcachedNodesManager.onLoadFromMemcachedSuccess( sessionId );\n\n            if ( object != null ) {\n                if ( !(object instanceof byte[]) ) {\n                    throw new RuntimeException( \"The loaded object for sessionId \" + sessionId + \" is not of required type byte[], but \" + object.getClass().getName() );\n                }\n                final long startDeserialization = System.currentTimeMillis();\n                final MemcachedBackupSession result = _transcoderService.deserialize( (byte[]) object, _manager );\n                _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                result.setSticky( _sticky );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                }\n\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Found session with id \" + sessionId );\n                }\n                return result;\n            }\n            else {\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n                _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                }\n                return null;\n            }\n\n        } catch ( final Exception e ) {\n            _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            if ( lockStatus == LockStatus.LOCKED ) {\n                _lockingStrategy.releaseLock( sessionId );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + memcachedNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedNodesManager reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( memcachedNodesManager, _statistics );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, memcachedNodesManager, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _memcachedNodesManager = memcachedNodesManager;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( memcachedNodesManager );\n\n        return memcachedNodesManager;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + failoverNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * Return the compiled pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributePattern\n     */\n    @CheckForNull\n    Pattern getSessionAttributePattern() {\n        return _sessionAttributePattern;\n    }\n\n    /**\n     * Return the string pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributeFilter\n     */\n    @CheckForNull\n    public String getSessionAttributeFilter() {\n        return _sessionAttributeFilter;\n    }\n\n    /**\n     * Set the pattern used for including session attributes to a session-backup.\n     * If not set, all session attributes will be part of the session-backup.\n     * <p>\n     * E.g. <code>^(userName|sessionHistory)$<\/code>\n     * <\/p>\n     *\n     * @param sessionAttributeFilter\n     *            the sessionAttributeNames to set\n     */\n    public void setSessionAttributeFilter( @Nullable final String sessionAttributeFilter ) {\n        if ( sessionAttributeFilter == null || sessionAttributeFilter.trim().equals(\"\") ) {\n            _sessionAttributeFilter = null;\n            _sessionAttributePattern = null;\n        }\n        else {\n            _sessionAttributeFilter = sessionAttributeFilter;\n            _sessionAttributePattern = Pattern.compile( sessionAttributeFilter );\n        }\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && _manager.isInitialized() ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && _manager.isInitialized() ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && _manager.getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + _manager.getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( @Nullable final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode != null && lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( _manager.isInitialized() ) {\n            initNonStickyLockingMode( createMemcachedNodesManager( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n\tprivate void initNonStickyLockingMode( @Nonnull final MemcachedNodesManager config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        if ( _sessionAttributeFilter != null ) {\n            _log.warn( \"There's a sessionAttributesFilter configured ('\" + _sessionAttributeFilter + \"'),\" +\n                    \" all other session attributes will be lost after the request due to non-sticky configuration!\" );\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1;\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _memcachedNodesManager,\n                _missingSessionsCache, storeSecondaryBackup, _statistics );\n        if ( _sessionTrackerValve != null ) {\n            _sessionTrackerValve.setLockingStrategy( _lockingStrategy );\n        }\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = _manager.findSessions();\n            final int delay = _manager.getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMaxInactiveInterval() > 0 // for <= 0 the session was stored in memcached with expiration 0\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && _manager.isInitialized() ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout from {@link #getSessionBackupTimeout()} is\n     * evaluated.\n     */\n    public boolean isSessionBackupAsync() {\n        return _sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed when {@link #getSessionBackupAsync()}) is <code>false<\/code>.\n     */\n    public long getSessionBackupTimeout() {\n        return _sessionBackupTimeout;\n    }\n\n    public Statistics getStatistics() {\n        return _statistics;\n    }\n\n\tpublic long getOperationTimeout() {\n\t\treturn _operationTimeout;\n\t}\n\n\tpublic void setOperationTimeout(final long operationTimeout ) {\n\t\t_operationTimeout = operationTimeout;\n\t}\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n    }\n\n    /**\n     * Return the memcached nodes manager.\n     */\n    @Nonnull\n    MemcachedNodesManager getMemcachedNodesManager() {\n        return _memcachedNodesManager;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _memcachedNodesManager.getPrimaryNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _memcachedNodesManager.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    void setMemcachedClient(final MemcachedClient memcachedClient) {\n        _memcached = memcachedClient;\n    }\n\n    /**\n     * The currently set locking strategy.\n     */\n    @Nullable\n    LockingStrategy getLockingStrategy() {\n        return _lockingStrategy;\n    }\n\n    public void setUsername(final String username) {\n        _username = username;\n    }\n\n    /**\n     * username required for SASL Connection types\n     * @return\n     */\n    public String getUsername() {\n        return _username;\n    }\n\n    public void setPassword(final String password) {\n       _password = password;\n    }\n\n    /**\n     * password required for SASL Connection types\n     * @return\n     */\n    public String getPassword() {\n        return _password;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.DELETE_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.LOAD_FROM_MEMCACHED;\nimport static de.javakaffee.web.msm.Statistics.StatsType.SESSION_DESERIALIZATION;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.security.Principal;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.BinaryConnectionFactory;\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.ConnectionFactoryBuilder;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.auth.AuthDescriptor;\nimport net.spy.memcached.auth.PlainCallbackHandler;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This is the core of memcached session manager, managing sessions in memcached.\n * A {@link SessionManager} interface represents the dependency to tomcats session manager\n * (which normally keeps sessions in memory). This {@link SessionManager} has to be subclassed\n * for a concrete major tomcat version (e.g. for 7.x.x) and configured in the context.xml\n * as manager (see <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SetupAndConfiguration\">SetupAndConfiguration<\/a>)\n * for more. The {@link SessionManager} then has to pass configuration settings to this\n * {@link MemcachedSessionService}. Relevant lifecycle methods are {@link #startInternal()}\n * and {@link #shutdown()}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class MemcachedSessionService implements SessionBackupService {\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    static class ConnectionType {\n\n        private final boolean membaseBucketConfig;\n        private final String username;\n        private final String password;\n        public ConnectionType(final boolean membaseBucketConfig, final String username, final String password) {\n            this.membaseBucketConfig = membaseBucketConfig;\n            this.username = username;\n            this.password = password;\n        }\n        public static ConnectionType valueOf(final boolean membaseBucketConfig, final String username, final String password) {\n            return new ConnectionType(membaseBucketConfig, username, password);\n        }\n        boolean isMembaseBucketConfig() {\n            return membaseBucketConfig;\n        }\n        boolean isSASL() {\n            return !membaseBucketConfig && !isBlank(username) && !isBlank(password);\n        }\n        boolean isDefault() {\n            return !isMembaseBucketConfig() && !isSASL();\n        }\n\n        boolean isBlank(final String value) {\n            return value == null || value.trim().length() == 0;\n        }\n    }\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * The pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private String _sessionAttributeFilter = null;\n\n    /**\n     * The compiled pattern used for including session attributes to a session-backup,\n     *  e.g. <code>^(userName|sessionHistory)$<\/code>. If not set, all session\n     *  attributes will be part of the session-backup.\n     */\n    private Pattern _sessionAttributePattern = null;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private String _username;\n    private String _password;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n\tprivate MemcachedNodesManager _memcachedNodesManager;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n    private long _operationTimeout = 1000;\n\n    private SessionTrackerValve _sessionTrackerValve;\n\n    private final SessionManager _manager;\n\tprivate final MemcachedClientCallback _memcachedClientCallback = createMemcachedClientCallback();\n\n    private final LRUCache<String, Object> _removedSessions = new LRUCache<String, Object>( 2000, 5000 );\n\n    public MemcachedSessionService( final SessionManager manager ) {\n        _manager = manager;\n    }\n\n    /**\n     * Returns the tomcat session manager.\n     * @return the session manager\n     */\n    @Nonnull\n    public SessionManager getManager() {\n        return _manager;\n    }\n\n    public static interface SessionManager extends Manager {\n        SessionTrackerValve createSessionTrackerValve(\n                @Nullable final String requestUriIgnorePattern,\n                @Nonnull final Statistics statistics,\n                @Nonnull final AtomicBoolean enabled );\n        String generateSessionId();\n        void expireSession( final String sessionId );\n        MemcachedBackupSession getSessionInternal( String sessionId );\n        Map<String, Session> getSessionsInternal();\n\n        String getJvmRoute();\n\n        /**\n          * Get a string from the underlying resource bundle or return\n          * null if the String is not found.\n          * @param key to desired resource String\n          * @return resource String matching <i>key<\/i> from underlying\n          *         bundle or null if not found.\n          * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(String key);\n\n        /**\n         * Get a string from the underlying resource bundle and format\n         * it with the given set of arguments.\n         *\n         * @param key to desired resource String\n         * @param args args for placeholders in the string\n         * @return resource String matching <i>key<\/i> from underlying\n         *         bundle or null if not found.\n         * @throws IllegalArgumentException if <i>key<\/i> is null.\n         */\n        String getString(final String key, final Object... args);\n\n        int getMaxActiveSessions();\n        void incrementSessionCounter();\n        void incrementRejectedSessions();\n\n        /**\n         * Remove this Session from the active Sessions for this Manager without\n         * removing it from memcached.\n         *\n         * @param session   Session to be removed\n         * @param update    Should the expiration statistics be updated (since tomcat7)\n         */\n        void removeInternal( final Session session, final boolean update );\n\n        /**\n         * Must return the initialized status. Must return <code>true<\/code> if this manager\n         * has already been started.\n         * @return the initialized status\n         */\n        boolean isInitialized();\n\n        @Nonnull\n        MemcachedSessionService getMemcachedSessionService();\n\n        /**\n         * Return the Container with which this Manager is associated.\n         */\n        @Override\n        @Nonnull\n        Container getContainer();\n\n        /**\n         * Reads the Principal from the given OIS.\n         * @param ois the object input stream to read from. Will be closed by the caller.\n         * @return the deserialized principal\n         * @throws ClassNotFoundException expected to be declared by the implementation.\n         * @throws IOException expected to be declared by the implementation.\n         */\n        @Nonnull\n        Principal readPrincipal( @Nonnull ObjectInputStream ois ) throws ClassNotFoundException, IOException;\n\n        // --------------------- setters for testing\n        /**\n         * Sets the sticky mode, must be provided for tests at least.\n         * @param sticky the stickyness.\n         */\n        void setSticky( boolean sticky );\n        void setEnabled( boolean b );\n        void setOperationTimeout(long operationTimeout);\n\n        /**\n         * Set the manager checks frequency in seconds.\n         * @param processExpiresFrequency the new manager checks frequency\n         */\n        void setProcessExpiresFrequency( int processExpiresFrequency );\n        void setMemcachedNodes( @Nonnull String memcachedNodes );\n        void setFailoverNodes( String failoverNodes );\n        void setLockingMode( @Nullable final String lockingMode );\n        void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup );\n        void setUsername(String username);\n        void setPassword(String password);\n\n        /**\n         * Creates a new instance of {@link MemcachedBackupSession} (needed so that it's possible to\n         * create specialized {@link MemcachedBackupSession} instances).\n         */\n        @Nonnull\n        MemcachedBackupSession newMemcachedBackupSession();\n    }\n\n    public void shutdown() {\n        _log.info( \"Stopping services.\" );\n        _backupSessionService.shutdown();\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.shutdown();\n        }\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _memcached = memcachedClient;\n        startInternal();\n    }\n\n    /**\n     * Initialize this manager.\n     */\n    void startInternal() throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        _memcachedNodesManager = createMemcachedNodesManager( _memcachedNodes, _failoverNodes);\n\n        if(_memcached == null) {\n            _memcached = createMemcachedClient( _memcachedNodesManager, _statistics );\n        }\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _sessionTrackerValve = _manager.createSessionTrackerValve( _requestUriIgnorePattern,  _statistics, _enabled );\n        _manager.getContainer().getPipeline().addValve( _sessionTrackerValve );\n\n        initNonStickyLockingMode( _memcachedNodesManager );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, sticky \"+ _sticky + \", operation timeout \" + _operationTimeout +\", with node ids \" +\n        \t\t_memcachedNodesManager.getPrimaryNodeIds() + \" and failover node ids \" + _memcachedNodesManager.getFailoverNodeIds() );\n\n    }\n\n\tprotected MemcachedClientCallback createMemcachedClientCallback() {\n\t\treturn new MemcachedClientCallback() {\n\t\t\t@Override\n\t\t\tpublic Object get(final String key) {\n\t\t\t\treturn _memcached.get(key);\n\t\t\t}\n\t\t};\n\t}\n\n    protected MemcachedNodesManager createMemcachedNodesManager(final String memcachedNodes, final String failoverNodes) {\n\t\treturn MemcachedNodesManager.createFor( memcachedNodes, failoverNodes, _memcachedClientCallback );\n\t}\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( _manager ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final MemcachedNodesManager memcachedNodesManager,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionType connectionType = ConnectionType.valueOf(memcachedNodesManager.isMembaseBucketConfig(), _username, _password);\n            final ConnectionFactory connectionFactory = createConnectionFactory(memcachedNodesManager, connectionType, statistics);\n            if (connectionType.isMembaseBucketConfig()) {\n            \t// For membase connectivity: http://docs.couchbase.org/membase-sdk-java-api-reference/membase-sdk-java-started.html\n            \t// And: http://code.google.com/p/spymemcached/wiki/Examples#Establishing_a_Membase_Connection\n                return new MemcachedClient(memcachedNodesManager.getMembaseBucketURIs(), _username, _password);\n            }\n            return new MemcachedClient(connectionFactory, memcachedNodesManager.getAllMemcachedAddresses());\n        } catch (final Exception e) {\n            throw new RuntimeException(\"Could not create memcached client\", e);\n        }\n    }\n\n    protected ConnectionFactory createConnectionFactory(final MemcachedNodesManager memcachedNodesManager,\n            final ConnectionType connectionType, final Statistics statistics ) {\n        if (PROTOCOL_BINARY.equals( _memcachedProtocol )) {\n            if (connectionType.isSASL()) {\n                final AuthDescriptor authDescriptor = new AuthDescriptor(new String[]{\"PLAIN\"}, new PlainCallbackHandler(_username, _password));\n                return memcachedNodesManager.isEncodeNodeIdInSessionId()\n                        ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                                memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout,\n                                authDescriptor)\n                        : new ConnectionFactoryBuilder().setProtocol(ConnectionFactoryBuilder.Protocol.BINARY)\n                                .setAuthDescriptor(authDescriptor)\n                                .setOpTimeout(_operationTimeout).build();\n            }\n            else if (connectionType.isMembaseBucketConfig()) {\n                return new ConnectionFactoryBuilder()\n                    .setProtocol(ConnectionFactoryBuilder.Protocol.BINARY)\n                    .setOpTimeout(_operationTimeout).build();\n            }\n            else {\n                return memcachedNodesManager.isEncodeNodeIdInSessionId() ? new SuffixLocatorBinaryConnectionFactory( memcachedNodesManager,\n                        memcachedNodesManager.getSessionIdFormat(),\n                        statistics, _operationTimeout ) : new BinaryConnectionFactory();\n            }\n        }\n        return memcachedNodesManager.isEncodeNodeIdInSessionId()\n        \t\t? new SuffixLocatorConnectionFactory( memcachedNodesManager, memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout )\n        \t\t: new DefaultConnectionFactory();\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = _manager.getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String newSessionId( @Nonnull final String sessionId ) {\n        return _memcachedNodesManager.createSessionId( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    public MemcachedBackupSession findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = _manager.getSessionInternal( id );\n        if ( result != null ) {\n            if (!_sticky && !_lockingStrategy.isContainerSessionLookup()) {\n                result.registerReference();\n            }\n        }\n        else if ( canHitMemcached( id ) && _missingSessionsCache.get( id ) == null ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            // or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based\n            // constraint needs the session to get the authenticated principal)\n            if ( !_sticky && _lockingStrategy.isContainerSessionLookup()\n                    && !contextHasFormBasedSecurityConstraint() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                if(!_sticky) {\n                    // synchronized to have correct refcounts\n                    synchronized (_manager.getSessionsInternal()) {\n                        // in the meantime another request might have loaded and added the session,\n                        // and we must ensure to have a single session instance per id to have\n                        // correct refcounts (otherwise a session might be removed from the map at\n                        // the end of #backupSession\n                        if(_manager.getSessionInternal(id) != null) {\n                            result = _manager.getSessionInternal(id);\n                        }\n                        else {\n                            addValidLoadedSession(result);\n                        }\n                        result.registerReference();\n                    }\n                }\n                else {\n                    addValidLoadedSession(result);\n                }\n            }\n        }\n        return result;\n    }\n\n    private void addValidLoadedSession(final MemcachedBackupSession result) {\n        // When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver\n        // (due to a tomcat failover) we don't want to notify listeners via session.activate for the\n        // old sessionId but do that later (in handleSessionTakeOver)\n        // See also http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        String jvmRoute;\n        final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null\n            && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( result.getId() ) );\n\n        final boolean activate = !sessionIdWillBeChanged;\n        addValidLoadedSession( result, activate );\n    }\n\n    private boolean contextHasFormBasedSecurityConstraint() {\n        final Context context = (Context)_manager.getContainer();\n        final SecurityConstraint[] constraints = context.findConstraints();\n        final LoginConfig loginConfig = context.getLoginConfig();\n        return constraints != null && constraints.length > 0\n                && loginConfig != null && Constants.FORM_METHOD.equals( loginConfig.getAuthMethod() );\n    }\n\n    private void addValidLoadedSession( final StandardSession session, final boolean activate ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        _manager.add( session );\n        if ( activate ) {\n            session.activate();\n        }\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        MemcachedBackupSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcachedWithCheck( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session, true );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() );\n\n            if ( sessionId == null || !_memcachedNodesManager.canHitMemcached( sessionId ) ) {\n                sessionId = _manager.generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        _manager.incrementSessionCounter();\n\n        return session;\n\n    }\n\n    /**\n     * Is invoked when a session was removed from the manager, e.g. because the\n     * session has been invalidated. Is used to keep track of such sessions in\n     * non-sticky mode, so that lockingStrategy.onBackupWithoutLoadedSession is not\n     * invoked.\n     *\n     * Motivated by issue 116.\n     *\n     * @param id the id of the removed session.\n     */\n    public void sessionRemoved(final String id) {\n        if(!_sticky) {\n            _removedSessions.put(id, \"unused\");\n        }\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _manager.getMaxActiveSessions() >= 0 && _manager.getSessionsInternal().size() >= _manager.getMaxActiveSessions() ) {\n            _manager.incrementRejectedSessions();\n            throw new IllegalStateException\n                (_manager.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = _manager.newMemcachedBackupSession();\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = _manager.getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( getSessionIdFormat().extractJvmRoute( requestedSessionId ) ) ) {\n\n            // the session might have been loaded already (by some valve), so let's check our session map\n            MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n            if ( session == null ) {\n                session = loadFromMemcachedWithCheck( requestedSessionId );\n            }\n\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    @Nonnull\n\tprivate SessionIdFormat getSessionIdFormat() {\n\t\treturn _memcachedNodesManager.getSessionIdFormat();\n\t}\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = getSessionIdFormat().changeJvmRoute( session.getIdInternal(), _manager.getJvmRoute() );\n\n        // If this session was already loaded we need to remove it from the session map\n        // See http://code.google.com/p/memcached-session-manager/issues/detail?id=92\n        if ( _manager.getSessionsInternal().containsKey( origSessionId ) ) {\n            _manager.getSessionsInternal().remove( origSessionId );\n        }\n\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session, true );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _memcachedNodesManager.isValidForMemcached( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId );\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n    \tif ( !_memcachedNodesManager.isEncodeNodeIdInSessionId() ) {\n    \t\treturn null;\n    \t}\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                \tfinal String newSessionId = _memcachedNodesManager.getNewSessionIdIfNodeFromSessionIdUnavailable( session.getId() );\n                    if ( newSessionId != null ) {\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            } else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _memcachedNodesManager.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                _log.info( \"Session needs to be relocated as node \"+ nodeId +\" is not available, loading backup session for \" + requestedSessionId );\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    _log.debug( \"Loaded backup session for \" + requestedSessionId + \", adding locally with \"+ backupSession.getIdInternal() +\".\" );\n                    addValidLoadedSession( backupSession, true );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final RuntimeException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String nodeId = getSessionIdFormat().extractMemcachedId( requestedSessionId );\n        if ( nodeId == null ) {\n            _log.info( \"Cannot load backupSession for sessionId without nodeId: \"+ requestedSessionId );\n            return null;\n        }\n\n        final String newNodeId = _memcachedNodesManager.getNextAvailableNodeId(nodeId);\n        if ( newNodeId == null ) {\n            _log.info( \"No next available node found for nodeId \"+ nodeId );\n            return null;\n        }\n\n        MemcachedBackupSession result = loadBackupSession(requestedSessionId, newNodeId);\n        String nextNodeId = nodeId;\n        // if we didn't find the backup in the next node, let's go through other nodes\n        // to see if the backup is there. For this we have to fake the session id so that\n        // the SuffixBasedNodeLocator selects another backup node.\n        while(result == null\n                && (nextNodeId = _memcachedNodesManager.getNextAvailableNodeId(nextNodeId)) != null\n                && !nextNodeId.equals(nodeId)) {\n            final String newSessionId = getSessionIdFormat().createNewSessionId(requestedSessionId, nextNodeId);\n            result = loadBackupSession(newSessionId, newNodeId);\n        }\n\n        if ( result == null ) {\n            _log.info( \"No backup found for sessionId \" + requestedSessionId );\n            return null;\n        }\n\n        return result;\n    }\n\n    private MemcachedBackupSession loadBackupSession(final String requestedSessionId, final String newNodeId) {\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( getSessionIdFormat().createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                if(_log.isDebugEnabled())\n                    _log.debug( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, _manager );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n            final String newSessionId = getSessionIdFormat().createNewSessionId( requestedSessionId, newNodeId );\n            _log.info( \"Session backup loaded from secondary memcached for \"+ requestedSessionId +\" (will be relocated),\" +\n            \t\t\" setting new id \"+ newSessionId +\" on session...\" );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n            return null;\n        }\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param sessionId\n     *            the id of the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    @Override\n    public Future<BackupResult> backupSession( final String sessionId, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = _manager.getSessionInternal( sessionId );\n        if ( msmSession == null ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"No session found in session map for \" + sessionId );\n            if ( !_sticky ) {\n                // Issue 116: Only notify the lockingStrategy if the session has not been removed/invalidated\n                if(_removedSessions.remove(sessionId) == null) {\n                    _lockingStrategy.onBackupWithoutLoadedSession( sessionId, requestId, _backupSessionService );\n                }\n            }\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !msmSession.isValidInternal() ) {\n            if(_log.isDebugEnabled())\n                _log.debug( \"Non valid session found in session map for \" + sessionId );\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        if ( !_sticky ) {\n            synchronized (_manager.getSessionsInternal()) {\n                // if another thread in the meantime retrieved the session\n                // we must not remove it as this would case session data loss\n                // for the other request\n                if ( msmSession.releaseReference() > 0 ) {\n                    if(_log.isDebugEnabled())\n                        _log.debug( \"Session \" + sessionId + \" is still used by another request, skipping backup and (optional) lock handling/release.\" );\n                    return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n                }\n                msmSession.passivate();\n                _manager.removeInternal( msmSession, false );\n            }\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= msmSession.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId can access memcached.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _memcachedNodesManager.canHitMemcached( sessionId );\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n        }\n\n        LockStatus lockStatus = null;\n        try {\n\n            if ( !_sticky ) {\n                lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n            }\n\n            final long start = System.currentTimeMillis();\n\n            /* In the previous version (<1.2) the session was completely serialized by\n             * custom Transcoder implementations.\n             * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n             * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n             * specializations.\n             */\n            final Object object = _memcached.get( sessionId );\n            _memcachedNodesManager.onLoadFromMemcachedSuccess( sessionId );\n\n            if ( object != null ) {\n                if ( !(object instanceof byte[]) ) {\n                    throw new RuntimeException( \"The loaded object for sessionId \" + sessionId + \" is not of required type byte[], but \" + object.getClass().getName() );\n                }\n                final long startDeserialization = System.currentTimeMillis();\n                final MemcachedBackupSession result = _transcoderService.deserialize( (byte[]) object, _manager );\n                _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                result.setSticky( _sticky );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                }\n\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Found session with id \" + sessionId );\n                }\n                return result;\n            }\n            else {\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n                _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                }\n                return null;\n            }\n\n        } catch ( final Exception e ) {\n            _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            if ( lockStatus == LockStatus.LOCKED ) {\n                _lockingStrategy.releaseLock( sessionId );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + memcachedNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedNodesManager reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( memcachedNodesManager, _statistics );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, memcachedNodesManager, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _memcachedNodesManager = memcachedNodesManager;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( memcachedNodesManager );\n\n        return memcachedNodesManager;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( _manager.isInitialized() ) {\n            final MemcachedNodesManager config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + failoverNodes +\n                    \"\\n- New node ids: \" + config.getPrimaryNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * Return the compiled pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributePattern\n     */\n    @CheckForNull\n    Pattern getSessionAttributePattern() {\n        return _sessionAttributePattern;\n    }\n\n    /**\n     * Return the string pattern used for including session attributes to a session-backup.\n     *\n     * @return the sessionAttributeFilter\n     */\n    @CheckForNull\n    public String getSessionAttributeFilter() {\n        return _sessionAttributeFilter;\n    }\n\n    /**\n     * Set the pattern used for including session attributes to a session-backup.\n     * If not set, all session attributes will be part of the session-backup.\n     * <p>\n     * E.g. <code>^(userName|sessionHistory)$<\/code>\n     * <\/p>\n     *\n     * @param sessionAttributeFilter\n     *            the sessionAttributeNames to set\n     */\n    public void setSessionAttributeFilter( @Nullable final String sessionAttributeFilter ) {\n        if ( sessionAttributeFilter == null || sessionAttributeFilter.trim().equals(\"\") ) {\n            _sessionAttributeFilter = null;\n            _sessionAttributePattern = null;\n        }\n        else {\n            _sessionAttributeFilter = sessionAttributeFilter;\n            _sessionAttributePattern = Pattern.compile( sessionAttributeFilter );\n        }\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && _manager.isInitialized() ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && _manager.isInitialized() ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && _manager.getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + _manager.getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( _manager.isInitialized() ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( @Nullable final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode != null && lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( _manager.isInitialized() ) {\n            initNonStickyLockingMode( createMemcachedNodesManager( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n\tprivate void initNonStickyLockingMode( @Nonnull final MemcachedNodesManager config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        if ( _sessionAttributeFilter != null ) {\n            _log.warn( \"There's a sessionAttributesFilter configured ('\" + _sessionAttributeFilter + \"'),\" +\n                    \" all other session attributes will be lost after the request due to non-sticky configuration!\" );\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1;\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _memcachedNodesManager,\n                _missingSessionsCache, storeSecondaryBackup, _statistics );\n        if ( _sessionTrackerValve != null ) {\n            _sessionTrackerValve.setLockingStrategy( _lockingStrategy );\n        }\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = _manager.findSessions();\n            final int delay = _manager.getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMaxInactiveInterval() > 0 // for <= 0 the session was stored in memcached with expiration 0\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && _manager.isInitialized() ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n        }\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout from {@link #getSessionBackupTimeout()} is\n     * evaluated.\n     */\n    public boolean isSessionBackupAsync() {\n        return _sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed when {@link #getSessionBackupAsync()}) is <code>false<\/code>.\n     */\n    public long getSessionBackupTimeout() {\n        return _sessionBackupTimeout;\n    }\n\n    public Statistics getStatistics() {\n        return _statistics;\n    }\n\n\tpublic long getOperationTimeout() {\n\t\treturn _operationTimeout;\n\t}\n\n\tpublic void setOperationTimeout(final long operationTimeout ) {\n\t\t_operationTimeout = operationTimeout;\n\t}\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _memcachedNodesManager, _statistics );\n    }\n\n    /**\n     * Return the memcached nodes manager.\n     */\n    @Nonnull\n    MemcachedNodesManager getMemcachedNodesManager() {\n        return _memcachedNodesManager;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _memcachedNodesManager.getPrimaryNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _memcachedNodesManager.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    void setMemcachedClient(final MemcachedClient memcachedClient) {\n        _memcached = memcachedClient;\n    }\n\n    /**\n     * The currently set locking strategy.\n     */\n    @Nullable\n    LockingStrategy getLockingStrategy() {\n        return _lockingStrategy;\n    }\n\n    public void setUsername(final String username) {\n        _username = username;\n    }\n\n    /**\n     * username required for SASL Connection types\n     * @return\n     */\n    public String getUsername() {\n        return _username;\n    }\n\n    public void setPassword(final String password) {\n       _password = password;\n    }\n\n    /**\n     * password required for SASL Connection types\n     * @return\n     */\n    public String getPassword() {\n        return _password;\n    }\n\n}\n","lineNo":486}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.STICKYNESS_PROVIDER;\nimport static de.javakaffee.web.msm.integration.TestUtils.createDaemon;\nimport static de.javakaffee.web.msm.integration.TestUtils.getManager;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertNull;\nimport static org.testng.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private String _memcachedNodeId;\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n    \n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n\t\t@Override\n\t\tpublic Object get(final String key) {\n\t\t\treturn _memcached.get(key);\n\t\t}\n\t};\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        _memcachedNodeId = \"n1\";\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n\n        try {\n            System.setProperty( \"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\", \"true\" );\n            _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( memcachedNodes, address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final String memcachedNodes, final InetSocketAddress address ) throws IOException, InterruptedException {\n    \tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(memcachedNodes, null, _memcachedClientCallback);\n        final MemcachedClient result = new MemcachedClient( new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create() ),\n                Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedSessionService#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n    \n    abstract TestUtils getTestUtils();\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).getMemcachedSessionService().isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final SessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.getMemcachedSessionService().isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private static final String GROUP_WITHOUT_NODE_ID = \"withoutNodeId\";\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private final String _memcachedNodeId = \"n1\";\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n    \n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n\t\t@Override\n\t\tpublic Object get(final String key) {\n\t\t\treturn _memcached.get(key);\n\t\t}\n\t};\n\n    @BeforeMethod\n    public void setUp(final Method testMethod) throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n        \n        final String[] testGroups = testMethod.getAnnotation(Test.class).groups();\n        final String nodePrefix = testGroups.length == 0 || !GROUP_WITHOUT_NODE_ID.equals(testGroups[0]) ? _memcachedNodeId + \":\" : \"\";\n\n        final String memcachedNodes = nodePrefix + \"localhost:\" + _memcachedPort;\n\n        try {\n            System.setProperty( \"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\", \"true\" );\n            _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( memcachedNodes, address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final String memcachedNodes, final InetSocketAddress address ) throws IOException, InterruptedException {\n    \tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(memcachedNodes, null, _memcachedClientCallback);\n        final ConnectionFactory cf = nodesManager.isEncodeNodeIdInSessionId()\n            ? new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create() )\n            : new DefaultConnectionFactory();\n        final MemcachedClient result = new MemcachedClient( cf, Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): this shall be possible\n     * and the generated session id must not contain a node id.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID )\n    public void testSessionIdIsNotChangedIfSingleNodeWithNoMemcachedNodeIdConfigured() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) == -1 );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): the session must be\n     * found on a second request.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n        \n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n        \n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, _portTomcat1, null, key, value ).getSessionId();\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        final Response response = get( _httpClient, _portTomcat1, sessionId1 );\n        final String sessionId2 = response.getSessionId();\n\n        assertEquals( sessionId2, sessionId1 );\n\n        /* check session attributes could be read\n         */\n        final String actualValue = response.get( key );\n        assertEquals( value, actualValue );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedSessionService#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n    \n    abstract TestUtils getTestUtils();\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).getMemcachedSessionService().isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final SessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.getMemcachedSessionService().isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","lineNo":121}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.STICKYNESS_PROVIDER;\nimport static de.javakaffee.web.msm.integration.TestUtils.createDaemon;\nimport static de.javakaffee.web.msm.integration.TestUtils.getManager;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertNull;\nimport static org.testng.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private String _memcachedNodeId;\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n    \n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n\t\t@Override\n\t\tpublic Object get(final String key) {\n\t\t\treturn _memcached.get(key);\n\t\t}\n\t};\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        _memcachedNodeId = \"n1\";\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n\n        try {\n            System.setProperty( \"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\", \"true\" );\n            _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( memcachedNodes, address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final String memcachedNodes, final InetSocketAddress address ) throws IOException, InterruptedException {\n    \tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(memcachedNodes, null, _memcachedClientCallback);\n        final MemcachedClient result = new MemcachedClient( new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create() ),\n                Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedSessionService#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n    \n    abstract TestUtils getTestUtils();\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).getMemcachedSessionService().isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final SessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.getMemcachedSessionService().isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private static final String GROUP_WITHOUT_NODE_ID = \"withoutNodeId\";\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private final String _memcachedNodeId = \"n1\";\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n    \n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n\t\t@Override\n\t\tpublic Object get(final String key) {\n\t\t\treturn _memcached.get(key);\n\t\t}\n\t};\n\n    @BeforeMethod\n    public void setUp(final Method testMethod) throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n        \n        final String[] testGroups = testMethod.getAnnotation(Test.class).groups();\n        final String nodePrefix = testGroups.length == 0 || !GROUP_WITHOUT_NODE_ID.equals(testGroups[0]) ? _memcachedNodeId + \":\" : \"\";\n\n        final String memcachedNodes = nodePrefix + \"localhost:\" + _memcachedPort;\n\n        try {\n            System.setProperty( \"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\", \"true\" );\n            _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( memcachedNodes, address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final String memcachedNodes, final InetSocketAddress address ) throws IOException, InterruptedException {\n    \tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(memcachedNodes, null, _memcachedClientCallback);\n        final ConnectionFactory cf = nodesManager.isEncodeNodeIdInSessionId()\n            ? new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create() )\n            : new DefaultConnectionFactory();\n        final MemcachedClient result = new MemcachedClient( cf, Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): this shall be possible\n     * and the generated session id must not contain a node id.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID )\n    public void testSessionIdIsNotChangedIfSingleNodeWithNoMemcachedNodeIdConfigured() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) == -1 );\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): the session must be\n     * found on a second request.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n        \n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n        \n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, _portTomcat1, null, key, value ).getSessionId();\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        final Response response = get( _httpClient, _portTomcat1, sessionId1 );\n        final String sessionId2 = response.getSessionId();\n\n        assertEquals( sessionId2, sessionId1 );\n\n        /* check session attributes could be read\n         */\n        final String actualValue = response.get( key );\n        assertEquals( value, actualValue );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedSessionService#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final SessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n    \n    abstract TestUtils getTestUtils();\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).getMemcachedSessionService().isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final SessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.getMemcachedSessionService().isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","lineNo":100}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.MemcachedNodesManager;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.SessionIdFormat;\nimport de.javakaffee.web.msm.Statistics;\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\nimport de.javakaffee.web.msm.integration.TestUtils.LoginType;\nimport de.javakaffee.web.msm.integration.TestUtils.RecordingSessionActivationListener;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing tomcat failover (tomcats failing).\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class TomcatFailoverIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( TomcatFailoverIntegrationTest.class );\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _client;\n    \n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n        @Override\n        public Object get(final String key) {\n            return _client.get(key);\n        }\n    };\n\n    private Embedded _tomcat1;\n    private Embedded _tomcat2;\n\n    private static final int TC_PORT_1 = 18888;\n    private static final int TC_PORT_2 = 18889;\n\n    private static final String JVM_ROUTE_2 = \"tc2\";\n    private static final String JVM_ROUTE_1 = \"tc1\";\n\n    private static final String NODE_ID = \"n1\";\n    private static final int MEMCACHED_PORT = 21211;\n    private static final String MEMCACHED_NODES = NODE_ID + \":localhost:\" + MEMCACHED_PORT;\n\n    private DefaultHttpClient _httpClient;\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", MEMCACHED_PORT );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        try {\n            _tomcat1 = startTomcat( TC_PORT_1, JVM_ROUTE_1 );\n            _tomcat2 = startTomcat( TC_PORT_2, JVM_ROUTE_2 );\n\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        final MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(MEMCACHED_NODES, null, _memcachedClientCallback);\n        _client =\n                new MemcachedClient( new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create() ),\n                        Arrays.asList( address ) );\n\n        _httpClient = new DefaultHttpClient();\n    }\n    \n    abstract TestUtils getTestUtils();\n\n    private Embedded startTomcat( final int port, final String jvmRoute ) throws MalformedURLException, UnknownHostException, LifecycleException {\n        return startTomcat( port, SessionAffinityMode.STICKY, jvmRoute, null );\n    }\n\n    private Embedded startTomcat( final int port, final SessionAffinityMode sessionAffinityMode,\n            final String jvmRoute, final LoginType loginType ) throws MalformedURLException, UnknownHostException, LifecycleException {\n        final Embedded tomcat = getTestUtils().createCatalina( port, MEMCACHED_NODES, jvmRoute, loginType );\n        tomcat.start();\n        getManager( tomcat ).setSticky( sessionAffinityMode.isSticky() );\n        return tomcat;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _client.shutdown();\n        _daemon.stop();\n        _tomcat1.stop();\n        _tomcat2.stop();\n        _httpClient.getConnectionManager().shutdown();\n    }\n\n    /**\n     * Test for issue #38:\n     * Notify HttpSessionActivationListeners when loading a session from memcached\n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute() throws Exception {\n        \n        \n        \n        final SessionManager manager1 = getManager( _tomcat1 );\n        final SessionManager manager2 = getManager( _tomcat2 );\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        final String sessionId1 = get( _httpClient, TC_PORT_1, null ).getSessionId();\n        assertEquals( format.extractJvmRoute( sessionId1 ), JVM_ROUTE_1 );\n\n        final MemcachedBackupSession session = (MemcachedBackupSession) manager1.findSession( sessionId1 );\n        session.setAttribute( \"listener\", new RecordingSessionActivationListener() );\n\n        get( _httpClient, TC_PORT_1, sessionId1 );\n\n        final String sessionId2 = get( _httpClient, TC_PORT_2, sessionId1 ).getSessionId();\n        assertEquals( format.stripJvmRoute( sessionId2 ), format.stripJvmRoute( sessionId1 ) );\n        assertEquals( format.extractJvmRoute( sessionId2 ), JVM_ROUTE_2 );\n\n        final MemcachedBackupSession loaded = (MemcachedBackupSession) manager2.findSession( sessionId2 );\n        assertNotNull( loaded );\n        final RecordingSessionActivationListener listener = (RecordingSessionActivationListener) loaded.getAttribute( \"listener\" );\n        assertNotNull( listener );\n\n        final String notifiedSessionId = listener.getSessionDidActivate();\n        assertEquals( notifiedSessionId, sessionId2 );\n    }\n\n    /**\n     * Test for issue #38:\n     * Notify HttpSessionActivationListeners when loading a session from memcached\n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testHttpSessionActivationListenersNotifiedOnLoadWithoutJvmRoute() throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, null );\n        _tomcat2 = startTomcat( TC_PORT_2, null );\n\n        final SessionManager manager1 = getManager( _tomcat1 );\n        final SessionManager manager2 = getManager( _tomcat2 );\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        final String sessionId1 = get( _httpClient, TC_PORT_1, null ).getSessionId();\n        assertNull( format.extractJvmRoute( sessionId1 ) );\n\n        final MemcachedBackupSession session = (MemcachedBackupSession) manager1.findSession( sessionId1 );\n        session.setAttribute( \"listener\", new RecordingSessionActivationListener() );\n\n        get( _httpClient, TC_PORT_1, sessionId1 );\n\n        final String sessionId2 = get( _httpClient, TC_PORT_2, sessionId1 ).getSessionId();\n        assertEquals( sessionId2, sessionId1 );\n\n        final MemcachedBackupSession loaded = (MemcachedBackupSession) manager2.findSession( sessionId2 );\n        assertNotNull( loaded );\n        final RecordingSessionActivationListener listener = (RecordingSessionActivationListener) loaded.getAttribute( \"listener\" );\n        assertNotNull( listener );\n\n        final String notifiedSessionId = listener.getSessionDidActivate();\n        assertEquals( notifiedSessionId, sessionId2 );\n    }\n\n    /**\n     * Tests that when two tomcats are running and one tomcat fails the other\n     * tomcat can take over the session.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testTomcatFailover() throws IOException, InterruptedException, HttpException {\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, TC_PORT_1, null, key, value ).getSessionId();\n        assertEquals( format.extractJvmRoute( sessionId1 ), JVM_ROUTE_1 );\n\n        final Object session = _client.get( sessionId1 );\n        assertNotNull( session, \"Session not found in memcached: \" + sessionId1 );\n\n        final Response response = get( _httpClient, TC_PORT_2, sessionId1 );\n        final String sessionId2 = response.getSessionId();\n        assertNull( _client.get( sessionId1 ) );\n        assertNotNull( _client.get( sessionId2 ) );\n\n        assertEquals( format.stripJvmRoute( sessionId1 ), format.stripJvmRoute( sessionId2 ) );\n        assertEquals( format.extractJvmRoute( sessionId2 ), JVM_ROUTE_2 );\n\n        /* check session attributes could be read\n         */\n        final String actualValue = response.get( key );\n        assertEquals( value, actualValue );\n\n        Thread.sleep( 10 );\n\n    }\n\n    /**\n     * Tests that the session that was taken over by another tomcat is not\n     * sent again by this tomcat if it was not modified.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testLoadedSessionOnlySentIfModified() throws IOException, InterruptedException, HttpException {\n\n        /* create a session on tomcat1\n         */\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, TC_PORT_1, null, key, value ).getSessionId();\n        assertEquals( 1, _daemon.getCache().getSetCmds() );\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        /* request the session on tomcat2\n         */\n        final Response response = get( _httpClient, TC_PORT_2, sessionId1 );\n        assertEquals( format.stripJvmRoute( sessionId1 ), format.stripJvmRoute( response.getSessionId() ) );\n        assertEquals( 2, _daemon.getCache().getSetCmds() );\n\n        /* post key/value already stored in the session again (on tomcat2)\n         */\n        post( _httpClient, TC_PORT_2, sessionId1, key, value );\n        assertEquals( 2, _daemon.getCache().getSetCmds() );\n\n        /* post another key/value pair (on tomcat2)\n         */\n        post( _httpClient, TC_PORT_2, sessionId1, \"bar\", \"baz\" );\n        assertEquals( 3, _daemon.getCache().getSetCmds() );\n\n        Thread.sleep( 10 );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSerializationOfAuthStuffWithFormAuth( final SessionAffinityMode stickyness ) throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, stickyness, stickyness.isSticky() ? JVM_ROUTE_1 : null, LoginType.FORM );\n        _tomcat2 = startTomcat( TC_PORT_2, stickyness, stickyness.isSticky() ? JVM_ROUTE_2 : null, LoginType.FORM );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        /* tomcat1: request secured resource, login and check that secured resource is accessable\n         */\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null );\n        final String sessionId = tc1Response1.getSessionId();\n\n        assertFalse( sessionId.equals( tc1Response1.get( TestServlet.ID ) ) );\n\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME );\n        params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD );\n        final Response tc1Response2 = post( _httpClient, TC_PORT_1, \"/j_security_check\", sessionId, params );\n\n        assertTrue( sessionId.equals( tc1Response2.get( TestServlet.ID ) ) );\n\n        /* tomcat1 failover \"simulation\":\n         * on tomcat2, we now be able to access the secured resource directly\n         * with the first request\n         */\n        final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId );\n        if ( stickyness.isSticky() ) {\n            assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        }\n        else {\n            assertEquals( tc2Response1.getSessionId(), sessionId );\n        }\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSerializationOfAuthStuffWithBasicAuth( final SessionAffinityMode stickyness ) throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, stickyness, stickyness.isSticky() ? JVM_ROUTE_1 : null, LoginType.BASIC );\n        _tomcat2 = startTomcat( TC_PORT_2, stickyness, stickyness.isSticky() ? JVM_ROUTE_2 : null, LoginType.BASIC );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        /* tomcat1: request secured resource, login and check that secured resource is accessable\n         */\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null,\n                new UsernamePasswordCredentials( TestUtils.USER_NAME, TestUtils.PASSWORD ) );\n        final String sessionId = tc1Response1.getSessionId();\n\n        assertEquals( sessionId, tc1Response1.get( TestServlet.ID ) );\n\n        /* tomcat1 failover \"simulation\":\n         * on tomcat2, we now should be able to access the secured resource directly\n         * with the first request\n         */\n        final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId );\n        if ( stickyness.isSticky() ) {\n            assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        }\n        else {\n            assertEquals( tc2Response1.getSessionId(), sessionId );\n        }\n\n    }\n\n    @Test( enabled = true )\n    public void testSessionOnlyLoadedOnceWithAuth() throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, SessionAffinityMode.STICKY, JVM_ROUTE_1, LoginType.BASIC );\n        _tomcat2 = startTomcat( TC_PORT_2, SessionAffinityMode.STICKY, JVM_ROUTE_2, LoginType.BASIC );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        /* tomcat1: request secured resource, login and check that secured resource is accessable\n         */\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null,\n                new UsernamePasswordCredentials( TestUtils.USER_NAME, TestUtils.PASSWORD ) );\n        final String sessionId = tc1Response1.getSessionId();\n\n        assertEquals( sessionId, tc1Response1.get( TestServlet.ID ) );\n        assertEquals( _daemon.getCache().getGetHits(), 0 );\n\n        /* on tomcat1 failover and session takeover by tomcat2, msm in tomcat2 should\n         * load the session only once.\n         */\n        final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId );\n        assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        assertEquals( _daemon.getCache().getGetHits(), 1 );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionModificationOnTomcatFailoverNotLostWithAuth( final SessionAffinityMode stickyness ) throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, stickyness, stickyness.isSticky() ? JVM_ROUTE_1 : null, LoginType.BASIC );\n        _tomcat2 = startTomcat( TC_PORT_2, stickyness, stickyness.isSticky() ? JVM_ROUTE_2 : null, LoginType.BASIC );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null, new UsernamePasswordCredentials( TestUtils.USER_NAME, TestUtils.PASSWORD ) );\n        final String sessionId = tc1Response1.getSessionId();\n        assertEquals( sessionId, tc1Response1.get( TestServlet.ID ) );\n\n        /* on tomcat1 failover and session takeover by tomcat2, the changes made to the\n         * session during this request must be available in the following request(s)\n         */\n        final Response tc2Response1 = post( _httpClient, TC_PORT_2, \"/\", sessionId, asMap( \"foo\", \"bar\" ) );\n        if ( stickyness.isSticky() ) {\n            assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        }\n        else {\n            assertEquals( tc2Response1.getSessionId(), sessionId );\n        }\n\n        final Response tc2Response2 = get( _httpClient, TC_PORT_2, tc2Response1.getResponseSessionId() );\n        assertEquals( tc2Response2.get( \"foo\" ), \"bar\" );\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.DefaultConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedBackupSession;\nimport de.javakaffee.web.msm.MemcachedNodesManager;\nimport de.javakaffee.web.msm.MemcachedNodesManager.MemcachedClientCallback;\nimport de.javakaffee.web.msm.MemcachedSessionService.SessionManager;\nimport de.javakaffee.web.msm.SessionIdFormat;\nimport de.javakaffee.web.msm.Statistics;\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\nimport de.javakaffee.web.msm.integration.TestUtils.LoginType;\nimport de.javakaffee.web.msm.integration.TestUtils.RecordingSessionActivationListener;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing tomcat failover (tomcats failing).\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class TomcatFailoverIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( TomcatFailoverIntegrationTest.class );\n\n    private static final String GROUP_WITHOUT_NODE_ID = \"withoutNodeId\";\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _client;\n    \n    private final MemcachedClientCallback _memcachedClientCallback = new MemcachedClientCallback() {\n        @Override\n        public Object get(final String key) {\n            return _client.get(key);\n        }\n    };\n\n    private Embedded _tomcat1;\n    private Embedded _tomcat2;\n\n    private static final int TC_PORT_1 = 18888;\n    private static final int TC_PORT_2 = 18889;\n\n    private static final String JVM_ROUTE_2 = \"tc2\";\n    private static final String JVM_ROUTE_1 = \"tc1\";\n\n    private static final String NODE_ID = \"n1\";\n    private static final int MEMCACHED_PORT = 21211;\n    private String _memcachedNodes;\n\n    private DefaultHttpClient _httpClient;\n\n    @BeforeMethod\n    public void setUp(final Method testMethod) throws Throwable {\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", MEMCACHED_PORT );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        final String[] testGroups = testMethod.getAnnotation(Test.class).groups();\n        final String nodePrefix = testGroups.length == 0 || !GROUP_WITHOUT_NODE_ID.equals(testGroups[0]) ? NODE_ID + \":\" : \"\";\n        _memcachedNodes = nodePrefix + \"localhost:\" + MEMCACHED_PORT;\n\n        try {\n            _tomcat1 = startTomcat( TC_PORT_1, JVM_ROUTE_1 );\n            _tomcat2 = startTomcat( TC_PORT_2, JVM_ROUTE_2 );\n\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        final MemcachedNodesManager nodesManager = MemcachedNodesManager.createFor(_memcachedNodes, null, _memcachedClientCallback);\n        final ConnectionFactory cf = nodesManager.isEncodeNodeIdInSessionId()\n            ? new SuffixLocatorConnectionFactory( nodesManager, nodesManager.getSessionIdFormat(), Statistics.create() )\n            : new DefaultConnectionFactory();\n        _client = new MemcachedClient( cf, Arrays.asList( address ) );\n\n        _httpClient = new DefaultHttpClient();\n    }\n    \n    abstract TestUtils getTestUtils();\n\n    private Embedded startTomcat( final int port, final String jvmRoute ) throws MalformedURLException, UnknownHostException, LifecycleException {\n        return startTomcat( port, SessionAffinityMode.STICKY, jvmRoute, null );\n    }\n\n    private Embedded startTomcat( final int port, final SessionAffinityMode sessionAffinityMode,\n            final String jvmRoute, final LoginType loginType ) throws MalformedURLException, UnknownHostException, LifecycleException {\n        final Embedded tomcat = getTestUtils().createCatalina( port, _memcachedNodes, jvmRoute, loginType );\n        tomcat.start();\n        getManager( tomcat ).setSticky( sessionAffinityMode.isSticky() );\n        return tomcat;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _client.shutdown();\n        _daemon.stop();\n        _tomcat1.stop();\n        _tomcat2.stop();\n        _httpClient.getConnectionManager().shutdown();\n    }\n\n    /**\n     * Test for issue #38:\n     * Notify HttpSessionActivationListeners when loading a session from memcached\n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute() throws Exception {\n        \n        \n        \n        final SessionManager manager1 = getManager( _tomcat1 );\n        final SessionManager manager2 = getManager( _tomcat2 );\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        final String sessionId1 = get( _httpClient, TC_PORT_1, null ).getSessionId();\n        assertEquals( format.extractJvmRoute( sessionId1 ), JVM_ROUTE_1 );\n\n        final MemcachedBackupSession session = (MemcachedBackupSession) manager1.findSession( sessionId1 );\n        session.setAttribute( \"listener\", new RecordingSessionActivationListener() );\n\n        get( _httpClient, TC_PORT_1, sessionId1 );\n\n        final String sessionId2 = get( _httpClient, TC_PORT_2, sessionId1 ).getSessionId();\n        assertEquals( format.stripJvmRoute( sessionId2 ), format.stripJvmRoute( sessionId1 ) );\n        assertEquals( format.extractJvmRoute( sessionId2 ), JVM_ROUTE_2 );\n\n        final MemcachedBackupSession loaded = (MemcachedBackupSession) manager2.findSession( sessionId2 );\n        assertNotNull( loaded );\n        final RecordingSessionActivationListener listener = (RecordingSessionActivationListener) loaded.getAttribute( \"listener\" );\n        assertNotNull( listener );\n\n        final String notifiedSessionId = listener.getSessionDidActivate();\n        assertEquals( notifiedSessionId, sessionId2 );\n    }\n\n    /**\n     * Test for issue #38:\n     * Notify HttpSessionActivationListeners when loading a session from memcached\n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testHttpSessionActivationListenersNotifiedOnLoadWithoutJvmRoute() throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, null );\n        _tomcat2 = startTomcat( TC_PORT_2, null );\n\n        final SessionManager manager1 = getManager( _tomcat1 );\n        final SessionManager manager2 = getManager( _tomcat2 );\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        final String sessionId1 = get( _httpClient, TC_PORT_1, null ).getSessionId();\n        assertNull( format.extractJvmRoute( sessionId1 ) );\n\n        final MemcachedBackupSession session = (MemcachedBackupSession) manager1.findSession( sessionId1 );\n        session.setAttribute( \"listener\", new RecordingSessionActivationListener() );\n\n        get( _httpClient, TC_PORT_1, sessionId1 );\n\n        final String sessionId2 = get( _httpClient, TC_PORT_2, sessionId1 ).getSessionId();\n        assertEquals( sessionId2, sessionId1 );\n\n        final MemcachedBackupSession loaded = (MemcachedBackupSession) manager2.findSession( sessionId2 );\n        assertNotNull( loaded );\n        final RecordingSessionActivationListener listener = (RecordingSessionActivationListener) loaded.getAttribute( \"listener\" );\n        assertNotNull( listener );\n\n        final String notifiedSessionId = listener.getSessionDidActivate();\n        assertEquals( notifiedSessionId, sessionId2 );\n    }\n\n    /**\n     * Tests that when two tomcats are running and one tomcat fails the other\n     * tomcat can take over the session.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testTomcatFailover() throws IOException, InterruptedException, HttpException {\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, TC_PORT_1, null, key, value ).getSessionId();\n        assertEquals( format.extractJvmRoute( sessionId1 ), JVM_ROUTE_1 );\n\n        final Object session = _client.get( sessionId1 );\n        assertNotNull( session, \"Session not found in memcached: \" + sessionId1 );\n\n        final Response response = get( _httpClient, TC_PORT_2, sessionId1 );\n        final String sessionId2 = response.getSessionId();\n        assertNull( _client.get( sessionId1 ) );\n        assertNotNull( _client.get( sessionId2 ) );\n\n        assertEquals( format.stripJvmRoute( sessionId1 ), format.stripJvmRoute( sessionId2 ) );\n        assertEquals( format.extractJvmRoute( sessionId2 ), JVM_ROUTE_2 );\n\n        /* check session attributes could be read\n         */\n        final String actualValue = response.get( key );\n        assertEquals( value, actualValue );\n\n        Thread.sleep( 10 );\n\n    }\n\n    /**\n     * Related to issue/feature 105 (single memcached node without node id): tomcat failover must work with this configuration.\n     */\n    @Test( enabled = true, groups = GROUP_WITHOUT_NODE_ID )\n    public void testTomcatFailoverWithSingleNodeWithoutConfiguredNodeId() throws IOException, InterruptedException, HttpException {\n        // with this group (GROUP_WITHOUT_NODE_ID) the setup method does no set the memcached node id\n        // in the memcached nodes configuration. the tomcat failover test does not rely on the node id\n        // so that we can just reuse it...\n        testTomcatFailover();\n    }\n\n    /**\n     * Tests that the session that was taken over by another tomcat is not\n     * sent again by this tomcat if it was not modified.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testLoadedSessionOnlySentIfModified() throws IOException, InterruptedException, HttpException {\n\n        /* create a session on tomcat1\n         */\n        final String key = \"foo\";\n        final String value = \"bar\";\n        final String sessionId1 = post( _httpClient, TC_PORT_1, null, key, value ).getSessionId();\n        assertEquals( 1, _daemon.getCache().getSetCmds() );\n\n        final SessionIdFormat format = new SessionIdFormat();\n\n        /* request the session on tomcat2\n         */\n        final Response response = get( _httpClient, TC_PORT_2, sessionId1 );\n        assertEquals( format.stripJvmRoute( sessionId1 ), format.stripJvmRoute( response.getSessionId() ) );\n        assertEquals( 2, _daemon.getCache().getSetCmds() );\n\n        /* post key/value already stored in the session again (on tomcat2)\n         */\n        post( _httpClient, TC_PORT_2, sessionId1, key, value );\n        assertEquals( 2, _daemon.getCache().getSetCmds() );\n\n        /* post another key/value pair (on tomcat2)\n         */\n        post( _httpClient, TC_PORT_2, sessionId1, \"bar\", \"baz\" );\n        assertEquals( 3, _daemon.getCache().getSetCmds() );\n\n        Thread.sleep( 10 );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSerializationOfAuthStuffWithFormAuth( final SessionAffinityMode stickyness ) throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, stickyness, stickyness.isSticky() ? JVM_ROUTE_1 : null, LoginType.FORM );\n        _tomcat2 = startTomcat( TC_PORT_2, stickyness, stickyness.isSticky() ? JVM_ROUTE_2 : null, LoginType.FORM );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        /* tomcat1: request secured resource, login and check that secured resource is accessable\n         */\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null );\n        final String sessionId = tc1Response1.getSessionId();\n\n        assertFalse( sessionId.equals( tc1Response1.get( TestServlet.ID ) ) );\n\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME );\n        params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD );\n        final Response tc1Response2 = post( _httpClient, TC_PORT_1, \"/j_security_check\", sessionId, params );\n\n        assertTrue( sessionId.equals( tc1Response2.get( TestServlet.ID ) ) );\n\n        /* tomcat1 failover \"simulation\":\n         * on tomcat2, we now be able to access the secured resource directly\n         * with the first request\n         */\n        final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId );\n        if ( stickyness.isSticky() ) {\n            assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        }\n        else {\n            assertEquals( tc2Response1.getSessionId(), sessionId );\n        }\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSerializationOfAuthStuffWithBasicAuth( final SessionAffinityMode stickyness ) throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, stickyness, stickyness.isSticky() ? JVM_ROUTE_1 : null, LoginType.BASIC );\n        _tomcat2 = startTomcat( TC_PORT_2, stickyness, stickyness.isSticky() ? JVM_ROUTE_2 : null, LoginType.BASIC );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        /* tomcat1: request secured resource, login and check that secured resource is accessable\n         */\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null,\n                new UsernamePasswordCredentials( TestUtils.USER_NAME, TestUtils.PASSWORD ) );\n        final String sessionId = tc1Response1.getSessionId();\n\n        assertEquals( sessionId, tc1Response1.get( TestServlet.ID ) );\n\n        /* tomcat1 failover \"simulation\":\n         * on tomcat2, we now should be able to access the secured resource directly\n         * with the first request\n         */\n        final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId );\n        if ( stickyness.isSticky() ) {\n            assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        }\n        else {\n            assertEquals( tc2Response1.getSessionId(), sessionId );\n        }\n\n    }\n\n    @Test( enabled = true )\n    public void testSessionOnlyLoadedOnceWithAuth() throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, SessionAffinityMode.STICKY, JVM_ROUTE_1, LoginType.BASIC );\n        _tomcat2 = startTomcat( TC_PORT_2, SessionAffinityMode.STICKY, JVM_ROUTE_2, LoginType.BASIC );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        /* tomcat1: request secured resource, login and check that secured resource is accessable\n         */\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null,\n                new UsernamePasswordCredentials( TestUtils.USER_NAME, TestUtils.PASSWORD ) );\n        final String sessionId = tc1Response1.getSessionId();\n\n        assertEquals( sessionId, tc1Response1.get( TestServlet.ID ) );\n        assertEquals( _daemon.getCache().getGetHits(), 0 );\n\n        /* on tomcat1 failover and session takeover by tomcat2, msm in tomcat2 should\n         * load the session only once.\n         */\n        final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId );\n        assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        assertEquals( _daemon.getCache().getGetHits(), 1 );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionModificationOnTomcatFailoverNotLostWithAuth( final SessionAffinityMode stickyness ) throws Exception {\n\n        _tomcat1.stop();\n        _tomcat2.stop();\n\n        _tomcat1 = startTomcat( TC_PORT_1, stickyness, stickyness.isSticky() ? JVM_ROUTE_1 : null, LoginType.BASIC );\n        _tomcat2 = startTomcat( TC_PORT_2, stickyness, stickyness.isSticky() ? JVM_ROUTE_2 : null, LoginType.BASIC );\n\n        setChangeSessionIdOnAuth( _tomcat1, false );\n        setChangeSessionIdOnAuth( _tomcat2, false );\n\n        final Response tc1Response1 = get( _httpClient, TC_PORT_1, null, new UsernamePasswordCredentials( TestUtils.USER_NAME, TestUtils.PASSWORD ) );\n        final String sessionId = tc1Response1.getSessionId();\n        assertEquals( sessionId, tc1Response1.get( TestServlet.ID ) );\n\n        /* on tomcat1 failover and session takeover by tomcat2, the changes made to the\n         * session during this request must be available in the following request(s)\n         */\n        final Response tc2Response1 = post( _httpClient, TC_PORT_2, \"/\", sessionId, asMap( \"foo\", \"bar\" ) );\n        if ( stickyness.isSticky() ) {\n            assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) );\n        }\n        else {\n            assertEquals( tc2Response1.getSessionId(), sessionId );\n        }\n\n        final Response tc2Response2 = get( _httpClient, TC_PORT_2, tc2Response1.getResponseSessionId() );\n        assertEquals( tc2Response2.get( \"foo\" ), \"bar\" );\n\n    }\n\n}\n","lineNo":118}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.CacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing memcached failover.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedFailoverIntegrationTest {\n\n    private static final Log LOG = LogFactory\n            .getLog( MemcachedFailoverIntegrationTest.class );\n\n    private MemCacheDaemon<? extends CacheElement> _daemon1;\n    private MemCacheDaemon<? extends CacheElement> _daemon2;\n    private MemCacheDaemon<? extends CacheElement> _daemon3;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private DefaultHttpClient _httpClient;\n\n    private String _nodeId1;\n    private String _nodeId2;\n    private String _nodeId3;\n\n    private InetSocketAddress _address1;\n\n    private InetSocketAddress _address2;\n\n    private InetSocketAddress _address3;\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _address1 = new InetSocketAddress( \"localhost\", 21211 );\n        _daemon1 = createDaemon( _address1 );\n        _daemon1.start();\n\n        _address2 = new InetSocketAddress( \"localhost\", 21212 );\n        _daemon2 = createDaemon( _address2 );\n        _daemon2.start();\n\n        _address3 = new InetSocketAddress( \"localhost\", 21213 );\n        _daemon3 = createDaemon( _address3 );\n        _daemon3.start();\n\n        _nodeId1 = \"n1\";\n        _nodeId2 = \"n2\";\n        _nodeId3 = \"n3\";\n\n        try {\n            final String memcachedNodes = toString( _nodeId1, _address1 ) +\n                \" \" + toString( _nodeId2, _address2 ) +\n                \" \" + toString( _nodeId3, _address3 );\n            _tomcat1 = createCatalina( _portTomcat1, 10, memcachedNodes );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private String toString( final String nodeId, final InetSocketAddress address ) {\n        return nodeId + \":\" + address.getHostName() + \":\" + address.getPort();\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        if ( _daemon1.isRunning() ) {\n            _daemon1.stop();\n        }\n        if ( _daemon2.isRunning() ) {\n            _daemon2.stop();\n        }\n        if ( _daemon3.isRunning() ) {\n            _daemon3.stop();\n        }\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n    }\n\n    /**\n     * Tests, that on a memcached failover sessions are relocated to another node and that\n     * the session id reflects this. The session must no longer be available under the old\n     * session id.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testRelocateSession( final SessionAffinityMode sessionAffinity ) throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String sid1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sid1, \"No session created.\" );\n        final String firstNode = extractNodeId( sid1 );\n        assertNotNull( firstNode, \"No node id encoded in session id.\" );\n\n        final FailoverInfo info = getFailoverInfo( firstNode );\n        info.activeNode.stop();\n\n        Thread.sleep( 50 );\n\n        final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 );\n        final String secondNode = extractNodeId( sid2 );\n\n        assertNotSame( secondNode, firstNode, \"First node again selected\" );\n\n        assertEquals(\n                sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + secondNode,\n                \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2 );\n\n        // we must get the same session back\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, \"We should keep the sessionId.\" );\n        assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], \"The session should exist in memcached.\" );\n\n        // some more checks in sticky mode\n        if ( sessionAffinity.isSticky() ) {\n            final Session session = getManager( _tomcat1 ).findSession( sid2 );\n            assertNotNull( session, \"Session not found by new id \" + sid2 );\n            assertFalse( session.getNoteNames().hasNext(), \"Some notes are set: \" + toArray( session.getNoteNames() ) );\n        }\n\n    }\n\n    /**\n     * Tests that multiple memcached nodes can fail and backup/relocation handles this.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testMultipleMemcachedNodesFailure( final SessionAffinityMode sessionAffinity ) throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String paramKey = \"foo\";\n        final String paramValue = \"bar\";\n        final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId();\n        assertNotNull( sid1, \"No session created.\" );\n        final String firstNode = extractNodeId( sid1 );\n        assertNotNull( firstNode, \"No node id encoded in session id.\" );\n\n        /* shutdown active and another memcached node\n         */\n        final FailoverInfo info = getFailoverInfo( firstNode );\n        info.activeNode.stop();\n        final Map.Entry<String, MemCacheDaemon<?>> otherNodeWithId = info.previousNode();\n        otherNodeWithId.getValue().stop();\n\n        Thread.sleep( 100 );\n\n        final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getResponseSessionId();\n        final String secondNode = extractNodeId( sid2 );\n        LOG.debug( \"Have secondNode \" + secondNode );\n        final String expectedNode = info.otherNodeExcept( otherNodeWithId.getKey() ).getKey();\n\n        assertEquals( secondNode, expectedNode, \"Unexpected nodeId: \" + secondNode + \".\" );\n\n        assertEquals(\n                sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + expectedNode,\n                \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2 );\n\n        // we must get the same session back\n        final Response response2 = get( _httpClient, _portTomcat1, sid2 );\n        assertEquals( response2.getSessionId(), sid2, \"We should keep the sessionId.\" );\n        assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], \"The session should exist in memcached.\" );\n        assertEquals( response2.get( paramKey ), paramValue, \"The session should still contain the previously stored value.\" );\n\n        // some more checks in sticky mode\n        if ( sessionAffinity.isSticky() ) {\n            final Session session = getManager( _tomcat1 ).findSession( sid2 );\n            assertFalse( session.getNoteNames().hasNext(), \"Some notes are set: \" + toArray( session.getNoteNames() ) );\n        }\n\n    }\n\n    /**\n     * Tests that after a memcached failure (with only 1 memcached left) and reactivation the backup of the session is\n     * stored again in the secondary memcached, so that the primary memcached can die and the session is still available.\n     */\n    @Test( enabled = true )\n    public void testSecondaryBackupForNonStickySessionAfterMemcachedFailover() throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( false );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String paramKey = \"foo\";\n        final String paramValue = \"bar\";\n        final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId();\n        assertNotNull( sid1, \"No session created.\" );\n        final String firstNode = extractNodeId( sid1 );\n        assertNotNull( firstNode, \"No node id encoded in session id.\" );\n\n        /* shutdown other nodes\n         */\n        LOG.info( \"-------------- stopping other nodes...\" );\n        final FailoverInfo info = getFailoverInfo( firstNode );\n        for( final MemCacheDaemon<?> node : info.otherNodes.values() ) {\n            node.stop();\n        }\n        Thread.sleep( 100 );\n\n        /* make a request with only one memcached\n         */\n        assertEquals( get( _httpClient, _portTomcat1, sid1 ).getSessionId(), sid1 );\n        Thread.sleep( 300 ); // wait for the async processes to complete / be cancelleds\n\n        /* now start the next node that shall get the backup again and make a request\n         * that does not modify the session\n         */\n        LOG.info( \"-------------- starting next node...\" );\n        info.nextNode().getValue().start();\n        waitForReconnect( getManager( _tomcat1 ), info.nextNode().getValue(), 5000 );\n        assertEquals( get( _httpClient, _portTomcat1, sid1 ).getSessionId(), sid1 );\n        Thread.sleep( 300 ); // wait for the async processes to complete / be cancelleds\n\n        /* now shutdown the active node so that the session is loaded from the secondary node\n         */\n        LOG.info( \"-------------- stopping active node...\" );\n        info.activeNode.stop();\n        Thread.sleep( 100 );\n\n        /* make the request and check that we still have all session data\n         */\n        final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getSessionId();\n        final String secondNode = extractNodeId( sid2 );\n        final String expectedNode = info.nextNode().getKey();\n\n        assertEquals( secondNode, expectedNode, \"Unexpected nodeId: \" + secondNode + \".\" );\n\n        assertEquals(\n                sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + expectedNode,\n                \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2 );\n\n        // we must get the same session back\n        final Response response2 = get( _httpClient, _portTomcat1, sid2 );\n        assertEquals( response2.getSessionId(), sid2, \"We should keep the sessionId.\" );\n        assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], \"The session should exist in memcached.\" );\n        assertEquals( response2.get( paramKey ), paramValue, \"The session should still contain the previously stored value.\" );\n\n    }\n\n    private void waitForReconnect( final MemcachedBackupSessionManager manager, final MemCacheDaemon<?> value, final long timeToWait ) throws InterruptedException {\n        MemcachedClient client;\n        InetSocketAddress serverAddress;\n        try {\n            final Method m = MemcachedBackupSessionManager.class.getDeclaredMethod( \"getMemcached\" );\n            m.setAccessible( true );\n            client = (MemcachedClient) m.invoke( manager );\n\n            final Field field = MemCacheDaemon.class.getDeclaredField( \"addr\" );\n            field.setAccessible( true );\n            serverAddress = (InetSocketAddress) field.get( value );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( e );\n        }\n\n        waitForReconnect( client, serverAddress, timeToWait );\n    }\n\n    public void waitForReconnect( final MemcachedClient client, final InetSocketAddress serverAddressToCheck, final long timeToWait )\n            throws InterruptedException, RuntimeException {\n        final long start = System.currentTimeMillis();\n        while( System.currentTimeMillis() < start + timeToWait ) {\n            for( final SocketAddress address : client.getAvailableServers() ) {\n                if ( address.equals( serverAddressToCheck ) ) {\n                    return;\n                }\n            }\n            Thread.sleep( 100 );\n        }\n        throw new RuntimeException( \"MemcachedClient did not reconnect after \" + timeToWait + \" millis.\" );\n    }\n\n    private Set<String> toArray( final Iterator<String> noteNames ) {\n        final Set<String> result = new HashSet<String>();\n        while ( noteNames.hasNext() ) {\n            result.add( noteNames.next() );\n        }\n        return result;\n    }\n\n    /**\n     * Tests that the previous session id is kept when all memcached nodes fail.\n     *\n     * @throws Throwable\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test( enabled = true )\n    public void testAllMemcachedNodesFailure() throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( true );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String sid1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sid1, \"No session created.\" );\n\n        /* shutdown all memcached nodes\n         */\n        _daemon1.stop();\n        _daemon2.stop();\n        _daemon3.stop();\n\n        // wait a little bit\n        Thread.sleep( 200 );\n\n        final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 );\n\n        assertEquals( sid1, sid2, \"SessionId changed.\" );\n\n        assertNotNull( getSessions().get( sid1 ), \"Session \"+ sid1 +\" not existing.\" );\n\n        final Session session = getManager( _tomcat1 ).findSession( sid2 );\n        assertFalse( session.getNoteNames().hasNext(), \"Some notes are set: \" + toArray( session.getNoteNames() ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testCookieNotSetWhenAllMemcachedsDownIssue40() throws IOException, HttpException, InterruptedException {\n\n        getManager( _tomcat1 ).setSticky( true );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        /* shutdown all memcached nodes\n         */\n        _daemon1.stop();\n        _daemon2.stop();\n        _daemon3.stop();\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId = response1.getSessionId();\n        assertNotNull( sessionId );\n        assertNotNull( response1.getResponseSessionId() );\n\n        final String nodeId = extractNodeId( response1.getResponseSessionId() );\n        assertNull( nodeId, \"NodeId should be null, but is \" + nodeId + \".\" );\n\n        final Response response2 = get( _httpClient, _portTomcat1, sessionId );\n        assertEquals( response2.getSessionId(), sessionId, \"SessionId changed\" );\n        assertNull( response2.getResponseSessionId() );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testCookieNotSetWhenRegularMemcachedDownIssue40( final SessionAffinityMode sessionAffinity ) throws Exception {\n\n        /* reconfigure tomcat with failover node\n         */\n        final String memcachedNodes = toString( _nodeId1, _address1 ) +\n        \" \" + toString( _nodeId2, _address2 );\n        restartTomcat( memcachedNodes, _nodeId1 );\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        /* shutdown regular memcached node\n         */\n        _daemon2.stop();\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId = response1.getSessionId();\n        assertNotNull( sessionId );\n        assertNotNull( response1.getResponseSessionId() );\n\n        final String nodeId = extractNodeId( response1.getResponseSessionId() );\n        assertEquals( nodeId, _nodeId1 );\n\n        final Response response2 = get( _httpClient, _portTomcat1, sessionId );\n        assertEquals( response2.getSessionId(), sessionId, \"SessionId changed\" );\n        assertNull( response2.getResponseSessionId() );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testReconfigureMemcachedNodesAtRuntimeFeature46( final SessionAffinityMode sessionAffinity ) throws Exception {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        /* reconfigure tomcat with only two memcached nodes\n         */\n        final String memcachedNodes1 = toString( _nodeId1, _address1 ) +\n        \" \" + toString( _nodeId2, _address2 );\n        restartTomcat( memcachedNodes1, _nodeId2 );\n\n        /* wait until everything's up and running...\n         */\n        Thread.sleep( 200 );\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId1 = response1.getSessionId();\n        assertNotNull( sessionId1 );\n        assertEquals( extractNodeId( sessionId1 ), _nodeId1 );\n\n        /* reconfigure tomcat with only third memcached nodes and stop\n         * the first one\n         */\n        final String memcachedNodes2 = toString( _nodeId1, _address1 ) +\n            \" \" + toString( _nodeId2, _address2 ) +\n            \" \" + toString( _nodeId3, _address3 );\n        getManager( _tomcat1 ).setMemcachedNodes( memcachedNodes2 );\n\n        _daemon1.stop();\n\n        Thread.sleep( 1000 );\n\n        /* Expect relocation to node3\n         */\n        final Response response2 = get( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( response2.getSessionId(), sessionId1 );\n        final String sessionId2 = response2.getResponseSessionId();\n        assertNotNull( sessionId2 );\n        assertEquals( extractNodeId( sessionId2 ), _nodeId3 );\n\n    }\n\n    @Test( enabled = true )\n    public void testReconfigureFailoverNodesAtRuntimeFeature46() throws Exception {\n\n        getManager( _tomcat1 ).setSticky( true );\n\n        /* set failover nodes n2 and n3\n         */\n        getManager( _tomcat1 ).setFailoverNodes( _nodeId2 + \" \" + _nodeId3 );\n\n        /* wait for changes...\n         */\n        Thread.sleep( 200 );\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId1 = response1.getSessionId();\n        assertNotNull( sessionId1 );\n        assertEquals( extractNodeId( sessionId1 ), _nodeId1 );\n\n        /* set failover nodes n1 and n2\n         */\n        getManager( _tomcat1 ).setFailoverNodes( _nodeId1 + \" \" + _nodeId2 );\n\n        /* wait for changes...\n         */\n        Thread.sleep( 200 );\n\n        // we need to use another http client, otherwise there's no response cookie.\n        final Response response2 = get( new DefaultHttpClient(), _portTomcat1, null );\n        final String sessionId2 = response2.getSessionId();\n        assertNotNull( sessionId2 );\n        assertEquals( extractNodeId( sessionId2 ), _nodeId3 );\n\n    }\n\n    private void restartTomcat( final String memcachedNodes, final String failoverNodes ) throws Exception {\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        _tomcat1 = createCatalina( _portTomcat1, 10, memcachedNodes );\n        getManager( _tomcat1 ).setFailoverNodes( failoverNodes );\n        _tomcat1.start();\n    }\n\n    private Map<String, Session> getSessions() throws NoSuchFieldException,\n            IllegalAccessException {\n        final Field field = ManagerBase.class.getDeclaredField( \"sessions\" );\n        field.setAccessible( true );\n        @SuppressWarnings(\"unchecked\")\n        final Map<String,Session> sessions = (Map<String, Session>)field.get( getManager( _tomcat1 ) );\n        return sessions;\n    }\n\n    /* plain stupid\n     */\n    private FailoverInfo getFailoverInfo( final String nodeId ) {\n        if ( _nodeId1.equals( nodeId ) ) {\n            return new FailoverInfo( _daemon1, asMap( _nodeId2, _daemon2, _nodeId3, _daemon3 ) );\n        } else if ( _nodeId2.equals( nodeId ) ) {\n            return new FailoverInfo( _daemon2, asMap( _nodeId3, _daemon3, _nodeId1, _daemon1 ) );\n        } else if ( _nodeId3.equals( nodeId ) ) {\n            return new FailoverInfo( _daemon3, asMap( _nodeId1, _daemon1, _nodeId2, _daemon2 ) );\n        }\n        throw new IllegalArgumentException( \"Node \" + nodeId + \" is not a valid node id.\" );\n    }\n\n    private Map<String, MemCacheDaemon<?>> asMap( final String nodeId1, final MemCacheDaemon<?> daemon1,\n            final String nodeId2, final MemCacheDaemon<?> daemon2 ) {\n        final Map<String, MemCacheDaemon<?>> result = new LinkedHashMap<String, MemCacheDaemon<?>>( 2 );\n        result.put( nodeId1, daemon1 );\n        result.put( nodeId2, daemon2 );\n        return result;\n    }\n\n    static class FailoverInfo {\n        MemCacheDaemon<?> activeNode;\n        Map<String, MemCacheDaemon<?>> otherNodes;\n        public FailoverInfo(final MemCacheDaemon<?> first,\n                final Map<String, MemCacheDaemon<?>> otherNodes ) {\n            this.activeNode = first;\n            this.otherNodes = otherNodes;\n        }\n        public Entry<String, MemCacheDaemon<?>> nextNode() {\n            return otherNodes.entrySet().iterator().next();\n        }\n        public Entry<String, MemCacheDaemon<?>> previousNode() {\n            Entry<String, MemCacheDaemon<?>> last = null;\n            for ( final Entry<String, MemCacheDaemon<?>> entry : otherNodes.entrySet() ) {\n                last = entry;\n            }\n            return last;\n        }\n        public Entry<String, MemCacheDaemon<?>> otherNodeExcept( final String key ) {\n            for( final Map.Entry<String, MemCacheDaemon<?>> entry : otherNodes.entrySet() ) {\n                if ( !entry.getKey().equals( key ) ) {\n                    return entry;\n                }\n            }\n            throw new IllegalStateException();\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.CacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.MemcachedSessionService;\nimport de.javakaffee.web.msm.integration.TestUtils.Response;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing memcached failover.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic abstract class MemcachedFailoverIntegrationTest {\n\n    private static final Log LOG = LogFactory\n            .getLog( MemcachedFailoverIntegrationTest.class );\n\n    private MemCacheDaemon<? extends CacheElement> _daemon1;\n    private MemCacheDaemon<? extends CacheElement> _daemon2;\n    private MemCacheDaemon<? extends CacheElement> _daemon3;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private DefaultHttpClient _httpClient;\n\n    private String _nodeId1;\n    private String _nodeId2;\n    private String _nodeId3;\n\n    private InetSocketAddress _address1;\n\n    private InetSocketAddress _address2;\n\n    private InetSocketAddress _address3;\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _address1 = new InetSocketAddress( \"localhost\", 21211 );\n        _daemon1 = createDaemon( _address1 );\n        _daemon1.start();\n\n        _address2 = new InetSocketAddress( \"localhost\", 21212 );\n        _daemon2 = createDaemon( _address2 );\n        _daemon2.start();\n\n        _address3 = new InetSocketAddress( \"localhost\", 21213 );\n        _daemon3 = createDaemon( _address3 );\n        _daemon3.start();\n\n        _nodeId1 = \"n1\";\n        _nodeId2 = \"n2\";\n        _nodeId3 = \"n3\";\n\n        try {\n            final String memcachedNodes = toString( _nodeId1, _address1 ) +\n                \" \" + toString( _nodeId2, _address2 ) +\n                \" \" + toString( _nodeId3, _address3 );\n            _tomcat1 = getTestUtils().createCatalina( _portTomcat1, 10, memcachedNodes );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _httpClient = new DefaultHttpClient();\n    }\n    \n    abstract TestUtils getTestUtils();\n\n    private String toString( final String nodeId, final InetSocketAddress address ) {\n        return nodeId + \":\" + address.getHostName() + \":\" + address.getPort();\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        if ( _daemon1.isRunning() ) {\n            _daemon1.stop();\n        }\n        if ( _daemon2.isRunning() ) {\n            _daemon2.stop();\n        }\n        if ( _daemon3.isRunning() ) {\n            _daemon3.stop();\n        }\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n    }\n\n    /**\n     * Tests, that on a memcached failover sessions are relocated to another node and that\n     * the session id reflects this. The session must no longer be available under the old\n     * session id.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testRelocateSession( final SessionAffinityMode sessionAffinity ) throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String sid1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sid1, \"No session created.\" );\n        final String firstNode = extractNodeId( sid1 );\n        assertNotNull( firstNode, \"No node id encoded in session id.\" );\n\n        final FailoverInfo info = getFailoverInfo( firstNode );\n        info.activeNode.stop();\n\n        Thread.sleep( 50 );\n\n        final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 );\n        final String secondNode = extractNodeId( sid2 );\n\n        assertNotSame( secondNode, firstNode, \"First node again selected\" );\n\n        assertEquals(\n                sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + secondNode,\n                \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2 );\n\n        // we must get the same session back\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, \"We should keep the sessionId.\" );\n        assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], \"The session should exist in memcached.\" );\n\n        // some more checks in sticky mode\n        if ( sessionAffinity.isSticky() ) {\n            final Session session = getManager( _tomcat1 ).findSession( sid2 );\n            assertNotNull( session, \"Session not found by new id \" + sid2 );\n            assertFalse( session.getNoteNames().hasNext(), \"Some notes are set: \" + toArray( session.getNoteNames() ) );\n        }\n\n    }\n\n    /**\n     * Tests that multiple memcached nodes can fail and backup/relocation handles this.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testMultipleMemcachedNodesFailure( final SessionAffinityMode sessionAffinity ) throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String paramKey = \"foo\";\n        final String paramValue = \"bar\";\n        final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId();\n        assertNotNull( sid1, \"No session created.\" );\n        final String firstNode = extractNodeId( sid1 );\n        assertNotNull( firstNode, \"No node id encoded in session id.\" );\n\n        /* shutdown active and another memcached node\n         */\n        final FailoverInfo info = getFailoverInfo( firstNode );\n        info.activeNode.stop();\n        final Map.Entry<String, MemCacheDaemon<?>> otherNodeWithId = info.previousNode();\n        otherNodeWithId.getValue().stop();\n\n        Thread.sleep( 100 );\n\n        final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getResponseSessionId();\n        final String secondNode = extractNodeId( sid2 );\n        LOG.debug( \"Have secondNode \" + secondNode );\n        final String expectedNode = info.otherNodeExcept( otherNodeWithId.getKey() ).getKey();\n\n        assertEquals( secondNode, expectedNode, \"Unexpected nodeId: \" + secondNode + \".\" );\n\n        assertEquals(\n                sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + expectedNode,\n                \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2 );\n\n        // we must get the same session back\n        final Response response2 = get( _httpClient, _portTomcat1, sid2 );\n        assertEquals( response2.getSessionId(), sid2, \"We should keep the sessionId.\" );\n        final MemCacheDaemon<?> activeNode = getFailoverInfo( secondNode ).activeNode;\n        assertNotNull( activeNode.getCache().get( key( sid2 ) )[0], \"The session should exist in memcached.\" );\n        assertEquals( response2.get( paramKey ), paramValue, \"The session should still contain the previously stored value.\" );\n\n        // some more checks in sticky mode\n        if ( sessionAffinity.isSticky() ) {\n            final Session session = getManager( _tomcat1 ).findSession( sid2 );\n            assertFalse( session.getNoteNames().hasNext(), \"Some notes are set: \" + toArray( session.getNoteNames() ) );\n        }\n\n    }\n\n    /**\n     * Tests that after a memcached failure (with only 1 memcached left) and reactivation the backup of the session is\n     * stored again in the secondary memcached, so that the primary memcached can die and the session is still available.\n     */\n    @Test( enabled = true )\n    public void testSecondaryBackupForNonStickySessionAfterMemcachedFailover() throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( false );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String paramKey = \"foo\";\n        final String paramValue = \"bar\";\n        final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId();\n        assertNotNull( sid1, \"No session created.\" );\n        final String firstNode = extractNodeId( sid1 );\n        assertNotNull( firstNode, \"No node id encoded in session id.\" );\n\n        /* shutdown other nodes\n         */\n        LOG.info( \"-------------- stopping other nodes...\" );\n        final FailoverInfo info = getFailoverInfo( firstNode );\n        for( final MemCacheDaemon<?> node : info.otherNodes.values() ) {\n            node.stop();\n        }\n        Thread.sleep( 100 );\n\n        /* make a request with only one memcached\n         */\n        assertEquals( get( _httpClient, _portTomcat1, sid1 ).getSessionId(), sid1 );\n        Thread.sleep( 300 ); // wait for the async processes to complete / be cancelleds\n\n        /* now start the next node that shall get the backup again and make a request\n         * that does not modify the session\n         */\n        LOG.info( \"-------------- starting next node...\" );\n        info.nextNode().getValue().start();\n        waitForReconnect( getManager( _tomcat1 ).getMemcachedSessionService(), info.nextNode().getValue(), 5000 );\n        assertEquals( get( _httpClient, _portTomcat1, sid1 ).getSessionId(), sid1 );\n        Thread.sleep( 300 ); // wait for the async processes to complete / be cancelleds\n\n        /* now shutdown the active node so that the session is loaded from the secondary node\n         */\n        LOG.info( \"-------------- stopping active node...\" );\n        info.activeNode.stop();\n        Thread.sleep( 100 );\n\n        /* make the request and check that we still have all session data\n         */\n        final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getSessionId();\n        final String secondNode = extractNodeId( sid2 );\n        final String expectedNode = info.nextNode().getKey();\n\n        assertEquals( secondNode, expectedNode, \"Unexpected nodeId: \" + secondNode + \".\" );\n\n        assertEquals(\n                sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + expectedNode,\n                \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2 );\n\n        // we must get the same session back\n        final Response response2 = get( _httpClient, _portTomcat1, sid2 );\n        assertEquals( response2.getSessionId(), sid2, \"We should keep the sessionId.\" );\n        assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], \"The session should exist in memcached.\" );\n        assertEquals( response2.get( paramKey ), paramValue, \"The session should still contain the previously stored value.\" );\n\n    }\n\n    private void waitForReconnect( final MemcachedSessionService service, final MemCacheDaemon<?> value, final long timeToWait ) throws InterruptedException {\n        MemcachedClient client;\n        InetSocketAddress serverAddress;\n        try {\n            final Method m = MemcachedSessionService.class.getDeclaredMethod( \"getMemcached\" );\n            m.setAccessible( true );\n            client = (MemcachedClient) m.invoke( service );\n\n            final Field field = MemCacheDaemon.class.getDeclaredField( \"addr\" );\n            field.setAccessible( true );\n            serverAddress = (InetSocketAddress) field.get( value );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( e );\n        }\n\n        waitForReconnect( client, serverAddress, timeToWait );\n    }\n\n    public void waitForReconnect( final MemcachedClient client, final InetSocketAddress serverAddressToCheck, final long timeToWait )\n            throws InterruptedException, RuntimeException {\n        final long start = System.currentTimeMillis();\n        while( System.currentTimeMillis() < start + timeToWait ) {\n            for( final SocketAddress address : client.getAvailableServers() ) {\n                if ( address.equals( serverAddressToCheck ) ) {\n                    return;\n                }\n            }\n            Thread.sleep( 100 );\n        }\n        throw new RuntimeException( \"MemcachedClient did not reconnect after \" + timeToWait + \" millis.\" );\n    }\n\n    private Set<String> toArray( final Iterator<String> noteNames ) {\n        final Set<String> result = new HashSet<String>();\n        while ( noteNames.hasNext() ) {\n            result.add( noteNames.next() );\n        }\n        return result;\n    }\n\n    /**\n     * Tests that the previous session id is kept when all memcached nodes fail.\n     *\n     * @throws Throwable\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test( enabled = true )\n    public void testAllMemcachedNodesFailure() throws Throwable {\n\n        getManager( _tomcat1 ).setSticky( true );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        final String sid1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sid1, \"No session created.\" );\n\n        /* shutdown all memcached nodes\n         */\n        _daemon1.stop();\n        _daemon2.stop();\n        _daemon3.stop();\n\n        // wait a little bit\n        Thread.sleep( 200 );\n\n        final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 );\n\n        assertEquals( sid1, sid2, \"SessionId changed.\" );\n\n        assertNotNull( getSessions().get( sid1 ), \"Session \"+ sid1 +\" not existing.\" );\n\n        final Session session = getManager( _tomcat1 ).findSession( sid2 );\n        assertFalse( session.getNoteNames().hasNext(), \"Some notes are set: \" + toArray( session.getNoteNames() ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testCookieNotSetWhenAllMemcachedsDownIssue40() throws IOException, HttpException, InterruptedException {\n\n        getManager( _tomcat1 ).setSticky( true );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        /* shutdown all memcached nodes\n         */\n        _daemon1.stop();\n        _daemon2.stop();\n        _daemon3.stop();\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId = response1.getSessionId();\n        assertNotNull( sessionId );\n        assertNotNull( response1.getResponseSessionId() );\n\n        final String nodeId = extractNodeId( response1.getResponseSessionId() );\n        assertNull( nodeId, \"NodeId should be null, but is \" + nodeId + \".\" );\n\n        final Response response2 = get( _httpClient, _portTomcat1, sessionId );\n        assertEquals( response2.getSessionId(), sessionId, \"SessionId changed\" );\n        assertNull( response2.getResponseSessionId() );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testCookieNotSetWhenRegularMemcachedDownIssue40( final SessionAffinityMode sessionAffinity ) throws Exception {\n\n        /* reconfigure tomcat with failover node\n         */\n        final String memcachedNodes = toString( _nodeId1, _address1 ) +\n        \" \" + toString( _nodeId2, _address2 );\n        restartTomcat( memcachedNodes, _nodeId1 );\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        /* shutdown regular memcached node\n         */\n        _daemon2.stop();\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId = response1.getSessionId();\n        assertNotNull( sessionId );\n        assertNotNull( response1.getResponseSessionId() );\n\n        final String nodeId = extractNodeId( response1.getResponseSessionId() );\n        assertEquals( nodeId, _nodeId1 );\n\n        final Response response2 = get( _httpClient, _portTomcat1, sessionId );\n        assertEquals( response2.getSessionId(), sessionId, \"SessionId changed\" );\n        assertNull( response2.getResponseSessionId() );\n\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testReconfigureMemcachedNodesAtRuntimeFeature46( final SessionAffinityMode sessionAffinity ) throws Exception {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        // we had a situation where no session was created, so let's take some break so that everything's up again\n        Thread.sleep( 200 );\n\n        /* reconfigure tomcat with only two memcached nodes\n         */\n        final String memcachedNodes1 = toString( _nodeId1, _address1 ) +\n        \" \" + toString( _nodeId2, _address2 );\n        restartTomcat( memcachedNodes1, _nodeId2 );\n\n        /* wait until everything's up and running...\n         */\n        Thread.sleep( 200 );\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId1 = response1.getSessionId();\n        assertNotNull( sessionId1 );\n        assertEquals( extractNodeId( sessionId1 ), _nodeId1 );\n\n        /* reconfigure tomcat with only third memcached nodes and stop\n         * the first one\n         */\n        final String memcachedNodes2 = toString( _nodeId1, _address1 ) +\n            \" \" + toString( _nodeId2, _address2 ) +\n            \" \" + toString( _nodeId3, _address3 );\n        getManager( _tomcat1 ).setMemcachedNodes( memcachedNodes2 );\n\n        _daemon1.stop();\n\n        Thread.sleep( 1000 );\n\n        /* Expect relocation to node3\n         */\n        final Response response2 = get( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( response2.getSessionId(), sessionId1 );\n        final String sessionId2 = response2.getResponseSessionId();\n        assertNotNull( sessionId2 );\n        assertEquals( extractNodeId( sessionId2 ), _nodeId3 );\n\n    }\n\n    @Test( enabled = true )\n    public void testReconfigureFailoverNodesAtRuntimeFeature46() throws Exception {\n\n        getManager( _tomcat1 ).setSticky( true );\n\n        /* set failover nodes n2 and n3\n         */\n        getManager( _tomcat1 ).setFailoverNodes( _nodeId2 + \" \" + _nodeId3 );\n\n        /* wait for changes...\n         */\n        Thread.sleep( 200 );\n\n        final Response response1 = get( _httpClient, _portTomcat1, null );\n        final String sessionId1 = response1.getSessionId();\n        assertNotNull( sessionId1 );\n        assertEquals( extractNodeId( sessionId1 ), _nodeId1 );\n\n        /* set failover nodes n1 and n2\n         */\n        getManager( _tomcat1 ).setFailoverNodes( _nodeId1 + \" \" + _nodeId2 );\n\n        /* wait for changes...\n         */\n        Thread.sleep( 200 );\n\n        // we need to use another http client, otherwise there's no response cookie.\n        final Response response2 = get( new DefaultHttpClient(), _portTomcat1, null );\n        final String sessionId2 = response2.getSessionId();\n        assertNotNull( sessionId2 );\n        assertEquals( extractNodeId( sessionId2 ), _nodeId3 );\n\n    }\n\n    private void restartTomcat( final String memcachedNodes, final String failoverNodes ) throws Exception {\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        _tomcat1 = getTestUtils().createCatalina( _portTomcat1, 10, memcachedNodes );\n        getManager( _tomcat1 ).setFailoverNodes( failoverNodes );\n        _tomcat1.start();\n    }\n\n    private Map<String, Session> getSessions() throws NoSuchFieldException,\n            IllegalAccessException {\n        final Field field = ManagerBase.class.getDeclaredField( \"sessions\" );\n        field.setAccessible( true );\n        @SuppressWarnings(\"unchecked\")\n        final Map<String,Session> sessions = (Map<String, Session>)field.get( getManager( _tomcat1 ) );\n        return sessions;\n    }\n\n    /* plain stupid\n     */\n    private FailoverInfo getFailoverInfo( final String nodeId ) {\n        if ( _nodeId1.equals( nodeId ) ) {\n            return new FailoverInfo( _daemon1, asMap( _nodeId2, _daemon2, _nodeId3, _daemon3 ) );\n        } else if ( _nodeId2.equals( nodeId ) ) {\n            return new FailoverInfo( _daemon2, asMap( _nodeId3, _daemon3, _nodeId1, _daemon1 ) );\n        } else if ( _nodeId3.equals( nodeId ) ) {\n            return new FailoverInfo( _daemon3, asMap( _nodeId1, _daemon1, _nodeId2, _daemon2 ) );\n        }\n        throw new IllegalArgumentException( \"Node \" + nodeId + \" is not a valid node id.\" );\n    }\n\n    private Map<String, MemCacheDaemon<?>> asMap( final String nodeId1, final MemCacheDaemon<?> daemon1,\n            final String nodeId2, final MemCacheDaemon<?> daemon2 ) {\n        final Map<String, MemCacheDaemon<?>> result = new LinkedHashMap<String, MemCacheDaemon<?>>( 2 );\n        result.put( nodeId1, daemon1 );\n        result.put( nodeId2, daemon2 );\n        return result;\n    }\n\n    static class FailoverInfo {\n        MemCacheDaemon<?> activeNode;\n        Map<String, MemCacheDaemon<?>> otherNodes;\n        public FailoverInfo(final MemCacheDaemon<?> first,\n                final Map<String, MemCacheDaemon<?>> otherNodes ) {\n            this.activeNode = first;\n            this.otherNodes = otherNodes;\n        }\n        public Entry<String, MemCacheDaemon<?>> nextNode() {\n            return otherNodes.entrySet().iterator().next();\n        }\n        public Entry<String, MemCacheDaemon<?>> previousNode() {\n            Entry<String, MemCacheDaemon<?>> last = null;\n            for ( final Entry<String, MemCacheDaemon<?>> entry : otherNodes.entrySet() ) {\n                last = entry;\n            }\n            return last;\n        }\n        public Entry<String, MemCacheDaemon<?>> otherNodeExcept( final String key ) {\n            for( final Map.Entry<String, MemCacheDaemon<?>> entry : otherNodes.entrySet() ) {\n                if ( !entry.getKey().equals( key ) ) {\n                    return entry;\n                }\n            }\n            throw new IllegalStateException();\n        }\n    }\n\n}\n","lineNo":232}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.spy.memcached.MemcachedNode;\nimport net.spy.memcached.NodeLocator;\nimport net.spy.memcached.ops.Operation;\n\n/**\n * Locates nodes based on their id which is a part of the sessionId (key).\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SuffixBasedNodeLocator implements NodeLocator {\n\n    private final List<MemcachedNode> _nodes;\n    private final NodeIdList _nodeIds;\n    private final NodeIdResolver _resolver;\n    private final Map<String, MemcachedNode> _nodesMap;\n    private final SessionIdFormat _sessionIdFormat;\n\n    /**\n     * Create a new {@link SuffixBasedNodeLocator}.\n     *\n     * @param nodes\n     *            the nodes to select from.\n     * @param nodeIds\n     *            the list of nodeIds.\n     * @param resolver\n     *            used to resolve the node id for the address of a memcached\n     *            node.\n     * @param sessionIdFormat\n     *            used to extract the node id from the session id.\n     */\n    public SuffixBasedNodeLocator( final List<MemcachedNode> nodes, final NodeIdList nodeIds, final NodeIdResolver resolver,\n            final SessionIdFormat sessionIdFormat ) {\n        _nodes = nodes;\n        _nodeIds = nodeIds;\n        _resolver = resolver;\n\n        final Map<String, MemcachedNode> map = new HashMap<String, MemcachedNode>( nodes.size(), 1 );\n        for ( int i = 0; i < nodes.size(); i++ ) {\n            final MemcachedNode memcachedNode = nodes.get( i );\n            final String nodeId = resolver.getNodeId( (InetSocketAddress) memcachedNode.getSocketAddress() );\n            map.put( nodeId, memcachedNode );\n        }\n        _nodesMap = map;\n\n        _sessionIdFormat = sessionIdFormat;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection<MemcachedNode> getAll() {\n        return _nodesMap.values();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedNode getPrimary( final String key ) {\n        final MemcachedNode result = _nodesMap.get( getNodeId( key ) );\n        if ( result == null ) {\n            throw new IllegalArgumentException( \"No node found for key \" + key );\n        }\n        return result;\n    }\n\n    private String getNodeId( final String key ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( key );\n        if ( !_sessionIdFormat.isBackupKey( key ) ) {\n            return nodeId;\n        }\n        return _nodeIds.getNextNodeId( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Iterator<MemcachedNode> getSequence( final String key ) {\n        throw new UnsupportedOperationException( \"This should not be called as we specified FailureMode.Cancel.\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeLocator getReadonlyCopy() {\n        final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>();\n        for ( final MemcachedNode node : _nodes ) {\n            nodes.add( new MyMemcachedNodeROImpl( node ) );\n        }\n        return new SuffixBasedNodeLocator( nodes, _nodeIds, _resolver, _sessionIdFormat );\n    }\n\n    /**\n     * The class that is used for readonly copies.\n     *\n     */\n    static class MyMemcachedNodeROImpl implements MemcachedNode {\n\n        private final MemcachedNode _root;\n\n        public MyMemcachedNodeROImpl( final MemcachedNode node ) {\n            _root = node;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String toString() {\n            return _root.toString();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void addOp( final Operation op ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void connected() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void copyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void fillWriteBuffer( final boolean optimizeGets ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void fixupOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getBytesRemainingToWrite() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public SocketChannel getChannel() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation getCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation getCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public ByteBuffer getRbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getReconnectCount() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getSelectionOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public SelectionKey getSk() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public SocketAddress getSocketAddress() {\n            return _root.getSocketAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public ByteBuffer getWbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean hasReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean hasWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean isActive() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void reconnecting() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void registerChannel( final SocketChannel ch, final SelectionKey selectionKey ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation removeCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation removeCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setChannel( final SocketChannel to ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSk( final SelectionKey to ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setupResend() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void transitionWriteItem() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int writeSome() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Collection<Operation> destroyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void authComplete() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void insertOp( final Operation arg0 ) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void setupForAuth() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.spy.memcached.MemcachedNode;\nimport net.spy.memcached.NodeLocator;\nimport net.spy.memcached.ops.Operation;\n\n/**\n * Locates nodes based on their id which is a part of the sessionId (key).\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SuffixBasedNodeLocator implements NodeLocator {\n\n    private final List<MemcachedNode> _nodes;\n    private final NodeIdList _nodeIds;\n    private final NodeIdResolver _resolver;\n    private final Map<String, MemcachedNode> _nodesMap;\n    private final SessionIdFormat _sessionIdFormat;\n\n    /**\n     * Create a new {@link SuffixBasedNodeLocator}.\n     *\n     * @param nodes\n     *            the nodes to select from.\n     * @param nodeIds\n     *            the list of nodeIds.\n     * @param resolver\n     *            used to resolve the node id for the address of a memcached\n     *            node.\n     * @param sessionIdFormat\n     *            used to extract the node id from the session id.\n     */\n    public SuffixBasedNodeLocator( final List<MemcachedNode> nodes, final NodeIdList nodeIds, final NodeIdResolver resolver,\n            final SessionIdFormat sessionIdFormat ) {\n        _nodes = nodes;\n        _nodeIds = nodeIds;\n        _resolver = resolver;\n\n        final Map<String, MemcachedNode> map = new HashMap<String, MemcachedNode>( nodes.size(), 1 );\n        for ( int i = 0; i < nodes.size(); i++ ) {\n            final MemcachedNode memcachedNode = nodes.get( i );\n            final String nodeId = resolver.getNodeId( (InetSocketAddress) memcachedNode.getSocketAddress() );\n            map.put( nodeId, memcachedNode );\n        }\n        _nodesMap = map;\n\n        _sessionIdFormat = sessionIdFormat;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection<MemcachedNode> getAll() {\n        return _nodesMap.values();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MemcachedNode getPrimary( final String key ) {\n        final String nodeId = getNodeId( key );\n        final MemcachedNode result = _nodesMap.get( nodeId );\n        if ( result == null ) {\n            throw new IllegalArgumentException( \"No node found for key \" + key + \" (nodeId: \" + nodeId + \", known nodeIds: \" + _nodesMap.keySet() + \")\" );\n        }\n        return result;\n    }\n\n    private String getNodeId( final String key ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( key );\n        if ( !_sessionIdFormat.isBackupKey( key ) ) {\n            return nodeId;\n        }\n        return _nodeIds.getNextNodeId( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Iterator<MemcachedNode> getSequence( final String key ) {\n        throw new UnsupportedOperationException( \"This should not be called as we specified FailureMode.Cancel.\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeLocator getReadonlyCopy() {\n        final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>();\n        for ( final MemcachedNode node : _nodes ) {\n            nodes.add( new MyMemcachedNodeROImpl( node ) );\n        }\n        return new SuffixBasedNodeLocator( nodes, _nodeIds, _resolver, _sessionIdFormat );\n    }\n\n    /**\n     * The class that is used for readonly copies.\n     *\n     */\n    static class MyMemcachedNodeROImpl implements MemcachedNode {\n\n        private final MemcachedNode _root;\n\n        public MyMemcachedNodeROImpl( final MemcachedNode node ) {\n            _root = node;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String toString() {\n            return _root.toString();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void addOp( final Operation op ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void connected() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void copyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void fillWriteBuffer( final boolean optimizeGets ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void fixupOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getBytesRemainingToWrite() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public SocketChannel getChannel() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation getCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation getCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public ByteBuffer getRbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getReconnectCount() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getSelectionOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public SelectionKey getSk() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public SocketAddress getSocketAddress() {\n            return _root.getSocketAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public ByteBuffer getWbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean hasReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean hasWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean isActive() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void reconnecting() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void registerChannel( final SocketChannel ch, final SelectionKey selectionKey ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation removeCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Operation removeCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setChannel( final SocketChannel to ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSk( final SelectionKey to ) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setupResend() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void transitionWriteItem() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int writeSome() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Collection<Operation> destroyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void authComplete() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void insertOp( final Operation arg0 ) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void setupForAuth() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n}\n","lineNo":91}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.ServletException;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.valves.ValveBase;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\n\n/**\n * This valve is used for tracking requests for that the session must be sent to\n * memcached.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SessionTrackerValve extends ValveBase {\n\n    static final String RELOCATE = \"session.relocate\";\n\n    private final Log _log = LogFactory.getLog( MemcachedBackupSessionManager.class );\n\n    private final Pattern _ignorePattern;\n    private final SessionBackupService _sessionBackupService;\n    private final Statistics _statistics;\n    private final AtomicBoolean _enabled;\n    private final String _sessionCookieName;\n    private @CheckForNull LockingStrategy _lockingStrategy;\n\n    /**\n     * Creates a new instance with the given ignore pattern and\n     * {@link SessionBackupService}.\n     *\n     * @param ignorePattern\n     *            the regular expression for request uris to ignore\n     * @param context\n     *            the catalina context of this valve\n     * @param sessionBackupService\n     *            the service that actually backups sessions\n     * @param statistics\n     *            used to store statistics\n     * @param enabled\n     *            specifies if memcached-session-manager is enabled or not.\n     *            If <code>false<\/code>, each request is just processed without doing anything further.\n     */\n    public SessionTrackerValve( @Nullable final String ignorePattern, @Nonnull final Context context,\n            @Nonnull final SessionBackupService sessionBackupService,\n            @Nonnull final Statistics statistics,\n            @Nonnull final AtomicBoolean enabled ) {\n        if ( ignorePattern != null ) {\n            _log.info( \"Setting ignorePattern to \" + ignorePattern );\n            _ignorePattern = Pattern.compile( ignorePattern );\n        } else {\n            _ignorePattern = null;\n        }\n        _sessionBackupService = sessionBackupService;\n        _statistics = statistics;\n        _enabled = enabled;\n        _sessionCookieName = getSessionCookieName( context );\n    }\n\n    private String getSessionCookieName( final Context context ) {\n        String result = getSessionCookieNameFromContext( context );\n        if ( result == null ) {\n            result = Globals.SESSION_COOKIE_NAME;\n            _log.debug( \"Using session cookie name from context: \" + result );\n        }\n        return result;\n    }\n\n    protected String getSessionCookieNameFromContext( final Context context ) {\n        // since 6.0.27 the session cookie name, domain and path is configurable per context,\n        // see issue http://issues.apache.org/bugzilla/show_bug.cgi?id=48379\n        try {\n            final Method getSessionCookieName = Context.class.getDeclaredMethod( \"getSessionCookieName\" );\n            final String result = (String) getSessionCookieName.invoke( context );\n            if ( result != null ) {\n                _log.debug( \"Using session cookie name from context: \" + result );\n            }\n            return result;\n        } catch( final NoSuchMethodException e ) {\n            // the context does not provide the method getSessionCookieName\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not read session cookie name from context.\", e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns the actually used name for the session cookie.\n     * @return the cookie name, never null.\n     */\n    protected String getSessionCookieName() {\n        return _sessionCookieName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke( final Request request, final Response response ) throws IOException, ServletException {\n\n        if ( !_enabled.get() || _ignorePattern != null && _ignorePattern.matcher( request.getRequestURI() ).matches() ) {\n            getNext().invoke( request, response );\n        } else {\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \">>>>>> Request starting: \" + getURIWithQueryString( request ) + \" ==================\" );\n            }\n\n            boolean sessionIdChanged = false;\n            try {\n                storeRequestThreadLocal( request );\n                sessionIdChanged = changeRequestedSessionId( request, response );\n                getNext().invoke( request, response );\n            } finally {\n                backupSession( request, response, sessionIdChanged );\n                resetRequestThreadLocal();\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                logDebugRequestSessionCookie( request );\n                logDebugResponseCookie( response );\n                _log.debug( \"<<<<<< Request finished: \" + getURIWithQueryString( request ) + \" ==================\" );\n            }\n\n        }\n\n    }\n\n    private void logDebugRequestSessionCookie( final Request request ) {\n        for( final javax.servlet.http.Cookie cookie : request.getCookies() ) {\n            if ( cookie.getName().equals( _sessionCookieName ) ) {\n                _log.debug( \"Have request session cookie: domain=\" + cookie.getDomain() + \", maxAge=\" + cookie.getMaxAge() +\n                        \", path=\" + cookie.getPath() + \", value=\" + cookie.getValue() +\n                        \", version=\" + cookie.getVersion() + \", secure=\" + cookie.getSecure() );\n            }\n        }\n    }\n\n    @Nonnull\n    protected static String getURIWithQueryString( @Nonnull final Request request ) {\n        final String uri = request.getRequestURI();\n        final String qs = request.getMethod().toLowerCase().equals( \"post\" ) ? null : request.getQueryString();\n        return qs != null ? uri + \"?\" + qs : uri;\n    }\n\n    private void resetRequestThreadLocal() {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestFinished();\n        }\n    }\n\n    private void storeRequestThreadLocal( @Nonnull final Request request ) {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestStart( request );\n        }\n    }\n\n    /**\n     * If there's a session for a requested session id that is taken over (tomcat failover) or\n     * that will be relocated (memcached failover), the new session id will be set (via {@link Request#changeSessionId(String)}).\n     *\n     * @param request the request\n     * @param response the response\n     *\n     * @return <code>true<\/code> if the id of a valid session was changed.\n     *\n     * @see Request#changeSessionId(String)\n     */\n    private boolean changeRequestedSessionId( final Request request, final Response response ) {\n        /*\n         * Check for session relocation only if a session id was requested\n         */\n        if ( request.getRequestedSessionId() != null ) {\n\n        \tString newSessionId = _sessionBackupService.changeSessionIdOnTomcatFailover( request.getRequestedSessionId() );\n        \tif ( newSessionId == null ) {\n                newSessionId = _sessionBackupService.changeSessionIdOnMemcachedFailover( request.getRequestedSessionId() );\n            }\n\n            if ( newSessionId != null ) {\n                request.changeSessionId( newSessionId );\n                return true;\n            }\n\n        }\n        return false;\n    }\n\n    private void backupSession( final Request request, final Response response, final boolean sessionIdChanged ) {\n\n        /*\n         * Do we have a session?\n         */\n        String sessionId = getSessionIdFromResponseSessionCookie( response );\n        if ( sessionId == null ) {\n            sessionId = request.getRequestedSessionId();\n        }\n        if ( sessionId != null ) {\n            _statistics.requestWithSession();\n            _sessionBackupService.backupSession( sessionId, sessionIdChanged, getURIWithQueryString( request ) );\n        }\n        else {\n            _statistics.requestWithoutSession();\n        }\n\n    }\n\n    private String getSessionIdFromResponseSessionCookie( final Response response ) {\n        final String header = response.getHeader( \"Set-Cookie\" );\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            final String sessionIdPrefix = _sessionCookieName + \"=\";\n            final int idxNameStart = header.indexOf( sessionIdPrefix );\n            final int idxValueStart = idxNameStart + sessionIdPrefix.length();\n            int idxValueEnd = header.indexOf( ';', idxNameStart );\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.indexOf( ' ', idxValueStart );\n            }\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.length();\n            }\n            return header.substring( idxValueStart, idxValueEnd );\n        }\n        return null;\n    }\n\n    private void logDebugResponseCookie( final Response response ) {\n        final String header = response.getHeader(\"Set-Cookie\");\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            _log.debug( \"Request finished, with Set-Cookie header: \" + header );\n        }\n    }\n\n    /**\n     * The service that stores session backups in memcached.\n     */\n    public static interface SessionBackupService {\n\n        /**\n         * Check if the given session id does not belong to this tomcat (according to the\n         * local jvmRoute and the jvmRoute in the session id). If the session contains a\n         * different jvmRoute load if from memcached. If the session was found in memcached and\n         * if it's valid it must be associated with this tomcat and therefore the session id has to\n         * be changed. The new session id must be returned if it was changed.\n         * <p>\n         * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n         * always be returned.\n         * <\/p>\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session is taken over and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnTomcatFailover( final String requestedSessionId );\n\n        /**\n         * Check if the valid session associated with the provided\n         * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n         * and change the session id to the new one (containing the new memcached node). The\n         * new session id must be returned if the session will be relocated and the id was changed.\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session will be relocated and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnMemcachedFailover( final String requestedSessionId );\n\n        /**\n         * Backup the session for the provided session id in memcached if the session was modified or\n         * if the session needs to be relocated. In non-sticky session-mode the session should not be\n         * loaded from memcached for just storing it again but only metadata should be updated.\n         *\n         * @param sessionId\n         *            the if of the session to backup\n         * @param sessionIdChanged\n         *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n         * @param requestId\n         *            the uri of the request for that the session backup shall be performed.\n         *\n         * @return a {@link Future} providing the {@link BackupResultStatus}.\n         */\n        Future<BackupResult> backupSession( @Nonnull String sessionId, boolean sessionIdChanged, String requestId );\n\n        /**\n         * The enumeration of possible backup results.\n         */\n        static enum BackupResultStatus {\n                /**\n                 * The session was successfully stored in the sessions default memcached node.\n                 * This status is also used, if a session was relocated to another memcached node.\n                 */\n                SUCCESS,\n                /**\n                 * The session could not be stored in any memcached node.\n                 */\n                FAILURE,\n                /**\n                 * The session was not modified and therefore the backup was skipped.\n                 */\n                SKIPPED\n        }\n\n    }\n\n    public void setLockingStrategy( @Nullable final LockingStrategy lockingStrategy ) {\n        _lockingStrategy = lockingStrategy;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.valves.ValveBase;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\n\n/**\n * This valve is used for tracking requests for that the session must be sent to\n * memcached.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SessionTrackerValve extends ValveBase {\n\n    static final String RELOCATE = \"session.relocate\";\n\n    private final Log _log = LogFactory.getLog( MemcachedBackupSessionManager.class );\n\n    private final Pattern _ignorePattern;\n    private final SessionBackupService _sessionBackupService;\n    private final Statistics _statistics;\n    private final AtomicBoolean _enabled;\n    private final String _sessionCookieName;\n    private @CheckForNull LockingStrategy _lockingStrategy;\n\n    /**\n     * Creates a new instance with the given ignore pattern and\n     * {@link SessionBackupService}.\n     *\n     * @param ignorePattern\n     *            the regular expression for request uris to ignore\n     * @param context\n     *            the catalina context of this valve\n     * @param sessionBackupService\n     *            the service that actually backups sessions\n     * @param statistics\n     *            used to store statistics\n     * @param enabled\n     *            specifies if memcached-session-manager is enabled or not.\n     *            If <code>false<\/code>, each request is just processed without doing anything further.\n     */\n    public SessionTrackerValve( @Nullable final String ignorePattern, @Nonnull final Context context,\n            @Nonnull final SessionBackupService sessionBackupService,\n            @Nonnull final Statistics statistics,\n            @Nonnull final AtomicBoolean enabled ) {\n        if ( ignorePattern != null ) {\n            _log.info( \"Setting ignorePattern to \" + ignorePattern );\n            _ignorePattern = Pattern.compile( ignorePattern );\n        } else {\n            _ignorePattern = null;\n        }\n        _sessionBackupService = sessionBackupService;\n        _statistics = statistics;\n        _enabled = enabled;\n        _sessionCookieName = getSessionCookieName( context );\n    }\n\n    private String getSessionCookieName( final Context context ) {\n        String result = getSessionCookieNameFromContext( context );\n        if ( result == null ) {\n            result = Globals.SESSION_COOKIE_NAME;\n            _log.debug( \"Using session cookie name from context: \" + result );\n        }\n        return result;\n    }\n\n    protected String getSessionCookieNameFromContext( final Context context ) {\n        // since 6.0.27 the session cookie name, domain and path is configurable per context,\n        // see issue http://issues.apache.org/bugzilla/show_bug.cgi?id=48379\n        try {\n            final Method getSessionCookieName = Context.class.getDeclaredMethod( \"getSessionCookieName\" );\n            final String result = (String) getSessionCookieName.invoke( context );\n            if ( result != null ) {\n                _log.debug( \"Using session cookie name from context: \" + result );\n            }\n            return result;\n        } catch( final NoSuchMethodException e ) {\n            // the context does not provide the method getSessionCookieName\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not read session cookie name from context.\", e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns the actually used name for the session cookie.\n     * @return the cookie name, never null.\n     */\n    protected String getSessionCookieName() {\n        return _sessionCookieName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke( final Request request, final Response response ) throws IOException, ServletException {\n\n        if ( !_enabled.get() || _ignorePattern != null && _ignorePattern.matcher( request.getRequestURI() ).matches() ) {\n            getNext().invoke( request, response );\n        } else {\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \">>>>>> Request starting: \" + getURIWithQueryString( request ) + \" ==================\" );\n            }\n\n            boolean sessionIdChanged = false;\n            try {\n                storeRequestThreadLocal( request );\n                sessionIdChanged = changeRequestedSessionId( request, response );\n                getNext().invoke( request, response );\n            } finally {\n                backupSession( request, response, sessionIdChanged );\n                resetRequestThreadLocal();\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                logDebugRequestSessionCookie( request );\n                logDebugResponseCookie( response );\n                _log.debug( \"<<<<<< Request finished: \" + getURIWithQueryString( request ) + \" ==================\" );\n            }\n\n        }\n\n    }\n\n    private void logDebugRequestSessionCookie( final Request request ) {\n        final Cookie[] cookies = request.getCookies();\n        if ( cookies == null ) {\n            return;\n        }\n        for( final javax.servlet.http.Cookie cookie : cookies ) {\n            if ( cookie.getName().equals( _sessionCookieName ) ) {\n                _log.debug( \"Have request session cookie: domain=\" + cookie.getDomain() + \", maxAge=\" + cookie.getMaxAge() +\n                        \", path=\" + cookie.getPath() + \", value=\" + cookie.getValue() +\n                        \", version=\" + cookie.getVersion() + \", secure=\" + cookie.getSecure() );\n            }\n        }\n    }\n\n    @Nonnull\n    protected static String getURIWithQueryString( @Nonnull final Request request ) {\n        final String uri = request.getRequestURI();\n        final String qs = request.getMethod().toLowerCase().equals( \"post\" ) ? null : request.getQueryString();\n        return qs != null ? uri + \"?\" + qs : uri;\n    }\n\n    private void resetRequestThreadLocal() {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestFinished();\n        }\n    }\n\n    private void storeRequestThreadLocal( @Nonnull final Request request ) {\n        if ( _lockingStrategy != null ) {\n            _lockingStrategy.onRequestStart( request );\n        }\n    }\n\n    /**\n     * If there's a session for a requested session id that is taken over (tomcat failover) or\n     * that will be relocated (memcached failover), the new session id will be set (via {@link Request#changeSessionId(String)}).\n     *\n     * @param request the request\n     * @param response the response\n     *\n     * @return <code>true<\/code> if the id of a valid session was changed.\n     *\n     * @see Request#changeSessionId(String)\n     */\n    private boolean changeRequestedSessionId( final Request request, final Response response ) {\n        /*\n         * Check for session relocation only if a session id was requested\n         */\n        if ( request.getRequestedSessionId() != null ) {\n\n        \tString newSessionId = _sessionBackupService.changeSessionIdOnTomcatFailover( request.getRequestedSessionId() );\n        \tif ( newSessionId == null ) {\n                newSessionId = _sessionBackupService.changeSessionIdOnMemcachedFailover( request.getRequestedSessionId() );\n            }\n\n            if ( newSessionId != null ) {\n                request.changeSessionId( newSessionId );\n                return true;\n            }\n\n        }\n        return false;\n    }\n\n    private void backupSession( final Request request, final Response response, final boolean sessionIdChanged ) {\n\n        /*\n         * Do we have a session?\n         */\n        String sessionId = getSessionIdFromResponseSessionCookie( response );\n        if ( sessionId == null ) {\n            sessionId = request.getRequestedSessionId();\n        }\n        if ( sessionId != null ) {\n            _statistics.requestWithSession();\n            _sessionBackupService.backupSession( sessionId, sessionIdChanged, getURIWithQueryString( request ) );\n        }\n        else {\n            _statistics.requestWithoutSession();\n        }\n\n    }\n\n    private String getSessionIdFromResponseSessionCookie( final Response response ) {\n        final String header = response.getHeader( \"Set-Cookie\" );\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            final String sessionIdPrefix = _sessionCookieName + \"=\";\n            final int idxNameStart = header.indexOf( sessionIdPrefix );\n            final int idxValueStart = idxNameStart + sessionIdPrefix.length();\n            int idxValueEnd = header.indexOf( ';', idxNameStart );\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.indexOf( ' ', idxValueStart );\n            }\n            if ( idxValueEnd == -1 ) {\n                idxValueEnd = header.length();\n            }\n            return header.substring( idxValueStart, idxValueEnd );\n        }\n        return null;\n    }\n\n    private void logDebugResponseCookie( final Response response ) {\n        final String header = response.getHeader(\"Set-Cookie\");\n        if ( header != null && header.contains( _sessionCookieName ) ) {\n            _log.debug( \"Request finished, with Set-Cookie header: \" + header );\n        }\n    }\n\n    /**\n     * The service that stores session backups in memcached.\n     */\n    public static interface SessionBackupService {\n\n        /**\n         * Check if the given session id does not belong to this tomcat (according to the\n         * local jvmRoute and the jvmRoute in the session id). If the session contains a\n         * different jvmRoute load if from memcached. If the session was found in memcached and\n         * if it's valid it must be associated with this tomcat and therefore the session id has to\n         * be changed. The new session id must be returned if it was changed.\n         * <p>\n         * This is only useful for sticky sessions, in non-sticky operation mode <code>null<\/code> should\n         * always be returned.\n         * <\/p>\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session is taken over and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnTomcatFailover( final String requestedSessionId );\n\n        /**\n         * Check if the valid session associated with the provided\n         * requested session Id will be relocated with the next {@link #backupSession(Session, boolean)}\n         * and change the session id to the new one (containing the new memcached node). The\n         * new session id must be returned if the session will be relocated and the id was changed.\n         *\n         * @param requestedSessionId\n         *            the sessionId that was requested.\n         *\n         * @return the new session id if the session will be relocated and the id was changed.\n         *          Otherwise <code>null<\/code>.\n         *\n         * @see Request#getRequestedSessionId()\n         */\n        String changeSessionIdOnMemcachedFailover( final String requestedSessionId );\n\n        /**\n         * Backup the session for the provided session id in memcached if the session was modified or\n         * if the session needs to be relocated. In non-sticky session-mode the session should not be\n         * loaded from memcached for just storing it again but only metadata should be updated.\n         *\n         * @param sessionId\n         *            the if of the session to backup\n         * @param sessionIdChanged\n         *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n         * @param requestId\n         *            the uri of the request for that the session backup shall be performed.\n         *\n         * @return a {@link Future} providing the {@link BackupResultStatus}.\n         */\n        Future<BackupResult> backupSession( @Nonnull String sessionId, boolean sessionIdChanged, String requestId );\n\n        /**\n         * The enumeration of possible backup results.\n         */\n        static enum BackupResultStatus {\n                /**\n                 * The session was successfully stored in the sessions default memcached node.\n                 * This status is also used, if a session was relocated to another memcached node.\n                 */\n                SUCCESS,\n                /**\n                 * The session could not be stored in any memcached node.\n                 */\n                FAILURE,\n                /**\n                 * The session was not modified and therefore the backup was skipped.\n                 */\n                SKIPPED\n        }\n\n    }\n\n    public void setLockingStrategy( @Nullable final LockingStrategy lockingStrategy ) {\n        _lockingStrategy = lockingStrategy;\n    }\n\n}\n","lineNo":164}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final byte[] validityData = encode( validityInfo.getMaxInactiveInterval(), System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            _memcached.set( validityKey, validityInfo.getMaxInactiveInterval(), validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, validityInfo.getMaxInactiveInterval() );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    _memcached.set( backupValidityKey, _maxInactiveInterval, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final int maxInactiveInterval = validityInfo.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, maxInactiveInterval );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final int maxInactiveInterval = session.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), 5, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            final int maxInactiveInterval = _session.getMaxInactiveInterval();\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( backupValidityKey, expiration, _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 5, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n                    final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval;\n                    _memcached.set( backupValidityKey, expiration, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n    // ---------------- for testing\n\n    @Nonnull\n    ExecutorService getExecutorService() {\n        return _executor;\n    }\n\n}\n","lineNo":510}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final byte[] validityData = encode( validityInfo.getMaxInactiveInterval(), System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            _memcached.set( validityKey, validityInfo.getMaxInactiveInterval(), validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, validityInfo.getMaxInactiveInterval() );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    _memcached.set( backupValidityKey, _maxInactiveInterval, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final int maxInactiveInterval = validityInfo.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, maxInactiveInterval );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final int maxInactiveInterval = session.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), 5, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            final int maxInactiveInterval = _session.getMaxInactiveInterval();\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( backupValidityKey, expiration, _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 5, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n                    final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval;\n                    _memcached.set( backupValidityKey, expiration, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n    // ---------------- for testing\n\n    @Nonnull\n    ExecutorService getExecutorService() {\n        return _executor;\n    }\n\n}\n","lineNo":512}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final byte[] validityData = encode( validityInfo.getMaxInactiveInterval(), System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            _memcached.set( validityKey, validityInfo.getMaxInactiveInterval(), validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, validityInfo.getMaxInactiveInterval() );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    _memcached.set( backupValidityKey, _maxInactiveInterval, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final int maxInactiveInterval = validityInfo.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, maxInactiveInterval );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final int maxInactiveInterval = session.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), 5, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            final int maxInactiveInterval = _session.getMaxInactiveInterval();\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( backupValidityKey, expiration, _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 5, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n                    final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval;\n                    _memcached.set( backupValidityKey, expiration, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n    // ---------------- for testing\n\n    @Nonnull\n    ExecutorService getExecutorService() {\n        return _executor;\n    }\n\n}\n","lineNo":586}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final byte[] validityData = encode( validityInfo.getMaxInactiveInterval(), System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            _memcached.set( validityKey, validityInfo.getMaxInactiveInterval(), validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, validityInfo.getMaxInactiveInterval() );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    _memcached.set( backupValidityKey, _maxInactiveInterval, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final int maxInactiveInterval = validityInfo.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, maxInactiveInterval );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final int maxInactiveInterval = session.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), 5, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            final int maxInactiveInterval = _session.getMaxInactiveInterval();\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( backupValidityKey, expiration, _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 5, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n                    final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval;\n                    _memcached.set( backupValidityKey, expiration, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n    // ---------------- for testing\n\n    @Nonnull\n    ExecutorService getExecutorService() {\n        return _executor;\n    }\n\n}\n","lineNo":226}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final byte[] validityData = encode( validityInfo.getMaxInactiveInterval(), System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            _memcached.set( validityKey, validityInfo.getMaxInactiveInterval(), validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, validityInfo.getMaxInactiveInterval() );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    _memcached.set( backupValidityKey, _maxInactiveInterval, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final int maxInactiveInterval = validityInfo.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, maxInactiveInterval );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final int maxInactiveInterval = session.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), 5, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            final int maxInactiveInterval = _session.getMaxInactiveInterval();\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( backupValidityKey, expiration, _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 5, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n                    final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval;\n                    _memcached.set( backupValidityKey, expiration, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n    // ---------------- for testing\n\n    @Nonnull\n    ExecutorService getExecutorService() {\n        return _executor;\n    }\n\n}\n","lineNo":230}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final byte[] validityData = encode( validityInfo.getMaxInactiveInterval(), System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            _memcached.set( validityKey, validityInfo.getMaxInactiveInterval(), validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, validityInfo.getMaxInactiveInterval() );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    _memcached.set( backupValidityKey, _maxInactiveInterval, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final int maxInactiveInterval = validityInfo.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, maxInactiveInterval );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final int maxInactiveInterval = session.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), 5, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            final int maxInactiveInterval = _session.getMaxInactiveInterval();\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( backupValidityKey, expiration, _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 5, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n                    final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval;\n                    _memcached.set( backupValidityKey, expiration, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n    // ---------------- for testing\n\n    @Nonnull\n    ExecutorService getExecutorService() {\n        return _executor;\n    }\n\n}\n","lineNo":270}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final byte[] validityData = encode( validityInfo.getMaxInactiveInterval(), System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            _memcached.set( validityKey, validityInfo.getMaxInactiveInterval(), validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, validityInfo.getMaxInactiveInterval() );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    _memcached.set( backupValidityKey, _maxInactiveInterval, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked for the backup of a non-sticky session that was not accessed for the current request.\n     */\n    protected void onBackupWithoutLoadedSession( @Nonnull final String sessionId, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final String validityKey = createValidityInfoKeyName( sessionId );\n            final SessionValidityInfo validityInfo = loadSessionValidityInfoForValidityKey( validityKey );\n            if ( validityInfo == null ) {\n                _log.warn( \"Found no validity info for session id \" + sessionId );\n                return;\n            }\n\n            final int maxInactiveInterval = validityInfo.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, System.currentTimeMillis(),\n                    System.currentTimeMillis() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n\n            /*\n             * - ping session\n             * - ping session backup\n             * - save validity backup\n             */\n            final Callable<?> backupSessionTask = new OnBackupWithoutLoadedSessionTask( sessionId,\n                    _storeSecondaryBackup, validityKey, validityData, maxInactiveInterval );\n            _executor.submit( backupSessionTask );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + sessionId );\n            }\n\n            _stats.registerSince( NON_STICKY_ON_BACKUP_WITHOUT_LOADED_SESSION, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error when trying to load/update validity info.\", e );\n        }\n\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        if ( !_sessionIdFormat.isValid( session.getIdInternal() ) ) {\n            return;\n        }\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final int maxInactiveInterval = session.getMaxInactiveInterval();\n            final byte[] validityData = encode( maxInactiveInterval, session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( validityKey, expiration, validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String sessionId ) {\n        return loadSessionValidityInfoForValidityKey( createValidityInfoKeyName( sessionId ) );\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfoForValidityKey( @Nonnull final String validityInfoKey ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( validityInfoKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String sessionId ) {\n        final String key = createValidityInfoKeyName( sessionId );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        return loadSessionValidityInfoForValidityKey( backupKey );\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private boolean pingSession( @Nonnull final String sessionId ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( sessionId, 1, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + sessionId\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore.\" );\n                return false;\n            }\n            return true;\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n            return false;\n        }\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), 5, 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            final int maxInactiveInterval = _session.getMaxInactiveInterval();\n            // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n            final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval;\n            _memcached.set( backupValidityKey, expiration, _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 5, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n    private final class OnBackupWithoutLoadedSessionTask implements Callable<Void> {\n\n        private final String _sessionId;\n        private final boolean _storeSecondaryBackup;\n        private final String _validityKey;\n        private final byte[] _validityData;\n        private final int _maxInactiveInterval;\n\n        private OnBackupWithoutLoadedSessionTask( @Nonnull final String sessionId,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData,\n                final int maxInactiveInterval ) {\n            _sessionId = sessionId;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _maxInactiveInterval = maxInactiveInterval;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            pingSession( _sessionId );\n\n            /*\n             * For non-sticky sessions we store/ping a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n\n                    pingSessionBackup( _sessionId );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n                    // fix for #88, along with the change in session.getMemcachedExpirationTimeToSet\n                    final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval;\n                    _memcached.set( backupValidityKey, expiration, _validityData );\n\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional ping of session \" + _sessionId );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _sessionId, e );\n                }\n\n            }\n\n            return null;\n        }\n\n        private boolean pingSessionBackup( @Nonnull final String sessionId ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( sessionId );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, 1, 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + sessionId\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing.\" );\n                    return false;\n                }\n                return true;\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + sessionId\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n                return false;\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + sessionId, e );\n                return false;\n            }\n        }\n    }\n\n    // ---------------- for testing\n\n    @Nonnull\n    ExecutorService getExecutorService() {\n        return _executor;\n    }\n\n}\n","lineNo":275}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Serializable;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Currency;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.naming.NamingException;\nimport javax.servlet.http.HttpSessionActivationListener;\nimport javax.servlet.http.HttpSessionEvent;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Role;\nimport org.apache.catalina.User;\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.authenticator.AuthenticatorBase;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.core.StandardEngine;\nimport org.apache.catalina.core.StandardServer;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityCollection;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.realm.UserDatabaseRealm;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.catalina.users.MemoryUserDatabase;\nimport org.apache.http.Header;\nimport org.apache.http.HeaderElement;\nimport org.apache.http.HttpException;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.Credentials;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.auth.BasicScheme;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.protocol.BasicHttpContext;\nimport org.apache.http.protocol.HTTP;\nimport org.apache.naming.NamingContext;\nimport org.testng.Assert;\nimport org.testng.annotations.DataProvider;\n\nimport com.thimbleware.jmemcached.CacheElement;\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.JavaSerializationTranscoderFactory;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    private static final String CONTEXT_PATH = \"/\";\n    private static final String DEFAULT_HOST = \"localhost\";\n    private static final String DEFAULT_TRANSCODER_FACTORY = JavaSerializationTranscoderFactory.class.getName();\n\n    private static final String USER_DATABASE = \"UserDatabase\";\n    protected static final String PASSWORD = \"secret\";\n    protected static final String USER_NAME = \"testuser\";\n    protected static final String ROLE_NAME = \"test\";\n\n    public static final String STICKYNESS_PROVIDER = \"stickynessProvider\";\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpGet method = new HttpGet(\"http://\"+ DEFAULT_HOST +\":\"+ port + CONTEXT_PATH);\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n        responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        // We must consume the content so that the connection will be released\n        response.getEntity().consumeContent();\n\n        return responseSessionId == null ? rsessionId : responseSessionId;\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId,\n            final Credentials credentials )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId, null, null, credentials );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, null, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final Map<String, String> params ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, params, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final SessionTrackingMode sessionTrackingMode,\n            final Map<String, String> params,\n            final Credentials credentials ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String url = getUrl( port, path );\n        if ( params != null && !params.isEmpty() ) {\n            url += toQueryString( params );\n        }\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.URL ) {\n            url += \";\" + Globals.SESSION_PARAMETER_NAME + \"=\" + rsessionId;\n        }\n        final HttpGet method = new HttpGet( url );\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.COOKIE ) {\n            method.setHeader( \"Cookie\", Globals.SESSION_COOKIE_NAME + \"=\" + rsessionId );\n        }\n\n        final HttpResponse response = credentials == null\n            ? client.execute( method )\n            : executeRequestWithAuth( client, method, credentials );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static String getUrl( final int port, String path ) throws IllegalArgumentException {\n        // we assume the context_path is \"/\"\n        if ( path != null && !path.startsWith( \"/\" ) ) {\n            // but we can also fix this\n            path = CONTEXT_PATH + path;\n        }\n        return \"http://\"+ DEFAULT_HOST +\":\"+ port + ( path != null ? path : CONTEXT_PATH );\n    }\n\n    /**\n     * @param params\n     * @return\n     */\n    private static String toQueryString( final Map<String, String> params ) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append( \"?\" );\n        for ( final Iterator<Entry<String, String>> iterator = params.entrySet().iterator(); iterator.hasNext(); ) {\n            final Entry<String, String> entry = iterator.next();\n            sb.append( entry.getKey() ).append( \"=\" ).append( entry.getValue() );\n            if ( iterator.hasNext() ) {\n                sb.append( \"&\" );\n            }\n        }\n        final String qs = sb.toString();\n        return qs;\n    }\n\n    private static HttpResponse executeRequestWithAuth( final DefaultHttpClient client, final HttpGet method,\n            final Credentials credentials ) throws IOException, ClientProtocolException {\n        client.getCredentialsProvider().setCredentials( AuthScope.ANY, credentials );\n\n        final BasicHttpContext localcontext = new BasicHttpContext();\n\n        // Generate BASIC scheme object and stick it to the local\n        // execution context\n        final BasicScheme basicAuth = new BasicScheme();\n        localcontext.setAttribute( \"preemptive-auth\", basicAuth );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        return client.execute( method, localcontext );\n    }\n\n    private static Response readResponse( final String rsessionId, final HttpResponse response ) throws IOException {\n        final String responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) );\n            String line = null;\n            while ( ( line = reader.readLine() ) != null ) {\n                final String[] keyValue = line.split( \"=\" );\n                if ( keyValue.length > 0 ) {\n                    keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n                }\n            }\n        } finally {\n            reader.close();\n        }\n\n        return new Response( responseSessionId == null ? rsessionId : responseSessionId, responseSessionId, keyValues );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String rsessionId,\n            final String paramName,\n            final String paramValue ) throws IOException, HttpException {\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( paramName, paramValue );\n        return post( client, port, null, rsessionId, params );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String path,\n            final String rsessionId,\n            final Map<String, String> params ) throws IOException, HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://\"+ DEFAULT_HOST +\":\"+ port;\n        final String url = getUrl( port, path );\n        final HttpPost method = new HttpPost( url );\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        method.setEntity( createFormEntity( params ) );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        final int statusCode = response.getStatusLine().getStatusCode();\n        if ( statusCode == 302 ) {\n            return redirect( response, client, port, rsessionId, baseUri );\n        }\n\n        if ( statusCode != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static Response redirect( final HttpResponse response, final DefaultHttpClient client, final int port,\n            final String rsessionId, final String baseUri ) throws IOException, HttpException {\n        final String location = response.getFirstHeader( \"Location\" ).getValue();\n        if ( !location.startsWith( baseUri ) ) {\n            throw new RuntimeException( \"There's s.th. wrong, the location header should start with the base URI \" + baseUri +\n                    \". The location header: \" + location );\n        }\n        /* consume content so that the connection can be released\n         */\n        response.getEntity().consumeContent();\n\n        /* redirect\n         */\n        final String redirectPath = location.substring( baseUri.length(), location.length() );\n        return get( client, port, redirectPath, rsessionId );\n    }\n\n    private static UrlEncodedFormEntity createFormEntity( final Map<String, String> params ) throws UnsupportedEncodingException {\n        final List<NameValuePair> parameters = new ArrayList <NameValuePair>();\n        for( final Map.Entry<String, String> param : params.entrySet() ) {\n            parameters.add( new BasicNameValuePair( param.getKey(), param.getValue() ) );\n        }\n        final UrlEncodedFormEntity entity = new UrlEncodedFormEntity( parameters, HTTP.UTF_8 );\n        return entity;\n    }\n\n    public static String getSessionIdFromResponse( final HttpResponse response ) {\n        final Header cookie = response.getFirstHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<? extends CacheElement> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( true );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, null, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, transcoderFactoryClassName );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute,\n            final LoginType loginType,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n\n        final Embedded catalina = new Embedded();\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer( server );\n\n        try {\n            final NamingContext globalNamingContext = new NamingContext( new Hashtable<Object, Object>(), \"ctxt\" );\n            server.setGlobalNamingContext( globalNamingContext );\n            globalNamingContext.bind( USER_DATABASE, createUserDatabase() );\n        } catch ( final NamingException e ) {\n            throw new RuntimeException( e );\n        }\n\n        final Engine engine = catalina.createEngine();\n        catalina.addEngine( engine );\n\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( DEFAULT_HOST );\n        engine.setJvmRoute( jvmRoute );\n\n        final UserDatabaseRealm realm = new UserDatabaseRealm();\n        realm.setResourceName( USER_DATABASE );\n        engine.setRealm( realm );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n\n        final String fileSeparator = File.separator.equals( \"\\\\\" ) ? \"\\\\\\\\\" : File.separator;\n        final String docBase = root.getFile() + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", fileSeparator );\n        final Host host = catalina.createHost( DEFAULT_HOST, docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final Context context = catalina.createContext( CONTEXT_PATH, \"webapp\" );\n        host.addChild( context );\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        if ( loginType != null ) {\n            context.addConstraint( createSecurityConstraint( \"/*\", ROLE_NAME ) );\n            // context.addConstraint( createSecurityConstraint( \"/j_security_check\", null ) );\n            context.addSecurityRole( ROLE_NAME );\n            final LoginConfig loginConfig = loginType == LoginType.FORM\n                ? new LoginConfig( \"FORM\", null, \"/login\", \"/error\" )\n                : new LoginConfig( \"BASIC\", null, null, null );\n                context.setLoginConfig( loginConfig );\n        }\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setSessionBackupAsync( false );\n        sessionManager.setSessionBackupTimeout( 100 );\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n        sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName );\n\n        final Connector connector = catalina.createConnector( \"localhost\", port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    private static SecurityConstraint createSecurityConstraint( final String pattern, final String role ) {\n        final SecurityConstraint constraint = new SecurityConstraint();\n        final SecurityCollection securityCollection = new SecurityCollection();\n        securityCollection.addPattern( pattern );\n        constraint.addCollection( securityCollection );\n        if ( role != null ) {\n            constraint.addAuthRole( role );\n        }\n        return constraint;\n    }\n\n    public static enum LoginType {\n        BASIC, FORM\n    }\n\n    private static MemoryUserDatabase createUserDatabase() {\n        final MemoryUserDatabase userDatabase = new MemoryUserDatabase();\n        final Role role = userDatabase.createRole( ROLE_NAME, \"the role for unit tests\" );\n        final User user = userDatabase.createUser( USER_NAME, PASSWORD, \"the user for unit tests\" );\n        user.addRole( role );\n        return userDatabase;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().findChild( DEFAULT_HOST ).findChild( CONTEXT_PATH ).getManager();\n    }\n\n    public static void setChangeSessionIdOnAuth( final Embedded tomcat, final boolean changeSessionIdOnAuth ) {\n        final Engine engine = (StandardEngine)tomcat.getContainer();\n        final Host host = (Host)engine.findChild( DEFAULT_HOST );\n        final Container context = host.findChild( CONTEXT_PATH );\n        final Valve first = context.getPipeline().getFirst();\n        if ( first instanceof AuthenticatorBase ) {\n            ((AuthenticatorBase)first).setChangeSessionIdOnAuthentication( false );\n        }\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final String _responseSessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final String responseSessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _responseSessionId = responseSessionId;\n            _keyValues = keyValues;\n        }\n        public String getSessionId() {\n            return _sessionId;\n        }\n        public String getResponseSessionId() {\n            return _responseSessionId;\n        }\n        public Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        public String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n    /**\n     * Extracts the memcached node id from the provided session id.\n     * @param sessionId the session id, that may contain the node id, e.g. as <code>${origsessionid}-${nodeid}<\/code>\n     * @return the extracted node id or <code>null<\/code>, if no node information was found.\n     */\n    public static String extractNodeId( final String sessionId ) {\n        final int idx = sessionId.lastIndexOf( '-' );\n        return idx > -1 ? sessionId.substring( idx + 1 ) : null;\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another ) {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked ) {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Set.class.isAssignableFrom( one.getClass() ) ) {\n            final Set<?> m1 = (Set<?>) one;\n            final Set<?> m2 = (Set<?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            final Iterator<?> iter1 = m1.iterator();\n            final Iterator<?> iter2 = m2.iterator();\n            while( iter1.hasNext() ) {\n                assertDeepEquals( iter1.next(), iter2.next() );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    public static void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                try {\n                    assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n                } catch ( final IllegalArgumentException e ) {\n                    throw new RuntimeException( e );\n                } catch ( final IllegalAccessException e ) {\n                    throw new RuntimeException( e );\n                }\n            }\n        }\n    }\n\n    /**\n     * A simple serializable {@link HttpSessionActivationListener} that provides the\n     * session id that was passed during {@link #sessionDidActivate(HttpSessionEvent)}\n     * via {@link #getSessionDidActivate()}.\n     */\n    public static final class RecordingSessionActivationListener implements HttpSessionActivationListener, Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private transient String _sessionDidActivate;\n\n        @Override\n        public void sessionWillPassivate( final HttpSessionEvent se ) {\n        }\n\n        @Override\n        public void sessionDidActivate( final HttpSessionEvent se ) {\n            _sessionDidActivate = se.getSession().getId();\n        }\n\n        /**\n         * Returns the id of the session that was passed in {@link #sessionDidActivate(HttpSessionEvent)}.\n         * @return a session id or <code>null<\/code>.\n         */\n        public String getSessionDidActivate() {\n            return _sessionDidActivate;\n        }\n\n    }\n\n    /**\n     * Creates a map from the given keys and values (key1, value1, key2, value2, etc.).\n     * @param <T> the type of the keys and values.\n     * @param keysAndValues the keys and values, must be an even number of arguments.\n     * @return a {@link Map} or null if no argument was given.\n     */\n    public static <T> Map<T,T> asMap( final T ... keysAndValues ) {\n        if ( keysAndValues == null ) {\n            return null;\n        }\n        if ( keysAndValues.length % 2 != 0 ) {\n            throw new IllegalArgumentException( \"You must provide an even number of arguments as key/value pairs.\" );\n        }\n\n        final Map<T,T> result = new HashMap<T,T>();\n        for ( int i = 0; i < keysAndValues.length; i++ ) {\n            if ( i % 2 == 1 ) {\n                result.put( keysAndValues[i - 1], keysAndValues[i] );\n            }\n        }\n\n        return result;\n    }\n\n    public static enum SessionTrackingMode {\n        COOKIE,\n        URL\n    }\n\n    public static enum SessionAffinityMode {\n        STICKY {\n            @Override public boolean isSticky() { return true; }\n        },\n        NON_STICKY {\n            @Override public boolean isSticky() { return false; }\n        };\n\n        public abstract boolean isSticky();\n    }\n\n    @DataProvider\n    public static Object[][] stickynessProvider() {\n        return new Object[][] {\n                { SessionAffinityMode.STICKY },\n                { SessionAffinityMode.NON_STICKY }\n        };\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Serializable;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Currency;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.naming.NamingException;\nimport javax.servlet.http.HttpSessionActivationListener;\nimport javax.servlet.http.HttpSessionEvent;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Role;\nimport org.apache.catalina.User;\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.authenticator.AuthenticatorBase;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.core.StandardEngine;\nimport org.apache.catalina.core.StandardServer;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityCollection;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.realm.UserDatabaseRealm;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.catalina.users.MemoryUserDatabase;\nimport org.apache.http.Header;\nimport org.apache.http.HeaderElement;\nimport org.apache.http.HttpException;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.Credentials;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.auth.BasicScheme;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.protocol.BasicHttpContext;\nimport org.apache.http.protocol.HTTP;\nimport org.apache.naming.NamingContext;\nimport org.testng.Assert;\nimport org.testng.annotations.DataProvider;\n\nimport com.thimbleware.jmemcached.CacheElement;\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.JavaSerializationTranscoderFactory;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    private static final String CONTEXT_PATH = \"/\";\n    private static final String DEFAULT_HOST = \"localhost\";\n    private static final String DEFAULT_TRANSCODER_FACTORY = JavaSerializationTranscoderFactory.class.getName();\n\n    private static final String USER_DATABASE = \"UserDatabase\";\n    protected static final String PASSWORD = \"secret\";\n    protected static final String USER_NAME = \"testuser\";\n    protected static final String ROLE_NAME = \"test\";\n\n    public static final String STICKYNESS_PROVIDER = \"stickynessProvider\";\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpGet method = new HttpGet(\"http://\"+ DEFAULT_HOST +\":\"+ port + CONTEXT_PATH);\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n        responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        // We must consume the content so that the connection will be released\n        response.getEntity().consumeContent();\n\n        return responseSessionId == null ? rsessionId : responseSessionId;\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId,\n            final Credentials credentials )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId, null, null, credentials );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, null, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final Map<String, String> params ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, params, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final SessionTrackingMode sessionTrackingMode,\n            final Map<String, String> params,\n            final Credentials credentials ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String url = getUrl( port, path );\n        if ( params != null && !params.isEmpty() ) {\n            url += toQueryString( params );\n        }\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.URL ) {\n            url += \";\" + Globals.SESSION_PARAMETER_NAME + \"=\" + rsessionId;\n        }\n        final HttpGet method = new HttpGet( url );\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.COOKIE ) {\n            method.setHeader( \"Cookie\", Globals.SESSION_COOKIE_NAME + \"=\" + rsessionId );\n        }\n\n        final HttpResponse response = credentials == null\n            ? client.execute( method )\n            : executeRequestWithAuth( client, method, credentials );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static String getUrl( final int port, String path ) throws IllegalArgumentException {\n        // we assume the context_path is \"/\"\n        if ( path != null && !path.startsWith( \"/\" ) ) {\n            // but we can also fix this\n            path = CONTEXT_PATH + path;\n        }\n        return \"http://\"+ DEFAULT_HOST +\":\"+ port + ( path != null ? path : CONTEXT_PATH );\n    }\n\n    /**\n     * @param params\n     * @return\n     */\n    private static String toQueryString( final Map<String, String> params ) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append( \"?\" );\n        for ( final Iterator<Entry<String, String>> iterator = params.entrySet().iterator(); iterator.hasNext(); ) {\n            final Entry<String, String> entry = iterator.next();\n            sb.append( entry.getKey() ).append( \"=\" ).append( entry.getValue() );\n            if ( iterator.hasNext() ) {\n                sb.append( \"&\" );\n            }\n        }\n        final String qs = sb.toString();\n        return qs;\n    }\n\n    private static HttpResponse executeRequestWithAuth( final DefaultHttpClient client, final HttpGet method,\n            final Credentials credentials ) throws IOException, ClientProtocolException {\n        client.getCredentialsProvider().setCredentials( AuthScope.ANY, credentials );\n\n        final BasicHttpContext localcontext = new BasicHttpContext();\n\n        // Generate BASIC scheme object and stick it to the local\n        // execution context\n        final BasicScheme basicAuth = new BasicScheme();\n        localcontext.setAttribute( \"preemptive-auth\", basicAuth );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        return client.execute( method, localcontext );\n    }\n\n    private static Response readResponse( final String rsessionId, final HttpResponse response ) throws IOException {\n        final String responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) );\n            String line = null;\n            while ( ( line = reader.readLine() ) != null ) {\n                final String[] keyValue = line.split( \"=\" );\n                if ( keyValue.length > 0 ) {\n                    keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n                }\n            }\n        } finally {\n            reader.close();\n        }\n\n        return new Response( responseSessionId == null ? rsessionId : responseSessionId, responseSessionId, keyValues );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String rsessionId,\n            final String paramName,\n            final String paramValue ) throws IOException, HttpException {\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( paramName, paramValue );\n        return post( client, port, null, rsessionId, params );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String path,\n            final String rsessionId,\n            final Map<String, String> params ) throws IOException, HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://\"+ DEFAULT_HOST +\":\"+ port;\n        final String url = getUrl( port, path );\n        final HttpPost method = new HttpPost( url );\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        method.setEntity( createFormEntity( params ) );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        final int statusCode = response.getStatusLine().getStatusCode();\n        if ( statusCode == 302 ) {\n            return redirect( response, client, port, rsessionId, baseUri );\n        }\n\n        if ( statusCode != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static Response redirect( final HttpResponse response, final DefaultHttpClient client, final int port,\n            final String rsessionId, final String baseUri ) throws IOException, HttpException {\n        final String location = response.getFirstHeader( \"Location\" ).getValue();\n        if ( !location.startsWith( baseUri ) ) {\n            throw new RuntimeException( \"There's s.th. wrong, the location header should start with the base URI \" + baseUri +\n                    \". The location header: \" + location );\n        }\n        /* consume content so that the connection can be released\n         */\n        response.getEntity().consumeContent();\n\n        /* redirect\n         */\n        final String redirectPath = location.substring( baseUri.length(), location.length() );\n        return get( client, port, redirectPath, rsessionId );\n    }\n\n    private static UrlEncodedFormEntity createFormEntity( final Map<String, String> params ) throws UnsupportedEncodingException {\n        final List<NameValuePair> parameters = new ArrayList <NameValuePair>();\n        for( final Map.Entry<String, String> param : params.entrySet() ) {\n            parameters.add( new BasicNameValuePair( param.getKey(), param.getValue() ) );\n        }\n        final UrlEncodedFormEntity entity = new UrlEncodedFormEntity( parameters, HTTP.UTF_8 );\n        return entity;\n    }\n\n    public static String getSessionIdFromResponse( final HttpResponse response ) {\n        final Header cookie = response.getFirstHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<? extends CacheElement> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( true );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, null, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, transcoderFactoryClassName );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute,\n            final LoginType loginType,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n\n        final Embedded catalina = new Embedded();\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer( server );\n\n        try {\n            final NamingContext globalNamingContext = new NamingContext( new Hashtable<Object, Object>(), \"ctxt\" );\n            server.setGlobalNamingContext( globalNamingContext );\n            globalNamingContext.bind( USER_DATABASE, createUserDatabase() );\n        } catch ( final NamingException e ) {\n            throw new RuntimeException( e );\n        }\n\n        final Engine engine = catalina.createEngine();\n        catalina.addEngine( engine );\n\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( DEFAULT_HOST );\n        engine.setJvmRoute( jvmRoute );\n\n        final UserDatabaseRealm realm = new UserDatabaseRealm();\n        realm.setResourceName( USER_DATABASE );\n        engine.setRealm( realm );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n        // use file to get correct separator char, replace %20 introduced by URL for spaces\n        final String cleanedRoot = new File( root.getFile().replaceAll(\"%20\", \" \") ).toString();\n\n        final String fileSeparator = File.separator.equals( \"\\\\\" ) ? \"\\\\\\\\\" : File.separator;\n        final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", fileSeparator );\n        final Host host = catalina.createHost( DEFAULT_HOST, docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final Context context = catalina.createContext( CONTEXT_PATH, \"webapp\" );\n        host.addChild( context );\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        if ( loginType != null ) {\n            context.addConstraint( createSecurityConstraint( \"/*\", ROLE_NAME ) );\n            // context.addConstraint( createSecurityConstraint( \"/j_security_check\", null ) );\n            context.addSecurityRole( ROLE_NAME );\n            final LoginConfig loginConfig = loginType == LoginType.FORM\n                ? new LoginConfig( \"FORM\", null, \"/login\", \"/error\" )\n                : new LoginConfig( \"BASIC\", null, null, null );\n                context.setLoginConfig( loginConfig );\n        }\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setSessionBackupAsync( false );\n        sessionManager.setSessionBackupTimeout( 100 );\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n        sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName );\n\n        final Connector connector = catalina.createConnector( \"localhost\", port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    private static SecurityConstraint createSecurityConstraint( final String pattern, final String role ) {\n        final SecurityConstraint constraint = new SecurityConstraint();\n        final SecurityCollection securityCollection = new SecurityCollection();\n        securityCollection.addPattern( pattern );\n        constraint.addCollection( securityCollection );\n        if ( role != null ) {\n            constraint.addAuthRole( role );\n        }\n        return constraint;\n    }\n\n    public static enum LoginType {\n        BASIC, FORM\n    }\n\n    private static MemoryUserDatabase createUserDatabase() {\n        final MemoryUserDatabase userDatabase = new MemoryUserDatabase();\n        final Role role = userDatabase.createRole( ROLE_NAME, \"the role for unit tests\" );\n        final User user = userDatabase.createUser( USER_NAME, PASSWORD, \"the user for unit tests\" );\n        user.addRole( role );\n        return userDatabase;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().findChild( DEFAULT_HOST ).findChild( CONTEXT_PATH ).getManager();\n    }\n\n    public static void setChangeSessionIdOnAuth( final Embedded tomcat, final boolean changeSessionIdOnAuth ) {\n        final Engine engine = (StandardEngine)tomcat.getContainer();\n        final Host host = (Host)engine.findChild( DEFAULT_HOST );\n        final Container context = host.findChild( CONTEXT_PATH );\n        final Valve first = context.getPipeline().getFirst();\n        if ( first instanceof AuthenticatorBase ) {\n            ((AuthenticatorBase)first).setChangeSessionIdOnAuthentication( false );\n        }\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final String _responseSessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final String responseSessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _responseSessionId = responseSessionId;\n            _keyValues = keyValues;\n        }\n        public String getSessionId() {\n            return _sessionId;\n        }\n        public String getResponseSessionId() {\n            return _responseSessionId;\n        }\n        public Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        public String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n    /**\n     * Extracts the memcached node id from the provided session id.\n     * @param sessionId the session id, that may contain the node id, e.g. as <code>${origsessionid}-${nodeid}<\/code>\n     * @return the extracted node id or <code>null<\/code>, if no node information was found.\n     */\n    public static String extractNodeId( final String sessionId ) {\n        final int idx = sessionId.lastIndexOf( '-' );\n        return idx > -1 ? sessionId.substring( idx + 1 ) : null;\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another ) {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked ) {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Set.class.isAssignableFrom( one.getClass() ) ) {\n            final Set<?> m1 = (Set<?>) one;\n            final Set<?> m2 = (Set<?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            final Iterator<?> iter1 = m1.iterator();\n            final Iterator<?> iter2 = m2.iterator();\n            while( iter1.hasNext() ) {\n                assertDeepEquals( iter1.next(), iter2.next() );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    public static void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                try {\n                    assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n                } catch ( final IllegalArgumentException e ) {\n                    throw new RuntimeException( e );\n                } catch ( final IllegalAccessException e ) {\n                    throw new RuntimeException( e );\n                }\n            }\n        }\n    }\n\n    /**\n     * A simple serializable {@link HttpSessionActivationListener} that provides the\n     * session id that was passed during {@link #sessionDidActivate(HttpSessionEvent)}\n     * via {@link #getSessionDidActivate()}.\n     */\n    public static final class RecordingSessionActivationListener implements HttpSessionActivationListener, Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private transient String _sessionDidActivate;\n\n        @Override\n        public void sessionWillPassivate( final HttpSessionEvent se ) {\n        }\n\n        @Override\n        public void sessionDidActivate( final HttpSessionEvent se ) {\n            _sessionDidActivate = se.getSession().getId();\n        }\n\n        /**\n         * Returns the id of the session that was passed in {@link #sessionDidActivate(HttpSessionEvent)}.\n         * @return a session id or <code>null<\/code>.\n         */\n        public String getSessionDidActivate() {\n            return _sessionDidActivate;\n        }\n\n    }\n\n    /**\n     * Creates a map from the given keys and values (key1, value1, key2, value2, etc.).\n     * @param <T> the type of the keys and values.\n     * @param keysAndValues the keys and values, must be an even number of arguments.\n     * @return a {@link Map} or null if no argument was given.\n     */\n    public static <T> Map<T,T> asMap( final T ... keysAndValues ) {\n        if ( keysAndValues == null ) {\n            return null;\n        }\n        if ( keysAndValues.length % 2 != 0 ) {\n            throw new IllegalArgumentException( \"You must provide an even number of arguments as key/value pairs.\" );\n        }\n\n        final Map<T,T> result = new HashMap<T,T>();\n        for ( int i = 0; i < keysAndValues.length; i++ ) {\n            if ( i % 2 == 1 ) {\n                result.put( keysAndValues[i - 1], keysAndValues[i] );\n            }\n        }\n\n        return result;\n    }\n\n    public static enum SessionTrackingMode {\n        COOKIE,\n        URL\n    }\n\n    public static enum SessionAffinityMode {\n        STICKY {\n            @Override public boolean isSticky() { return true; }\n        },\n        NON_STICKY {\n            @Override public boolean isSticky() { return false; }\n        };\n\n        public abstract boolean isSticky();\n    }\n\n    @DataProvider\n    public static Object[][] stickynessProvider() {\n        return new Object[][] {\n                { SessionAffinityMode.STICKY },\n                { SessionAffinityMode.NON_STICKY }\n        };\n    }\n\n}\n","lineNo":412}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Serializable;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Currency;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.naming.NamingException;\nimport javax.servlet.http.HttpSessionActivationListener;\nimport javax.servlet.http.HttpSessionEvent;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Role;\nimport org.apache.catalina.User;\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.authenticator.AuthenticatorBase;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.core.StandardEngine;\nimport org.apache.catalina.core.StandardServer;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityCollection;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.realm.UserDatabaseRealm;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.catalina.users.MemoryUserDatabase;\nimport org.apache.http.Header;\nimport org.apache.http.HeaderElement;\nimport org.apache.http.HttpException;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.Credentials;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.auth.BasicScheme;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.protocol.BasicHttpContext;\nimport org.apache.http.protocol.HTTP;\nimport org.apache.naming.NamingContext;\nimport org.testng.Assert;\nimport org.testng.annotations.DataProvider;\n\nimport com.thimbleware.jmemcached.CacheElement;\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.JavaSerializationTranscoderFactory;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    private static final String CONTEXT_PATH = \"/\";\n    private static final String DEFAULT_HOST = \"localhost\";\n    private static final String DEFAULT_TRANSCODER_FACTORY = JavaSerializationTranscoderFactory.class.getName();\n\n    private static final String USER_DATABASE = \"UserDatabase\";\n    protected static final String PASSWORD = \"secret\";\n    protected static final String USER_NAME = \"testuser\";\n    protected static final String ROLE_NAME = \"test\";\n\n    public static final String STICKYNESS_PROVIDER = \"stickynessProvider\";\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpGet method = new HttpGet(\"http://\"+ DEFAULT_HOST +\":\"+ port + CONTEXT_PATH);\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n        responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        // We must consume the content so that the connection will be released\n        response.getEntity().consumeContent();\n\n        return responseSessionId == null ? rsessionId : responseSessionId;\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId,\n            final Credentials credentials )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId, null, null, credentials );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, null, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final Map<String, String> params ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, params, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final SessionTrackingMode sessionTrackingMode,\n            final Map<String, String> params,\n            final Credentials credentials ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String url = getUrl( port, path );\n        if ( params != null && !params.isEmpty() ) {\n            url += toQueryString( params );\n        }\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.URL ) {\n            url += \";\" + Globals.SESSION_PARAMETER_NAME + \"=\" + rsessionId;\n        }\n        final HttpGet method = new HttpGet( url );\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.COOKIE ) {\n            method.setHeader( \"Cookie\", Globals.SESSION_COOKIE_NAME + \"=\" + rsessionId );\n        }\n\n        final HttpResponse response = credentials == null\n            ? client.execute( method )\n            : executeRequestWithAuth( client, method, credentials );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static String getUrl( final int port, String path ) throws IllegalArgumentException {\n        // we assume the context_path is \"/\"\n        if ( path != null && !path.startsWith( \"/\" ) ) {\n            // but we can also fix this\n            path = CONTEXT_PATH + path;\n        }\n        return \"http://\"+ DEFAULT_HOST +\":\"+ port + ( path != null ? path : CONTEXT_PATH );\n    }\n\n    /**\n     * @param params\n     * @return\n     */\n    private static String toQueryString( final Map<String, String> params ) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append( \"?\" );\n        for ( final Iterator<Entry<String, String>> iterator = params.entrySet().iterator(); iterator.hasNext(); ) {\n            final Entry<String, String> entry = iterator.next();\n            sb.append( entry.getKey() ).append( \"=\" ).append( entry.getValue() );\n            if ( iterator.hasNext() ) {\n                sb.append( \"&\" );\n            }\n        }\n        final String qs = sb.toString();\n        return qs;\n    }\n\n    private static HttpResponse executeRequestWithAuth( final DefaultHttpClient client, final HttpGet method,\n            final Credentials credentials ) throws IOException, ClientProtocolException {\n        client.getCredentialsProvider().setCredentials( AuthScope.ANY, credentials );\n\n        final BasicHttpContext localcontext = new BasicHttpContext();\n\n        // Generate BASIC scheme object and stick it to the local\n        // execution context\n        final BasicScheme basicAuth = new BasicScheme();\n        localcontext.setAttribute( \"preemptive-auth\", basicAuth );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        return client.execute( method, localcontext );\n    }\n\n    private static Response readResponse( final String rsessionId, final HttpResponse response ) throws IOException {\n        final String responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) );\n            String line = null;\n            while ( ( line = reader.readLine() ) != null ) {\n                final String[] keyValue = line.split( \"=\" );\n                if ( keyValue.length > 0 ) {\n                    keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n                }\n            }\n        } finally {\n            reader.close();\n        }\n\n        return new Response( responseSessionId == null ? rsessionId : responseSessionId, responseSessionId, keyValues );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String rsessionId,\n            final String paramName,\n            final String paramValue ) throws IOException, HttpException {\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( paramName, paramValue );\n        return post( client, port, null, rsessionId, params );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String path,\n            final String rsessionId,\n            final Map<String, String> params ) throws IOException, HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://\"+ DEFAULT_HOST +\":\"+ port;\n        final String url = getUrl( port, path );\n        final HttpPost method = new HttpPost( url );\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        method.setEntity( createFormEntity( params ) );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        final int statusCode = response.getStatusLine().getStatusCode();\n        if ( statusCode == 302 ) {\n            return redirect( response, client, port, rsessionId, baseUri );\n        }\n\n        if ( statusCode != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static Response redirect( final HttpResponse response, final DefaultHttpClient client, final int port,\n            final String rsessionId, final String baseUri ) throws IOException, HttpException {\n        final String location = response.getFirstHeader( \"Location\" ).getValue();\n        if ( !location.startsWith( baseUri ) ) {\n            throw new RuntimeException( \"There's s.th. wrong, the location header should start with the base URI \" + baseUri +\n                    \". The location header: \" + location );\n        }\n        /* consume content so that the connection can be released\n         */\n        response.getEntity().consumeContent();\n\n        /* redirect\n         */\n        final String redirectPath = location.substring( baseUri.length(), location.length() );\n        return get( client, port, redirectPath, rsessionId );\n    }\n\n    private static UrlEncodedFormEntity createFormEntity( final Map<String, String> params ) throws UnsupportedEncodingException {\n        final List<NameValuePair> parameters = new ArrayList <NameValuePair>();\n        for( final Map.Entry<String, String> param : params.entrySet() ) {\n            parameters.add( new BasicNameValuePair( param.getKey(), param.getValue() ) );\n        }\n        final UrlEncodedFormEntity entity = new UrlEncodedFormEntity( parameters, HTTP.UTF_8 );\n        return entity;\n    }\n\n    public static String getSessionIdFromResponse( final HttpResponse response ) {\n        final Header cookie = response.getFirstHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<? extends CacheElement> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( true );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, null, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, transcoderFactoryClassName );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute,\n            final LoginType loginType,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n\n        final Embedded catalina = new Embedded();\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer( server );\n\n        try {\n            final NamingContext globalNamingContext = new NamingContext( new Hashtable<Object, Object>(), \"ctxt\" );\n            server.setGlobalNamingContext( globalNamingContext );\n            globalNamingContext.bind( USER_DATABASE, createUserDatabase() );\n        } catch ( final NamingException e ) {\n            throw new RuntimeException( e );\n        }\n\n        final Engine engine = catalina.createEngine();\n        catalina.addEngine( engine );\n\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( DEFAULT_HOST );\n        engine.setJvmRoute( jvmRoute );\n\n        final UserDatabaseRealm realm = new UserDatabaseRealm();\n        realm.setResourceName( USER_DATABASE );\n        engine.setRealm( realm );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n\n        final String docBase = root.getFile() + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", File.separator );\n        final Host host = catalina.createHost( DEFAULT_HOST, docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final Context context = catalina.createContext( CONTEXT_PATH, \"webapp\" );\n        host.addChild( context );\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        if ( loginType != null ) {\n            context.addConstraint( createSecurityConstraint( \"/*\", ROLE_NAME ) );\n            // context.addConstraint( createSecurityConstraint( \"/j_security_check\", null ) );\n            context.addSecurityRole( ROLE_NAME );\n            final LoginConfig loginConfig = loginType == LoginType.FORM\n                ? new LoginConfig( \"FORM\", null, \"/login\", \"/error\" )\n                : new LoginConfig( \"BASIC\", null, null, null );\n                context.setLoginConfig( loginConfig );\n        }\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setSessionBackupAsync( false );\n        sessionManager.setSessionBackupTimeout( 100 );\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n        sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName );\n\n        final Connector connector = catalina.createConnector( \"localhost\", port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    private static SecurityConstraint createSecurityConstraint( final String pattern, final String role ) {\n        final SecurityConstraint constraint = new SecurityConstraint();\n        final SecurityCollection securityCollection = new SecurityCollection();\n        securityCollection.addPattern( pattern );\n        constraint.addCollection( securityCollection );\n        if ( role != null ) {\n            constraint.addAuthRole( role );\n        }\n        return constraint;\n    }\n\n    public static enum LoginType {\n        BASIC, FORM\n    }\n\n    private static MemoryUserDatabase createUserDatabase() {\n        final MemoryUserDatabase userDatabase = new MemoryUserDatabase();\n        final Role role = userDatabase.createRole( ROLE_NAME, \"the role for unit tests\" );\n        final User user = userDatabase.createUser( USER_NAME, PASSWORD, \"the user for unit tests\" );\n        user.addRole( role );\n        return userDatabase;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().findChild( DEFAULT_HOST ).findChild( CONTEXT_PATH ).getManager();\n    }\n\n    public static void setChangeSessionIdOnAuth( final Embedded tomcat, final boolean changeSessionIdOnAuth ) {\n        final Engine engine = (StandardEngine)tomcat.getContainer();\n        final Host host = (Host)engine.findChild( DEFAULT_HOST );\n        final Container context = host.findChild( CONTEXT_PATH );\n        final Valve first = context.getPipeline().getFirst();\n        if ( first instanceof AuthenticatorBase ) {\n            ((AuthenticatorBase)first).setChangeSessionIdOnAuthentication( false );\n        }\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final String _responseSessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final String responseSessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _responseSessionId = responseSessionId;\n            _keyValues = keyValues;\n        }\n        public String getSessionId() {\n            return _sessionId;\n        }\n        public String getResponseSessionId() {\n            return _responseSessionId;\n        }\n        public Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        public String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n    /**\n     * Extracts the memcached node id from the provided session id.\n     * @param sessionId the session id, that may contain the node id, e.g. as <code>${origsessionid}-${nodeid}<\/code>\n     * @return the extracted node id or <code>null<\/code>, if no node information was found.\n     */\n    public static String extractNodeId( final String sessionId ) {\n        final int idx = sessionId.lastIndexOf( '-' );\n        return idx > -1 ? sessionId.substring( idx + 1 ) : null;\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another ) {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked ) {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Set.class.isAssignableFrom( one.getClass() ) ) {\n            final Set<?> m1 = (Set<?>) one;\n            final Set<?> m2 = (Set<?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            final Iterator<?> iter1 = m1.iterator();\n            final Iterator<?> iter2 = m2.iterator();\n            while( iter1.hasNext() ) {\n                assertDeepEquals( iter1.next(), iter2.next() );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    public static void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                try {\n                    assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n                } catch ( final IllegalArgumentException e ) {\n                    throw new RuntimeException( e );\n                } catch ( final IllegalAccessException e ) {\n                    throw new RuntimeException( e );\n                }\n            }\n        }\n    }\n\n    /**\n     * A simple serializable {@link HttpSessionActivationListener} that provides the\n     * session id that was passed during {@link #sessionDidActivate(HttpSessionEvent)}\n     * via {@link #getSessionDidActivate()}.\n     */\n    public static final class RecordingSessionActivationListener implements HttpSessionActivationListener, Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private transient String _sessionDidActivate;\n\n        @Override\n        public void sessionWillPassivate( final HttpSessionEvent se ) {\n        }\n\n        @Override\n        public void sessionDidActivate( final HttpSessionEvent se ) {\n            _sessionDidActivate = se.getSession().getId();\n        }\n\n        /**\n         * Returns the id of the session that was passed in {@link #sessionDidActivate(HttpSessionEvent)}.\n         * @return a session id or <code>null<\/code>.\n         */\n        public String getSessionDidActivate() {\n            return _sessionDidActivate;\n        }\n\n    }\n\n    /**\n     * Creates a map from the given keys and values (key1, value1, key2, value2, etc.).\n     * @param <T> the type of the keys and values.\n     * @param keysAndValues the keys and values, must be an even number of arguments.\n     * @return a {@link Map} or null if no argument was given.\n     */\n    public static <T> Map<T,T> asMap( final T ... keysAndValues ) {\n        if ( keysAndValues == null ) {\n            return null;\n        }\n        if ( keysAndValues.length % 2 != 0 ) {\n            throw new IllegalArgumentException( \"You must provide an even number of arguments as key/value pairs.\" );\n        }\n\n        final Map<T,T> result = new HashMap<T,T>();\n        for ( int i = 0; i < keysAndValues.length; i++ ) {\n            if ( i % 2 == 1 ) {\n                result.put( keysAndValues[i - 1], keysAndValues[i] );\n            }\n        }\n\n        return result;\n    }\n\n    public static enum SessionTrackingMode {\n        COOKIE,\n        URL\n    }\n\n    public static enum SessionAffinityMode {\n        STICKY {\n            @Override public boolean isSticky() { return true; }\n        },\n        NON_STICKY {\n            @Override public boolean isSticky() { return false; }\n        };\n\n        public abstract boolean isSticky();\n    }\n\n    @DataProvider\n    public static Object[][] stickynessProvider() {\n        return new Object[][] {\n                { SessionAffinityMode.STICKY },\n                { SessionAffinityMode.NON_STICKY }\n        };\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Serializable;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Currency;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.naming.NamingException;\nimport javax.servlet.http.HttpSessionActivationListener;\nimport javax.servlet.http.HttpSessionEvent;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Role;\nimport org.apache.catalina.User;\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.authenticator.AuthenticatorBase;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.core.StandardEngine;\nimport org.apache.catalina.core.StandardServer;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityCollection;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.realm.UserDatabaseRealm;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.catalina.users.MemoryUserDatabase;\nimport org.apache.http.Header;\nimport org.apache.http.HeaderElement;\nimport org.apache.http.HttpException;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.Credentials;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.auth.BasicScheme;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.protocol.BasicHttpContext;\nimport org.apache.http.protocol.HTTP;\nimport org.apache.naming.NamingContext;\nimport org.testng.Assert;\nimport org.testng.annotations.DataProvider;\n\nimport com.thimbleware.jmemcached.CacheElement;\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.JavaSerializationTranscoderFactory;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    private static final String CONTEXT_PATH = \"/\";\n    private static final String DEFAULT_HOST = \"localhost\";\n    private static final String DEFAULT_TRANSCODER_FACTORY = JavaSerializationTranscoderFactory.class.getName();\n\n    private static final String USER_DATABASE = \"UserDatabase\";\n    protected static final String PASSWORD = \"secret\";\n    protected static final String USER_NAME = \"testuser\";\n    protected static final String ROLE_NAME = \"test\";\n\n    public static final String STICKYNESS_PROVIDER = \"stickynessProvider\";\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpGet method = new HttpGet(\"http://\"+ DEFAULT_HOST +\":\"+ port + CONTEXT_PATH);\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n        responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        // We must consume the content so that the connection will be released\n        response.getEntity().consumeContent();\n\n        return responseSessionId == null ? rsessionId : responseSessionId;\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String rsessionId,\n            final Credentials credentials )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId, null, null, credentials );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, null, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final Map<String, String> params ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null, params, null );\n    }\n\n    public static Response get( final DefaultHttpClient client, final int port, final String path, final String rsessionId,\n            final SessionTrackingMode sessionTrackingMode,\n            final Map<String, String> params,\n            final Credentials credentials ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String url = getUrl( port, path );\n        if ( params != null && !params.isEmpty() ) {\n            url += toQueryString( params );\n        }\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.URL ) {\n            url += \";\" + Globals.SESSION_PARAMETER_NAME + \"=\" + rsessionId;\n        }\n        final HttpGet method = new HttpGet( url );\n        if ( rsessionId != null && sessionTrackingMode == SessionTrackingMode.COOKIE ) {\n            method.setHeader( \"Cookie\", Globals.SESSION_COOKIE_NAME + \"=\" + rsessionId );\n        }\n\n        final HttpResponse response = credentials == null\n            ? client.execute( method )\n            : executeRequestWithAuth( client, method, credentials );\n\n        if ( response.getStatusLine().getStatusCode() != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static String getUrl( final int port, String path ) throws IllegalArgumentException {\n        // we assume the context_path is \"/\"\n        if ( path != null && !path.startsWith( \"/\" ) ) {\n            // but we can also fix this\n            path = CONTEXT_PATH + path;\n        }\n        return \"http://\"+ DEFAULT_HOST +\":\"+ port + ( path != null ? path : CONTEXT_PATH );\n    }\n\n    /**\n     * @param params\n     * @return\n     */\n    private static String toQueryString( final Map<String, String> params ) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append( \"?\" );\n        for ( final Iterator<Entry<String, String>> iterator = params.entrySet().iterator(); iterator.hasNext(); ) {\n            final Entry<String, String> entry = iterator.next();\n            sb.append( entry.getKey() ).append( \"=\" ).append( entry.getValue() );\n            if ( iterator.hasNext() ) {\n                sb.append( \"&\" );\n            }\n        }\n        final String qs = sb.toString();\n        return qs;\n    }\n\n    private static HttpResponse executeRequestWithAuth( final DefaultHttpClient client, final HttpGet method,\n            final Credentials credentials ) throws IOException, ClientProtocolException {\n        client.getCredentialsProvider().setCredentials( AuthScope.ANY, credentials );\n\n        final BasicHttpContext localcontext = new BasicHttpContext();\n\n        // Generate BASIC scheme object and stick it to the local\n        // execution context\n        final BasicScheme basicAuth = new BasicScheme();\n        localcontext.setAttribute( \"preemptive-auth\", basicAuth );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        return client.execute( method, localcontext );\n    }\n\n    private static Response readResponse( final String rsessionId, final HttpResponse response ) throws IOException {\n        final String responseSessionId = getSessionIdFromResponse( response );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) );\n            String line = null;\n            while ( ( line = reader.readLine() ) != null ) {\n                final String[] keyValue = line.split( \"=\" );\n                if ( keyValue.length > 0 ) {\n                    keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n                }\n            }\n        } finally {\n            reader.close();\n        }\n\n        return new Response( responseSessionId == null ? rsessionId : responseSessionId, responseSessionId, keyValues );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String rsessionId,\n            final String paramName,\n            final String paramValue ) throws IOException, HttpException {\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( paramName, paramValue );\n        return post( client, port, null, rsessionId, params );\n    }\n\n    public static Response post( final DefaultHttpClient client,\n            final int port,\n            final String path,\n            final String rsessionId,\n            final Map<String, String> params ) throws IOException, HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://\"+ DEFAULT_HOST +\":\"+ port;\n        final String url = getUrl( port, path );\n        final HttpPost method = new HttpPost( url );\n        if ( rsessionId != null ) {\n            method.setHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n        }\n\n        method.setEntity( createFormEntity( params ) );\n\n        // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n        //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n        final HttpResponse response = client.execute( method );\n\n        final int statusCode = response.getStatusLine().getStatusCode();\n        if ( statusCode == 302 ) {\n            return redirect( response, client, port, rsessionId, baseUri );\n        }\n\n        if ( statusCode != 200 ) {\n            throw new RuntimeException( \"GET did not return status 200, but \" + response.getStatusLine() );\n        }\n\n        return readResponse( rsessionId, response );\n    }\n\n    private static Response redirect( final HttpResponse response, final DefaultHttpClient client, final int port,\n            final String rsessionId, final String baseUri ) throws IOException, HttpException {\n        final String location = response.getFirstHeader( \"Location\" ).getValue();\n        if ( !location.startsWith( baseUri ) ) {\n            throw new RuntimeException( \"There's s.th. wrong, the location header should start with the base URI \" + baseUri +\n                    \". The location header: \" + location );\n        }\n        /* consume content so that the connection can be released\n         */\n        response.getEntity().consumeContent();\n\n        /* redirect\n         */\n        final String redirectPath = location.substring( baseUri.length(), location.length() );\n        return get( client, port, redirectPath, rsessionId );\n    }\n\n    private static UrlEncodedFormEntity createFormEntity( final Map<String, String> params ) throws UnsupportedEncodingException {\n        final List<NameValuePair> parameters = new ArrayList <NameValuePair>();\n        for( final Map.Entry<String, String> param : params.entrySet() ) {\n            parameters.add( new BasicNameValuePair( param.getKey(), param.getValue() ) );\n        }\n        final UrlEncodedFormEntity entity = new UrlEncodedFormEntity( parameters, HTTP.UTF_8 );\n        return entity;\n    }\n\n    public static String getSessionIdFromResponse( final HttpResponse response ) {\n        final Header cookie = response.getFirstHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<? extends CacheElement> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( true );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, null, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null, transcoderFactoryClassName );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, loginType, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null, null, DEFAULT_TRANSCODER_FACTORY );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute,\n            final LoginType loginType,\n            final String transcoderFactoryClassName ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n\n        final Embedded catalina = new Embedded();\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer( server );\n\n        try {\n            final NamingContext globalNamingContext = new NamingContext( new Hashtable<Object, Object>(), \"ctxt\" );\n            server.setGlobalNamingContext( globalNamingContext );\n            globalNamingContext.bind( USER_DATABASE, createUserDatabase() );\n        } catch ( final NamingException e ) {\n            throw new RuntimeException( e );\n        }\n\n        final Engine engine = catalina.createEngine();\n        catalina.addEngine( engine );\n\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( DEFAULT_HOST );\n        engine.setJvmRoute( jvmRoute );\n\n        final UserDatabaseRealm realm = new UserDatabaseRealm();\n        realm.setResourceName( USER_DATABASE );\n        engine.setRealm( realm );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n\n        final String fileSeparator = File.separator.equals( \"\\\\\" ) ? \"\\\\\\\\\" : File.separator;\n        final String docBase = root.getFile() + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", fileSeparator );\n        final Host host = catalina.createHost( DEFAULT_HOST, docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final Context context = catalina.createContext( CONTEXT_PATH, \"webapp\" );\n        host.addChild( context );\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        if ( loginType != null ) {\n            context.addConstraint( createSecurityConstraint( \"/*\", ROLE_NAME ) );\n            // context.addConstraint( createSecurityConstraint( \"/j_security_check\", null ) );\n            context.addSecurityRole( ROLE_NAME );\n            final LoginConfig loginConfig = loginType == LoginType.FORM\n                ? new LoginConfig( \"FORM\", null, \"/login\", \"/error\" )\n                : new LoginConfig( \"BASIC\", null, null, null );\n                context.setLoginConfig( loginConfig );\n        }\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setSessionBackupAsync( false );\n        sessionManager.setSessionBackupTimeout( 100 );\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n        sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName );\n\n        final Connector connector = catalina.createConnector( \"localhost\", port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    private static SecurityConstraint createSecurityConstraint( final String pattern, final String role ) {\n        final SecurityConstraint constraint = new SecurityConstraint();\n        final SecurityCollection securityCollection = new SecurityCollection();\n        securityCollection.addPattern( pattern );\n        constraint.addCollection( securityCollection );\n        if ( role != null ) {\n            constraint.addAuthRole( role );\n        }\n        return constraint;\n    }\n\n    public static enum LoginType {\n        BASIC, FORM\n    }\n\n    private static MemoryUserDatabase createUserDatabase() {\n        final MemoryUserDatabase userDatabase = new MemoryUserDatabase();\n        final Role role = userDatabase.createRole( ROLE_NAME, \"the role for unit tests\" );\n        final User user = userDatabase.createUser( USER_NAME, PASSWORD, \"the user for unit tests\" );\n        user.addRole( role );\n        return userDatabase;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().findChild( DEFAULT_HOST ).findChild( CONTEXT_PATH ).getManager();\n    }\n\n    public static void setChangeSessionIdOnAuth( final Embedded tomcat, final boolean changeSessionIdOnAuth ) {\n        final Engine engine = (StandardEngine)tomcat.getContainer();\n        final Host host = (Host)engine.findChild( DEFAULT_HOST );\n        final Container context = host.findChild( CONTEXT_PATH );\n        final Valve first = context.getPipeline().getFirst();\n        if ( first instanceof AuthenticatorBase ) {\n            ((AuthenticatorBase)first).setChangeSessionIdOnAuthentication( false );\n        }\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final String _responseSessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final String responseSessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _responseSessionId = responseSessionId;\n            _keyValues = keyValues;\n        }\n        public String getSessionId() {\n            return _sessionId;\n        }\n        public String getResponseSessionId() {\n            return _responseSessionId;\n        }\n        public Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        public String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n    /**\n     * Extracts the memcached node id from the provided session id.\n     * @param sessionId the session id, that may contain the node id, e.g. as <code>${origsessionid}-${nodeid}<\/code>\n     * @return the extracted node id or <code>null<\/code>, if no node information was found.\n     */\n    public static String extractNodeId( final String sessionId ) {\n        final int idx = sessionId.lastIndexOf( '-' );\n        return idx > -1 ? sessionId.substring( idx + 1 ) : null;\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another ) {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked ) {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Set.class.isAssignableFrom( one.getClass() ) ) {\n            final Set<?> m1 = (Set<?>) one;\n            final Set<?> m2 = (Set<?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            final Iterator<?> iter1 = m1.iterator();\n            final Iterator<?> iter2 = m2.iterator();\n            while( iter1.hasNext() ) {\n                assertDeepEquals( iter1.next(), iter2.next() );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    public static void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                try {\n                    assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n                } catch ( final IllegalArgumentException e ) {\n                    throw new RuntimeException( e );\n                } catch ( final IllegalAccessException e ) {\n                    throw new RuntimeException( e );\n                }\n            }\n        }\n    }\n\n    /**\n     * A simple serializable {@link HttpSessionActivationListener} that provides the\n     * session id that was passed during {@link #sessionDidActivate(HttpSessionEvent)}\n     * via {@link #getSessionDidActivate()}.\n     */\n    public static final class RecordingSessionActivationListener implements HttpSessionActivationListener, Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private transient String _sessionDidActivate;\n\n        @Override\n        public void sessionWillPassivate( final HttpSessionEvent se ) {\n        }\n\n        @Override\n        public void sessionDidActivate( final HttpSessionEvent se ) {\n            _sessionDidActivate = se.getSession().getId();\n        }\n\n        /**\n         * Returns the id of the session that was passed in {@link #sessionDidActivate(HttpSessionEvent)}.\n         * @return a session id or <code>null<\/code>.\n         */\n        public String getSessionDidActivate() {\n            return _sessionDidActivate;\n        }\n\n    }\n\n    /**\n     * Creates a map from the given keys and values (key1, value1, key2, value2, etc.).\n     * @param <T> the type of the keys and values.\n     * @param keysAndValues the keys and values, must be an even number of arguments.\n     * @return a {@link Map} or null if no argument was given.\n     */\n    public static <T> Map<T,T> asMap( final T ... keysAndValues ) {\n        if ( keysAndValues == null ) {\n            return null;\n        }\n        if ( keysAndValues.length % 2 != 0 ) {\n            throw new IllegalArgumentException( \"You must provide an even number of arguments as key/value pairs.\" );\n        }\n\n        final Map<T,T> result = new HashMap<T,T>();\n        for ( int i = 0; i < keysAndValues.length; i++ ) {\n            if ( i % 2 == 1 ) {\n                result.put( keysAndValues[i - 1], keysAndValues[i] );\n            }\n        }\n\n        return result;\n    }\n\n    public static enum SessionTrackingMode {\n        COOKIE,\n        URL\n    }\n\n    public static enum SessionAffinityMode {\n        STICKY {\n            @Override public boolean isSticky() { return true; }\n        },\n        NON_STICKY {\n            @Override public boolean isSticky() { return false; }\n        };\n\n        public abstract boolean isSticky();\n    }\n\n    @DataProvider\n    public static Object[][] stickynessProvider() {\n        return new Object[][] {\n                { SessionAffinityMode.STICKY },\n                { SessionAffinityMode.NON_STICKY }\n        };\n    }\n\n}\n","lineNo":411}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 50;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    /**\n     * Has this component been _started yet?\n     */\n    protected boolean _started = false;\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n\n    private SessionTrackerValve _sessionTrackerValve;\n\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        super.init();\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _sessionTrackerValve = new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled );\n        getContainer().getPipeline().addValve( _sessionTrackerValve );\n\n        initNonStickyLockingMode( config );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    protected static MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, new NodeIdList( nodeIds ), failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final NodeIdList nodeIds, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( nodeIds, address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final NodeIdList nodeIds, final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private static List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private static void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = (MemcachedBackupSession) super.findSession( id );\n        if ( result == null && canHitMemcached( id ) ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcachedWithCheck( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = new MemcachedBackupSession( this );\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    @Override\n    public void changeSessionId( final Session session ) {\n        // e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation\n        // so that session backup won't be omitted we must store this event\n        super.changeSessionId( session );\n        ((MemcachedBackupSession)session).setSessionIdChanged( true );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcachedWithCheck( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId );\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                    final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                    final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                    if ( newNodeId != null ) {\n                        final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            }\n            else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = _sessionIdFormat.extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _nodeIdService.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    addValidLoadedSession( backupSession );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String backupNodeId = getBackupNodeId( requestedSessionId );\n        if ( !_nodeIdService.isNodeAvailable( backupNodeId ) ) {\n            _log.info( \"Node \"+ backupNodeId +\" that stores the backup of the session \"+ requestedSessionId +\" is not available.\" );\n            return null;\n        }\n\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                _log.info( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( _sessionIdFormat.createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                _log.info( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, getContainer().getRealm(), this );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n\n            _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n            final String newSessionId = _sessionIdFormat.createNewSessionId( requestedSessionId, backupNodeId );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n        }\n        return null;\n    }\n\n    /**\n     * Determines if the (secondary) memcached node used for failover backup of non-sticky sessions is available.\n     * @param sessionId the id of the session that shall be stored in another, secondary memcached node.\n     * @return <code>true<\/code> if the backup node is available.\n     * @see #getBackupNodeId(String)\n     */\n    boolean isBackupNodeAvailable( @Nonnull final String sessionId ) {\n        return _nodeIdService.isNodeAvailable( getBackupNodeId( sessionId ) );\n    }\n\n    /**\n     * Determines the id of the (secondary) memcached node that's used for additional backup\n     * of non-sticky sessions.\n     * @param sessionId the id of the session\n     * @return the nodeId, e.g. \"n2\"\n     * @see #isBackupNodeAvailable(String)\n     */\n    @Nonnull\n    String getBackupNodeId( @Nonnull final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return _nodeIdService.getNextNodeId( nodeId );\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = (MemcachedBackupSession) session;\n\n        if ( !_sticky ) {\n            msmSession.passivate();\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= session.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            remove( session, false );\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId is not in our missingSessionsCache.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _sessionIdFormat.isValid( sessionId ) && _missingSessionsCache.get( sessionId ) == null;\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n\n            LockStatus lockStatus = null;\n            try {\n\n                if ( !_sticky ) {\n                    lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n                }\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        final long startDeserialization = System.currentTimeMillis();\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                        _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                    }\n                    _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                    result.setSticky( _sticky );\n                    if ( !_sticky ) {\n                        _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                    }\n\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    if ( lockStatus == LockStatus.LOCKED ) {\n                        _lockingStrategy.releaseLock( sessionId );\n                    }\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        remove( session, session.getNote( NODE_FAILURE ) != Boolean.TRUE );\n    }\n\n    private void remove( final Session session, final boolean removeFromMemcached ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, removeFromMemcached: \" + removeFromMemcached +\n                    \", id: \" + session.getId() );\n        }\n        if ( removeFromMemcached ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                Integer.valueOf( oldMaxActiveSessions ),\n                Integer.valueOf( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( config );\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && initialized ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && initialized ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( initialized ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( initialized ) {\n            initNonStickyLockingMode( createMemcachedConfig( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n    private void initNonStickyLockingMode( @Nonnull final MemcachedConfig config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1;\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nonnull final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _missingSessionsCache, storeSecondaryBackup, _statistics );\n        if ( _sessionTrackerValve != null ) {\n            _sessionTrackerValve.setLockingStrategy( _lockingStrategy );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n\n        if( ! initialized ) {\n            init();\n        }\n\n        // Validate and update our current component state\n        if (_started) {\n            return;\n        }\n        _lifecycle.fireLifecycleEvent(START_EVENT, null);\n        _started = true;\n\n        // Force initialization of the random number generator\n        if (log.isDebugEnabled()) {\n            log.debug(\"Force random number initialization starting\");\n        }\n        super.generateSessionId();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Force random number initialization completed\");\n        }\n\n        startInternal( null );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping\");\n        }\n\n        // Validate and update our current component state\n        if (!_started) {\n            throw new LifecycleException\n                (sm.getString(\"standardManager.notStarted\"));\n        }\n        _lifecycle.fireLifecycleEvent(STOP_EVENT, null);\n        _started = false;\n\n        // Require a new random number generator if we are restarted\n        random = null;\n\n        if ( initialized ) {\n\n            if ( _sticky ) {\n                _log.info( \"Removing sessions from local session map.\" );\n                for( final Session session : sessions.values() ) {\n                    swapOut( (StandardSession) session );\n                }\n            }\n\n            _log.info( \"Stopping services.\" );\n            _backupSessionService.shutdown();\n            if ( _lockingStrategy != null ) {\n                _lockingStrategy.shutdown();\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n\n            destroy();\n        }\n    }\n\n    private void swapOut( @Nonnull final StandardSession session ) {\n        // implementation like the one in PersistentManagerBase.swapOut\n        if (!session.isValid()) {\n            return;\n        }\n        session.passivate();\n        remove( session, false );\n        session.recycle();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && initialized ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _nodeIdService, _statistics );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    public long getMsmStatNumNonStickySessionsPingFailed() {\n        return _statistics.getNonStickySessionsPingFailed();\n    }\n    public long getMsmStatNumNonStickySessionsReadOnlyRequest() {\n        return _statistics.getNonStickySessionsReadOnlyRequest();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getProbe( ATTRIBUTES_SERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getProbe( EFFECTIVE_BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getProbe( BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatSessionDeserializationInfo()\n     * @see #getMsmStatNonStickyAfterLoadFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getProbe( LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deleting sessions from memcached took.\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatNonStickyAfterDeleteFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsDeletedFromMemcachedInfo() {\n        return _statistics.getProbe( DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deserialization of session data took.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionDeserializationInfo() {\n        return _statistics.getProbe( SESSION_DESERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getProbe( CACHED_DATA_SIZE ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getProbe( MEMCACHED_UPDATE ).getInfo();\n    }\n\n    /**\n     * Info about locks acquired in non-sticky mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK ).getInfo();\n    }\n\n    /**\n     * Lock acquiration in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockFailureInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK_FAILURE ).getInfo();\n    }\n\n    /**\n     * Lock release in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyReleaseLockInfo() {\n        return _statistics.getProbe( RELEASE_LOCK ).getInfo();\n    }\n\n    /**\n     * Store metadata / validity info in memcached.\n     */\n    public String[] getMsmStatNonStickyStoreMetaDataInfo() {\n        return _statistics.getProbe( NON_STICKY_STORE_METADATA ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after session backup (ping session, store validity info / meta data,\n     * store additional backup in secondary memcached).\n     */\n    public String[] getMsmStatNonStickyAfterBackupInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_BACKUP ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was loaded from memcached (load validity info / meta data).\n     */\n    public String[] getMsmStatNonStickyAfterLoadFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was deleted from memcached (delete validity info and backup data).\n     */\n    public String[] getMsmStatNonStickyAfterDeleteFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final NodeIdList _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final NodeIdList nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public NodeIdList getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 50;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    /**\n     * Has this component been _started yet?\n     */\n    protected boolean _started = false;\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n\n    private SessionTrackerValve _sessionTrackerValve;\n\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        super.init();\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _sessionTrackerValve = new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled );\n        getContainer().getPipeline().addValve( _sessionTrackerValve );\n\n        initNonStickyLockingMode( config );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    protected static MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, new NodeIdList( nodeIds ), failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final NodeIdList nodeIds, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( nodeIds, address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final NodeIdList nodeIds, final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private static List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private static void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = (MemcachedBackupSession) super.findSession( id );\n        if ( result == null && canHitMemcached( id ) && _missingSessionsCache.get( id ) == null ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        if ( session.isNew() ) {\n            session.tellNew();\n        }\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcachedWithCheck( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = new MemcachedBackupSession( this );\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    @Override\n    public void changeSessionId( final Session session ) {\n        // e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation\n        // so that session backup won't be omitted we must store this event\n        super.changeSessionId( session );\n        ((MemcachedBackupSession)session).setSessionIdChanged( true );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcachedWithCheck( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId );\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                    final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                    final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                    if ( newNodeId != null ) {\n                        final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            }\n            else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = _sessionIdFormat.extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _nodeIdService.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                _log.info( \"Session needs to be relocated as node \"+ nodeId +\" is not available, loading backup session for \" + requestedSessionId );\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId );\n                if ( backupSession != null ) {\n                    _log.debug( \"Loaded backup session for \" + requestedSessionId + \", adding locally with \"+ backupSession.getIdInternal() +\".\" );\n                    addValidLoadedSession( backupSession );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId ) {\n\n        final String backupNodeId = getBackupNodeId( requestedSessionId );\n        if ( backupNodeId == null ) {\n            _log.info( \"No backup node found for nodeId \"+ _sessionIdFormat.extractMemcachedId( requestedSessionId ) );\n            return null;\n        }\n\n        if ( !_nodeIdService.isNodeAvailable( backupNodeId ) ) {\n            _log.info( \"Node \"+ backupNodeId +\" that stores the backup of the session \"+ requestedSessionId +\" is not available.\" );\n            return null;\n        }\n\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                _log.info( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( _sessionIdFormat.createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                _log.info( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, getContainer().getRealm(), this );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n\n            final String newSessionId = _sessionIdFormat.createNewSessionId( requestedSessionId, backupNodeId );\n            _log.info( \"Session backup loaded from secondary memcached for \"+ requestedSessionId +\" (will be relocated),\" +\n            \t\t\" setting new id \"+ newSessionId +\" on session...\" );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n        }\n        return null;\n    }\n\n    /**\n     * Determines if the (secondary) memcached node used for failover backup of non-sticky sessions is available.\n     * @param sessionId the id of the session that shall be stored in another, secondary memcached node.\n     * @return <code>true<\/code> if the backup node is available. If there's no secondary memcached node\n     *         (e.g. as there's only a single memcached), <code>false<\/code> is returned.\n     * @see #getBackupNodeId(String)\n     */\n    boolean isBackupNodeAvailable( @Nonnull final String sessionId ) {\n        final String backupNodeId = getBackupNodeId( sessionId );\n        return backupNodeId == null ? false : _nodeIdService.isNodeAvailable( backupNodeId );\n    }\n\n    /**\n     * Determines the id of the (secondary) memcached node that's used for additional backup\n     * of non-sticky sessions.\n     * @param sessionId the id of the session\n     * @return the nodeId, e.g. \"n2\", or <code>null<\/code>.\n     * @see #isBackupNodeAvailable(String)\n     * @see NodeIdService#getNextNodeId(String)\n     */\n    @CheckForNull\n    String getBackupNodeId( @Nonnull final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId == null ? null : _nodeIdService.getNextNodeId( nodeId );\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = (MemcachedBackupSession) session;\n\n        if ( !_sticky ) {\n            msmSession.passivate();\n        }\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= session.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n\n        if ( !_sticky ) {\n            remove( session, false );\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n\n        return result;\n    }\n\n    @Nonnull\n    byte[] serialize( @Nonnull final MemcachedBackupSession session ) {\n        return _transcoderService.serialize( session );\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId is not in our missingSessionsCache.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _sessionIdFormat.isValid( sessionId );\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( nodeId == null ) {\n            throw new IllegalArgumentException( \"The sessionId should contain a nodeId, this should be checked\" +\n            \t\t\" by invoking canHitMemcached before invoking this method (bug, needs fix).\" );\n        }\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n\n            LockStatus lockStatus = null;\n            try {\n\n                if ( !_sticky ) {\n                    lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n                }\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        final long startDeserialization = System.currentTimeMillis();\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                        _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                    }\n                    _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                    result.setSticky( _sticky );\n                    if ( !_sticky ) {\n                        _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                    }\n\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    if ( lockStatus == LockStatus.LOCKED ) {\n                        _lockingStrategy.releaseLock( sessionId );\n                    }\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        remove( session, session.getNote( NODE_FAILURE ) != Boolean.TRUE );\n    }\n\n    private void remove( final Session session, final boolean removeFromMemcached ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, removeFromMemcached: \" + removeFromMemcached +\n                    \", id: \" + session.getId() );\n        }\n        if ( removeFromMemcached ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                Integer.valueOf( oldMaxActiveSessions ),\n                Integer.valueOf( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( config );\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && initialized ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && initialized ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( initialized ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( @Nullable final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode != null && lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( initialized ) {\n            initNonStickyLockingMode( createMemcachedConfig( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n    private void initNonStickyLockingMode( @Nonnull final MemcachedConfig config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1;\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _missingSessionsCache, storeSecondaryBackup, _statistics );\n        if ( _sessionTrackerValve != null ) {\n            _sessionTrackerValve.setLockingStrategy( _lockingStrategy );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n\n        if( ! initialized ) {\n            init();\n        }\n\n        // Validate and update our current component state\n        if (_started) {\n            return;\n        }\n        _lifecycle.fireLifecycleEvent(START_EVENT, null);\n        _started = true;\n\n        // Force initialization of the random number generator\n        if (log.isDebugEnabled()) {\n            log.debug(\"Force random number initialization starting\");\n        }\n        super.generateSessionId();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Force random number initialization completed\");\n        }\n\n        startInternal( null );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping\");\n        }\n\n        // Validate and update our current component state\n        if (!_started) {\n            throw new LifecycleException\n                (sm.getString(\"standardManager.notStarted\"));\n        }\n        _lifecycle.fireLifecycleEvent(STOP_EVENT, null);\n        _started = false;\n\n        // Require a new random number generator if we are restarted\n        random = null;\n\n        if ( initialized ) {\n\n            if ( _sticky ) {\n                _log.info( \"Removing sessions from local session map.\" );\n                for( final Session session : sessions.values() ) {\n                    swapOut( (StandardSession) session );\n                }\n            }\n\n            _log.info( \"Stopping services.\" );\n            _backupSessionService.shutdown();\n            if ( _lockingStrategy != null ) {\n                _lockingStrategy.shutdown();\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n\n            destroy();\n        }\n    }\n\n    private void swapOut( @Nonnull final StandardSession session ) {\n        // implementation like the one in PersistentManagerBase.swapOut\n        if (!session.isValid()) {\n            return;\n        }\n        session.passivate();\n        remove( session, false );\n        session.recycle();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && initialized ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _nodeIdService, _statistics );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    public long getMsmStatNumNonStickySessionsPingFailed() {\n        return _statistics.getNonStickySessionsPingFailed();\n    }\n    public long getMsmStatNumNonStickySessionsReadOnlyRequest() {\n        return _statistics.getNonStickySessionsReadOnlyRequest();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getProbe( ATTRIBUTES_SERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getProbe( EFFECTIVE_BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getProbe( BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatSessionDeserializationInfo()\n     * @see #getMsmStatNonStickyAfterLoadFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getProbe( LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deleting sessions from memcached took.\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatNonStickyAfterDeleteFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsDeletedFromMemcachedInfo() {\n        return _statistics.getProbe( DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deserialization of session data took.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionDeserializationInfo() {\n        return _statistics.getProbe( SESSION_DESERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getProbe( CACHED_DATA_SIZE ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getProbe( MEMCACHED_UPDATE ).getInfo();\n    }\n\n    /**\n     * Info about locks acquired in non-sticky mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK ).getInfo();\n    }\n\n    /**\n     * Lock acquiration in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockFailureInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK_FAILURE ).getInfo();\n    }\n\n    /**\n     * Lock release in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyReleaseLockInfo() {\n        return _statistics.getProbe( RELEASE_LOCK ).getInfo();\n    }\n\n    /**\n     * Store metadata / validity info in memcached.\n     */\n    public String[] getMsmStatNonStickyStoreMetaDataInfo() {\n        return _statistics.getProbe( NON_STICKY_STORE_METADATA ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after session backup (ping session, store validity info / meta data,\n     * store additional backup in secondary memcached).\n     */\n    public String[] getMsmStatNonStickyAfterBackupInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_BACKUP ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was loaded from memcached (load validity info / meta data).\n     */\n    public String[] getMsmStatNonStickyAfterLoadFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was deleted from memcached (delete validity info and backup data).\n     */\n    public String[] getMsmStatNonStickyAfterDeleteFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final NodeIdList _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final NodeIdList nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public NodeIdList getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","lineNo":779}
{"Smelly Sample":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            if ( !backupWasForced ) {\n                pingSessionIfBackupWasSkipped( session, result, backupSessionService );\n            }\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    final Callable<?> backupSessionTask = new StoreNonStickySessionBackupTask( session, result );\n                    _executor.submit( backupSessionTask );\n\n                    final String backupValidityKey = _sessionIdFormat.createBackupKey( validityKey );\n                    _memcached.set( backupValidityKey, session.getMaxInactiveInterval(), validityData );\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + session.getIdInternal(), e );\n                }\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    private void pingSessionIfBackupWasSkipped( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final Future<BackupResult> result, @Nonnull final BackupSessionService backupSessionService ) {\n        final Callable<Void> task = new Callable<Void>() {\n\n            @Override\n            public Void call() {\n                try {\n                    if ( result.get().getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSession( session, backupSessionService );\n                    }\n                } catch ( final Exception e ) {\n                    _log.warn( \"An exception occurred during backup.\", e );\n                }\n                return null;\n            }\n\n        };\n        /*\n         * A simple future does not need to go through the executor, but we can process the result right now.\n         */\n        if ( result instanceof SimpleFuture ) {\n            try {\n                task.call();\n            } catch ( final Exception e ) { /* caught in the callable */\n            }\n        }\n        else {\n            _executor.submit( task );\n        }\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String id ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( createValidityInfoKeyName( id ) );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String id ) {\n        final String key = createValidityInfoKeyName( id );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        final byte[] validityInfo = (byte[]) _memcached.get( backupKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class StoreNonStickySessionBackupTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n\n        private StoreNonStickySessionBackupTask( final MemcachedBackupSession session, final Future<BackupResult> result ) {\n            _session = session;\n            _result = result;\n        }\n\n        @Override\n        public Void call() throws Exception {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n            }\n            final BackupResult backupResult = _result.get();\n            if ( backupResult.getStatus() != BackupResultStatus.SKIPPED ) {\n                final byte[] data = backupResult.getData();\n                if ( data != null ) {\n                    final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                    _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n                }\n                else {\n                    _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                            + _session.getIdInternal() + \", skipping backup\"\n                            + \" of non-sticky session in secondary memcached.\" );\n                }\n            }\n            else {\n                pingSessionBackup( _session );\n            }\n            return null;\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    updateSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void updateSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2011 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.SessionValidityInfo.createValidityInfoKeyName;\nimport static de.javakaffee.web.msm.SessionValidityInfo.decode;\nimport static de.javakaffee.web.msm.SessionValidityInfo.encode;\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\nimport static java.lang.Math.min;\nimport static java.lang.Thread.sleep;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.connector.Request;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.LockStatus;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Represents the session locking hooks that must be implemented by the various locking strategies.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic abstract class LockingStrategy {\n\n    public static enum LockingMode {\n        /** Sessions are never locked. */\n        NONE,\n        /** Sessions are locked for each request. */\n        ALL,\n        /** Readonly requests are tracked and for requests that modify the session the session is locked. */\n        AUTO,\n        /** The application explicitely manages locks */\n        APP,\n        /** The session is locked for configured request patterns **/\n        URI_PATTERN\n    }\n\n    protected static final String LOCK_VALUE = \"locked\";\n    protected static final int LOCK_RETRY_INTERVAL = 10;\n    protected static final int LOCK_MAX_RETRY_INTERVAL = 500;\n    protected static final int LOCK_TIMEOUT = 2000;\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    protected MemcachedBackupSessionManager _manager;\n    protected final MemcachedClient _memcached;\n    protected LRUCache<String, Boolean> _missingSessionsCache;\n    protected final SessionIdFormat _sessionIdFormat;\n    protected final InheritableThreadLocal<Request> _requestsThreadLocal;\n    private final ExecutorService _executor;\n    private final boolean _storeSecondaryBackup;\n    protected final Statistics _stats;\n\n    protected LockingStrategy( @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final MemcachedClient memcached,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        _manager = manager;\n        _memcached = memcached;\n        _missingSessionsCache = missingSessionsCache;\n        _sessionIdFormat = new SessionIdFormat();\n        _requestsThreadLocal = new InheritableThreadLocal<Request>();\n        _storeSecondaryBackup = storeSecondaryBackup;\n        _stats = stats;\n        _executor = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors() );\n    }\n\n    /**\n     * Creates the appropriate {@link LockingStrategy} for the given {@link LockingMode}.\n     */\n    @CheckForNull\n    public static LockingStrategy create( @Nullable final LockingMode lockingMode, @Nullable final Pattern uriPattern,\n            @Nonnull final MemcachedClient memcached, @Nonnull final MemcachedBackupSessionManager manager,\n            @Nonnull final LRUCache<String, Boolean> missingSessionsCache, final boolean storeSecondaryBackup,\n            @Nonnull final Statistics stats ) {\n        if ( lockingMode == null ) {\n            return null;\n        }\n        switch ( lockingMode ) {\n        case ALL:\n            return new LockingStrategyAll( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case AUTO:\n            return new LockingStrategyAuto( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        case URI_PATTERN:\n            return new LockingStrategyUriPattern( manager, uriPattern, memcached, missingSessionsCache, storeSecondaryBackup,\n                    stats );\n        case NONE:\n            return new LockingStrategyNone( manager, memcached, missingSessionsCache, storeSecondaryBackup, stats );\n        default:\n            throw new IllegalArgumentException( \"LockingMode not yet supported: \" + lockingMode );\n        }\n    }\n\n    /**\n     * Shutdown this lockingStrategy, which frees all resources / releases threads.\n     */\n    public void shutdown() {\n        _executor.shutdown();\n    }\n\n    protected LockStatus lock( final String sessionId ) {\n        return lock( sessionId, LOCK_TIMEOUT, TimeUnit.MILLISECONDS );\n    }\n\n    protected LockStatus lock( final String sessionId, final long timeout, final TimeUnit timeUnit ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Locking session \" + sessionId );\n        }\n        final long start = System.currentTimeMillis();\n        try {\n            acquireLock( sessionId, LOCK_RETRY_INTERVAL, LOCK_MAX_RETRY_INTERVAL, timeUnit.toMillis( timeout ),\n                    System.currentTimeMillis() );\n            _stats.registerSince( ACQUIRE_LOCK, start );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return LockStatus.LOCKED;\n        } catch ( final TimeoutException e ) {\n            _log.warn( \"Reached timeout when trying to aquire lock for session \" + sessionId\n                    + \". Will use this session without this lock.\" );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        } catch ( final InterruptedException e ) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException( \"Got interrupted while trying to lock session.\", e );\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to aquire lock for session \" + sessionId );\n            _stats.registerSince( ACQUIRE_LOCK_FAILURE, start );\n            return LockStatus.COULD_NOT_AQUIRE_LOCK;\n        }\n    }\n\n    protected void acquireLock( @Nonnull final String sessionId, final long retryInterval, final long maxRetryInterval,\n            final long timeout, final long start ) throws InterruptedException, ExecutionException, TimeoutException {\n        final Future<Boolean> result = _memcached.add( _sessionIdFormat.createLockName( sessionId ), 5, LOCK_VALUE );\n        if ( result.get().booleanValue() ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Locked session \" + sessionId );\n            }\n            return;\n        }\n        else {\n            checkTimeoutAndWait( sessionId, retryInterval, maxRetryInterval, timeout, start );\n            acquireLock( sessionId, retryInterval * 2, maxRetryInterval, timeout, start );\n        }\n    }\n\n    protected void checkTimeoutAndWait( @Nonnull final String sessionId, final long retryInterval,\n            final long maxRetryInterval, final long timeout, final long start ) throws TimeoutException,\n            InterruptedException {\n        if ( System.currentTimeMillis() >= start + timeout ) {\n            throw new TimeoutException( \"Reached timeout when trying to aquire lock for session \" + sessionId );\n        }\n        final long timeToWait = min( retryInterval, maxRetryInterval );\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Could not aquire lock for session \" + sessionId + \", waiting \" + timeToWait + \" millis now...\" );\n        }\n        sleep( timeToWait );\n    }\n\n    protected void releaseLock( @Nonnull final String sessionId ) {\n        try {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Releasing lock for session \" + sessionId );\n            }\n            final long start = System.currentTimeMillis();\n            _memcached.delete( _sessionIdFormat.createLockName( sessionId ) );\n            _stats.registerSince( RELEASE_LOCK, start );\n        } catch ( final Exception e ) {\n            _log.warn( \"Caught exception when trying to release lock for session \" + sessionId );\n        }\n    }\n\n    /**\n     * Is invoked after the backup of the session is initiated, it's represented by the provided backupResult. The\n     * requestId is identifying the request.\n     */\n    protected void onAfterBackupSession( @Nonnull final MemcachedBackupSession session, final boolean backupWasForced,\n            @Nonnull final Future<BackupResult> result, @Nonnull final String requestId,\n            @Nonnull final BackupSessionService backupSessionService ) {\n\n        try {\n\n            final long start = System.currentTimeMillis();\n\n            final byte[] validityData = encode( session.getMaxInactiveInterval(), session.getLastAccessedTimeInternal(),\n                    session.getThisAccessedTimeInternal() );\n            final String validityKey = createValidityInfoKeyName( session.getIdInternal() );\n            _memcached.set( validityKey, session.getMaxInactiveInterval(), validityData );\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Stored session validity info for session \" + session.getIdInternal() );\n            }\n\n            /* The following task are performed outside of the request thread (includes waiting for the backup result):\n             * - ping session if the backup was skipped (depends on the backup result)\n             * - save secondary session backup if session was modified (backup not skipped)\n             * - ping secondary session backup if the backup was skipped\n             * - save secondary validity backup\n             */\n            final boolean pingSessionIfBackupWasSkipped = !backupWasForced;\n            final boolean performAsyncTasks = pingSessionIfBackupWasSkipped || _storeSecondaryBackup;\n\n            if ( performAsyncTasks ) {\n                final Callable<?> backupSessionTask = new OnAfterBackupSessionTask( session, result,\n                        pingSessionIfBackupWasSkipped, backupSessionService, _storeSecondaryBackup, validityKey, validityData );\n                _executor.submit( backupSessionTask );\n            }\n\n            _stats.registerSince( NON_STICKY_AFTER_BACKUP, start );\n\n        } catch( final Throwable e ) {\n            _log.warn( \"An error occurred during onAfterBackupSession.\", e );\n        }\n\n    }\n\n    /**\n     * Is used to determine if this thread / the current request already hit the application or if this method\n     * invocation comes from the container.\n     */\n    protected final boolean isContainerSessionLookup() {\n        return _requestsThreadLocal.get() == null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadSessionValidityInfo( @Nonnull final String id ) {\n        final byte[] validityInfo = (byte[]) _memcached.get( createValidityInfoKeyName( id ) );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    @CheckForNull\n    protected SessionValidityInfo loadBackupSessionValidityInfo( @Nonnull final String id ) {\n        final String key = createValidityInfoKeyName( id );\n        final String backupKey = _sessionIdFormat.createBackupKey( key );\n        final byte[] validityInfo = (byte[]) _memcached.get( backupKey );\n        return validityInfo != null ? decode( validityInfo ) : null;\n    }\n\n    /**\n     * Invoked before the session for this sessionId is loaded from memcached.\n     */\n    @CheckForNull\n    protected abstract LockStatus onBeforeLoadFromMemcached( @Nonnull String sessionId ) throws InterruptedException,\n            ExecutionException;\n\n    /**\n     * Invoked after a non-sticky session is loaded from memcached, can be used to update some session fields based on\n     * separately stored information (e.g. session validity info).\n     *\n     * @param lockStatus\n     *            the {@link LockStatus} that was returned from {@link #onBeforeLoadFromMemcached(String)}.\n     */\n    protected void onAfterLoadFromMemcached( @Nonnull final MemcachedBackupSession session,\n            @Nullable final LockStatus lockStatus ) {\n        session.setLockStatus( lockStatus );\n\n        final long start = System.currentTimeMillis();\n        final SessionValidityInfo info = loadSessionValidityInfo( session.getIdInternal() );\n        if ( info != null ) {\n            _stats.registerSince( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start );\n            session.setLastAccessedTimeInternal( info.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( info.getThisAccessedTime() );\n        }\n        else {\n            _log.warn( \"No validity info available for session \" + session.getIdInternal() );\n        }\n    }\n\n    /**\n     * Invoked after a non-sticky session is removed from memcached.\n     */\n    protected void onAfterDeleteFromMemcached( @Nonnull final String sessionId ) {\n        final long start = System.currentTimeMillis();\n\n        _memcached.delete( _sessionIdFormat.createBackupKey( sessionId ) );\n\n        final String validityInfoKey = createValidityInfoKeyName( sessionId );\n        _memcached.delete( validityInfoKey );\n        _memcached.delete( _sessionIdFormat.createBackupKey( validityInfoKey ) );\n\n        _stats.registerSince( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED, start );\n    }\n\n    protected final void onRequestStart( final Request request ) {\n        _requestsThreadLocal.set( request );\n    }\n\n    protected final void onRequestFinished() {\n        _requestsThreadLocal.set( null );\n    }\n\n    private void pingSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<Boolean> touchResult = _memcached.add( session.getIdInternal(), session.getMaxInactiveInterval(), 1 );\n        try {\n            _log.debug( \"Got ping result \" + touchResult.get() );\n            if ( touchResult.get() ) {\n                _stats.nonStickySessionsPingFailed();\n                _log.warn( \"The session \" + session.getIdInternal()\n                        + \" should be touched in memcached, but it seemed to be\"\n                        + \" not existing anymore. Will store in memcached again.\" );\n                updateSession( session, backupSessionService );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private void updateSession( @Nonnull final MemcachedBackupSession session,\n            @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException {\n        final Future<BackupResult> result = backupSessionService.backupSession( session, true );\n        try {\n            if ( result.get().getStatus() != BackupResultStatus.SUCCESS ) {\n                _log.warn( \"Update for session (after unsuccessful ping) did not return SUCCESS, but \" + result.get() );\n            }\n        } catch ( final ExecutionException e ) {\n            _log.warn( \"An exception occurred when trying to update session \" + session.getIdInternal(), e );\n        }\n    }\n\n    private final class OnAfterBackupSessionTask implements Callable<Void> {\n\n        private final MemcachedBackupSession _session;\n        private final Future<BackupResult> _result;\n        private final boolean _pingSessionIfBackupWasSkipped;\n        private final boolean _storeSecondaryBackup;\n        private final BackupSessionService _backupSessionService;\n        private final String _validityKey;\n        private final byte[] _validityData;\n\n        private OnAfterBackupSessionTask( @Nonnull final MemcachedBackupSession session, @Nonnull final Future<BackupResult> result,\n                final boolean pingSessionIfBackupWasSkipped,\n                @Nonnull final BackupSessionService backupSessionService,\n                final boolean storeSecondaryBackup,\n                @Nonnull final String validityKey,\n                @Nonnull final byte[] validityData ) {\n            _session = session;\n            _result = result;\n            _pingSessionIfBackupWasSkipped = pingSessionIfBackupWasSkipped;\n            _storeSecondaryBackup = storeSecondaryBackup;\n            _validityKey = validityKey;\n            _validityData = validityData;\n            _backupSessionService = backupSessionService;\n        }\n\n        @Override\n        public Void call() throws Exception {\n\n            final BackupResult backupResult = _result.get();\n\n            if ( _pingSessionIfBackupWasSkipped ) {\n                if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                    pingSession( _session, _backupSessionService );\n                }\n            }\n\n            /*\n             * For non-sticky sessions we store a backup of the session in a secondary memcached node (under a special key\n             * that's resolved by the SuffixBasedNodeLocator), but only when we have more than 1 memcached node configured...\n             */\n            if ( _storeSecondaryBackup ) {\n                try {\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Storing backup in secondary memcached for non-sticky session \" + _session.getId() );\n                    }\n                    if ( backupResult.getStatus() == BackupResultStatus.SKIPPED ) {\n                        pingSessionBackup( _session );\n                    }\n                    else {\n                        saveSessionBackupFromResult( backupResult );\n                    }\n\n                    saveValidityBackup();\n                } catch( final NodeFailureException e ) {\n                    // handle an unavailable secondary/backup node (fix for issue #83)\n                    _log.info( \"Secondary/backup node \"+ e.getNodeId() +\" not available, skipping additional backup of session \" + _session.getIdInternal() );\n                } catch( final RuntimeException e ) {\n                    _log.info( \"Could not store secondary backup of session \" + _session.getIdInternal(), e );\n                }\n\n            }\n\n            return null;\n        }\n\n        public void saveSessionBackupFromResult( final BackupResult backupResult ) {\n            final byte[] data = backupResult.getData();\n            if ( data != null ) {\n                final String key = _sessionIdFormat.createBackupKey( _session.getId() );\n                _memcached.set( key, _session.getMemcachedExpirationTimeToSet(), data );\n            }\n            else {\n                _log.warn( \"No data set for backupResultStatus \" + backupResult.getStatus() + \" for sessionId \"\n                        + _session.getIdInternal() + \", skipping backup\"\n                        + \" of non-sticky session in secondary memcached.\" );\n            }\n        }\n\n        public void saveValidityBackup() {\n            final String backupValidityKey = _sessionIdFormat.createBackupKey( _validityKey );\n            _memcached.set( backupValidityKey, _session.getMaxInactiveInterval(), _validityData );\n        }\n\n        private void pingSessionBackup( @Nonnull final MemcachedBackupSession session ) throws InterruptedException {\n            final String key = _sessionIdFormat.createBackupKey( session.getId() );\n            final Future<Boolean> touchResultFuture = _memcached.add( key, session.getMaxInactiveInterval(), 1 );\n            try {\n                final boolean touchResult = touchResultFuture.get(200, TimeUnit.MILLISECONDS);\n                _log.debug( \"Got backup ping result \" + touchResult );\n                if ( touchResult ) {\n                    _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                            + \" should be touched in memcached, but it seemed to be\"\n                            + \" not existing. Will store in memcached again.\" );\n                    saveSessionBackup( session, key );\n                }\n            } catch ( final TimeoutException e ) {\n                _log.warn( \"The secondary backup for session \" + session.getIdInternal()\n                        + \" could not be completed within 200 millis, was cancelled now.\" );\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to ping session \" + session.getIdInternal(), e );\n            }\n        }\n\n        public void saveSessionBackup( @Nonnull final MemcachedBackupSession session, @Nonnull final String key )\n                throws InterruptedException {\n            try {\n                final byte[] data = _manager.serialize( session );\n                final Future<Boolean> backupResult = _memcached.set( key, session.getMemcachedExpirationTimeToSet(), data );\n                if ( !backupResult.get().booleanValue() ) {\n                    _log.warn( \"Update for secondary backup of session \"+ session.getIdInternal() +\" (after unsuccessful ping) did not return sucess.\" );\n                }\n            } catch ( final ExecutionException e ) {\n                _log.warn( \"An exception occurred when trying to update secondary session backup for \" + session.getIdInternal(), e );\n            }\n        }\n    }\n\n}\n","lineNo":232}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 50;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n\n    private SessionTrackerValve _sessionTrackerValve;\n\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _sessionTrackerValve = new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled );\n        getContainer().getPipeline().addValve( _sessionTrackerValve );\n\n        initNonStickyLockingMode( config );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    protected static MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, new NodeIdList( nodeIds ), failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final NodeIdList nodeIds, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( nodeIds, address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final NodeIdList nodeIds, final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private static List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private static void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = (MemcachedBackupSession) super.findSession( id );\n        if ( result == null && canHitMemcached( id ) ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        session.tellNew();\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcachedWithCheck( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = new MemcachedBackupSession( this );\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    @Override\n    public void changeSessionId( final Session session ) {\n        // e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation\n        // so that session backup won't be omitted we must store this event\n        super.changeSessionId( session );\n        ((MemcachedBackupSession)session).setSessionIdChanged( true );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcachedWithCheck( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId );\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                    final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                    final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                    if ( newNodeId != null ) {\n                        final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            }\n            else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = _sessionIdFormat.extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _nodeIdService.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId, nodeId );\n                if ( backupSession != null ) {\n                    addValidLoadedSession( backupSession );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId, @Nonnull final String nodeId ) {\n        /* check the node that holds the backup of the session\n         */\n        final String nextNodeId = _nodeIdService.getNextNodeId( nodeId );\n        if ( !_nodeIdService.isNodeAvailable( nextNodeId ) ) {\n            _log.info( \"Node \"+ nodeId +\" that stores the backup of the session \"+ requestedSessionId +\" is not available.\" );\n            return null;\n        }\n\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                _log.info( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( _sessionIdFormat.createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                _log.info( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, getContainer().getRealm(), this );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n\n            _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n            final String newSessionId = _sessionIdFormat.createNewSessionId( requestedSessionId, nextNodeId );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = (MemcachedBackupSession) session;\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= session.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n        if ( !_sticky ) {\n            remove( session, false );\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n        return result;\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId is not in our missingSessionsCache.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _sessionIdFormat.isValid( sessionId ) && _missingSessionsCache.get( sessionId ) == null;\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n\n            LockStatus lockStatus = null;\n            try {\n\n                if ( !_sticky ) {\n                    lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n                }\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        final long startDeserialization = System.currentTimeMillis();\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                        _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                    }\n                    _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                    result.setSticky( _sticky );\n                    if ( !_sticky ) {\n                        _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                    }\n\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    if ( lockStatus == LockStatus.LOCKED ) {\n                        _lockingStrategy.releaseLock( sessionId );\n                    }\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        remove( session, session.getNote( NODE_FAILURE ) != Boolean.TRUE );\n    }\n\n    private void remove( final Session session, final boolean removeFromMemcached ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, removeFromMemcached: \" + removeFromMemcached +\n                    \", id: \" + session.getId() );\n        }\n        if ( removeFromMemcached ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                Integer.valueOf( oldMaxActiveSessions ),\n                Integer.valueOf( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( config );\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        _enableStatistics = enableStatistics;\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        if ( _enabled.compareAndSet( !enabled, enabled ) ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( initialized ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( initialized ) {\n            initNonStickyLockingMode( createMemcachedConfig( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n    private void initNonStickyLockingMode( @Nonnull final MemcachedConfig config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1;\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nonnull final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _missingSessionsCache, storeSecondaryBackup, _statistics );\n        if ( _sessionTrackerValve != null ) {\n            _sessionTrackerValve.setLockingStrategy( _lockingStrategy );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n\n            if ( _sticky ) {\n                _log.info( \"Removing sessions from local session map.\" );\n                for( final Session session : sessions.values() ) {\n                    swapOut( (StandardSession) session );\n                }\n            }\n\n            _log.info( \"Stopping services.\" );\n            _backupSessionService.shutdown();\n            if ( _lockingStrategy != null ) {\n                _lockingStrategy.shutdown();\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n\n            destroy();\n        }\n    }\n\n    private void swapOut( @Nonnull final StandardSession session ) {\n        // implementation like the one in PersistentManagerBase.swapOut\n        if (!session.isValid()) {\n            return;\n        }\n        session.passivate();\n        remove( session, false );\n        session.recycle();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( initialized && oldSessionBackupAsync != sessionBackupAsync ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _nodeIdService, _statistics );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    public long getMsmStatNumNonStickySessionsPingFailed() {\n        return _statistics.getNonStickySessionsPingFailed();\n    }\n    public long getMsmStatNumNonStickySessionsReadOnlyRequest() {\n        return _statistics.getNonStickySessionsReadOnlyRequest();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getProbe( ATTRIBUTES_SERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getProbe( EFFECTIVE_BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getProbe( BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatSessionDeserializationInfo()\n     * @see #getMsmStatNonStickyAfterLoadFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getProbe( LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deleting sessions from memcached took.\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatNonStickyAfterDeleteFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsDeletedFromMemcachedInfo() {\n        return _statistics.getProbe( DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deserialization of session data took.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionDeserializationInfo() {\n        return _statistics.getProbe( SESSION_DESERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getProbe( CACHED_DATA_SIZE ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getProbe( MEMCACHED_UPDATE ).getInfo();\n    }\n\n    /**\n     * Info about locks acquired in non-sticky mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK ).getInfo();\n    }\n\n    /**\n     * Lock acquiration in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockFailureInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK_FAILURE ).getInfo();\n    }\n\n    /**\n     * Lock release in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyReleaseLockInfo() {\n        return _statistics.getProbe( RELEASE_LOCK ).getInfo();\n    }\n\n    /**\n     * Store metadata / validity info in memcached.\n     */\n    public String[] getMsmStatNonStickyStoreMetaDataInfo() {\n        return _statistics.getProbe( NON_STICKY_STORE_METADATA ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after session backup (ping session, store validity info / meta data,\n     * store additional backup in secondary memcached).\n     */\n    public String[] getMsmStatNonStickyAfterBackupInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_BACKUP ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was loaded from memcached (load validity info / meta data).\n     */\n    public String[] getMsmStatNonStickyAfterLoadFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was deleted from memcached (delete validity info and backup data).\n     */\n    public String[] getMsmStatNonStickyAfterDeleteFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final NodeIdList _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final NodeIdList nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public NodeIdList getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\n\nimport static de.javakaffee.web.msm.Statistics.StatsType.*;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 50;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    /**\n     * Has this component been _started yet?\n     */\n    protected boolean _started = false;\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = true;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n\n    private SessionTrackerValve _sessionTrackerValve;\n\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        super.init();\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void startInternal( final MemcachedClient memcachedClient ) throws LifecycleException {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _sessionTrackerValve = new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled );\n        getContainer().getPipeline().addValve( _sessionTrackerValve );\n\n        initNonStickyLockingMode( config );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    protected static MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, new NodeIdList( nodeIds ), failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final NodeIdList nodeIds, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( nodeIds, address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final NodeIdList nodeIds, final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private static List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private static void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = (MemcachedBackupSession) super.findSession( id );\n        if ( result == null && canHitMemcached( id ) ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        session.tellNew();\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcachedWithCheck( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = new MemcachedBackupSession( this );\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    @Override\n    public void changeSessionId( final Session session ) {\n        // e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation\n        // so that session backup won't be omitted we must store this event\n        super.changeSessionId( session );\n        ((MemcachedBackupSession)session).setSessionIdChanged( true );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcachedWithCheck( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                _memcached.delete( sessionId );\n                _statistics.registerSince( DELETE_FROM_MEMCACHED, start );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                    final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                    final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                    if ( newNodeId != null ) {\n                        final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            }\n            else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = _sessionIdFormat.extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _nodeIdService.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId, nodeId );\n                if ( backupSession != null ) {\n                    addValidLoadedSession( backupSession );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId, @Nonnull final String nodeId ) {\n        /* check the node that holds the backup of the session\n         */\n        final String nextNodeId = _nodeIdService.getNextNodeId( nodeId );\n        if ( !_nodeIdService.isNodeAvailable( nextNodeId ) ) {\n            _log.info( \"Node \"+ nodeId +\" that stores the backup of the session \"+ requestedSessionId +\" is not available.\" );\n            return null;\n        }\n\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                _log.info( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( _sessionIdFormat.createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                _log.info( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, getContainer().getRealm(), this );\n            session.setSticky( _sticky );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n\n            _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n            final String newSessionId = _sessionIdFormat.createNewSessionId( requestedSessionId, nextNodeId );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = (MemcachedBackupSession) session;\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= session.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n        if ( !_sticky ) {\n            remove( session, false );\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n        return result;\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId is not in our missingSessionsCache.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _sessionIdFormat.isValid( sessionId ) && _missingSessionsCache.get( sessionId ) == null;\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n\n            LockStatus lockStatus = null;\n            try {\n\n                if ( !_sticky ) {\n                    lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n                }\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        final long startDeserialization = System.currentTimeMillis();\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                        _statistics.registerSince( SESSION_DESERIALIZATION, startDeserialization );\n                    }\n                    _statistics.registerSince( LOAD_FROM_MEMCACHED, start );\n\n                    result.setSticky( _sticky );\n                    if ( !_sticky ) {\n                        _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                    }\n\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    if ( lockStatus == LockStatus.LOCKED ) {\n                        _lockingStrategy.releaseLock( sessionId );\n                    }\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        remove( session, session.getNote( NODE_FAILURE ) != Boolean.TRUE );\n    }\n\n    private void remove( final Session session, final boolean removeFromMemcached ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, removeFromMemcached: \" + removeFromMemcached +\n                    \", id: \" + session.getId() );\n        }\n        if ( removeFromMemcached ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                Integer.valueOf( oldMaxActiveSessions ),\n                Integer.valueOf( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode( config );\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        final boolean oldEnableStatistics = _enableStatistics;\n        _enableStatistics = enableStatistics;\n        if ( oldEnableStatistics != enableStatistics && initialized ) {\n            _log.info( \"Changed enableStatistics from \" + oldEnableStatistics + \" to \" + enableStatistics + \".\" +\n            \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n        }\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        final boolean changed = _enabled.compareAndSet( !enabled, enabled );\n        if ( changed && initialized ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( initialized ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( initialized ) {\n            initNonStickyLockingMode( createMemcachedConfig( _memcachedNodes, _failoverNodes ) );\n        }\n    }\n\n    private void initNonStickyLockingMode( @Nonnull final MemcachedConfig config ) {\n        if ( _sticky ) {\n            setLockingMode( null, null, false );\n            return;\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        final boolean storeSecondaryBackup = config.getCountNodes() > 1;\n        setLockingMode( lockingMode, uriPattern, storeSecondaryBackup );\n    }\n\n    public void setLockingMode( @Nonnull final LockingMode lockingMode, @Nullable final Pattern uriPattern, final boolean storeSecondaryBackup ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _missingSessionsCache, storeSecondaryBackup, _statistics );\n        if ( _sessionTrackerValve != null ) {\n            _sessionTrackerValve.setLockingStrategy( _lockingStrategy );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n\n        if( ! initialized ) {\n            init();\n        }\n\n        // Validate and update our current component state\n        if (_started) {\n            return;\n        }\n        _lifecycle.fireLifecycleEvent(START_EVENT, null);\n        _started = true;\n\n        // Force initialization of the random number generator\n        if (log.isDebugEnabled()) {\n            log.debug(\"Force random number initialization starting\");\n        }\n        super.generateSessionId();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Force random number initialization completed\");\n        }\n\n        startInternal( null );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping\");\n        }\n\n        // Validate and update our current component state\n        if (!_started) {\n            throw new LifecycleException\n                (sm.getString(\"standardManager.notStarted\"));\n        }\n        _lifecycle.fireLifecycleEvent(STOP_EVENT, null);\n        _started = false;\n\n        // Require a new random number generator if we are restarted\n        random = null;\n\n        if ( initialized ) {\n\n            if ( _sticky ) {\n                _log.info( \"Removing sessions from local session map.\" );\n                for( final Session session : sessions.values() ) {\n                    swapOut( (StandardSession) session );\n                }\n            }\n\n            _log.info( \"Stopping services.\" );\n            _backupSessionService.shutdown();\n            if ( _lockingStrategy != null ) {\n                _lockingStrategy.shutdown();\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n\n            destroy();\n        }\n    }\n\n    private void swapOut( @Nonnull final StandardSession session ) {\n        // implementation like the one in PersistentManagerBase.swapOut\n        if (!session.isValid()) {\n            return;\n        }\n        session.passivate();\n        remove( session, false );\n        session.recycle();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( ( oldSessionBackupAsync != sessionBackupAsync ) && initialized ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _nodeIdService, _statistics );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    public long getMsmStatNumNonStickySessionsPingFailed() {\n        return _statistics.getNonStickySessionsPingFailed();\n    }\n    public long getMsmStatNumNonStickySessionsReadOnlyRequest() {\n        return _statistics.getNonStickySessionsReadOnlyRequest();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getProbe( ATTRIBUTES_SERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getProbe( EFFECTIVE_BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getProbe( BACKUP ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatSessionDeserializationInfo()\n     * @see #getMsmStatNonStickyAfterLoadFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getProbe( LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deleting sessions from memcached took.\n     * @return a String array for statistics inspection via jmx.\n     * @see #getMsmStatNonStickyAfterDeleteFromMemcachedInfo()\n     */\n    public String[] getMsmStatSessionsDeletedFromMemcachedInfo() {\n        return _statistics.getProbe( DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that deserialization of session data took.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionDeserializationInfo() {\n        return _statistics.getProbe( SESSION_DESERIALIZATION ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getProbe( CACHED_DATA_SIZE ).getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getProbe( MEMCACHED_UPDATE ).getInfo();\n    }\n\n    /**\n     * Info about locks acquired in non-sticky mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK ).getInfo();\n    }\n\n    /**\n     * Lock acquiration in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyAcquireLockFailureInfo() {\n        return _statistics.getProbe( ACQUIRE_LOCK_FAILURE ).getInfo();\n    }\n\n    /**\n     * Lock release in non-sticky session mode.\n     */\n    public String[] getMsmStatNonStickyReleaseLockInfo() {\n        return _statistics.getProbe( RELEASE_LOCK ).getInfo();\n    }\n\n    /**\n     * Store metadata / validity info in memcached.\n     */\n    public String[] getMsmStatNonStickyStoreMetaDataInfo() {\n        return _statistics.getProbe( NON_STICKY_STORE_METADATA ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after session backup (ping session, store validity info / meta data,\n     * store additional backup in secondary memcached).\n     */\n    public String[] getMsmStatNonStickyAfterBackupInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_BACKUP ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was loaded from memcached (load validity info / meta data).\n     */\n    public String[] getMsmStatNonStickyAfterLoadFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED ).getInfo();\n    }\n\n    /**\n     * Tasks executed for non-sticky sessions after a session was deleted from memcached (delete validity info and backup data).\n     */\n    public String[] getMsmStatNonStickyAfterDeleteFromMemcachedInfo() {\n        return _statistics.getProbe( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED ).getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final NodeIdList _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final NodeIdList nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public NodeIdList getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","lineNo":1228}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 1000;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled ) );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    private MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, nodeIds, failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        StandardSession result = (StandardSession) super.findSession( id );\n        if ( result == null ) {\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        session.tellNew();\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    @Override\n    public void changeSessionId( final Session session ) {\n        // e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation\n        // so that session backup won't be omitted we must store this event\n        super.changeSessionId( session );\n        ((MemcachedBackupSession)session).setSessionIdChanged( true );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcached( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                _memcached.delete( sessionId );\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        /* We can just lookup the session in the local session map, as we wouldn't get\n         * the session from memcached if the node was not available - or, the other way round,\n         * if we would get the session from memcached, the session would not have to be relocated.\n         */\n        try {\n            final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n            if ( session != null && session.isValid() ) {\n                final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                if ( newNodeId != null ) {\n                    final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                    _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                    session.setIdForRelocate( newSessionId );\n                    _statistics.requestWithMemcachedFailover();\n                    return newSessionId;\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResultStatus> backupSession( final Session session, final boolean sessionIdChanged ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResultStatus>( BackupResultStatus.SKIPPED );\n        }\n        final MemcachedBackupSession msmSession = (MemcachedBackupSession) session;\n        return _backupSessionService.backupSession( msmSession, sessionIdChanged || msmSession.isSessionIdChanged() );\n    }\n\n    protected MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( !_enabled.get() || !_sessionIdFormat.isValid( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n            try {\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n\n                if ( _log.isDebugEnabled() ) {\n                    if ( object == null ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                    }\n                    _statistics.getLoadFromMemcachedProbe().registerSince( start );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE ) +\n                    \", node failure: \" + session.getNote( NODE_FAILURE ) +\n                    \", id: \" + session.getId() );\n        }\n        if ( session.getNote( NODE_FAILURE ) != Boolean.TRUE ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                new Integer( oldMaxActiveSessions ),\n                new Integer( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        _enableStatistics = enableStatistics;\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     */\n    public void setEnabled( final boolean enabled ) {\n        if ( _enabled.compareAndSet( !enabled, enabled ) ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            try {\n                _backupSessionService.shutdown();\n            } catch ( final InterruptedException e ) {\n                _log.info( \"Got interrupted during backupSessionService shutdown,\" +\n                        \" continuing to shutdown memcached client and to destroy myself...\", e );\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( initialized && oldSessionBackupAsync != sessionBackupAsync ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackup()\n     */\n    public long getMsmStatNumBackups() {\n        return _statistics.getRequestsWithBackup();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getSessionsLoadedFromMemcached()\n     */\n    public long getMsmStatNumSessionsLoadedFromMemcached() {\n        return _statistics.getSessionsLoadedFromMemcached();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getAttributesSerializationProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getEffectiveBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getLoadFromMemcachedProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getCachedDataSizeProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getMemcachedUpdateProbe().getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final List<String> _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final List<String> nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public List<String> getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.LockingStrategy.LockingMode;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 50;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    private boolean _sticky = false;\n    private String _lockingMode;\n    private LockingStrategy _lockingStrategy;\n\n    private SessionTrackerValve _sessionTrackerValve;\n\n\n    static enum LockStatus {\n        /**\n         * For sticky sessions or readonly requests with non-sticky sessions there's no lock required.\n         */\n        LOCK_NOT_REQUIRED,\n        LOCKED,\n        COULD_NOT_AQUIRE_LOCK\n    }\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _sessionTrackerValve = new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled );\n        getContainer().getPipeline().addValve( _sessionTrackerValve );\n\n        initNonStickyLockingMode();\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics, _sticky );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    private MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, new NodeIdList( nodeIds ), failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final NodeIdList nodeIds, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( nodeIds, address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final NodeIdList nodeIds, final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( nodeIds, resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        MemcachedBackupSession result = (MemcachedBackupSession) super.findSession( id );\n        if ( result == null && canHitMemcached( id ) ) {\n            // when the request comes from the container, it's from CoyoteAdapter.postParseRequest\n            if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) {\n                // we can return just null as the requestedSessionId will still be set on\n                // the request.\n                return null;\n            }\n\n            // else load the session from memcached\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        session.tellNew();\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcachedWithCheck( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        final MemcachedBackupSession result = new MemcachedBackupSession( this );\n        result.setSticky( _sticky );\n        return result;\n    }\n\n    @Override\n    public void changeSessionId( final Session session ) {\n        // e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation\n        // so that session backup won't be omitted we must store this event\n        super.changeSessionId( session );\n        ((MemcachedBackupSession)session).setSessionIdChanged( true );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        if ( !_sticky ) {\n            return null;\n        }\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcachedWithCheck( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                _memcached.delete( sessionId );\n                if ( !_sticky ) {\n                    _lockingStrategy.onAfterDeleteFromMemcached( sessionId );\n                }\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        try {\n            if ( _sticky ) {\n                /* We can just lookup the session in the local session map, as we wouldn't get\n                 * the session from memcached if the node was not available - or, the other way round,\n                 * if we would get the session from memcached, the session would not have to be relocated.\n                 */\n                final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n                if ( session != null && session.isValid() ) {\n                    final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                    final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                    if ( newNodeId != null ) {\n                        final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                        _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                        session.setIdForRelocate( newSessionId );\n                        _statistics.requestWithMemcachedFailover();\n                        return newSessionId;\n                    }\n                }\n            }\n            else {\n\n                /* for non-sticky sessions we check the validity info\n                 */\n                final String nodeId = _sessionIdFormat.extractMemcachedId( requestedSessionId );\n                if ( nodeId == null || _nodeIdService.isNodeAvailable( nodeId ) ) {\n                    return null;\n                }\n\n                final MemcachedBackupSession backupSession = loadBackupSession( requestedSessionId, nodeId );\n                if ( backupSession != null ) {\n                    addValidLoadedSession( backupSession );\n                    _statistics.requestWithMemcachedFailover();\n                    return backupSession.getId();\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    @CheckForNull\n    private MemcachedBackupSession loadBackupSession( @Nonnull final String requestedSessionId, @Nonnull final String nodeId ) {\n        /* check the node that holds the backup of the session\n         */\n        final String nextNodeId = _nodeIdService.getNextNodeId( nodeId );\n        if ( !_nodeIdService.isNodeAvailable( nextNodeId ) ) {\n            _log.info( \"Node \"+ nodeId +\" that stores the backup of the session \"+ requestedSessionId +\" is not available.\" );\n            return null;\n        }\n\n        try {\n            final SessionValidityInfo validityInfo = _lockingStrategy.loadBackupSessionValidityInfo( requestedSessionId );\n            if ( validityInfo == null || !validityInfo.isValid() ) {\n                _log.info( \"No validity info (or no valid one) found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final Object obj = _memcached.get( _sessionIdFormat.createBackupKey( requestedSessionId ) );\n            if ( obj == null ) {\n                _log.info( \"No backup found for sessionId \" + requestedSessionId );\n                return null;\n            }\n\n            final MemcachedBackupSession session = _transcoderService.deserialize( (byte[]) obj, getContainer().getRealm(), this );\n            session.setLastAccessedTimeInternal( validityInfo.getLastAccessedTime() );\n            session.setThisAccessedTimeInternal( validityInfo.getThisAccessedTime() );\n\n            _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n            final String newSessionId = _sessionIdFormat.createNewSessionId( requestedSessionId, nextNodeId );\n            session.setIdInternal( newSessionId );\n            return session;\n\n        } catch( final Exception e ) {\n            _log.error( \"Could not get backup validityInfo or backup session for sessionId \" + requestedSessionId, e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @param requestId\n     *            the uri/id of the request for that the session backup shall be performed, used for readonly tracking.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestId ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResult>( BackupResult.SKIPPED );\n        }\n\n        final MemcachedBackupSession msmSession = (MemcachedBackupSession) session;\n\n        final boolean force = sessionIdChanged || msmSession.isSessionIdChanged() || !_sticky && (msmSession.getSecondsSinceLastBackup() >= session.getMaxInactiveInterval());\n        final Future<BackupResult> result = _backupSessionService.backupSession( msmSession, force );\n        if ( !_sticky ) {\n            remove( session, false );\n            _lockingStrategy.onAfterBackupSession( msmSession, force, result, requestId, _backupSessionService );\n        }\n        return result;\n    }\n\n    protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) {\n        if ( !canHitMemcached( sessionId ) ) {\n            return null;\n        }\n        return loadFromMemcached( sessionId );\n    }\n\n    /**\n     * Checks if this manager {@link #isEnabled()}, if the given sessionId is valid (contains a memcached id)\n     * and if this sessionId is not in our missingSessionsCache.\n     */\n    private boolean canHitMemcached( @Nonnull final String sessionId ) {\n        return _enabled.get() && _sessionIdFormat.isValid( sessionId ) && _missingSessionsCache.get( sessionId ) == null;\n    }\n\n    /**\n     * Assumes that before you checked {@link #canHitMemcached(String)}.\n     */\n    private MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n\n            LockStatus lockStatus = null;\n            try {\n\n                if ( !_sticky ) {\n                    lockStatus = _lockingStrategy.onBeforeLoadFromMemcached( sessionId );\n                }\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                    }\n                    if ( !_sticky ) {\n                        _lockingStrategy.onAfterLoadFromMemcached( result, lockStatus );\n                    }\n\n                    _statistics.getLoadFromMemcachedProbe().registerSince( start );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    if ( lockStatus == LockStatus.LOCKED ) {\n                        _lockingStrategy.releaseLock( sessionId );\n                    }\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n                if ( lockStatus == LockStatus.LOCKED ) {\n                    _lockingStrategy.releaseLock( sessionId );\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        remove( session, session.getNote( NODE_FAILURE ) != Boolean.TRUE );\n    }\n\n    private void remove( final Session session, final boolean removeFromMemcached ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, removeFromMemcached: \" + removeFromMemcached +\n                    \", id: \" + session.getId() );\n        }\n        if ( removeFromMemcached ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                Integer.valueOf( oldMaxActiveSessions ),\n                Integer.valueOf( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getNodeIds(), config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics, _sticky );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        initNonStickyLockingMode();\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        _enableStatistics = enableStatistics;\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     * @throws IllegalStateException it's not allowed to disable this session manager when running in non-sticky mode.\n     */\n    public void setEnabled( final boolean enabled ) throws IllegalStateException {\n        if ( !enabled && !_sticky ) {\n            throw new IllegalStateException( \"Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before.\" );\n        }\n        if ( _enabled.compareAndSet( !enabled, enabled ) ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    public void setSticky( final boolean sticky ) {\n        if ( sticky == _sticky ) {\n            return;\n        }\n        if ( !sticky && getJvmRoute() != null ) {\n            _log.warn( \"Setting sticky to false while there's still a jvmRoute configured (\" + getJvmRoute() + \"), this might cause trouble.\" +\n            \t\t\" You should remve the jvmRoute configuration for non-sticky mode.\" );\n        }\n        _sticky = sticky;\n        if ( initialized ) {\n            _log.info( \"Changed sticky to \" + _sticky + \". Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    protected void setStickyInternal( final boolean sticky ) {\n        _sticky = sticky;\n    }\n\n    public boolean isSticky() {\n        return _sticky;\n    }\n\n    /**\n     * Sets the session locking mode. Possible values:\n     * <ul>\n     * <li><code>none<\/code> - does not lock the session at all (default for non-sticky sessions).<\/li>\n     * <li><code>all<\/code> - the session is locked for each request accessing the session.<\/li>\n     * <li><code>auto<\/code> - locks the session for each request except for those the were detected to access the session only readonly.<\/li>\n     * <li><code>uriPattern:&lt;regexp&gt;<\/code> - locks the session for each request with a request uri (with appended querystring) matching\n     * the provided regular expression.<\/li>\n     * <\/ul>\n     */\n    public void setLockingMode( final String lockingMode ) {\n        if ( lockingMode == null && _lockingMode == null\n                || lockingMode.equals( _lockingMode ) ) {\n            return;\n        }\n        _lockingMode = lockingMode;\n        if ( initialized ) {\n            initNonStickyLockingMode();\n        }\n    }\n\n    private void initNonStickyLockingMode() {\n        if ( _sticky ) {\n            setLockingMode( null, null );\n            return;\n        }\n\n        Pattern uriPattern = null;\n        LockingMode lockingMode = null;\n        if ( _lockingMode != null ) {\n            if ( _lockingMode.startsWith( \"uriPattern:\" ) ) {\n                lockingMode = LockingMode.URI_PATTERN;\n                uriPattern = Pattern.compile( _lockingMode.substring( \"uriPattern:\".length() ) );\n            }\n            else {\n                lockingMode = LockingMode.valueOf( _lockingMode.toUpperCase() );\n            }\n        }\n        if ( lockingMode == null ) {\n            lockingMode = LockingMode.NONE;\n        }\n        setLockingMode( lockingMode, uriPattern );\n    }\n\n    public void setLockingMode( @Nonnull final LockingMode lockingMode, @Nullable final Pattern uriPattern ) {\n        _log.info( \"Setting lockingMode to \" + lockingMode + ( uriPattern != null ? \" with pattern \" + uriPattern.pattern() : \"\" ) );\n        _lockingStrategy = LockingStrategy.create( lockingMode, uriPattern, _memcached, this, _missingSessionsCache );\n        if ( _sessionTrackerValve != null ) {\n            _sessionTrackerValve.setLockingStrategy( _lockingStrategy );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            try {\n                _backupSessionService.shutdown();\n            } catch ( final InterruptedException e ) {\n                _log.info( \"Got interrupted during backupSessionService shutdown,\" +\n                        \" continuing to shutdown memcached client and to destroy myself...\", e );\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() && _sticky ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( initialized && oldSessionBackupAsync != sessionBackupAsync ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _backupThreadCount, _memcached, _nodeIdService, _statistics, _sticky );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                _backupThreadCount, _memcached, _nodeIdService, _statistics, _sticky );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    /**\n     * The memcached client.\n     */\n    MemcachedClient getMemcached() {\n        return _memcached;\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackup()\n     */\n    public long getMsmStatNumBackups() {\n        return _statistics.getRequestsWithBackup();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getSessionsLoadedFromMemcached()\n     */\n    public long getMsmStatNumSessionsLoadedFromMemcached() {\n        return _statistics.getSessionsLoadedFromMemcached();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getAttributesSerializationProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getEffectiveBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getLoadFromMemcachedProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getCachedDataSizeProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getMemcachedUpdateProbe().getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final NodeIdList _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final NodeIdList nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public NodeIdList getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","lineNo":800}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.assertDeepEquals;\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.createDaemon;\nimport static de.javakaffee.web.msm.integration.TestUtils.getManager;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertNull;\nimport static org.testng.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private String _memcachedNodeId;\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        try {\n            _memcachedNodeId = \"n1\";\n            final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final InetSocketAddress address ) throws IOException, InterruptedException {\n        final MemcachedClient result = new MemcachedClient( new SuffixLocatorConnectionFactory( NodeIdResolver.node(\n                _memcachedNodeId, address ).build(), new SessionIdFormat(), Statistics.create() ),\n                Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testInvalidSessionId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionAvailableInMemcached() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true )\n    public void testExpiredSessionRemovedFromMemcached() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration();\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true )\n    public void testInvalidSessionNotFound() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that relocated sessions are no longer available under the\n     * old/former session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testRelocateSession() throws IOException, InterruptedException, HttpException {\n        // FIXME implementation does not match docs\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple() throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        makeRequest( _httpClient, _portTomcat1, sessionId1 );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session expired in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 1000 ); // +1000 just to be sure that we're >4 secs\n        assertNull( _memcached.get( sessionId1 ), \"Session not expired in memcached.\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedBackupSessionManager#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests() throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        makeRequest( _httpClient, _portTomcat1, sessionId1 );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        makeRequest( _httpClient, _portTomcat1, sessionId1 );\n\n        /* after another nearly 4 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 4 ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session expired in memcached.\" );\n\n        /* after another second (more than 4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNull( _memcached.get( sessionId1 ), \"Session not expired in memcached.\" );\n\n    }\n\n    /**\n     * Test that a session that has been serialized with the old serialization\n     * format (the complete session was serialized by one serialization strategy)\n     * can be loaded from memcached.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test( enabled = true )\n    public void testLoadFromMemcachedOldSessionSerializationFormat() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        final Session session = manager.createSession( null );\n        final SessionTranscoder oldSessionTranscoder = manager.getTranscoderFactory().createSessionTranscoder( manager );\n        final Future<Boolean> future = _memcached.set( session.getId(), session.getMaxInactiveInterval(), session, oldSessionTranscoder );\n        assertTrue( future.get() );\n        final Session loadedFromMemcached = manager.loadFromMemcached( session.getId() );\n        assertNotNull( loadedFromMemcached );\n        assertDeepEquals( session, loadedFromMemcached );\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 2500 );\n\n        final String newSessionId = manager.changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        // disable msm, shutdown our server and our client\n        getManager( _tomcat1 ).setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        getManager( _tomcat1 ).setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        getManager( _tomcat1 ).setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration();\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration();\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration() throws InterruptedException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis( container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval() ) + 100;\n        Thread.sleep( timeout );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private String _memcachedNodeId;\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        try {\n            _memcachedNodeId = \"n1\";\n            final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final InetSocketAddress address ) throws IOException, InterruptedException {\n        final MemcachedClient result = new MemcachedClient( new SuffixLocatorConnectionFactory( NodeIdList.create( _memcachedNodeId ),  NodeIdResolver.node(\n                _memcachedNodeId, address ).build(), new SessionIdFormat(), Statistics.create() ),\n                Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedBackupSessionManager#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test that a session that has been serialized with the old serialization\n     * format (the complete session was serialized by one serialization strategy)\n     * can be loaded from memcached.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test( enabled = true )\n    public void testLoadFromMemcachedOldSessionSerializationFormat() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        final Session session = manager.createSession( null );\n        final SessionTranscoder oldSessionTranscoder = manager.getTranscoderFactory().createSessionTranscoder( manager );\n        final Future<Boolean> future = _memcached.set( session.getId(), session.getMaxInactiveInterval(), session, oldSessionTranscoder );\n        assertTrue( future.get() );\n        final Session loadedFromMemcached = manager.loadFromMemcachedWithCheck( session.getId() );\n        assertNotNull( loadedFromMemcached );\n        assertDeepEquals( session, loadedFromMemcached );\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","lineNo":350}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.assertDeepEquals;\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.createDaemon;\nimport static de.javakaffee.web.msm.integration.TestUtils.getManager;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertNull;\nimport static org.testng.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private String _memcachedNodeId;\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        try {\n            _memcachedNodeId = \"n1\";\n            final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final InetSocketAddress address ) throws IOException, InterruptedException {\n        final MemcachedClient result = new MemcachedClient( new SuffixLocatorConnectionFactory( NodeIdResolver.node(\n                _memcachedNodeId, address ).build(), new SessionIdFormat(), Statistics.create() ),\n                Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testInvalidSessionId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionAvailableInMemcached() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true )\n    public void testExpiredSessionRemovedFromMemcached() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration();\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true )\n    public void testInvalidSessionNotFound() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that relocated sessions are no longer available under the\n     * old/former session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true )\n    public void testRelocateSession() throws IOException, InterruptedException, HttpException {\n        // FIXME implementation does not match docs\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple() throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        makeRequest( _httpClient, _portTomcat1, sessionId1 );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session expired in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 1000 ); // +1000 just to be sure that we're >4 secs\n        assertNull( _memcached.get( sessionId1 ), \"Session not expired in memcached.\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedBackupSessionManager#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests() throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        makeRequest( _httpClient, _portTomcat1, sessionId1 );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        makeRequest( _httpClient, _portTomcat1, sessionId1 );\n\n        /* after another nearly 4 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 4 ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session expired in memcached.\" );\n\n        /* after another second (more than 4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNull( _memcached.get( sessionId1 ), \"Session not expired in memcached.\" );\n\n    }\n\n    /**\n     * Test that a session that has been serialized with the old serialization\n     * format (the complete session was serialized by one serialization strategy)\n     * can be loaded from memcached.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test( enabled = true )\n    public void testLoadFromMemcachedOldSessionSerializationFormat() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        final Session session = manager.createSession( null );\n        final SessionTranscoder oldSessionTranscoder = manager.getTranscoderFactory().createSessionTranscoder( manager );\n        final Future<Boolean> future = _memcached.set( session.getId(), session.getMaxInactiveInterval(), session, oldSessionTranscoder );\n        assertTrue( future.get() );\n        final Session loadedFromMemcached = manager.loadFromMemcached( session.getId() );\n        assertNotNull( loadedFromMemcached );\n        assertDeepEquals( session, loadedFromMemcached );\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 2500 );\n\n        final String newSessionId = manager.changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        // disable msm, shutdown our server and our client\n        getManager( _tomcat1 ).setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        getManager( _tomcat1 ).setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        getManager( _tomcat1 ).setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration();\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration();\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration() throws InterruptedException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis( container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval() ) + 100;\n        Thread.sleep( timeout );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.*;\nimport static org.testng.Assert.*;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.Nonnull;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.http.HttpException;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.integration.TestUtils;\nimport de.javakaffee.web.msm.integration.TestUtils.SessionAffinityMode;\n\n/**\n * Integration test testing basic session manager functionality.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedSessionManagerIntegrationTest {\n\n    private static final Log LOG = LogFactory.getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private MemCacheDaemon<?> _daemon;\n    private MemcachedClient _memcached;\n\n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private String _memcachedNodeId;\n\n    private DefaultHttpClient _httpClient;\n\n    private int _memcachedPort;\n\n    @BeforeMethod\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 18888;\n\n        _memcachedPort = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", _memcachedPort );\n        _daemon = createDaemon( address );\n        _daemon.start();\n\n        try {\n            _memcachedNodeId = \"n1\";\n            final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n            getManager( _tomcat1 ).setSticky( true );\n            _tomcat1.start();\n        } catch ( final Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n\n        _memcached = createMemcachedClient( address );\n\n        _httpClient = new DefaultHttpClient();\n    }\n\n    private MemcachedClient createMemcachedClient( final InetSocketAddress address ) throws IOException, InterruptedException {\n        final MemcachedClient result = new MemcachedClient( new SuffixLocatorConnectionFactory( NodeIdList.create( _memcachedNodeId ),  NodeIdResolver.node(\n                _memcachedNodeId, address ).build(), new SessionIdFormat(), Statistics.create() ),\n                Arrays.asList( address ) );\n\n        // Wait a little bit, so that the memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        return result;\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _memcached.shutdown();\n        _tomcat1.stop();\n        _httpClient.getConnectionManager().shutdown();\n        _daemon.stop();\n    }\n\n    @Test( enabled = true )\n    public void testConfiguredMemcachedNodeId() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        /*\n         * test that we have the configured memcachedNodeId in the sessionId,\n         * the session id looks like \"<sid>-<memcachedId>[.<jvmRoute>]\"\n         */\n        final String nodeId = sessionId1.substring( sessionId1.indexOf( '-' ) + 1, sessionId1.indexOf( '.' ) );\n        assertEquals( _memcachedNodeId, nodeId, \"Invalid memcached node id\" );\n    }\n\n    @Test( enabled = true )\n    public void testSessionIdJvmRouteCompatibility() throws IOException, InterruptedException, HttpException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.matches( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" ),\n                \"Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>].\" );\n    }\n\n    /**\n     * Tests, that session ids with an invalid format (not containing the\n     * memcached id) do not cause issues. Instead, we want to retrieve a new\n     * session id.\n     *\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws HttpException\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionId( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, \"12345\" );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertTrue( sessionId1.indexOf( '-' ) > -1, \"Invalid session id format\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testSessionAvailableInMemcached( final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpiredSessionRemovedFromMemcached( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        waitForSessionExpiration( sessionAffinity.isSticky() );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n    }\n\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testInvalidSessionNotFound( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException, InterruptedException, HttpException {\n\n        getManager( _tomcat1 ).setSticky( sessionAffinity.isSticky() );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n\n        /*\n         * wait some time, as processExpires runs every second and the\n         * maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId1, sessionId2, \"Expired session returned.\" );\n    }\n\n    /**\n     * Tests, that for a session that was not sent to memcached (because it's attributes\n     * were not modified), the expiration is updated so that they don't expire in memcached\n     * before they expire in tomcat.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple( final SessionAffinityMode stickyness ) throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 2 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 2 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n\n        /* after another 3 seconds check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another >1 second (4 seconds since the last request)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); // +1000 just to be sure that we're >4 secs\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Tests update of session expiration in memcached (like {@link #testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple()})\n     * but for the scenario where many readonly requests occur: in this case, we cannot just use\n     * <em>maxInactiveInterval - secondsSinceLastBackup<\/em> (in {@link MemcachedBackupSessionManager#updateExpirationInMemcached})\n     * to determine if an expiration update is required, but we must use the last expiration time sent to memcached.\n     *\n     * @throws Exception if something goes wrong with the http communication with tomcat\n     */\n    @Test( enabled = true, dataProviderClass = TestUtils.class, dataProvider = STICKYNESS_PROVIDER )\n    public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests( final SessionAffinityMode stickyness ) throws Exception {\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( stickyness.isSticky() );\n\n        // set to 1 sec above (in setup), default is 10 seconds\n        final int delay = manager.getContainer().getBackgroundProcessorDelay();\n        manager.setMaxInactiveInterval( delay * 4 );\n\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        /* after 3 seconds make another request without changing the session, so that\n         * it's not sent to memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another 3 seconds make another request without changing the session\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay * 3 ) );\n        assertEquals( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, \"SessionId should be the same\" );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another nearly 4 seconds (maxInactiveInterval) check that the session is still alive in memcached,\n         * this would have been expired without an updated expiration\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( manager.getMaxInactiveInterval() ) - 500 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session should still exist in memcached.\" );\n\n        /* after another second in sticky mode (more than 4 seconds since the last request), or an two times the\n         * maxInactiveInterval in non-sticky mode (we must keep sessions in memcached with double expirationtime)\n         * the session must be expired in memcached\n         */\n        Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 );\n        assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1,\n                \"The sessionId should have changed due to expired sessin\" );\n\n    }\n\n    /**\n     * Test that a session that has been serialized with the old serialization\n     * format (the complete session was serialized by one serialization strategy)\n     * can be loaded from memcached.\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @Test( enabled = true )\n    public void testLoadFromMemcachedOldSessionSerializationFormat() throws InterruptedException, ExecutionException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        final Session session = manager.createSession( null );\n        final SessionTranscoder oldSessionTranscoder = manager.getTranscoderFactory().createSessionTranscoder( manager );\n        final Future<Boolean> future = _memcached.set( session.getId(), session.getMaxInactiveInterval(), session, oldSessionTranscoder );\n        assertTrue( future.get() );\n        final Session loadedFromMemcached = manager.loadFromMemcachedWithCheck( session.getId() );\n        assertNotNull( loadedFromMemcached );\n        assertDeepEquals( session, loadedFromMemcached );\n    }\n\n    /**\n     * Test for issue #49:\n     * Sessions not associated with a memcached node don't get associated as soon as a memcached is available\n     * @throws InterruptedException\n     * @throws IOException\n     * @throws TimeoutException\n     * @throws ExecutionException\n     */\n    @Test( enabled = true )\n    public void testNotAssociatedSessionGetsAssociatedIssue49() throws InterruptedException, IOException, ExecutionException, TimeoutException {\n        _daemon.stop();\n\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setMaxInactiveInterval( 5 );\n        manager.setSticky( true );\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n\n        final Session session = manager.createSession( null );\n        assertNull( sessionIdFormat.extractMemcachedId( session.getId() ) );\n\n        _daemon.start();\n\n        // Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick)\n        Thread.sleep( 4000 );\n\n        final String newSessionId = manager.changeSessionIdOnMemcachedFailover( session.getId() );\n        assertNotNull( newSessionId );\n        assertEquals( newSessionId, session.getId() );\n        assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId );\n\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): disable msm\n     */\n    @Test( enabled = true )\n    public void testDisableMsmAtRuntime() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        // disable msm, shutdown our server and our client\n        manager.setEnabled( false );\n        _memcached.shutdown();\n        _daemon.stop();\n\n        checkSessionFunctionalityWithMsmDisabled();\n    }\n\n    /**\n     * Test for issue #60 (Add possibility to disable msm at runtime): start msm disabled and afterwards enable\n     */\n    @Test( enabled = true )\n    public void testStartMsmDisabled() throws InterruptedException, IOException, ExecutionException, TimeoutException, LifecycleException, HttpException {\n\n        // shutdown our server and our client\n        _memcached.shutdown();\n        _daemon.stop();\n\n        // start a new tomcat with msm initially disabled\n        _tomcat1.stop();\n        Thread.sleep( 500 );\n        final String memcachedNodes = _memcachedNodeId + \":localhost:\" + _memcachedPort;\n        _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, \"app1\" );\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        manager.setSticky( true );\n        manager.setEnabled( false );\n        _tomcat1.start();\n\n        LOG.info( \"Waiting, check logs to see if the client causes any 'Connection refused' logging...\" );\n        Thread.sleep( 1000 );\n\n        // some basic tests for session functionality\n        checkSessionFunctionalityWithMsmDisabled();\n\n        // start memcached, client and reenable msm\n        _daemon.start();\n        _memcached = createMemcachedClient( new InetSocketAddress( \"localhost\", _memcachedPort ) );\n        manager.setEnabled( true );\n        // Wait a little bit, so that msm's memcached client can connect and is ready when test starts\n        Thread.sleep( 100 );\n\n        // memcached based stuff should work again\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"memcached node id missing with msm switched to enabled\" );\n        Thread.sleep( 50 );\n        assertNotNull( _memcached.get( sessionId1 ), \"Session not available in memcached.\" );\n\n        waitForSessionExpiration( true );\n\n        assertNull( _memcached.get( sessionId1 ), \"Expired session still existing in memcached\" );\n\n    }\n\n    private void checkSessionFunctionalityWithMsmDisabled() throws IOException, HttpException, InterruptedException {\n        assertTrue( getManager( _tomcat1 ).isSticky() );\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( sessionId1, \"No session created.\" );\n        assertNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), \"Got a memcached node id, even with msm disabled.\" );\n        waitForSessionExpiration( true );\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( sessionId2, sessionId1, \"SessionId not changed.\" );\n    }\n\n    private void waitForSessionExpiration(final boolean sticky) throws InterruptedException {\n        final MemcachedBackupSessionManager manager = getManager( _tomcat1 );\n        assertEquals( manager.isSticky(), sticky );\n        final Container container = manager.getContainer();\n        final long timeout = TimeUnit.SECONDS.toMillis(\n                sticky ? container.getBackgroundProcessorDelay() + manager.getMaxInactiveInterval()\n                       : 2 * manager.getMaxInactiveInterval() ) + 1000;\n        Thread.sleep( timeout );\n    }\n\n}\n","lineNo":375}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 1000;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled ) );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    private MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, nodeIds, failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        StandardSession result = (StandardSession) super.findSession( id );\n        if ( result == null ) {\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        session.tellNew();\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcached( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                _memcached.delete( sessionId );\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        /* We can just lookup the session in the local session map, as we wouldn't get\n         * the session from memcached if the node was not available - or, the other way round,\n         * if we would get the session from memcached, the session would not have to be relocated.\n         */\n        try {\n            final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n            if ( session != null && session.isValid() ) {\n                final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                if ( newNodeId != null ) {\n                    final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                    _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                    session.setIdForRelocate( newSessionId );\n                    _statistics.requestWithMemcachedFailover();\n                    return newSessionId;\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResultStatus> backupSession( final Session session, final boolean sessionIdChanged ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResultStatus>( BackupResultStatus.SKIPPED );\n        }\n        return _backupSessionService.backupSession( (MemcachedBackupSession) session, sessionIdChanged );\n    }\n\n    protected MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( !_enabled.get() || !_sessionIdFormat.isValid( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n            try {\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n\n                if ( _log.isDebugEnabled() ) {\n                    if ( object == null ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                    }\n                    _statistics.getLoadFromMemcachedProbe().registerSince( start );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE ) +\n                    \", node failure: \" + session.getNote( NODE_FAILURE ) +\n                    \", id: \" + session.getId() );\n        }\n        if ( session.getNote( NODE_FAILURE ) != Boolean.TRUE ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                new Integer( oldMaxActiveSessions ),\n                new Integer( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        _enableStatistics = enableStatistics;\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     */\n    public void setEnabled( final boolean enabled ) {\n        if ( _enabled.compareAndSet( !enabled, enabled ) ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            try {\n                _backupSessionService.shutdown();\n            } catch ( final InterruptedException e ) {\n                _log.info( \"Got interrupted during backupSessionService shutdown,\" +\n                        \" continuing to shutdown memcached client and to destroy myself...\", e );\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( initialized && oldSessionBackupAsync != sessionBackupAsync ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackup()\n     */\n    public long getMsmStatNumBackups() {\n        return _statistics.getRequestsWithBackup();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getSessionsLoadedFromMemcached()\n     */\n    public long getMsmStatNumSessionsLoadedFromMemcached() {\n        return _statistics.getSessionsLoadedFromMemcached();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getAttributesSerializationProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getEffectiveBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getLoadFromMemcachedProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getCachedDataSizeProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getMemcachedUpdateProbe().getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final List<String> _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final List<String> nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public List<String> getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.ConnectionFactory;\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionService.SimpleFuture;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final int NODE_AVAILABILITY_CACHE_TTL = 1000;\n\n    private static final String PROTOCOL_TEXT = \"text\";\n    private static final String PROTOCOL_BINARY = \"binary\";\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    protected final Log _log = LogFactory.getLog( getClass() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = true;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class name of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class name is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private String _transcoderFactoryClassName = JavaSerializationTranscoderFactory.class.getName();\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    private int _backupThreadCount = Runtime.getRuntime().availableProcessors();\n\n    private String _memcachedProtocol = PROTOCOL_TEXT;\n\n    private final AtomicBoolean _enabled = new AtomicBoolean( true );\n\n    // -------------------- END configuration properties --------------------\n\n    protected Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /**\n     * The maximum number of active Sessions allowed, or -1 for no limit.\n     */\n    private int _maxActiveSessions = -1;\n\n    private int _rejectedSessions;\n\n    protected TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    private BackupSessionService _backupSessionService;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n                \" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern,\n                (Context) getContainer(), this, _statistics, _enabled ) );\n\n        /* init memcached\n         */\n        final MemcachedConfig config = createMemcachedConfig( _memcachedNodes, _failoverNodes );\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, _memcached ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + config.getNodeIds() + \" and failover node ids \" + config.getFailoverNodeIds() );\n\n    }\n\n    private MemcachedConfig createMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes  );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( failoverNodes, nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        return new MemcachedConfig( memcachedNodes, failoverNodes, nodeIds, failoverNodeIds, addresses, address2Ids );\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    protected MemcachedClient createMemcachedClient( final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        if ( ! _enabled.get() ) {\n            return null;\n        }\n        try {\n            final ConnectionFactory connectionFactory = createConnectionFactory( address2Ids, statistics );\n            return new MemcachedClient( connectionFactory, addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private ConnectionFactory createConnectionFactory(\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        final MapBasedResolver resolver = new MapBasedResolver( address2Ids );\n        if ( PROTOCOL_BINARY.equals( _memcachedProtocol ) ) {\n            return new SuffixLocatorBinaryConnectionFactory( resolver, _sessionIdFormat, statistics );\n        }\n        return new SuffixLocatorConnectionFactory( resolver, _sessionIdFormat, statistics );\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n        _log.info( \"Creating transcoder factory \" + _transcoderFactoryClassName );\n        final Class<? extends TranscoderFactory> transcoderFactoryClass = loadTranscoderFactoryClass();\n        final TranscoderFactory transcoderFactory = transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Found configured custom converter classes, setting on transcoder factory: \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \",\\\\s*\" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private Class<? extends TranscoderFactory> loadTranscoderFactoryClass() throws ClassNotFoundException {\n        Class<? extends TranscoderFactory> transcoderFactoryClass;\n        final ClassLoader classLoader = getContainer().getLoader().getClassLoader();\n        try {\n            _log.debug( \"Loading transcoder factory class \" + _transcoderFactoryClassName + \" using classloader \" + classLoader );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, classLoader ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.info( \"Could not load transcoderfactory class with classloader \"+ classLoader +\", trying \" + getClass().getClassLoader() );\n            transcoderFactoryClass = Class.forName( _transcoderFactoryClassName, false, getClass().getClassLoader() ).asSubclass( TranscoderFactory.class );\n        }\n        return transcoderFactoryClass;\n    }\n\n    protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            final MemcachedClient memcachedClient ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    memcachedClient.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private List<String> initFailoverNodes( final String failoverNodes, final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( failoverNodes != null && failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodesArray = failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodesArray ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + nodeIds + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"expireSession invoked: \" + sessionId );\n        }\n        super.expireSession( sessionId );\n        deleteFromMemcached( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        StandardSession result = (StandardSession) super.findSession( id );\n        if ( result == null ) {\n            result = loadFromMemcached( id );\n            // checking valid() would expire() the session if it's not valid!\n            if ( result != null && result.isValid() ) {\n                addValidLoadedSession( result );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    private void addValidLoadedSession( final StandardSession session ) {\n        // make sure the listeners know about it. (as done by PersistentManagerBase)\n        session.tellNew();\n        add( session );\n        session.activate();\n        // endAccess() to ensure timeouts happen correctly.\n        // access() to keep access count correct or it will end up\n        // negative\n        session.access();\n        session.endAccess();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( String sessionId ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"createSession invoked: \" + sessionId );\n        }\n\n        checkMaxActiveSessions();\n\n        StandardSession session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n            // checking valid() would expire() the session if it's not valid!\n            if ( session != null && session.isValid() ) {\n                addValidLoadedSession( session );\n            }\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n\n            if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) {\n                sessionId = generateSessionId();\n            }\n\n            session.setId( sessionId );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return session;\n\n    }\n\n    private void checkMaxActiveSessions() {\n        if ( _maxActiveSessions >= 0 && sessions.size() >= _maxActiveSessions ) {\n            _rejectedSessions++;\n            throw new IllegalStateException\n                (sm.getString(\"standardManager.createSession.ise\"));\n        }\n    }\n\n    private boolean isNodeAvailableForSessionId( final String sessionId ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        return nodeId != null && _nodeIdService.isNodeAvailable( nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    @Override\n    public void changeSessionId( final Session session ) {\n        // e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation\n        // so that session backup won't be omitted we must store this event\n        super.changeSessionId( session );\n        ((MemcachedBackupSession)session).setSessionIdChanged( true );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnTomcatFailover( final String requestedSessionId ) {\n        final String localJvmRoute = getJvmRoute();\n        if ( localJvmRoute != null && !localJvmRoute.equals( _sessionIdFormat.extractJvmRoute( requestedSessionId ) ) ) {\n            final MemcachedBackupSession session = loadFromMemcached( requestedSessionId );\n            // checking valid() can expire() the session!\n            if ( session != null && session.isValid() ) {\n                return handleSessionTakeOver( session );\n            }\n        }\n        return null;\n    }\n\n    private String handleSessionTakeOver( final MemcachedBackupSession session ) {\n\n        checkMaxActiveSessions();\n\n        final String origSessionId = session.getIdInternal();\n\n        final String newSessionId = _sessionIdFormat.changeJvmRoute( session.getIdInternal(), getJvmRoute() );\n        session.setIdInternal( newSessionId );\n\n        addValidLoadedSession( session );\n\n        deleteFromMemcached( origSessionId );\n\n        _statistics.requestWithTomcatFailover();\n\n        return newSessionId;\n\n    }\n\n    protected void deleteFromMemcached(final String sessionId) {\n        if ( _enabled.get() && _sessionIdFormat.isValid( sessionId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Deleting session from memcached: \" + sessionId );\n            }\n            try {\n                _memcached.delete( sessionId );\n            } catch ( final Throwable e ) {\n                _log.info( \"Could not delete session from memcached.\", e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String changeSessionIdOnMemcachedFailover( final String requestedSessionId ) {\n\n        /* We can just lookup the session in the local session map, as we wouldn't get\n         * the session from memcached if the node was not available - or, the other way round,\n         * if we would get the session from memcached, the session would not have to be relocated.\n         */\n        try {\n            final MemcachedBackupSession session = (MemcachedBackupSession) super.findSession( requestedSessionId );\n\n            if ( session != null && session.isValid() ) {\n                final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                final String newNodeId = getNewNodeIdIfUnavailable( nodeId );\n                if ( newNodeId != null ) {\n                    final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), newNodeId );\n                    _log.debug( \"Session needs to be relocated, setting new id on session...\" );\n                    session.setIdForRelocate( newSessionId );\n                    _statistics.requestWithMemcachedFailover();\n                    return newSessionId;\n                }\n            }\n\n        } catch ( final IOException e ) {\n            _log.warn( \"Could not find session in local session map.\", e );\n        }\n        return null;\n    }\n\n    /**\n     * Returns a new node id if the given one is <code>null<\/code> or not available.\n     * @param nodeId the node id that is checked for availability (if not <code>null<\/code>).\n     * @return a new node id if the given one is <code>null<\/code> or not available, otherwise <code>null<\/code>.\n     */\n    private String getNewNodeIdIfUnavailable( final String nodeId ) {\n        final String newNodeId;\n        if ( nodeId == null ) {\n            newNodeId = _nodeIdService.getMemcachedNodeId();\n        }\n        else {\n            if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n                newNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n                if ( newNodeId == null ) {\n                    _log.warn( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n                }\n            }\n            else {\n                newNodeId = null;\n            }\n        }\n        return newNodeId;\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @param sessionRelocationRequired\n     *            specifies, if the session id was changed due to a memcached failover or tomcat failover.\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public Future<BackupResultStatus> backupSession( final Session session, final boolean sessionIdChanged ) {\n        if ( !_enabled.get() ) {\n            return new SimpleFuture<BackupResultStatus>( BackupResultStatus.SKIPPED );\n        }\n        final MemcachedBackupSession msmSession = (MemcachedBackupSession) session;\n        return _backupSessionService.backupSession( msmSession, sessionIdChanged || msmSession.isSessionIdChanged() );\n    }\n\n    protected MemcachedBackupSession loadFromMemcached( final String sessionId ) {\n        if ( !_enabled.get() || !_sessionIdFormat.isValid( sessionId ) || _missingSessionsCache.get( sessionId ) != null ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Loading session from memcached: \" + sessionId );\n            }\n            try {\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n\n                if ( _log.isDebugEnabled() ) {\n                    if ( object == null ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object != null ) {\n                    final MemcachedBackupSession result;\n                    if ( object instanceof MemcachedBackupSession ) {\n                        result = (MemcachedBackupSession) object;\n                    }\n                    else {\n                        result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                    }\n                    _statistics.getLoadFromMemcachedProbe().registerSince( start );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                    return result;\n                }\n                else {\n                    _missingSessionsCache.put( sessionId, Boolean.TRUE );\n                    if ( _log.isDebugEnabled() ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    }\n                    return null;\n                }\n\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE ) +\n                    \", node failure: \" + session.getNote( NODE_FAILURE ) +\n                    \", id: \" + session.getId() );\n        }\n        if ( session.getNote( NODE_FAILURE ) != Boolean.TRUE ) {\n            deleteFromMemcached( session.getId() );\n        }\n        super.remove( session );\n    }\n\n    /**\n     * Set the maximum number of active Sessions allowed, or -1 for no limit.\n     *\n     * @param max\n     *            The new maximum number of sessions\n     */\n    public void setMaxActiveSessions( final int max ) {\n        final int oldMaxActiveSessions = _maxActiveSessions;\n        _maxActiveSessions = max;\n        support.firePropertyChange( \"maxActiveSessions\",\n                new Integer( oldMaxActiveSessions ),\n                new Integer( _maxActiveSessions ) );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes space or comma separated.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * <p>\n     * When the memcached nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace or comma separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( memcachedNodes, _failoverNodes );\n            _log.info( \"Loaded new memcached node configuration.\" +\n                    \"\\n- Former config: \"+ _memcachedNodes +\n                    \"\\n- New config: \" + config.getMemcachedNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The memcached nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the memcached nodes.\n     */\n    public String getMemcachedNodes() {\n        return _memcachedNodes;\n    }\n\n    private MemcachedConfig reloadMemcachedConfig( final String memcachedNodes, final String failoverNodes ) {\n\n        /* first create all dependent services\n         */\n        final MemcachedConfig config = createMemcachedConfig( memcachedNodes, failoverNodes );\n        final MemcachedClient memcachedClient = createMemcachedClient( config.getAddresses(),\n                config.getAddress2Ids(), _statistics );\n        final NodeIdService nodeIdService = new NodeIdService(\n                createNodeAvailabilityCache( config.getCountNodes(), NODE_AVAILABILITY_CACHE_TTL, memcachedClient ),\n                config.getNodeIds(), config.getFailoverNodeIds() );\n        final BackupSessionService backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync,\n                _sessionBackupTimeout, _backupThreadCount, memcachedClient, nodeIdService, _statistics );\n\n        /* then assign new services\n         */\n        if ( _memcached != null ) {\n            _memcached.shutdown();\n        }\n        _memcached = memcachedClient;\n        _nodeIdService = nodeIdService;\n        _backupSessionService = backupSessionService;\n\n        return config;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace or comma.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * <p>\n     * When the failover nodes are set when this manager is already initialized,\n     * the new configuration will be loaded.\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace or comma separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        if ( initialized ) {\n            final MemcachedConfig config = reloadMemcachedConfig( _memcachedNodes, failoverNodes );\n            _log.info( \"Loaded new memcached failover node configuration.\" +\n                    \"\\n- Former failover config: \"+ _failoverNodes +\n                    \"\\n- New failover config: \" + config.getFailoverNodes() +\n                    \"\\n- New node ids: \" + config.getNodeIds() +\n                    \"\\n- New failover node ids: \" + config.getFailoverNodeIds() );\n        }\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * The memcached failover nodes configuration as provided in the server.xml/context.xml.\n     * <p>\n     * This getter is there to make this configuration accessible via jmx.\n     * <\/p>\n     * @return the configuration string for the failover nodes.\n     */\n    public String getFailoverNodes() {\n        return _failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        _transcoderFactoryClassName = transcoderFactoryClassName;\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        _enableStatistics = enableStatistics;\n    }\n\n    /**\n     * Specifies the number of threads that are used if {@link #setSessionBackupAsync(boolean)}\n     * is set to <code>true<\/code>.\n     *\n     * @param backupThreadCount the number of threads to use for session backup.\n     */\n    public void setBackupThreadCount( final int backupThreadCount ) {\n        final int oldBackupThreadCount = _backupThreadCount;\n        _backupThreadCount = backupThreadCount;\n        if ( initialized ) {\n            _log.info( \"Changed backupThreadCount from \" + oldBackupThreadCount + \" to \" + _backupThreadCount + \".\" +\n                    \" Reloading configuration...\" );\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Finished reloading configuration.\" );\n        }\n    }\n\n    /**\n     * The number of threads to use for session backup if session backup shall be\n     * done asynchronously.\n     * @return the number of threads for session backup.\n     */\n    public int getBackupThreadCount() {\n        return _backupThreadCount;\n    }\n\n    /**\n     * Specifies the memcached protocol to use, either \"text\" (default) or \"binary\".\n     *\n     * @param memcachedProtocol one of \"text\" or \"binary\".\n     */\n    public void setMemcachedProtocol( final String memcachedProtocol ) {\n        if ( !PROTOCOL_TEXT.equals( memcachedProtocol )\n                && !PROTOCOL_BINARY.equals( memcachedProtocol ) ) {\n            _log.warn( \"Illegal memcachedProtocol \" + memcachedProtocol + \", using default (\" + _memcachedProtocol + \").\" );\n            return;\n        }\n        _memcachedProtocol = memcachedProtocol;\n    }\n\n    /**\n     * Enable/disable memcached-session-manager (default <code>true<\/code> / enabled).\n     * If disabled, sessions are neither looked up in memcached nor stored in memcached.\n     *\n     * @param enabled specifies if msm shall be disabled or not.\n     */\n    public void setEnabled( final boolean enabled ) {\n        if ( _enabled.compareAndSet( !enabled, enabled ) ) {\n            reloadMemcachedConfig( _memcachedNodes, _failoverNodes );\n            _log.info( \"Changed enabled status to \" + enabled + \".\" );\n        }\n    }\n\n    /**\n     * Specifies, if msm is enabled or not.\n     *\n     * @return <code>true<\/code> if enabled, otherwise <code>false<\/code>.\n     */\n    public boolean isEnabled() {\n        return _enabled.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            try {\n                _backupSessionService.shutdown();\n            } catch ( final InterruptedException e ) {\n                _log.info( \"Got interrupted during backupSessionService shutdown,\" +\n                        \" continuing to shutdown memcached client and to destroy myself...\", e );\n            }\n            if ( _memcached != null ) {\n                _memcached.shutdown();\n            }\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    protected void updateExpirationInMemcached() {\n        if ( _enabled.get() ) {\n            final Session[] sessions = findSessions();\n            final int delay = getContainer().getBackgroundProcessorDelay();\n            for ( final Session s : sessions ) {\n                final MemcachedBackupSession session = (MemcachedBackupSession) s;\n                if ( _log.isDebugEnabled() ) {\n                    _log.debug( \"Checking session \" + session.getId() + \": \" +\n                            \"\\n- isValid: \" + session.isValidInternal() +\n                            \"\\n- isExpiring: \" + session.isExpiring() +\n                            \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                            \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                            \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                            \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n                }\n                if ( session.isValidInternal()\n                        && !session.isExpiring()\n                        && !session.isBackupRunning()\n                        && !session.isExpirationUpdateRunning()\n                        && session.wasAccessedSinceLastBackup()\n                        && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                    try {\n                        _backupSessionService.updateExpiration( session );\n                    } catch ( final Throwable e ) {\n                        _log.info( \"Could not update expiration in memcached for session \" + session.getId(), e );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated. If this is <code>true<\/code>, the {@link #setBackupThreadCount(int)}\n     * is evaluated.\n     * <p>\n     * By default this property is set to <code>true<\/code> - the session\n     * backup is performed asynchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        final boolean oldSessionBackupAsync = _sessionBackupAsync;\n        _sessionBackupAsync = sessionBackupAsync;\n        if ( initialized && oldSessionBackupAsync != sessionBackupAsync ) {\n            _log.info( \"SessionBackupAsync was changed to \" + sessionBackupAsync + \", creating new BackupSessionService with new configuration.\" );\n            _backupSessionService = new BackupSessionService( _transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n        }\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionService}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n        _backupSessionService = new BackupSessionService( transcoderService, _sessionBackupAsync, _sessionBackupTimeout, _backupThreadCount, _memcached, _nodeIdService, _statistics );\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackup()\n     */\n    public long getMsmStatNumBackups() {\n        return _statistics.getRequestsWithBackup();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumTomcatFailover() {\n        return _statistics.getRequestsWithTomcatFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithMemcachedFailover()\n     */\n    public long getMsmStatNumMemcachedFailover() {\n        return _statistics.getRequestsWithMemcachedFailover();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutAttributesAccess()\n     */\n    public long getMsmStatNumNoAttributesAccess() {\n        return _statistics.getRequestsWithoutAttributesAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getSessionsLoadedFromMemcached()\n     */\n    public long getMsmStatNumSessionsLoadedFromMemcached() {\n        return _statistics.getSessionsLoadedFromMemcached();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getAttributesSerializationProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took in the request thread (including omitted\n     * session backups e.g. because the session attributes were not accessed).\n     * This time was spent in the request thread.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatEffectiveBackupInfo() {\n        return _statistics.getEffectiveBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated). This time was spent in the request thread if session backup\n     * is done synchronously, otherwise another thread used this time.\n     *\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getLoadFromMemcachedProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getCachedDataSizeProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getMemcachedUpdateProbe().getInfo();\n    }\n\n    // ---------------------------------------------------------------------------\n\n    private static class MemcachedConfig {\n        private final String _memcachedNodes;\n        private final String _failoverNodes;\n        private final List<String> _nodeIds;\n        private final List<String> _failoverNodeIds;\n        private final List<InetSocketAddress> _addresses;\n        private final Map<InetSocketAddress, String> _address2Ids;\n        public MemcachedConfig( final String memcachedNodes, final String failoverNodes,\n                final List<String> nodeIds, final List<String> failoverNodeIds, final List<InetSocketAddress> addresses,\n                final Map<InetSocketAddress, String> address2Ids ) {\n            _memcachedNodes = memcachedNodes;\n            _failoverNodes = failoverNodes;\n            _nodeIds = nodeIds;\n            _failoverNodeIds = failoverNodeIds;\n            _addresses = addresses;\n            _address2Ids = address2Ids;\n        }\n\n        /**\n         * @return the number of all known memcached nodes.\n         */\n        public int getCountNodes() {\n            return _addresses.size();\n        }\n\n        public String getMemcachedNodes() {\n            return _memcachedNodes;\n        }\n        public String getFailoverNodes() {\n            return _failoverNodes;\n        }\n        public List<String> getNodeIds() {\n            return _nodeIds;\n        }\n        public List<String> getFailoverNodeIds() {\n            return _failoverNodeIds;\n        }\n        public List<InetSocketAddress> getAddresses() {\n            return _addresses;\n        }\n        public Map<InetSocketAddress, String> getAddress2Ids() {\n            return _address2Ids;\n        }\n    }\n\n}\n","lineNo":706}
{"Smelly Sample":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.kryo;\n\nimport org.apache.wicket.Component;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.Serializer;\n\nimport de.javakaffee.kryoserializers.ReferenceFieldSerializerReflectionFactorySupport;\n\n/**\n * A {@link KryoCustomization} that creates a {@link ReferenceFieldSerializerReflectionFactorySupport} as\n * serializer for subclasses of {@link Component}. This is required, as the {@link Component}\n * constructor invokes {@link org.apache.wicket.Application#get()} to tell the application\n * to {@link org.apache.wicket.Application#notifyComponentInstantiationListeners()}. This will\n * lead to NullpointerExceptions if the application is not yet bound to the current thread\n * because the session is e.g. accessed from within a servlet filter. If the component is created\n * via the constructor for serialization, this problem does not occur.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ComponentSerializerFactory implements SerializerFactory {\n\n    private final Kryo _kryo;\n    \n    public ComponentSerializerFactory( final Kryo kryo ) {\n        _kryo = kryo;\n    }\n    \n    @Override\n    public Serializer newSerializer( final Class<?> type ) {\n        if ( Component.class.isAssignableFrom( type ) ) {\n            return new ReferenceFieldSerializerReflectionFactorySupport( _kryo, type );\n        }\n        return null;\n    }\n    \n}\n","Method after Refactoring":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.kryo;\n\nimport org.apache.wicket.Component;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.Serializer;\n\nimport de.javakaffee.kryoserializers.ReferenceFieldSerializerReflectionFactorySupport;\n\n/**\n * A {@link KryoCustomization} that creates a {@link ReferenceFieldSerializerReflectionFactorySupport} as\n * serializer for subclasses of {@link Component}. This is required, as the {@link Component}\n * constructor invokes {@link org.apache.wicket.Application#get()} to tell the application\n * to {@link org.apache.wicket.Application#notifyComponentInstantiationListeners()}. This will\n * lead to NullpointerExceptions if the application is not yet bound to the current thread\n * because the session is e.g. accessed from within a servlet filter. If the component is created\n * via the constructor for serialization, this problem does not occur.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ComponentSerializerFactory implements SerializerFactory {\n\n    private final Kryo _kryo;\n    \n    public ComponentSerializerFactory( final Kryo kryo ) {\n        _kryo = kryo;\n    }\n    \n    @Override\n    public Serializer newSerializer( final Class<?> type ) {\n        if ( Component.class.isAssignableFrom( type ) ) {\n            final ReferenceFieldSerializerReflectionFactorySupport result = new ReferenceFieldSerializerReflectionFactorySupport( _kryo, type );\n            result.setIgnoreSyntheticFields( false );\n            return result;\n        }\n        return null;\n    }\n    \n}\n","lineNo":48}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Currency;\nimport java.util.GregorianCalendar;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javolution.lang.Reflection;\nimport javolution.text.CharArray;\nimport javolution.xml.XMLBinding;\nimport javolution.xml.XMLFormat;\nimport javolution.xml.XMLSerializable;\nimport javolution.xml.stream.XMLStreamException;\nimport javolution.xml.stream.XMLStreamReader;\nimport javolution.xml.stream.XMLStreamWriter;\n\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport sun.reflect.ReflectionFactory;\n\n/**\n * An {@link XMLBinding} that provides class bindings based on reflection.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ReflectionBinding extends XMLBinding {\n\n    private static final long serialVersionUID = -7047053153745571559L;\n\n    private static final Log LOG = LogFactory.getLog( ReflectionBinding.class );\n\n    private static final ReflectionFactory REFLECTION_FACTORY = ReflectionFactory.getReflectionFactory();\n    private static final Object[] INITARGS = new Object[0];\n    private static final String SIZE = \"size\";\n\n    private static final XMLCalendarFormat CALENDAR_FORMAT = new XMLCalendarFormat();\n\n    private static final XMLCurrencyFormat CURRENCY_FORMAT = new XMLCurrencyFormat();\n\n    private final Map<Class<?>, XMLFormat<?>> _formats = new ConcurrentHashMap<Class<?>, XMLFormat<?>>();\n\n    private final ClassLoader _classLoader;\n    private final XMLEnumFormat _enumFormat;\n    private final XMLArrayFormat _arrayFormat;\n    private final XMLCollectionFormat _collectionFormat;\n    private final XMLMapFormat _mapFormat;\n    private final XMLJdkProxyFormat _jdkProxyFormat;\n    private final XMLFormat<?>[] _customFormats;\n\n    public ReflectionBinding( final ClassLoader classLoader ) {\n        this( classLoader, false );\n    }\n\n    public ReflectionBinding( final ClassLoader classLoader, final boolean copyCollectionsForSerialization,\n            final XMLFormat<?> ... customFormats ) {\n        _classLoader = classLoader;\n        _enumFormat = new XMLEnumFormat( classLoader );\n        _arrayFormat = new XMLArrayFormat( classLoader );\n        _collectionFormat = new XMLCollectionFormat( copyCollectionsForSerialization );\n        _mapFormat = new XMLMapFormat( copyCollectionsForSerialization );\n        _jdkProxyFormat = new XMLJdkProxyFormat( classLoader );\n        _customFormats = customFormats;\n\n        Reflection.getInstance().add( classLoader );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    protected void writeClass( Class cls, final XMLStreamWriter writer, final boolean useAttributes ) throws XMLStreamException {\n        if ( Proxy.isProxyClass( cls ) ) {\n            cls = Proxy.class;\n        }\n        if ( useAttributes ) {\n            writer.writeAttribute( \"class\", cls.getName() );\n        } else {\n            writer.writeStartElement( cls.getName() );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    protected Class readClass( final XMLStreamReader reader, final boolean useAttributes ) throws XMLStreamException {\n        final CharArray className = useAttributes\n            ? reader.getAttributeValue( null, \"class\" )\n            : reader.getLocalName();\n        try {\n            return Class.forName( className.toString(), true, _classLoader );\n        } catch ( final ClassNotFoundException e ) {\n            throw new XMLStreamException( e );\n        }\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    public XMLFormat<?> getFormat( final Class cls ) throws XMLStreamException {\n\n        XMLFormat<?> xmlFormat = _formats.get( cls );\n        if ( xmlFormat != null ) {\n            return xmlFormat;\n        }\n\n        if ( cls.isPrimitive()\n                || cls == String.class\n                || cls == Boolean.class\n                || cls == Integer.class\n                || cls == Long.class\n                || cls == Short.class\n                || cls == Double.class\n                || cls == Float.class\n                || cls == Character.class\n                || cls == Byte.class\n                || cls == Class.class ) {\n            return super.getFormat( cls );\n        } else if ( XMLSerializable.class.isAssignableFrom( cls ) ) {\n            return super.getFormat( cls );\n        } else if ( cls.isArray() ) {\n            return getArrayFormat( cls );\n        } else if ( Collection.class.isAssignableFrom( cls )\n                && Modifier.isPublic( cls.getModifiers() ) ) {\n            // the check for the private modifier is required, so that\n            // lists like Arrays.ArrayList are handled by the ReflectionFormat\n            return _collectionFormat;\n        }  else if ( Map.class.isAssignableFrom( cls )\n                && Modifier.isPublic( cls.getModifiers() ) ) {\n            return _mapFormat;\n        } else if ( cls.isEnum() ) {\n            return _enumFormat;\n        } else if ( Calendar.class.isAssignableFrom( cls ) ) {\n            return CALENDAR_FORMAT;\n        } else if ( Currency.class.isAssignableFrom( cls ) ) {\n            return CURRENCY_FORMAT;\n        } else if ( Proxy.isProxyClass( cls ) || cls == Proxy.class ) {\n            /* the Proxy.isProxyClass check is required for serialization,\n             * Proxy.class is required for deserialization\n             */\n            return _jdkProxyFormat;\n        } else if ( cls == StringBuilder.class ) {\n            return STRING_BUILDER_FORMAT;\n        } else if ( cls == StringBuffer.class ) {\n            return STRING_BUFFER_FORMAT;\n        } else if ( ( xmlFormat = getCustomFormat( cls ) ) != null ) {\n            return xmlFormat;\n        } else {\n            if ( xmlFormat == null ) {\n                if ( ReflectionFormat.isNumberFormat( cls ) ) {\n                    xmlFormat = ReflectionFormat.getNumberFormat( cls );\n                } else {\n                    xmlFormat = new ReflectionFormat( cls, _classLoader );\n                }\n                _formats.put( cls, xmlFormat );\n            }\n            return xmlFormat;\n        }\n    }\n\n    private XMLFormat<?> getCustomFormat( final Class<?> cls ) {\n        if ( _customFormats == null ) {\n            return null;\n        }\n        for( final XMLFormat<?> xmlFormat : _customFormats ) {\n            if ( xmlFormat.getBoundClass() == cls ) {\n                return xmlFormat;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private XMLFormat getArrayFormat( final Class cls ) {\n        if ( cls == int[].class ) {\n            return XMLArrayFormats.INT_ARRAY_FORMAT;\n        } else if ( cls == long[].class ) {\n            return XMLArrayFormats.LONG_ARRAY_FORMAT;\n        } else if ( cls == short[].class ) {\n            return XMLArrayFormats.SHORT_ARRAY_FORMAT;\n        } else if ( cls == float[].class ) {\n            return XMLArrayFormats.FLOAT_ARRAY_FORMAT;\n        } else if ( cls == double[].class ) {\n            return XMLArrayFormats.DOUBLE_ARRAY_FORMAT;\n        } else if ( cls == char[].class ) {\n            return XMLArrayFormats.CHAR_ARRAY_FORMAT;\n        } else if ( cls == byte[].class ) {\n            return XMLArrayFormats.BYTE_ARRAY_FORMAT;\n        } else {\n            return _arrayFormat;\n        }\n    }\n\n    static class XMLEnumFormat extends XMLFormat<Enum<?>> {\n\n        private final ClassLoader _classLoader;\n\n        public XMLEnumFormat( final ClassLoader classLoader ) {\n            super( null );\n            _classLoader = classLoader;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Enum<?> newInstance( final Class<Enum<?>> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            final String value = xml.getAttribute( \"value\" ).toString();\n            final String clazzName = xml.getAttribute( \"type\" ).toString();\n            try {\n                @SuppressWarnings( \"unchecked\" )\n                final Enum<?> enumValue = Enum.valueOf( Class.forName( clazzName, true, _classLoader ).asSubclass( Enum.class ), value );\n                return enumValue;\n            } catch ( final ClassNotFoundException e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Enum<?> object ) throws XMLStreamException {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write( final Enum<?> object, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"value\", object.name() );\n            xml.setAttribute( \"type\", object.getClass().getName() );\n        }\n\n    }\n\n    public static class XMLArrayFormat extends XMLFormat<Object[]> {\n\n        private final ClassLoader _classLoader;\n\n        public XMLArrayFormat( final ClassLoader classLoader ) {\n            super( null );\n            _classLoader = classLoader;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( \"unchecked\" )\n        @Override\n        public Object[] newInstance( final Class clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException {\n            try {\n                final String componentType = input.getAttribute( \"componentType\", (String) null );\n                final int length = input.getAttribute( \"length\", 0 );\n                return (Object[]) Array.newInstance( Class.forName( componentType, false, _classLoader ), length );\n            } catch ( final Exception e ) {\n                LOG.error( \"caught exception\", e );\n                throw new XMLStreamException( e );\n            }\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement input, final Object[] array ) throws XMLStreamException {\n            int i = 0;\n            while ( input.hasNext() ) {\n                array[i++] = input.getNext();\n            }\n        }\n\n        @Override\n        public final void write( final Object[] array, final javolution.xml.XMLFormat.OutputElement output )\n            throws XMLStreamException {\n            output.setAttribute( \"type\", \"array\" );\n            output.setAttribute( \"componentType\", array.getClass().getComponentType().getName() );\n            output.setAttribute( \"length\", array.length );\n            writeElements( array, output );\n        }\n\n        public void writeElements( final Object[] array, final javolution.xml.XMLFormat.OutputElement output )\n            throws XMLStreamException {\n            for ( final Object item : array ) {\n                output.add( item );\n            }\n        }\n\n    }\n\n    public static class XMLCollectionFormat extends XMLFormat<Collection<Object>> {\n\n        private final boolean _copyForWrite;\n\n        protected XMLCollectionFormat( final boolean copyForWrite ) {\n            super( null );\n            _copyForWrite = copyForWrite;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( \"unchecked\" )\n        @Override\n        public Collection<Object> newInstance( final Class<Collection<Object>> cls, final javolution.xml.XMLFormat.InputElement xml )\n            throws XMLStreamException {\n\n            Collection<Object> result = newInstanceFromPublicConstructor( cls, xml );\n\n            if ( result == null && Modifier.isPrivate( cls.getModifiers() ) ) {\n                try {\n                    final Constructor<?> constructor = REFLECTION_FACTORY.newConstructorForSerialization( cls, Object.class.getDeclaredConstructor( new Class[0] ) );\n                    constructor.setAccessible( true );\n                    return (Collection<Object>) constructor.newInstance( INITARGS );\n                } catch ( final Exception e ) {\n                    throw new XMLStreamException( e );\n                }\n            }\n\n            if ( result == null ) {\n                result = super.newInstance( cls, xml );\n            }\n\n            return result;\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Collection<Object> obj ) throws XMLStreamException {\n            while ( xml.hasNext() ) {\n                obj.add( xml.getNext() );\n            }\n        }\n\n        @Override\n        public void write( final Collection<Object> obj, final javolution.xml.XMLFormat.OutputElement xml )\n            throws XMLStreamException {\n            xml.setAttribute( SIZE, obj.size() );\n            for ( final Object item : _copyForWrite ? new ArrayList<Object>( obj ) : obj ) {\n                xml.add( item );\n            }\n        }\n\n    }\n\n    public static class XMLMapFormat extends XMLFormat<Map<Object,Object>> {\n\n        private final boolean _copyForWrite;\n\n        protected XMLMapFormat( final boolean copyForWrite ) {\n            super( null );\n            _copyForWrite = copyForWrite;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( \"unchecked\" )\n        @Override\n        public Map<Object, Object> newInstance( final Class<Map<Object, Object>> cls, final javolution.xml.XMLFormat.InputElement xml )\n            throws XMLStreamException {\n\n            Map<Object, Object> result = newInstanceFromPublicConstructor( cls, xml );\n\n            if ( result == null && Modifier.isPrivate( cls.getModifiers() ) ) {\n                try {\n                    final Constructor<?> constructor = REFLECTION_FACTORY.newConstructorForSerialization( cls, Object.class.getDeclaredConstructor( new Class[0] ) );\n                    constructor.setAccessible( true );\n                    result = (Map<Object, Object>) constructor.newInstance( INITARGS );\n                } catch ( final Exception e ) {\n                    throw new XMLStreamException( e );\n                }\n            }\n\n            if ( result == null ) {\n                result = super.newInstance( cls, xml );\n            }\n\n            return result;\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Map<Object,Object> obj ) throws XMLStreamException {\n            while ( xml.hasNext() ) {\n                obj.put(xml.get(\"k\"), xml.get(\"v\"));\n            }\n        }\n\n        @Override\n        public void write( final Map<Object,Object> obj, final javolution.xml.XMLFormat.OutputElement xml )\n            throws XMLStreamException {\n            xml.setAttribute( SIZE, obj.size() );\n            final Set<Entry<Object, Object>> entrySet = _copyForWrite ? new LinkedHashMap<Object, Object>( obj ).entrySet() : obj.entrySet();\n            for ( final Map.Entry<Object, Object> entry : entrySet ) {\n                xml.add( entry.getKey(), \"k\" );\n                xml.add( entry.getValue(), \"v\" );\n            }\n        }\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private static <T> T newInstanceFromPublicConstructor( final Class<T> cls,\n            final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n        try {\n            final Constructor<?>[] constructors = cls.getConstructors();\n            for ( final Constructor<?> constructor : constructors ) {\n                final Class<?>[] parameterTypes = constructor.getParameterTypes();\n                if ( parameterTypes.length == 0 ) {\n                    return (T) constructor.newInstance();\n                }\n                else if ( parameterTypes.length == 1 && parameterTypes[0] == int.class ) {\n                    return (T) constructor.newInstance( xml.getAttribute( SIZE ).toInt() );\n                }\n            }\n            if ( LOG.isDebugEnabled() && constructors.length > 0 ) {\n                LOG.debug( \"No suitable constructor found for map \" + cls + \", available constructors:\\n\" +\n                        Arrays.asList( constructors ) );\n            }\n        } catch ( final SecurityException e ) {\n            // ignore\n        } catch ( final IllegalArgumentException e ) {\n            throw new XMLStreamException( e ); // not expected\n        } catch ( final InstantiationException e ) {\n            throw new XMLStreamException( e ); // not expected\n        } catch ( final IllegalAccessException e ) {\n            throw new XMLStreamException( e ); // not expected\n        } catch ( final InvocationTargetException e ) {\n            // ignore - constructor threw exception\n            LOG.info( \"Tried to invoke int constructor on \" + cls.getName() + \", this threw an exception.\", e.getTargetException() );\n        }\n        return null;\n    }\n\n    public static class XMLCurrencyFormat extends XMLFormat<Currency> {\n\n        public XMLCurrencyFormat() {\n            super( Currency.class );\n        }\n\n        /**\n         * Currency instance do not have to be handled by the reference resolver, as we're using\n         * Currency.getInstance for retrieving an instance.\n         *\n         * @return <code>false<\/code>\n         */\n        @Override\n        public boolean isReferenceable() {\n            return false;\n        }\n\n        @Override\n        public Currency newInstance( final Class<Currency> cls, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return Currency.getInstance( xml.getAttribute( \"code\", \"\" ) );\n        }\n\n        public void write( final Currency currency, final OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"code\", currency.getCurrencyCode() );\n        }\n\n        public void read( final InputElement xml, final Currency pos ) {\n            // Immutable, deserialization occurs at creation, ref. newIntance(...)\n        }\n\n    }\n\n    /**\n     * An {@link XMLFormat} for {@link Calendar} that serialized those calendar\n     * fields that contain actual data (these fields also are used by\n     * {@link Calendar#equals(Object)}.\n     */\n    public static class XMLCalendarFormat extends XMLFormat<Calendar> {\n\n        private final Field _zoneField;\n\n        public XMLCalendarFormat() {\n            super( Calendar.class );\n            try {\n                _zoneField = Calendar.class.getDeclaredField( \"zone\" );\n                _zoneField.setAccessible( true );\n            } catch ( final Exception e ) {\n                throw new RuntimeException( e );\n            }\n        }\n\n        @Override\n        public Calendar newInstance( final Class<Calendar> clazz, final javolution.xml.XMLFormat.InputElement arg1 ) throws XMLStreamException {\n            if ( clazz.equals( GregorianCalendar.class ) ) {\n                return GregorianCalendar.getInstance();\n            }\n            throw new IllegalArgumentException( \"Calendar of type \" + clazz.getName()\n                    + \" not yet supported. Please submit an issue so that it will be implemented.\" );\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Calendar obj ) throws XMLStreamException {\n            /* check if we actually need to set the timezone, as\n             * TimeZone.getTimeZone is synchronized, so we might prevent this\n             */\n            final String timeZoneId = xml.getAttribute( \"tz\", \"\" );\n            if ( !getTimeZone( obj ).getID().equals( timeZoneId ) ) {\n                obj.setTimeZone( TimeZone.getTimeZone( timeZoneId ) );\n            }\n            obj.setMinimalDaysInFirstWeek( xml.getAttribute( \"minimalDaysInFirstWeek\", -1 ) );\n            obj.setFirstDayOfWeek( xml.getAttribute( \"firstDayOfWeek\", -1 ) );\n            obj.setLenient( xml.getAttribute( \"lenient\", true ) );\n            obj.setTimeInMillis( xml.getAttribute( \"timeInMillis\", -1L ) );\n        }\n\n        @Override\n        public void write( final Calendar obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n\n            if ( !obj.getClass().equals( GregorianCalendar.class ) ) {\n                throw new IllegalArgumentException( \"Calendar of type \" + obj.getClass().getName()\n                        + \" not yet supported. Please submit an issue so that it will be implemented.\" );\n            }\n\n            xml.setAttribute( \"timeInMillis\", obj.getTimeInMillis() );\n            xml.setAttribute( \"lenient\", obj.isLenient() );\n            xml.setAttribute( \"firstDayOfWeek\", obj.getFirstDayOfWeek() );\n            xml.setAttribute( \"minimalDaysInFirstWeek\", obj.getMinimalDaysInFirstWeek() );\n            xml.setAttribute( \"tz\", getTimeZone( obj ).getID() );\n        }\n\n        private TimeZone getTimeZone( final Calendar obj ) throws XMLStreamException {\n            /* access the timezone via the field, to prevent cloning of the tz */\n            try {\n                return (TimeZone) _zoneField.get( obj );\n            } catch ( final Exception e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n\n    }\n\n    public static final class XMLJdkProxyFormat extends XMLFormat<Object> {\n\n        private final ClassLoader _classLoader;\n\n        public XMLJdkProxyFormat( final ClassLoader classLoader ) {\n            super( null );\n            _classLoader = classLoader;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isReferenceable() {\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object newInstance( final Class<Object> clazz, final javolution.xml.XMLFormat.InputElement input )\n            throws XMLStreamException {\n            final InvocationHandler invocationHandler = input.get( \"handler\" );\n            final Class<?>[] interfaces = getInterfaces( input );\n            return Proxy.newProxyInstance( _classLoader, interfaces, invocationHandler );\n        }\n\n        private Class<?>[] getInterfaces( final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException {\n            final String[] interfaceNames = input.get( \"interfaces\" );\n            if ( interfaceNames != null ) {\n                try {\n                    final Class<?>[] interfaces = new Class<?>[interfaceNames.length];\n                    for ( int i = 0; i < interfaceNames.length; i++ ) {\n                        interfaces[i] = Class.forName( interfaceNames[i], true, _classLoader );\n                    }\n                    return interfaces;\n                } catch ( final ClassNotFoundException e ) {\n                    throw new XMLStreamException( e );\n                }\n            }\n            return new Class<?>[0];\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement input, final Object obj ) throws XMLStreamException {\n            // nothing to do\n        }\n\n        @Override\n        public final void write( final Object obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException {\n            final InvocationHandler invocationHandler = Proxy.getInvocationHandler( obj );\n            output.add( invocationHandler, \"handler\" );\n            final String[] interfaceNames = getInterfaceNames( obj );\n            output.add( interfaceNames, \"interfaces\" );\n        }\n\n        private String[] getInterfaceNames( final Object obj ) {\n            final Class<?>[] interfaces = obj.getClass().getInterfaces();\n            if ( interfaces != null ) {\n                final String[] interfaceNames = new String[interfaces.length];\n                for ( int i = 0; i < interfaces.length; i++ ) {\n                    interfaceNames[i] = interfaces[i].getName();\n                }\n                return interfaceNames;\n            }\n            return new String[0];\n        }\n\n    }\n\n    public static final XMLFormat<StringBuilder> STRING_BUILDER_FORMAT = new XMLFormat<StringBuilder>( StringBuilder.class ) {\n\n        public StringBuilder newInstance( final Class<StringBuilder> cls, final InputElement xml ) throws XMLStreamException {\n            return new StringBuilder( xml.getAttribute( \"val\" ) );\n        }\n\n        @Override\n        public void read( final InputElement xml, final StringBuilder obj ) throws XMLStreamException {\n            // nothing todo\n        }\n\n        @Override\n        public void write( final StringBuilder obj, final OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"val\", obj.toString() );\n        }\n\n    };\n\n    public static final XMLFormat<StringBuffer> STRING_BUFFER_FORMAT = new XMLFormat<StringBuffer>( StringBuffer.class ) {\n\n        public StringBuffer newInstance( final Class<StringBuffer> cls, final InputElement xml ) throws XMLStreamException {\n            return new StringBuffer( xml.getAttribute( \"val\" ) );\n        }\n\n        @Override\n        public void read( final InputElement xml, final StringBuffer obj ) throws XMLStreamException {\n            // nothing todo\n        }\n\n        @Override\n        public void write( final StringBuffer obj, final OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"val\", obj.toString() );\n        }\n\n    };\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Currency;\nimport java.util.GregorianCalendar;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javolution.lang.Reflection;\nimport javolution.text.CharArray;\nimport javolution.xml.XMLBinding;\nimport javolution.xml.XMLFormat;\nimport javolution.xml.XMLSerializable;\nimport javolution.xml.stream.XMLStreamException;\nimport javolution.xml.stream.XMLStreamReader;\nimport javolution.xml.stream.XMLStreamWriter;\n\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport sun.reflect.ReflectionFactory;\n\n/**\n * An {@link XMLBinding} that provides class bindings based on reflection.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ReflectionBinding extends XMLBinding {\n\n    public static final String CLASS = \"class\";\n\n    private static final long serialVersionUID = -7047053153745571559L;\n\n    private static final Log LOG = LogFactory.getLog( ReflectionBinding.class );\n\n    private static final ReflectionFactory REFLECTION_FACTORY = ReflectionFactory.getReflectionFactory();\n    private static final Object[] INITARGS = new Object[0];\n    private static final String SIZE = \"size\";\n\n    private static final XMLCalendarFormat CALENDAR_FORMAT = new XMLCalendarFormat();\n\n    private static final XMLCurrencyFormat CURRENCY_FORMAT = new XMLCurrencyFormat();\n\n    private final Map<Class<?>, XMLFormat<?>> _formats = new ConcurrentHashMap<Class<?>, XMLFormat<?>>();\n\n    private final ClassLoader _classLoader;\n    private final XMLEnumFormat _enumFormat;\n    private final XMLArrayFormat _arrayFormat;\n    private final XMLCollectionFormat _collectionFormat;\n    private final XMLMapFormat _mapFormat;\n    private final XMLJdkProxyFormat _jdkProxyFormat;\n    private final CustomXMLFormat<?>[] _customFormats;\n\n    public ReflectionBinding( final ClassLoader classLoader ) {\n        this( classLoader, false );\n    }\n\n    public ReflectionBinding( final ClassLoader classLoader, final boolean copyCollectionsForSerialization,\n            final CustomXMLFormat<?> ... customFormats ) {\n        _classLoader = classLoader;\n        _enumFormat = new XMLEnumFormat( classLoader );\n        _arrayFormat = new XMLArrayFormat( classLoader );\n        _collectionFormat = new XMLCollectionFormat( copyCollectionsForSerialization );\n        _mapFormat = new XMLMapFormat( copyCollectionsForSerialization );\n        _jdkProxyFormat = new XMLJdkProxyFormat( classLoader );\n        _customFormats = customFormats;\n\n        Reflection.getInstance().add( classLoader );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    protected void writeClass( Class cls, final XMLStreamWriter writer, final boolean useAttributes ) throws XMLStreamException {\n\n        if ( Proxy.isProxyClass( cls ) ) {\n            cls = Proxy.class;\n        }\n\n        CustomXMLFormat<?> xmlFormat = null;\n        if ( ( xmlFormat = getCustomFormat( cls ) ) != null ) {\n            cls = xmlFormat.getTargetClass( cls );\n        }\n\n        if ( useAttributes ) {\n            writer.writeAttribute( CLASS, cls.getName() );\n        } else {\n            writer.writeStartElement( cls.getName() );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    protected Class readClass( final XMLStreamReader reader, final boolean useAttributes ) throws XMLStreamException {\n        final CharArray className = useAttributes\n            ? reader.getAttributeValue( null, CLASS )\n            : reader.getLocalName();\n        try {\n            return Class.forName( className.toString(), true, _classLoader );\n        } catch ( final ClassNotFoundException e ) {\n            throw new XMLStreamException( e );\n        }\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    @Override\n    public XMLFormat<?> getFormat( final Class cls ) throws XMLStreamException {\n\n        XMLFormat<?> xmlFormat = _formats.get( cls );\n        if ( xmlFormat != null ) {\n            return xmlFormat;\n        }\n\n        /* after reflection based formats check custom formats. this is\n         * required for the cglib extension, and is useful to allow the user\n         * to overwrite existing formats\n         */\n        if ( ( xmlFormat = getCustomFormat( cls ) ) != null ) {\n            return xmlFormat;\n        } else if ( cls.isPrimitive()\n                || cls == String.class\n                || cls == Boolean.class\n                || cls == Integer.class\n                || cls == Long.class\n                || cls == Short.class\n                || cls == Double.class\n                || cls == Float.class\n                || cls == Character.class\n                || cls == Byte.class\n                || cls == Class.class ) {\n            return super.getFormat( cls );\n        } else if ( XMLSerializable.class.isAssignableFrom( cls ) ) {\n            return super.getFormat( cls );\n        } else if ( cls.isArray() ) {\n            return getArrayFormat( cls );\n        } else if ( Collection.class.isAssignableFrom( cls )\n                && Modifier.isPublic( cls.getModifiers() ) ) {\n            // the check for the private modifier is required, so that\n            // lists like Arrays.ArrayList are handled by the ReflectionFormat\n            return _collectionFormat;\n        }  else if ( Map.class.isAssignableFrom( cls )\n                && Modifier.isPublic( cls.getModifiers() ) ) {\n            return _mapFormat;\n        } else if ( cls.isEnum() ) {\n            return _enumFormat;\n        } else if ( Calendar.class.isAssignableFrom( cls ) ) {\n            return CALENDAR_FORMAT;\n        } else if ( Currency.class.isAssignableFrom( cls ) ) {\n            return CURRENCY_FORMAT;\n        } else if ( Proxy.isProxyClass( cls ) || cls == Proxy.class ) {\n            /* the Proxy.isProxyClass check is required for serialization,\n             * Proxy.class is required for deserialization\n             */\n            return _jdkProxyFormat;\n        } else if ( cls == StringBuilder.class ) {\n            return STRING_BUILDER_FORMAT;\n        } else if ( cls == StringBuffer.class ) {\n            return STRING_BUFFER_FORMAT;\n        } else {\n            if ( xmlFormat == null ) {\n                if ( ReflectionFormat.isNumberFormat( cls ) ) {\n                    xmlFormat = ReflectionFormat.getNumberFormat( cls );\n                } else {\n                    xmlFormat = new ReflectionFormat( cls, _classLoader );\n                }\n                _formats.put( cls, xmlFormat );\n            }\n            return xmlFormat;\n        }\n    }\n\n    private CustomXMLFormat<?> getCustomFormat( final Class<?> cls ) {\n        if ( _customFormats == null ) {\n            return null;\n        }\n        for( final CustomXMLFormat<?> xmlFormat : _customFormats ) {\n            if ( xmlFormat.canConvert( cls ) ) {\n                return xmlFormat;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private XMLFormat getArrayFormat( final Class cls ) {\n        if ( cls == int[].class ) {\n            return XMLArrayFormats.INT_ARRAY_FORMAT;\n        } else if ( cls == long[].class ) {\n            return XMLArrayFormats.LONG_ARRAY_FORMAT;\n        } else if ( cls == short[].class ) {\n            return XMLArrayFormats.SHORT_ARRAY_FORMAT;\n        } else if ( cls == float[].class ) {\n            return XMLArrayFormats.FLOAT_ARRAY_FORMAT;\n        } else if ( cls == double[].class ) {\n            return XMLArrayFormats.DOUBLE_ARRAY_FORMAT;\n        } else if ( cls == char[].class ) {\n            return XMLArrayFormats.CHAR_ARRAY_FORMAT;\n        } else if ( cls == byte[].class ) {\n            return XMLArrayFormats.BYTE_ARRAY_FORMAT;\n        } else {\n            return _arrayFormat;\n        }\n    }\n\n    static class XMLEnumFormat extends XMLFormat<Enum<?>> {\n\n        private final ClassLoader _classLoader;\n\n        public XMLEnumFormat( final ClassLoader classLoader ) {\n            super( null );\n            _classLoader = classLoader;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Enum<?> newInstance( final Class<Enum<?>> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            final String value = xml.getAttribute( \"value\" ).toString();\n            final String clazzName = xml.getAttribute( \"type\" ).toString();\n            try {\n                @SuppressWarnings( \"unchecked\" )\n                final Enum<?> enumValue = Enum.valueOf( Class.forName( clazzName, true, _classLoader ).asSubclass( Enum.class ), value );\n                return enumValue;\n            } catch ( final ClassNotFoundException e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Enum<?> object ) throws XMLStreamException {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write( final Enum<?> object, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"value\", object.name() );\n            xml.setAttribute( \"type\", object.getClass().getName() );\n        }\n\n    }\n\n    public static class XMLArrayFormat extends XMLFormat<Object[]> {\n\n        private final ClassLoader _classLoader;\n\n        public XMLArrayFormat( final ClassLoader classLoader ) {\n            super( null );\n            _classLoader = classLoader;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( \"unchecked\" )\n        @Override\n        public Object[] newInstance( final Class clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException {\n            try {\n                final String componentType = input.getAttribute( \"componentType\", (String) null );\n                final int length = input.getAttribute( \"length\", 0 );\n                return (Object[]) Array.newInstance( Class.forName( componentType, false, _classLoader ), length );\n            } catch ( final Exception e ) {\n                LOG.error( \"caught exception\", e );\n                throw new XMLStreamException( e );\n            }\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement input, final Object[] array ) throws XMLStreamException {\n            int i = 0;\n            while ( input.hasNext() ) {\n                array[i++] = input.getNext();\n            }\n        }\n\n        @Override\n        public final void write( final Object[] array, final javolution.xml.XMLFormat.OutputElement output )\n            throws XMLStreamException {\n            output.setAttribute( \"type\", \"array\" );\n            output.setAttribute( \"componentType\", array.getClass().getComponentType().getName() );\n            output.setAttribute( \"length\", array.length );\n            writeElements( array, output );\n        }\n\n        public void writeElements( final Object[] array, final javolution.xml.XMLFormat.OutputElement output )\n            throws XMLStreamException {\n            for ( final Object item : array ) {\n                output.add( item );\n            }\n        }\n\n    }\n\n    public static class XMLCollectionFormat extends XMLFormat<Collection<Object>> {\n\n        private final boolean _copyForWrite;\n\n        protected XMLCollectionFormat( final boolean copyForWrite ) {\n            super( null );\n            _copyForWrite = copyForWrite;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( \"unchecked\" )\n        @Override\n        public Collection<Object> newInstance( final Class<Collection<Object>> cls, final javolution.xml.XMLFormat.InputElement xml )\n            throws XMLStreamException {\n\n            Collection<Object> result = newInstanceFromPublicConstructor( cls, xml );\n\n            if ( result == null && Modifier.isPrivate( cls.getModifiers() ) ) {\n                try {\n                    final Constructor<?> constructor = REFLECTION_FACTORY.newConstructorForSerialization( cls, Object.class.getDeclaredConstructor( new Class[0] ) );\n                    constructor.setAccessible( true );\n                    return (Collection<Object>) constructor.newInstance( INITARGS );\n                } catch ( final Exception e ) {\n                    throw new XMLStreamException( e );\n                }\n            }\n\n            if ( result == null ) {\n                result = super.newInstance( cls, xml );\n            }\n\n            return result;\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Collection<Object> obj ) throws XMLStreamException {\n            while ( xml.hasNext() ) {\n                obj.add( xml.getNext() );\n            }\n        }\n\n        @Override\n        public void write( final Collection<Object> obj, final javolution.xml.XMLFormat.OutputElement xml )\n            throws XMLStreamException {\n            xml.setAttribute( SIZE, obj.size() );\n            for ( final Object item : _copyForWrite ? new ArrayList<Object>( obj ) : obj ) {\n                xml.add( item );\n            }\n        }\n\n    }\n\n    public static class XMLMapFormat extends XMLFormat<Map<Object,Object>> {\n\n        private final boolean _copyForWrite;\n\n        protected XMLMapFormat( final boolean copyForWrite ) {\n            super( null );\n            _copyForWrite = copyForWrite;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( \"unchecked\" )\n        @Override\n        public Map<Object, Object> newInstance( final Class<Map<Object, Object>> cls, final javolution.xml.XMLFormat.InputElement xml )\n            throws XMLStreamException {\n\n            Map<Object, Object> result = newInstanceFromPublicConstructor( cls, xml );\n\n            if ( result == null && Modifier.isPrivate( cls.getModifiers() ) ) {\n                try {\n                    final Constructor<?> constructor = REFLECTION_FACTORY.newConstructorForSerialization( cls, Object.class.getDeclaredConstructor( new Class[0] ) );\n                    constructor.setAccessible( true );\n                    result = (Map<Object, Object>) constructor.newInstance( INITARGS );\n                } catch ( final Exception e ) {\n                    throw new XMLStreamException( e );\n                }\n            }\n\n            if ( result == null ) {\n                result = super.newInstance( cls, xml );\n            }\n\n            return result;\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Map<Object,Object> obj ) throws XMLStreamException {\n            while ( xml.hasNext() ) {\n                obj.put(xml.get(\"k\"), xml.get(\"v\"));\n            }\n        }\n\n        @Override\n        public void write( final Map<Object,Object> obj, final javolution.xml.XMLFormat.OutputElement xml )\n            throws XMLStreamException {\n            xml.setAttribute( SIZE, obj.size() );\n            final Set<Entry<Object, Object>> entrySet = _copyForWrite ? new LinkedHashMap<Object, Object>( obj ).entrySet() : obj.entrySet();\n            for ( final Map.Entry<Object, Object> entry : entrySet ) {\n                xml.add( entry.getKey(), \"k\" );\n                xml.add( entry.getValue(), \"v\" );\n            }\n        }\n\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private static <T> T newInstanceFromPublicConstructor( final Class<T> cls,\n            final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n        try {\n            final Constructor<?>[] constructors = cls.getConstructors();\n            for ( final Constructor<?> constructor : constructors ) {\n                final Class<?>[] parameterTypes = constructor.getParameterTypes();\n                if ( parameterTypes.length == 0 ) {\n                    return (T) constructor.newInstance();\n                }\n                else if ( parameterTypes.length == 1 && parameterTypes[0] == int.class ) {\n                    final CharArray size = xml.getAttribute( SIZE );\n                    if ( size != null ) {\n                        return (T) constructor.newInstance( size.toInt() );\n                    }\n                }\n            }\n            if ( LOG.isDebugEnabled() && constructors.length > 0 ) {\n                LOG.debug( \"No suitable constructor found for map \" + cls + \", available constructors:\\n\" +\n                        Arrays.asList( constructors ) );\n            }\n        } catch ( final SecurityException e ) {\n            // ignore\n        } catch ( final IllegalArgumentException e ) {\n            throw new XMLStreamException( e ); // not expected\n        } catch ( final InstantiationException e ) {\n            throw new XMLStreamException( e ); // not expected\n        } catch ( final IllegalAccessException e ) {\n            throw new XMLStreamException( e ); // not expected\n        } catch ( final InvocationTargetException e ) {\n            // ignore - constructor threw exception\n            LOG.info( \"Tried to invoke int constructor on \" + cls.getName() + \", this threw an exception.\", e.getTargetException() );\n        }\n        return null;\n    }\n\n    public static class XMLCurrencyFormat extends XMLFormat<Currency> {\n\n        public XMLCurrencyFormat() {\n            super( Currency.class );\n        }\n\n        /**\n         * Currency instance do not have to be handled by the reference resolver, as we're using\n         * Currency.getInstance for retrieving an instance.\n         *\n         * @return <code>false<\/code>\n         */\n        @Override\n        public boolean isReferenceable() {\n            return false;\n        }\n\n        @Override\n        public Currency newInstance( final Class<Currency> cls, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return Currency.getInstance( xml.getAttribute( \"code\", \"\" ) );\n        }\n\n        public void write( final Currency currency, final OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"code\", currency.getCurrencyCode() );\n        }\n\n        public void read( final InputElement xml, final Currency pos ) {\n            // Immutable, deserialization occurs at creation, ref. newIntance(...)\n        }\n\n    }\n\n    /**\n     * An {@link XMLFormat} for {@link Calendar} that serialized those calendar\n     * fields that contain actual data (these fields also are used by\n     * {@link Calendar#equals(Object)}.\n     */\n    public static class XMLCalendarFormat extends XMLFormat<Calendar> {\n\n        private final Field _zoneField;\n\n        public XMLCalendarFormat() {\n            super( Calendar.class );\n            try {\n                _zoneField = Calendar.class.getDeclaredField( \"zone\" );\n                _zoneField.setAccessible( true );\n            } catch ( final Exception e ) {\n                throw new RuntimeException( e );\n            }\n        }\n\n        @Override\n        public Calendar newInstance( final Class<Calendar> clazz, final javolution.xml.XMLFormat.InputElement arg1 ) throws XMLStreamException {\n            if ( clazz.equals( GregorianCalendar.class ) ) {\n                return GregorianCalendar.getInstance();\n            }\n            throw new IllegalArgumentException( \"Calendar of type \" + clazz.getName()\n                    + \" not yet supported. Please submit an issue so that it will be implemented.\" );\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final Calendar obj ) throws XMLStreamException {\n            /* check if we actually need to set the timezone, as\n             * TimeZone.getTimeZone is synchronized, so we might prevent this\n             */\n            final String timeZoneId = xml.getAttribute( \"tz\", \"\" );\n            if ( !getTimeZone( obj ).getID().equals( timeZoneId ) ) {\n                obj.setTimeZone( TimeZone.getTimeZone( timeZoneId ) );\n            }\n            obj.setMinimalDaysInFirstWeek( xml.getAttribute( \"minimalDaysInFirstWeek\", -1 ) );\n            obj.setFirstDayOfWeek( xml.getAttribute( \"firstDayOfWeek\", -1 ) );\n            obj.setLenient( xml.getAttribute( \"lenient\", true ) );\n            obj.setTimeInMillis( xml.getAttribute( \"timeInMillis\", -1L ) );\n        }\n\n        @Override\n        public void write( final Calendar obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n\n            if ( !obj.getClass().equals( GregorianCalendar.class ) ) {\n                throw new IllegalArgumentException( \"Calendar of type \" + obj.getClass().getName()\n                        + \" not yet supported. Please submit an issue so that it will be implemented.\" );\n            }\n\n            xml.setAttribute( \"timeInMillis\", obj.getTimeInMillis() );\n            xml.setAttribute( \"lenient\", obj.isLenient() );\n            xml.setAttribute( \"firstDayOfWeek\", obj.getFirstDayOfWeek() );\n            xml.setAttribute( \"minimalDaysInFirstWeek\", obj.getMinimalDaysInFirstWeek() );\n            xml.setAttribute( \"tz\", getTimeZone( obj ).getID() );\n        }\n\n        private TimeZone getTimeZone( final Calendar obj ) throws XMLStreamException {\n            /* access the timezone via the field, to prevent cloning of the tz */\n            try {\n                return (TimeZone) _zoneField.get( obj );\n            } catch ( final Exception e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n\n    }\n\n    public static final class XMLJdkProxyFormat extends XMLFormat<Object> {\n\n        private final ClassLoader _classLoader;\n\n        public XMLJdkProxyFormat( final ClassLoader classLoader ) {\n            super( null );\n            _classLoader = classLoader;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isReferenceable() {\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object newInstance( final Class<Object> clazz, final javolution.xml.XMLFormat.InputElement input )\n            throws XMLStreamException {\n            final InvocationHandler invocationHandler = input.get( \"handler\" );\n            final Class<?>[] interfaces = getInterfaces( input, \"interfaces\", _classLoader );\n            return Proxy.newProxyInstance( _classLoader, interfaces, invocationHandler );\n        }\n\n        public static Class<?>[] getInterfaces( final javolution.xml.XMLFormat.InputElement input,\n                final String elementName,\n                final ClassLoader classLoader ) throws XMLStreamException {\n            final String[] interfaceNames = input.get( elementName );\n            if ( interfaceNames != null ) {\n                try {\n                    final Class<?>[] interfaces = new Class<?>[interfaceNames.length];\n                    for ( int i = 0; i < interfaceNames.length; i++ ) {\n                        interfaces[i] = Class.forName( interfaceNames[i], true, classLoader );\n                    }\n                    return interfaces;\n                } catch ( final ClassNotFoundException e ) {\n                    throw new XMLStreamException( e );\n                }\n            }\n            return new Class<?>[0];\n        }\n\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement input, final Object obj ) throws XMLStreamException {\n            // nothing to do\n        }\n\n        @Override\n        public final void write( final Object obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException {\n            final InvocationHandler invocationHandler = Proxy.getInvocationHandler( obj );\n            output.add( invocationHandler, \"handler\" );\n            final String[] interfaceNames = getInterfaceNames( obj );\n            output.add( interfaceNames, \"interfaces\" );\n        }\n\n        public static String[] getInterfaceNames( final Object obj ) {\n            final Class<?>[] interfaces = obj.getClass().getInterfaces();\n            if ( interfaces != null ) {\n                final String[] interfaceNames = new String[interfaces.length];\n                for ( int i = 0; i < interfaces.length; i++ ) {\n                    interfaceNames[i] = interfaces[i].getName();\n                }\n                return interfaceNames;\n            }\n            return new String[0];\n        }\n\n    }\n\n    public static final XMLFormat<StringBuilder> STRING_BUILDER_FORMAT = new XMLFormat<StringBuilder>( StringBuilder.class ) {\n\n        public StringBuilder newInstance( final Class<StringBuilder> cls, final InputElement xml ) throws XMLStreamException {\n            return new StringBuilder( xml.getAttribute( \"val\" ) );\n        }\n\n        @Override\n        public void read( final InputElement xml, final StringBuilder obj ) throws XMLStreamException {\n            // nothing todo\n        }\n\n        @Override\n        public void write( final StringBuilder obj, final OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"val\", obj.toString() );\n        }\n\n    };\n\n    public static final XMLFormat<StringBuffer> STRING_BUFFER_FORMAT = new XMLFormat<StringBuffer>( StringBuffer.class ) {\n\n        public StringBuffer newInstance( final Class<StringBuffer> cls, final InputElement xml ) throws XMLStreamException {\n            return new StringBuffer( xml.getAttribute( \"val\" ) );\n        }\n\n        @Override\n        public void read( final InputElement xml, final StringBuffer obj ) throws XMLStreamException {\n            // nothing todo\n        }\n\n        @Override\n        public void write( final StringBuffer obj, final OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"val\", obj.toString() );\n        }\n\n    };\n\n}\n","lineNo":456}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Stores the provided session in memcached if the session was modified\n * or if the session needs to be relocated (set <code>force<\/code> to <code>true<\/code>).\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class BackupSessionTask implements Callable<BackupResultStatus> {\n\n    private static final Log _log = LogFactory.getLog( BackupSessionTask.class );\n\n    /* the original session id is stored so that we can set this if no\n     * memcached node is left for taking over\n     */\n    private static final String ORIG_SESSION_ID_KEY = \"orig.sessionid\";\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    private final MemcachedBackupSession _session;\n    private final boolean _force;\n    private final TranscoderService _transcoderService;\n    private final boolean _sessionBackupAsync;\n    private final int _sessionBackupTimeout;\n    private final MemcachedClient _memcached;\n    private final NodeIdService _nodeIdService;\n    private final Statistics _statistics;\n\n    /**\n     * @param session\n     *            the session to save\n     * @param force\n     *            specifies, if the session needs to be saved by all means, e.g.\n     *            as it has to be relocated to another memcached\n     *            node (the session id had been changed before in this case).\n     * @param sessionBackupAsync\n     * @param sessionBackupTimeout\n     * @param memcached\n     * @param nodeAvailabilityCache\n     * @param nodeIds\n     * @param failoverNodeIds\n     */\n    public BackupSessionTask( final MemcachedBackupSession session,\n            final boolean force,\n            final TranscoderService transcoderService,\n            final boolean sessionBackupAsync,\n            final int sessionBackupTimeout,\n            final MemcachedClient memcached,\n            final NodeIdService nodeIdService,\n            final Statistics statistics ) {\n        _session = session;\n        _force = force;\n        _transcoderService = transcoderService;\n        _sessionBackupAsync = sessionBackupAsync;\n        _sessionBackupTimeout = sessionBackupTimeout;\n        _memcached = memcached;\n        _nodeIdService = nodeIdService;\n        _statistics = statistics;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public BackupResultStatus call() throws Exception {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Starting for session id \" + _session.getId() );\n        }\n\n        _session.setBackupRunning( true );\n        try {\n\n            final long startBackup = System.currentTimeMillis();\n\n            final Map<String, Object> attributes = _session.getAttributesInternal();\n\n            final byte[] attributesData = serializeAttributes( _session, attributes );\n            final int hashCode = Arrays.hashCode( attributesData );\n            final BackupResultStatus result;\n            if ( _session.getDataHashCode() != hashCode\n                    || _force\n                    || _session.authenticationChanged() ) {\n                final byte[] data = _transcoderService.serialize( _session, attributesData );\n\n                final BackupResult backupResult = doBackupSession( _session, data, attributesData );\n                if ( backupResult.isSuccess() || backupResult.isRelocated() ) {\n                    /* we can use the already calculated hashcode if we have still the same\n                     * attributes data, which is the case for the most common case SUCCESS\n                     */\n                    final int newHashCode = backupResult.getAttributesData() == attributesData\n                        ? hashCode\n                        : Arrays.hashCode( backupResult.getAttributesData() );\n                    _session.setDataHashCode( newHashCode );\n                }\n\n                result = backupResult.getStatus();\n            } else {\n                result = BackupResultStatus.SKIPPED;\n            }\n\n            switch ( result ) {\n                case FAILURE:\n                    _statistics.requestWithBackupFailure();\n                    break;\n                case SKIPPED:\n                    _statistics.requestWithoutSessionModification();\n                    _session.storeThisAccessedTimeFromLastBackupCheck();\n                    break;\n                case SUCCESS:\n                    _statistics.requestWithBackup();\n                    _statistics.getBackupProbe().registerSince( startBackup );\n                    _session.storeThisAccessedTimeFromLastBackupCheck();\n                    _session.backupFinished();\n                    break;\n                case RELOCATED:\n                    _statistics.requestWithBackupRelocation();\n                    _statistics.getBackupRelocationProbe().registerSince( startBackup );\n                    _session.storeThisAccessedTimeFromLastBackupCheck();\n                    _session.backupFinished();\n                    break;\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Finished for session id \" + _session.getId() +\n                        \", returning status \" + result );\n            }\n\n            return result;\n\n        } finally {\n            _session.setBackupRunning( false );\n        }\n\n    }\n\n    private byte[] serializeAttributes( final MemcachedBackupSession session, final Map<String, Object> attributes ) {\n        final long start = System.currentTimeMillis();\n        final byte[] attributesData = _transcoderService.serializeAttributes( session, attributes );\n        _statistics.getAttributesSerializationProbe().registerSince( start );\n        return attributesData;\n    }\n\n    /**\n     * Store the provided session in memcached.\n     * @param session the session to backup\n     * @param data the serialized session data (session fields and session attributes).\n     * @param attributesData just the serialized session attributes.\n     *\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    BackupResult doBackupSession( final MemcachedBackupSession session, final byte[] data, final byte[] attributesData ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Trying to store session in memcached: \" + session.getId() );\n        }\n\n        try {\n\n            storeSessionInMemcached( session, data );\n\n            return new BackupResult( BackupResultStatus.SUCCESS, attributesData );\n        } catch ( final NodeFailureException e ) {\n            if ( _log.isInfoEnabled() ) {\n                _log.info( \"Could not store session \" + session.getId() +\n                        \" in memcached due to unavailable node \" + e.getNodeId() );\n            }\n\n            /*\n             * get the next memcached node to try\n             */\n            final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n            final String targetNodeId = _nodeIdService.getAvailableNodeId( nodeId );\n\n            if ( targetNodeId == null ) {\n\n                if ( _log.isInfoEnabled() ) {\n                    _log.info( \"The node \" + nodeId\n                            + \" is not available and there's no node for relocation left, omitting session backup.\" );\n                }\n\n                noFailoverNodeLeft( session );\n\n                return new BackupResult( BackupResultStatus.FAILURE, null );\n\n            } else {\n\n                final BackupResult backupResult = failover( session, targetNodeId );\n                final BackupResultStatus translatedStatus = handleAndTranslateFailoverBackupResult( session, backupResult.getStatus() );\n\n                return new BackupResult( translatedStatus, backupResult.getAttributesData() );\n            }\n        }\n    }\n\n    private BackupResultStatus handleAndTranslateFailoverBackupResult( final MemcachedBackupSession session,\n            final BackupResultStatus backupResult ) {\n        switch ( backupResult ) {\n            case SUCCESS:\n\n                //_relocatedSessions.put( session.getNote( ORIG_SESSION_ID ).toString(), session.getId() );\n\n                /*\n                 * cleanup\n                 */\n                session.removeNote( ORIG_SESSION_ID_KEY );\n\n                /*\n                 * and tell our client to do his part as well\n                 */\n                return BackupResultStatus.RELOCATED;\n            default:\n                /*\n                 * just pass it up\n                 */\n                return backupResult;\n\n        }\n    }\n\n    private BackupResult failover( final MemcachedBackupSession session, final String targetNodeId ) {\n        /*\n         * we must store the original session id so that we can set this if no\n         * memcached node is left for taking over\n         */\n        if ( session.getNote( ORIG_SESSION_ID_KEY ) == null ) {\n            session.setNote( ORIG_SESSION_ID_KEY, session.getId() );\n        }\n\n        /*\n         * relocate session to our memcached node...\n         */\n        session.setIdForRelocate( _sessionIdFormat.createNewSessionId( session.getId(), targetNodeId ) );\n\n        /* the serialized session data needs to be recreated as it changed.\n         */\n        final byte[] attributesData = serializeAttributes( session, session.getAttributesInternal() );\n        final byte[] data = _transcoderService.serialize( session, attributesData );\n\n        /*\n         * invoke backup again, until we have a success or a failure\n         */\n        final BackupResult backupResult = doBackupSession( session, data, attributesData );\n\n        return backupResult;\n    }\n\n    private void noFailoverNodeLeft( final MemcachedBackupSession session ) {\n\n        /*\n         * we must set the original session id in case we changed it already\n         */\n        final String origSessionId = (String) session.getNote( ORIG_SESSION_ID_KEY );\n        if ( origSessionId != null && !origSessionId.equals( session.getId() ) ) {\n            session.setIdForRelocate( origSessionId );\n        }\n\n        /*\n         * cleanup\n         */\n        session.removeNote( ORIG_SESSION_ID_KEY );\n    }\n\n    private void storeSessionInMemcached( final MemcachedBackupSession session, final byte[] data) throws NodeFailureException {\n\n        /* calculate the expiration time (instead of using just maxInactiveInterval), as\n         * this is relevant for the update of the expiration time: if we would just use\n         * maxInactiveInterval, the session would exist longer in memcached than it would\n         * be valid in tomcat\n         */\n        final int expirationTime = session.getMemcachedExpirationTimeToSet();\n        final long start = System.currentTimeMillis();\n        try {\n            final Future<Boolean> future = _memcached.set( session.getId(), expirationTime, data );\n            if ( !_sessionBackupAsync ) {\n                try {\n                    future.get( _sessionBackupTimeout, TimeUnit.MILLISECONDS );\n                    session.setLastMemcachedExpirationTime( expirationTime );\n                    session.setLastBackupTimestamp( System.currentTimeMillis() );\n                } catch ( final Exception e ) {\n                    if ( _log.isInfoEnabled() ) {\n                        _log.info( \"Could not store session \" + session.getId() + \" in memcached.\" );\n                    }\n                    final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                    _nodeIdService.setNodeAvailable( nodeId, false );\n                    throw new NodeFailureException( \"Could not store session in memcached.\", nodeId );\n                }\n            }\n            else {\n                /* in async mode, we asume the session was stored successfully\n                 */\n                session.setLastMemcachedExpirationTime( expirationTime );\n                session.setLastBackupTimestamp( System.currentTimeMillis() );\n            }\n        } finally {\n            _statistics.getMemcachedUpdateProbe().registerSince( start );\n        }\n    }\n\n    static final class BackupResult {\n        private final BackupResultStatus _status;\n        private final byte[] _attributesData;\n        public BackupResult( final BackupResultStatus status, final byte[] attributesData ) {\n            _status = status;\n            _attributesData = attributesData;\n        }\n        /**\n         * The status/result of the backup operation.\n         * @return the status\n         */\n        BackupResultStatus getStatus() {\n            return _status;\n        }\n        /**\n         * The serialized attributes that were actually stored in memcached with the\n         * full serialized session data. This can be <code>null<\/code>, e.g. if\n         * {@link #getStatus()} is {@link BackupResultStatus#FAILURE}.\n         *\n         * @return the attributesData\n         */\n        byte[] getAttributesData() {\n            return _attributesData;\n        }\n        /**\n         * @return <code>true<\/code> if the status is {@link BackupResultStatus#SUCCESS},\n         * otherwise <code>false<\/code>.\n         */\n        public boolean isSuccess() {\n            return _status == BackupResultStatus.SUCCESS;\n        }\n        /**\n         * @return <code>true<\/code> if the status is {@link BackupResultStatus#RELOCATED},\n         * otherwise <code>false<\/code>.\n         */\n        public boolean isRelocated() {\n            return _status == BackupResultStatus.RELOCATED;\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Stores the provided session in memcached if the session was modified\n * or if the session needs to be relocated (set <code>force<\/code> to <code>true<\/code>).\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class BackupSessionTask implements Callable<BackupResultStatus> {\n\n    private static final Log _log = LogFactory.getLog( BackupSessionTask.class );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    private final MemcachedBackupSession _session;\n    private final boolean _force;\n    private final TranscoderService _transcoderService;\n    private final boolean _sessionBackupAsync;\n    private final int _sessionBackupTimeout;\n    private final MemcachedClient _memcached;\n    private final NodeIdService _nodeIdService;\n    private final Statistics _statistics;\n\n    /**\n     * @param session\n     *            the session to save\n     * @param force\n     *            specifies, if the session needs to be saved by all means, e.g.\n     *            as it has to be relocated to another memcached\n     *            node (the session id had been changed before in this case).\n     * @param sessionBackupAsync\n     * @param sessionBackupTimeout\n     * @param memcached\n     * @param nodeAvailabilityCache\n     * @param nodeIds\n     * @param failoverNodeIds\n     */\n    public BackupSessionTask( final MemcachedBackupSession session,\n            final boolean force,\n            final TranscoderService transcoderService,\n            final boolean sessionBackupAsync,\n            final int sessionBackupTimeout,\n            final MemcachedClient memcached,\n            final NodeIdService nodeIdService,\n            final Statistics statistics ) {\n        _session = session;\n        _force = force;\n        _transcoderService = transcoderService;\n        _sessionBackupAsync = sessionBackupAsync;\n        _sessionBackupTimeout = sessionBackupTimeout;\n        _memcached = memcached;\n        _nodeIdService = nodeIdService;\n        _statistics = statistics;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public BackupResultStatus call() throws Exception {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Starting for session id \" + _session.getId() );\n        }\n\n        _session.setBackupRunning( true );\n        try {\n\n            final long startBackup = System.currentTimeMillis();\n\n            final Map<String, Object> attributes = _session.getAttributesInternal();\n\n            final byte[] attributesData = serializeAttributes( _session, attributes );\n            final int hashCode = Arrays.hashCode( attributesData );\n            final BackupResultStatus result;\n            if ( _session.getDataHashCode() != hashCode\n                    || _force\n                    || _session.authenticationChanged() ) {\n                final byte[] data = _transcoderService.serialize( _session, attributesData );\n\n                final BackupResult backupResult = doBackupSession( _session, data, attributesData );\n                if ( backupResult.isSuccess() ) {\n                    _session.setDataHashCode( hashCode );\n                }\n\n                result = backupResult.getStatus();\n            } else {\n                result = BackupResultStatus.SKIPPED;\n            }\n\n            switch ( result ) {\n                case FAILURE:\n                    _statistics.requestWithBackupFailure();\n                    break;\n                case SKIPPED:\n                    _statistics.requestWithoutSessionModification();\n                    _session.storeThisAccessedTimeFromLastBackupCheck();\n                    break;\n                case SUCCESS:\n                    if ( _force ) {\n                        _statistics.requestWithBackupRelocation();\n                        _statistics.getBackupRelocationProbe().registerSince( startBackup );\n                    }\n                    else {\n                        _statistics.requestWithBackup();\n                        _statistics.getBackupProbe().registerSince( startBackup );\n                    }\n                    _session.storeThisAccessedTimeFromLastBackupCheck();\n                    _session.backupFinished();\n                    break;\n            }\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Finished for session id \" + _session.getId() +\n                        \", returning status \" + result );\n            }\n\n            return result;\n\n        } finally {\n            _session.setBackupRunning( false );\n        }\n\n    }\n\n    private byte[] serializeAttributes( final MemcachedBackupSession session, final Map<String, Object> attributes ) {\n        final long start = System.currentTimeMillis();\n        final byte[] attributesData = _transcoderService.serializeAttributes( session, attributes );\n        _statistics.getAttributesSerializationProbe().registerSince( start );\n        return attributesData;\n    }\n\n    /**\n     * Store the provided session in memcached.\n     * @param session the session to backup\n     * @param data the serialized session data (session fields and session attributes).\n     * @param attributesData just the serialized session attributes.\n     *\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    BackupResult doBackupSession( final MemcachedBackupSession session, final byte[] data, final byte[] attributesData ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"Trying to store session in memcached: \" + session.getId() );\n        }\n\n        try {\n\n            storeSessionInMemcached( session, data );\n\n            return new BackupResult( BackupResultStatus.SUCCESS, attributesData );\n        } catch ( final NodeFailureException e ) {\n            if ( _log.isInfoEnabled() ) {\n                String msg = \"Could not store session \" + session.getId() +\n                        \" in memcached due to unavailable node \" + e.getNodeId() + \".\";\n                if ( _force ) {\n                    msg += \"\\nNote that this session was relocated to this node because the original node was not available.\";\n                }\n                _log.info( msg );\n            }\n\n            return new BackupResult( BackupResultStatus.FAILURE, null );\n        }\n    }\n\n    private void storeSessionInMemcached( final MemcachedBackupSession session, final byte[] data) throws NodeFailureException {\n\n        /* calculate the expiration time (instead of using just maxInactiveInterval), as\n         * this is relevant for the update of the expiration time: if we would just use\n         * maxInactiveInterval, the session would exist longer in memcached than it would\n         * be valid in tomcat\n         */\n        final int expirationTime = session.getMemcachedExpirationTimeToSet();\n        final long start = System.currentTimeMillis();\n        try {\n            final Future<Boolean> future = _memcached.set( session.getId(), expirationTime, data );\n            if ( !_sessionBackupAsync ) {\n                try {\n                    future.get( _sessionBackupTimeout, TimeUnit.MILLISECONDS );\n                    session.setLastMemcachedExpirationTime( expirationTime );\n                    session.setLastBackupTimestamp( System.currentTimeMillis() );\n                } catch ( final Exception e ) {\n                    if ( _log.isInfoEnabled() ) {\n                        _log.info( \"Could not store session \" + session.getId() + \" in memcached.\" );\n                    }\n                    final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                    _nodeIdService.setNodeAvailable( nodeId, false );\n                    throw new NodeFailureException( \"Could not store session in memcached.\", nodeId );\n                }\n            }\n            else {\n                /* in async mode, we asume the session was stored successfully\n                 */\n                session.setLastMemcachedExpirationTime( expirationTime );\n                session.setLastBackupTimestamp( System.currentTimeMillis() );\n            }\n        } finally {\n            _statistics.getMemcachedUpdateProbe().registerSince( start );\n        }\n    }\n\n    static final class BackupResult {\n        private final BackupResultStatus _status;\n        private final byte[] _attributesData;\n        public BackupResult( final BackupResultStatus status, final byte[] attributesData ) {\n            _status = status;\n            _attributesData = attributesData;\n        }\n        /**\n         * The status/result of the backup operation.\n         * @return the status\n         */\n        BackupResultStatus getStatus() {\n            return _status;\n        }\n        /**\n         * The serialized attributes that were actually stored in memcached with the\n         * full serialized session data. This can be <code>null<\/code>, e.g. if\n         * {@link #getStatus()} is {@link BackupResultStatus#FAILURE}.\n         *\n         * @return the attributesData\n         */\n        byte[] getAttributesData() {\n            return _attributesData;\n        }\n        /**\n         * @return <code>true<\/code> if the status is {@link BackupResultStatus#SUCCESS},\n         * otherwise <code>false<\/code>.\n         */\n        public boolean isSuccess() {\n            return _status == BackupResultStatus.SUCCESS;\n        }\n    }\n\n}\n","lineNo":181}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.util.regex.Pattern;\n\n/**\n * This class defines the session id format: It creates session ids based on the\n * original session id and the memcached id, and it extracts the session id and\n * memcached id from a compound session id.\n * <p>\n * The session id is of the following format:\n * <code>[^-.]+-[^.]+(\\.[\\w]+)?<\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class SessionIdFormat {\n\n    /**\n     * The pattern for the session id.\n     */\n    private final Pattern _pattern = Pattern.compile( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" );\n\n    /**\n     * Create a session id including the provided memcachedId.\n     *\n     * @param sessionId\n     *            the original session id, it might contain the jvm route\n     * @param memcachedId\n     *            the memcached id to encode in the session id, may be <code>null<\/code>.\n     * @return the sessionId which now contains the memcachedId if one was provided, otherwise\n     *  the sessionId unmodified.\n     */\n    public String createSessionId( final String sessionId, final String memcachedId ) {\n        if ( memcachedId == null ) {\n            return sessionId;\n        }\n        final int idx = sessionId.indexOf( '.' );\n        if ( idx < 0 ) {\n            return sessionId + \"-\" + memcachedId;\n        } else {\n            return sessionId.substring( 0, idx ) + \"-\" + memcachedId + sessionId.substring( idx );\n        }\n    }\n\n    /**\n     * Change the provided session id already including a memcachedId so that it\n     * contains the provided newMemcachedId.\n     *\n     * @param sessionId\n     *            the session id containing the former memcachedId.\n     * @param newMemcachedId\n     *            the new memcached id.\n     * @return the sessionId which now contains the new memcachedId instead the\n     *         former one.\n     */\n    public String createNewSessionId( final String sessionId, final String newMemcachedId ) {\n        final int idxDash = sessionId.indexOf( '-' );\n        if ( idxDash < 0 ) {\n            return sessionId + \"-\" + newMemcachedId;\n        }\n\n        final int idxDot = sessionId.indexOf( '.' );\n        if ( idxDot < 0 ) {\n            return sessionId.substring( 0, idxDash + 1 ) + newMemcachedId;\n        } else {\n            return sessionId.substring( 0, idxDash + 1 ) + newMemcachedId + sessionId.substring( idxDot );\n        }\n    }\n\n    /**\n     * Checks if the given session id matches the pattern\n     * <code>[^-.]+-[^.]+(\\.[\\w]+)?<\/code>.\n     *\n     * @param sessionId\n     *            the session id\n     * @return true if matching, otherwise false.\n     */\n    public boolean isValid( final String sessionId ) {\n        return sessionId != null && _pattern.matcher( sessionId ).matches();\n    }\n\n    /**\n     * Extract the memcached id from the given session id.\n     *\n     * @param sessionId\n     *            the session id including the memcached id and eventually the\n     *            jvmRoute.\n     * @return the memcached id or null if the session id didn't contain any\n     *         memcached id.\n     */\n    public String extractMemcachedId( final String sessionId ) {\n        final int idxDash = sessionId.indexOf( '-' );\n        if ( idxDash < 0 ) {\n            return null;\n        }\n        final int idxDot = sessionId.indexOf( '.' );\n        if ( idxDot < 0 ) {\n            return sessionId.substring( idxDash + 1 );\n        } else {\n            return sessionId.substring( idxDash + 1, idxDot );\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.util.regex.Pattern;\n\n/**\n * This class defines the session id format: It creates session ids based on the\n * original session id and the memcached id, and it extracts the session id and\n * memcached id from a compound session id.\n * <p>\n * The session id is of the following format:\n * <code>[^-.]+-[^.]+(\\.[\\w]+)?<\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class SessionIdFormat {\n\n    /**\n     * The pattern for the session id.\n     */\n    private final Pattern _pattern = Pattern.compile( \"[^-.]+-[^.]+(\\\\.[\\\\w]+)?\" );\n\n    /**\n     * Create a session id including the provided memcachedId.\n     *\n     * @param sessionId\n     *            the original session id, it might contain the jvm route\n     * @param memcachedId\n     *            the memcached id to encode in the session id, may be <code>null<\/code>.\n     * @return the sessionId which now contains the memcachedId if one was provided, otherwise\n     *  the sessionId unmodified.\n     */\n    public String createSessionId( final String sessionId, final String memcachedId ) {\n        if ( memcachedId == null ) {\n            return sessionId;\n        }\n        final int idx = sessionId.indexOf( '.' );\n        if ( idx < 0 ) {\n            return sessionId + \"-\" + memcachedId;\n        } else {\n            return sessionId.substring( 0, idx ) + \"-\" + memcachedId + sessionId.substring( idx );\n        }\n    }\n\n    /**\n     * Change the provided session id (optionally already including a memcachedId) so that it\n     * contains the provided newMemcachedId.\n     *\n     * @param sessionId\n     *            the session id that may contain a former memcachedId.\n     * @param newMemcachedId\n     *            the new memcached id.\n     * @return the sessionId which now contains the new memcachedId instead the\n     *         former one.\n     */\n    public String createNewSessionId( final String sessionId, final String newMemcachedId ) {\n        final int idxDash = sessionId.indexOf( '-' );\n        final int idxDot = sessionId.indexOf( '.' );\n\n        final String sessionIdWithNewMemcachedId;\n        if ( idxDash < 0 ) {\n            final String plainSessionId = idxDot < 0 ? sessionId : sessionId.substring( 0, idxDot );\n            sessionIdWithNewMemcachedId = plainSessionId + \"-\" + newMemcachedId;\n        } else {\n            sessionIdWithNewMemcachedId = sessionId.substring( 0, idxDash + 1 ) + newMemcachedId;\n        }\n\n        return idxDot < 0 ? sessionIdWithNewMemcachedId : sessionIdWithNewMemcachedId + sessionId.substring( idxDot );\n    }\n\n    /**\n     * Checks if the given session id matches the pattern\n     * <code>[^-.]+-[^.]+(\\.[\\w]+)?<\/code>.\n     *\n     * @param sessionId\n     *            the session id\n     * @return true if matching, otherwise false.\n     */\n    public boolean isValid( final String sessionId ) {\n        return sessionId != null && _pattern.matcher( sessionId ).matches();\n    }\n\n    /**\n     * Extract the memcached id from the given session id.\n     *\n     * @param sessionId\n     *            the session id including the memcached id and eventually the\n     *            jvmRoute.\n     * @return the memcached id or null if the session id didn't contain any\n     *         memcached id.\n     */\n    public String extractMemcachedId( final String sessionId ) {\n        final int idxDash = sessionId.indexOf( '-' );\n        if ( idxDash < 0 ) {\n            return null;\n        }\n        final int idxDot = sessionId.indexOf( '.' );\n        if ( idxDot < 0 ) {\n            return sessionId.substring( idxDash + 1 );\n        } else {\n            return sessionId.substring( idxDash + 1, idxDot );\n        }\n    }\n\n}\n","lineNo":79}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.catalina.Session;\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.core.StandardContext;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Test the {@link SessionTrackerValve}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class SessionTrackerValveTest extends MockObjectTestCase {\n\n    private Mock _sessionBackupServiceControl;\n    private SessionBackupService _service;\n    private SessionTrackerValve _sessionTrackerValve;\n    private Mock _nextValve;\n    private Mock _requestControl;\n    private Request _request;\n    private Response _response;\n    private Mock _responseControl;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        _sessionBackupServiceControl = mock( SessionBackupService.class );\n        _service = (SessionBackupService) _sessionBackupServiceControl.proxy();\n        _sessionTrackerValve = new SessionTrackerValve( null, _service, Statistics.create() );\n        _nextValve = mock( Valve.class );\n        _sessionTrackerValve.setNext( (Valve) _nextValve.proxy() );\n\n        _requestControl = mock( Request.class );\n        _request = (Request) _requestControl.proxy();\n        _responseControl = mock( Response.class );\n        _response = (Response) _responseControl.proxy();\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _sessionBackupServiceControl.reset();\n        _nextValve.reset();\n        _requestControl.reset();\n        _responseControl.reset();\n    }\n\n    @Test\n    public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent() throws IOException, ServletException {\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _responseControl.expects( once() ).method( \"getCookies\" ).will( returnValue( null ) );\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n    @Test\n    public final void testGetSessionInternalInvokedWhenRequestedSessionIdPresent() throws IOException, ServletException {\n\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( \"foo\" ) );\n        _responseControl.expects( once() ).method( \"getCoyoteResponse\" ).will( returnValue( new org.apache.coyote.Response() ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( \"foo\" ) );\n        _requestControl.expects( once() ).method( \"getSessionInternal\" ).with( eq( false ) )\n            .will( returnValue( null ) );\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n    @Test\n    public final void testGetSessionInternalInvokedWhenResponseCookiePresent() throws IOException, ServletException {\n\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _responseControl.expects( once() ).method( \"getCookies\" )\n            .will( returnValue( new Cookie[] { new Cookie( SessionTrackerValve.JSESSIONID, \"foo\" ) } ) );\n        _requestControl.expects( once() ).method( \"getSessionInternal\" ).with( eq( false ) )\n            .will( returnValue( null ) );\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n    @Test\n    public final void testBackupSessionInvokedWhenSessionExisting() throws IOException, ServletException {\n\n        final Session session = (Session) mock( Session.class ).proxy();\n\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( \"foo\" ) );\n        _responseControl.expects( once() ).method( \"getCoyoteResponse\" ).will( returnValue( new org.apache.coyote.Response() ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( \"foo\" ) );\n        _requestControl.expects( once() ).method( \"getSessionInternal\" ).with( eq( false ) )\n            .will( returnValue( session ) );\n        _sessionBackupServiceControl.expects( once() ).method( \"backupSession\" ).with( eq( session ) )\n            .will( returnValue( BackupResultStatus.SUCCESS ) );\n\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n    @Test\n    public final void testResponseCookieForRelocatedSession() throws IOException, ServletException {\n\n        final Mock sessionControl = mock( Session.class );\n        final Session session = (Session) sessionControl.proxy();\n        final String sessionId = \"bar\";\n\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( sessionId ) );\n        _responseControl.expects( once() ).method( \"getCoyoteResponse\" ).will( returnValue( new org.apache.coyote.Response() ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( sessionId ) );\n        _requestControl.expects( once() ).method( \"getSessionInternal\" ).with( eq( false ) )\n            .will( returnValue( session ) );\n        _sessionBackupServiceControl.expects( once() ).method( \"backupSession\" ).with( eq( session ) )\n            .will( returnValue( BackupResultStatus.RELOCATED ) );\n        sessionControl.expects( once() ).method( \"getId\" ).will( returnValue( sessionId ) );\n        _requestControl.expects( atLeastOnce() ).method( \"getContext\" ).will( returnValue( new StandardContext() ) );\n        _requestControl.expects( once() ).method( \"isSecure\" ).will( returnValue( false ) );\n        _responseControl.expects( once() ).method( \"addCookieInternal\" ).with(\n                and( hasProperty( \"name\", eq( SessionTrackerValve.JSESSIONID ) ),\n                     hasProperty( \"value\", eq( sessionId ) ) ) );\n\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.catalina.Session;\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.connector.Request;\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.core.StandardContext;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService.BackupResultStatus;\n\n/**\n * Test the {@link SessionTrackerValve}.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class SessionTrackerValveTest extends MockObjectTestCase {\n\n    private Mock _sessionBackupServiceControl;\n    private SessionBackupService _service;\n    private SessionTrackerValve _sessionTrackerValve;\n    private Mock _nextValve;\n    private Mock _requestControl;\n    private Request _request;\n    private Response _response;\n    private Mock _responseControl;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        _sessionBackupServiceControl = mock( SessionBackupService.class );\n        _service = (SessionBackupService) _sessionBackupServiceControl.proxy();\n        _sessionTrackerValve = new SessionTrackerValve( null, _service, Statistics.create() );\n        _nextValve = mock( Valve.class );\n        _sessionTrackerValve.setNext( (Valve) _nextValve.proxy() );\n\n        _requestControl = mock( Request.class );\n        _request = (Request) _requestControl.proxy();\n        _responseControl = mock( Response.class );\n        _response = (Response) _responseControl.proxy();\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        _sessionBackupServiceControl.reset();\n        _nextValve.reset();\n        _requestControl.reset();\n        _responseControl.reset();\n    }\n\n    @Test\n    public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent() throws IOException, ServletException {\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _responseControl.expects( once() ).method( \"getCookies\" ).will( returnValue( null ) );\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n    @Test\n    public final void testGetSessionInternalInvokedWhenResponseCookiePresent() throws IOException, ServletException {\n\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getRequestedSessionId\" ).will( returnValue( null ) );\n        _responseControl.expects( once() ).method( \"getCookies\" )\n            .will( returnValue( new Cookie[] { new Cookie( SessionTrackerValve.JSESSIONID, \"foo\" ) } ) );\n        _requestControl.expects( once() ).method( \"getSessionInternal\" ).with( eq( false ) )\n            .will( returnValue( null ) );\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n    @Test\n    public final void testBackupSessionInvokedWhenSessionExisting() throws IOException, ServletException {\n\n        final Session session = (Session) mock( Session.class ).proxy();\n\n        final String sessionId = \"foo\";\n        _sessionBackupServiceControl.expects( once() ).method( \"changeSessionIdIfRelocationRequired\" ).with( eq( sessionId)  );\n        _requestControl.expects( atLeastOnce() ).method( \"getRequestedSessionId\" ).will( returnValue( sessionId ) );\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getSessionInternal\" ).with( eq( false ) )\n            .will( returnValue( session ) );\n        _sessionBackupServiceControl.expects( once() ).method( \"backupSession\" ).with( eq( session ), eq( false ) )\n            .will( returnValue( BackupResultStatus.SUCCESS ) );\n\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n    @Test\n    public final void testChangeSessionIdForRelocatedSession() throws IOException, ServletException {\n\n        final Mock sessionControl = mock( Session.class );\n        final Session session = (Session) sessionControl.proxy();\n        final String sessionId = \"bar\";\n        final String newSessionId = \"newId\";\n\n        _requestControl.expects( atLeastOnce() ).method( \"getRequestedSessionId\" ).will( returnValue( sessionId ) );\n        _sessionBackupServiceControl.expects( once() ).method( \"changeSessionIdIfRelocationRequired\" ).with( eq( sessionId)  ).will( returnValue( newSessionId ) );\n\n        _requestControl.expects( once() ).method( \"setRequestedSessionId\" ).with( eq( newSessionId ) );\n\n        _requestControl.expects( atLeastOnce() ).method( \"isRequestedSessionIdFromCookie\" ).will( returnValue( true ) );\n        _requestControl.expects( atLeastOnce() ).method( \"getContext\" ).will( returnValue( new StandardContext() ) );\n        _requestControl.expects( once() ).method( \"isSecure\" ).will( returnValue( false ) );\n        _responseControl.expects( once() ).method( \"addCookieInternal\" ).with(\n                and( hasProperty( \"name\", eq( SessionTrackerValve.JSESSIONID ) ),\n                     hasProperty( \"value\", eq( newSessionId ) ) ) );\n\n        _nextValve.expects( once() ).method( \"invoke\" );\n        _requestControl.expects( once() ).method( \"getSessionInternal\" ).with( eq( false ) )\n            .will( returnValue( session ) );\n        _sessionBackupServiceControl.expects( once() ).method( \"backupSession\" ).with( eq( session ), eq( true ) )\n            .will( returnValue( BackupResultStatus.SUCCESS ) );\n\n        _sessionTrackerValve.invoke( _request, _response );\n\n    }\n\n}\n","lineNo":106}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    private final Log _log = LogFactory.getLog( MemcachedBackupSessionManager.class );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = false;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private Class<? extends TranscoderFactory> _transcoderFactoryClass = JavaSerializationTranscoderFactory.class;\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    // -------------------- END configuration properties --------------------\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /*\n     * we have to implement rejectedSessions - not sure why\n     */\n    private int _rejectedSessions;\n\n    private TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n        \t\t\" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        /* add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern, this ) );\n\n        /* init memcached\n         */\n\n        if ( !NODES_PATTERN.matcher( _memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Set<String> allNodeIds = new HashSet<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( _memcachedNodes );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds, allNodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( addresses, address2Ids );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( allNodeIds.size(), 1000 ), nodeIds, failoverNodeIds );\n\n        _transcoderService = createTranscoderService();\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + nodeIds + \" and failover node ids \" + failoverNodeIds );\n\n    }\n\n    private TranscoderService createTranscoderService() {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    private MemcachedClient createMemcachedClient( final List<InetSocketAddress> addresses, final Map<InetSocketAddress, String> address2Ids ) {\n        try {\n            return new MemcachedClient( new SuffixLocatorConnectionFactory( new MapBasedResolver( address2Ids ), _sessionIdFormat ), addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException {\n        log.info( \"Starting with transcoder factory \" + _transcoderFactoryClass.getName() );\n        final TranscoderFactory transcoderFactory = _transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Loading custom converter classes \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \", \" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    _memcached.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private List<String> initFailoverNodes( final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( _failoverNodes != null && _failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodes = _failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodes ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + _memcachedNodes + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds, final Set<String> allNodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n        allNodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        _log.debug( \"expireSession invoked: \" + sessionId );\n        super.expireSession( sessionId );\n        if ( _sessionIdFormat.isValid( sessionId ) ) {\n            _memcached.delete( sessionId );\n        }\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        Session result = super.findSession( id );\n        if ( result == null && _missingSessionsCache.get( id ) == null ) {\n            result = loadFromMemcached( id );\n            if ( result != null ) {\n                add( result );\n            } else {\n                _missingSessionsCache.put( id, Boolean.TRUE );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( final String sessionId ) {\n        _log.debug( \"createSession invoked: \" + sessionId );\n\n        Session session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n            session.setId( generateSessionId() );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return ( session );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String determineSessionIdForBackup( final Session session ) {\n        return getOrCreateBackupSessionTask( (MemcachedBackupSession) session ).determineSessionIdForBackup();\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public BackupResultStatus backupSession( final Session session ) {\n        return getOrCreateBackupSessionTask( (MemcachedBackupSession) session ).backupSession();\n\n    }\n\n    private BackupSessionTask getOrCreateBackupSessionTask( final MemcachedBackupSession session ) {\n        if ( session.getBackupTask() == null ) {\n            session.setBackupTask( new BackupSessionTask( session, _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _memcached, _nodeIdService ) );\n        }\n        return session.getBackupTask();\n    }\n\n    protected Session loadFromMemcached( final String sessionId ) {\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n            try {\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n\n                if ( _log.isDebugEnabled() ) {\n                    if ( object == null ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object instanceof MemcachedBackupSession ) {\n                    return (Session) object;\n                }\n                else {\n                    return _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                }\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE ) +\n                    \", node failure: \" + session.getNote( NODE_FAILURE ) +\n                    \", id: \" + session.getId() );\n        }\n        if ( _sessionIdFormat.isValid( session.getId() )\n                && session.getNote( NODE_FAILURE ) != Boolean.TRUE ) {\n            try {\n                _log.debug( \"Deleting session from memcached: \" + session.getId() );\n                _memcached.delete( session.getId() );\n            } catch ( final NodeFailureException e ) {\n                /* We can ignore this */\n            }\n        }\n        super.remove( session );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        try {\n            _transcoderFactoryClass = Class.forName( transcoderFactoryClassName ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.error( \"The transcoderFactoryClass (\" + transcoderFactoryClassName + \") could not be found\" );\n            throw new RuntimeException( e );\n        }\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            _memcached.shutdown();\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    private void updateExpirationInMemcached() {\n        final Session[] sessions = findSessions();\n        final int delay = getContainer().getBackgroundProcessorDelay();\n        for ( final Session s : sessions ) {\n            final MemcachedBackupSession session = (MemcachedBackupSession) s;\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Checking session \" + session.getId() + \": \" +\n                        \"\\n- isValid: \" + session.isValidInternal() +\n                        \"\\n- isExpiring: \" + session.isExpiring() +\n                        \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                        \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                        \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                        \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n            }\n            if ( session.isValidInternal()\n                    && !session.isExpiring()\n                    && !session.isBackupRunning()\n                    && !session.isExpirationUpdateRunning()\n                    && session.wasAccessedSinceLastBackup()\n                    && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                try {\n                    getOrCreateBackupSessionTask( session ).updateExpiration();\n                } catch ( final Throwable e ) {\n                    _log.info( \"Could not update expiration in memcached for session \" + session.getId() );\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        _sessionBackupAsync = sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionTask}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.MemcachedClient;\nimport net.spy.memcached.transcoders.SerializingTranscoder;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    protected static final String NODE_FAILURE = \"node.failure\";\n\n    private final Log _log = LogFactory.getLog( MemcachedBackupSessionManager.class );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = false;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private Class<? extends TranscoderFactory> _transcoderFactoryClass = JavaSerializationTranscoderFactory.class;\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    private boolean _enableStatistics = true;\n\n    // -------------------- END configuration properties --------------------\n\n    private Statistics _statistics;\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    private NodeIdService _nodeIdService;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /*\n     * we have to implement rejectedSessions - not sure why\n     */\n    private int _rejectedSessions;\n\n    private TranscoderService _transcoderService;\n\n    private TranscoderFactory _transcoderFactory;\n\n    private SerializingTranscoder _upgradeSupportTranscoder;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n        \t\t\" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        _statistics = Statistics.create( _enableStatistics );\n\n        /* add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern, this, _statistics ) );\n\n        /* init memcached\n         */\n\n        if ( !NODES_PATTERN.matcher( _memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final List<String> nodeIds = new ArrayList<String>();\n        final Set<String> allNodeIds = new HashSet<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( _memcachedNodes );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids, nodeIds, allNodeIds );\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes( nodeIds );\n\n        if ( nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( addresses, address2Ids, _statistics );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n        _nodeIdService = new NodeIdService( createNodeAvailabilityCache( allNodeIds.size(), 1000 ), nodeIds, failoverNodeIds );\n\n        _transcoderService = createTranscoderService( _statistics );\n\n        _upgradeSupportTranscoder = getTranscoderFactory().createSessionTranscoder( this );\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + nodeIds + \" and failover node ids \" + failoverNodeIds );\n\n    }\n\n    private TranscoderService createTranscoderService( final Statistics statistics ) {\n        return new TranscoderService( getTranscoderFactory().createTranscoder( this ) );\n    }\n\n    protected TranscoderFactory getTranscoderFactory() {\n        if ( _transcoderFactory == null ) {\n            try {\n                _transcoderFactory = createTranscoderFactory();\n            } catch ( final Exception e ) {\n                throw new RuntimeException( \"Could not create transcoder factory.\", e );\n            }\n        }\n        return _transcoderFactory;\n    }\n\n    private MemcachedClient createMemcachedClient( final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids,\n            final Statistics statistics ) {\n        try {\n            return new MemcachedClient( new SuffixLocatorConnectionFactory(\n                    new MapBasedResolver( address2Ids ), _sessionIdFormat, statistics ), addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException {\n        log.info( \"Starting with transcoder factory \" + _transcoderFactoryClass.getName() );\n        final TranscoderFactory transcoderFactory = _transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Loading custom converter classes \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \", \" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis ) {\n        return new NodeAvailabilityCache<String>( size, ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    _memcached.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private List<String> initFailoverNodes( final List<String> nodeIds ) {\n        final List<String> failoverNodeIds = new ArrayList<String>();\n        if ( _failoverNodes != null && _failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodes = _failoverNodes.split( \" |,\" );\n            for ( final String failoverNode : failoverNodes ) {\n                final String nodeId = failoverNode.trim();\n                if ( !nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + _memcachedNodes + \"'.\" );\n                }\n                failoverNodeIds.add( nodeId );\n            }\n        }\n        return failoverNodeIds;\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids, final List<String> nodeIds, final Set<String> allNodeIds ) {\n        final String nodeId = matcher.group( 1 );\n        nodeIds.add( nodeId );\n        allNodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), _nodeIdService.getMemcachedNodeId() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        _log.debug( \"expireSession invoked: \" + sessionId );\n        super.expireSession( sessionId );\n        if ( _sessionIdFormat.isValid( sessionId ) ) {\n            _memcached.delete( sessionId );\n        }\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        Session result = super.findSession( id );\n        if ( result == null && _missingSessionsCache.get( id ) == null ) {\n            result = loadFromMemcached( id );\n            if ( result != null ) {\n                add( result );\n            } else {\n                _missingSessionsCache.put( id, Boolean.TRUE );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( final String sessionId ) {\n        _log.debug( \"createSession invoked: \" + sessionId );\n\n        Session session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n            session.setId( generateSessionId() );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return ( session );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String determineSessionIdForBackup( final Session session ) {\n        return getOrCreateBackupSessionTask( (MemcachedBackupSession) session ).determineSessionIdForBackup();\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public BackupResultStatus backupSession( final Session session ) {\n        return getOrCreateBackupSessionTask( (MemcachedBackupSession) session ).backupSession();\n\n    }\n\n    private BackupSessionTask getOrCreateBackupSessionTask( final MemcachedBackupSession session ) {\n        if ( session.getBackupTask() == null ) {\n            session.setBackupTask( new BackupSessionTask( session, _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _memcached, _nodeIdService, _statistics ) );\n        }\n        return session.getBackupTask();\n    }\n\n    protected Session loadFromMemcached( final String sessionId ) {\n        if ( !_sessionIdFormat.isValid( sessionId ) ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeIdService.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n            try {\n\n                final long start = System.currentTimeMillis();\n\n                /* In the previous version (<1.2) the session was completely serialized by\n                 * custom Transcoder implementations.\n                 * Such sessions have set the SERIALIZED flag (from SerializingTranscoder) so that\n                 * they get deserialized by BaseSerializingTranscoder.deserialize or the appropriate\n                 * specializations.\n                 */\n                final Object object = _memcached.get( sessionId, _upgradeSupportTranscoder );\n\n                if ( _log.isDebugEnabled() ) {\n                    if ( object == null ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeIdService.setNodeAvailable( nodeId, true );\n\n                if ( object instanceof MemcachedBackupSession ) {\n                    _statistics.getLoadFromMemcachedProbe().registerSince( start );\n                    return (Session) object;\n                }\n                else {\n                    final MemcachedBackupSession result = _transcoderService.deserialize( (byte[]) object, getContainer().getRealm(), this );\n                    if ( object != null ) {\n                        _statistics.getLoadFromMemcachedProbe().registerSince( start );\n                    }\n                    return result;\n                }\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeIdService.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE ) +\n                    \", node failure: \" + session.getNote( NODE_FAILURE ) +\n                    \", id: \" + session.getId() );\n        }\n        if ( _sessionIdFormat.isValid( session.getId() )\n                && session.getNote( NODE_FAILURE ) != Boolean.TRUE ) {\n            try {\n                _log.debug( \"Deleting session from memcached: \" + session.getId() );\n                _memcached.delete( session.getId() );\n            } catch ( final NodeFailureException e ) {\n                /* We can ignore this */\n            }\n        }\n        super.remove( session );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        try {\n            _transcoderFactoryClass = Class.forName( transcoderFactoryClassName ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.error( \"The transcoderFactoryClass (\" + transcoderFactoryClassName + \") could not be found\" );\n            throw new RuntimeException( e );\n        }\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * Specifies if statistics (like number of requests with/without session) shall be\n     * gathered. Default value of this property is <code>true<\/code>.\n     * <p>\n     * Statistics will be available via jmx and the Manager mbean (\n     * e.g. in the jconsole mbean tab open the attributes node of the\n     * <em>Catalina/Manager/&lt;context-path&gt;/&lt;host name&gt;<\/em>\n     * mbean and check for <em>msmStat*<\/em> values.\n     * <\/p>\n     *\n     * @param enableStatistics <code>true<\/code> if statistics shall be gathered.\n     */\n    public void setEnableStatistics( final boolean enableStatistics ) {\n        _enableStatistics = enableStatistics;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            _memcached.shutdown();\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void backgroundProcess() {\n        updateExpirationInMemcached();\n        super.backgroundProcess();\n    }\n\n    private void updateExpirationInMemcached() {\n        final Session[] sessions = findSessions();\n        final int delay = getContainer().getBackgroundProcessorDelay();\n        for ( final Session s : sessions ) {\n            final MemcachedBackupSession session = (MemcachedBackupSession) s;\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Checking session \" + session.getId() + \": \" +\n                        \"\\n- isValid: \" + session.isValidInternal() +\n                        \"\\n- isExpiring: \" + session.isExpiring() +\n                        \"\\n- isBackupRunning: \" + session.isBackupRunning() +\n                        \"\\n- isExpirationUpdateRunning: \" + session.isExpirationUpdateRunning() +\n                        \"\\n- wasAccessedSinceLastBackup: \" + session.wasAccessedSinceLastBackup() +\n                        \"\\n- memcachedExpirationTime: \" + session.getMemcachedExpirationTime() );\n            }\n            if ( session.isValidInternal()\n                    && !session.isExpiring()\n                    && !session.isBackupRunning()\n                    && !session.isExpirationUpdateRunning()\n                    && session.wasAccessedSinceLastBackup()\n                    && session.getMemcachedExpirationTime() <= 2 * delay ) {\n                try {\n                    getOrCreateBackupSessionTask( session ).updateExpiration();\n                } catch ( final Throwable e ) {\n                    _log.info( \"Could not update expiration in memcached for session \" + session.getId() );\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        _sessionBackupAsync = sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    // ----------------------- protected getters/setters for testing ------------------\n\n    /**\n     * Set the {@link TranscoderService} that is used by this manager and the {@link BackupSessionTask}.\n     *\n     * @param transcoderService the transcoder service to use.\n     */\n    void setTranscoderService( final TranscoderService transcoderService ) {\n        _transcoderService = transcoderService;\n    }\n\n    /**\n     * Just for testing, DON'T USE THIS OTHERWISE!\n     */\n    void resetInitialized() {\n        initialized = false;\n    }\n\n    /**\n     * Return the currently configured node ids - just for testing.\n     * @return the list of node ids.\n     */\n    List<String> getNodeIds() {\n        return _nodeIdService.getNodeIds();\n    }\n    /**\n     * Return the currently configured failover node ids - just for testing.\n     * @return the list of failover node ids.\n     */\n    List<String> getFailoverNodeIds() {\n        return _nodeIdService.getFailoverNodeIds();\n    }\n\n    // -------------------------  statistics via jmx ----------------\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackup()\n     */\n    public long getMsmStatNumBackups() {\n        return _statistics.getRequestsWithBackup();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupFailure()\n     */\n    public long getMsmStatNumBackupFailures() {\n        return _statistics.getRequestsWithBackupFailure();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithBackupRelocation()\n     */\n    public long getMsmStatBackupRelocations() {\n        return _statistics.getRequestsWithBackupRelocation();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSession()\n     */\n    public long getMsmStatNumRequestsWithoutSession() {\n        return _statistics.getRequestsWithoutSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionAccess()\n     */\n    public long getMsmStatNumNoSessionAccess() {\n        return _statistics.getRequestsWithoutSessionAccess();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithoutSessionModification()\n     */\n    public long getMsmStatNumNoSessionModification() {\n        return _statistics.getRequestsWithoutSessionModification();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getRequestsWithSession()\n     */\n    public long getMsmStatNumRequestsWithSession() {\n        return _statistics.getRequestsWithSession();\n    }\n\n    /**\n     * @return\n     * @see de.javakaffee.web.msm.Statistics#getSessionsLoadedFromMemcached()\n     */\n    public long getMsmStatNumSessionsLoadedFromMemcached() {\n        return _statistics.getSessionsLoadedFromMemcached();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that took the attributes serialization.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatAttributesSerializationInfo() {\n        return _statistics.getAttributesSerializationProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session backups took (excluding backups where a session\n     * was relocated).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupInfo() {\n        return _statistics.getBackupProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that session relocations took.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatBackupRelocationInfo() {\n        return _statistics.getBackupRelocationProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that loading sessions from memcached took (including deserialization).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatSessionsLoadedFromMemcachedInfo() {\n        return _statistics.getLoadFromMemcachedProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the size of the data that was sent to memcached.\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatCachedDataSizeInfo() {\n        return _statistics.getCachedDataSizeProbe().getInfo();\n    }\n\n    /**\n     * Returns a string array with labels and values of count, min, avg and max\n     * of the time that storing data in memcached took (excluding serialization,\n     * including compression).\n     * @return a String array for statistics inspection via jmx.\n     */\n    public String[] getMsmStatMemcachedUpdateInfo() {\n        return _statistics.getMemcachedUpdateProbe().getInfo();\n    }\n\n}\n","lineNo":559}
{"Smelly Sample":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.Principal;\nimport java.util.Date;\nimport java.util.Map;\n\nimport org.apache.catalina.Realm;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.ha.session.SerializablePrincipal;\nimport org.apache.catalina.realm.GenericPrincipal;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\n\n/**\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TranscoderService {\n\n    @SuppressWarnings( \"unused\" )\n    private static final Log LOG = LogFactory.getLog( TranscoderService.class );\n\n    private static final short CURRENT_VERSION = 1;\n\n    static final int NUM_BYTES = 8 // creationTime: long\n            + 8 // lastAccessedTime: long\n            + 4 // maxInactiveInterval: int\n            + 1 // isNew: boolean\n            + 1 // isValid: boolean\n            + 8; // thisAccessedTime\n\n    private final SessionAttributesTranscoder _attributesTranscoder;\n\n    /**\n     * @param createTranscoder\n     */\n    public TranscoderService( final SessionAttributesTranscoder attributesTranscoder ) {\n        _attributesTranscoder = attributesTranscoder;\n    }\n\n    public static void main( final String[] args ) throws UnsupportedEncodingException {\n        System.out.println( \"42 as byte[]: \" + Integer.toBinaryString( Integer.MAX_VALUE ) );\n        System.out.println( \"date: \" + new Date( Integer.MAX_VALUE ).toString() );\n        System.out.println( \"diff: \" + ( System.currentTimeMillis() - Integer.MAX_VALUE ) );\n        System.out.println( \"length of foo.getBytes, foobar.getBytes: \" + \"foo\".getBytes().length + \", \"\n                + \"foobar\".getBytes().length );\n\n        //Long.valueOf( 42L )\n    }\n\n    /**\n     * Serialize the given session to a byte array. This is a shortcut for\n     * <pre><code>final byte[] attributesData = serializeAttributes( session, session.getAttributes() );\nserialize( session, attributesData );\n     * <\/code><\/pre>\n     * The returned byte array can be deserialized using {@link #deserialize(byte[], Realm)}.\n     *\n     * @see #serializeAttributes(MemcachedBackupSession, Map)\n     * @see #serialize(MemcachedBackupSession, byte[])\n     * @see #deserialize(byte[], Realm)\n     * @param session the session to serialize.\n     * @return the serialized session data.\n     */\n    public byte[] serialize( final MemcachedBackupSession session ) {\n        final byte[] attributesData = serializeAttributes( session, session.getAttributesInternal() );\n        return serialize( session, attributesData );\n    }\n\n    /**\n     * Deserialize session data that was serialized using {@link #serialize(MemcachedBackupSession)}\n     * (or a combination of {@link #serializeAttributes(MemcachedBackupSession, Map)} and\n     * {@link #serialize(MemcachedBackupSession, byte[])}).\n     * <p>\n     * Note: the returned session does not yet have the manager set neither was\n     * {@link MemcachedBackupSession#doAfterDeserialization()} invoked.\n     * <\/p>\n     * @param data the byte array of the serialized session and its session attributes.\n     * @param realm the realm that is used to reconstruct the principal if there was any stored in the session.\n     * @return the deserialized {@link MemcachedBackupSession}.\n     */\n    public MemcachedBackupSession deserialize( final byte[] data, final Realm realm ) {\n        final DeserializationResult deserializationResult = deserializeSessionFields( data, realm );\n        final Map<String, Object> attributes = _attributesTranscoder.deserializeAttributes( deserializationResult.getAttributesData() );\n        final MemcachedBackupSession result = deserializationResult.getSession();\n        result.setAttributesInternal( attributes );\n        return result;\n    }\n\n    /**\n     * @param session\n     * @param attributes\n     * @return\n     * @see de.javakaffee.web.msm.SessionAttributesTranscoder#serializeAttributes(MemcachedBackupSession, Map)\n     */\n    public byte[] serializeAttributes( final MemcachedBackupSession session, final Map<String, Object> attributes ) {\n        return _attributesTranscoder.serializeAttributes( session, attributes );\n    }\n\n\n\n    /**\n     * @param data\n     * @return\n     * @see de.javakaffee.web.msm.SessionAttributesTranscoder#deserializeAttributes(byte[])\n     */\n    public Map<String, Object> deserializeAttributes( final byte[] data ) {\n        return _attributesTranscoder.deserializeAttributes( data );\n    }\n\n    /**\n     * @param session\n     * @param attributesData\n     * @return\n     */\n    public byte[] serialize( final MemcachedBackupSession session, final byte[] attributesData ) {\n        final byte[] sessionData = serializeSessionFields( session );\n        final byte[] result = new byte[ sessionData.length + attributesData.length ];\n        System.arraycopy( sessionData, 0, result, 0, sessionData.length );\n        System.arraycopy( attributesData, 0, result, sessionData.length, attributesData.length );\n        return result;\n    }\n\n    // ---------------------  private/protected helper methods  -------------------\n\n\n    static byte[] serializeSessionFields( final MemcachedBackupSession session ) {\n\n        final byte[] idData = serializeId( session.getIdInternal() );\n\n        final byte[] principalData = session.getPrincipal() != null ? serializePrincipal( session.getPrincipal() ) : null;\n        final int principalDataLength = principalData != null ? principalData.length : 0;\n\n        final int sessionFieldsDataLength = 2 // short value for the version\n        // the following might change with other versions, refactoring needed then\n                + 2 // short value that stores the dataLength\n                + NUM_BYTES // bytes that store all session attributes but the id\n                + 2 // short value that stores the idData length\n                + idData.length // the number of bytes for the id\n                + 2 // short value for the authType\n                + 2 // short value that stores the principalData length\n                + principalDataLength; // the number of bytes for the principal\n        final byte[] data = new byte[sessionFieldsDataLength];\n\n        int idx = 0;\n        idx = encodeNum( CURRENT_VERSION, data, idx, 2 );\n        idx = encodeNum( sessionFieldsDataLength, data, idx, 2 );\n        idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 );\n        idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 );\n        idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 );\n        idx = encodeBoolean( session.isNewInternal(), data, idx );\n        idx = encodeBoolean( session.isValidInternal(), data, idx );\n        idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 );\n        idx = encodeNum( idData.length, data, idx, 2 );\n        idx = copy( idData, data, idx );\n        idx = encodeNum( AuthType.valueOfValue( session.getAuthType() ).getId(), data, idx, 2 );\n        idx = encodeNum( principalDataLength, data, idx, 2 );\n        copy( principalData, data, idx );\n\n        return data;\n    }\n\n    static DeserializationResult deserializeSessionFields( final byte[] data, final Realm realm ) throws InvalidVersionException {\n        final MemcachedBackupSession result = new MemcachedBackupSession();\n\n        final short version = (short) decodeNum( data, 0, 2 );\n\n        if ( version != CURRENT_VERSION ) {\n            throw new InvalidVersionException( \"The version \" + version + \" does not match the current version \" + CURRENT_VERSION, version );\n        }\n\n        final short sessionFieldsDataLength = (short) decodeNum( data, 2, 2 );\n\n        result.setCreationTimeInternal( decodeNum( data, 4, 8 ) );\n        result.setLastAccessedTimeInternal( decodeNum( data, 12, 8 ) );\n        result.setMaxInactiveInterval( (int) decodeNum( data, 20, 4 ) );\n        result.setIsNewInternal( decodeBoolean( data, 24 ) );\n        result.setIsValidInternal( decodeBoolean( data, 25 ) );\n        result.setThisAccessedTimeInternal( decodeNum( data, 26, 8 ) );\n\n        final short idLength = (short) decodeNum( data, 34, 2 );\n        result.setIdInternal( decodeString( data, 36, idLength ) );\n\n        final short authTypeId = (short)decodeNum( data, 36 + idLength, 2 );\n        result.setAuthType( AuthType.valueOfId( authTypeId ).getValue() );\n\n        final int currentIdx = 36 + idLength + 2;\n        final short principalDataLength = (short) decodeNum( data, currentIdx, 2 );\n        if ( principalDataLength > 0 ) {\n            final byte[] principalData = new byte[principalDataLength];\n            System.arraycopy( data, currentIdx + 2, principalData, 0, principalDataLength );\n            result.setPrincipal( deserializePrincipal( principalData, realm ) );\n        }\n\n        final byte[] attributesData = new byte[ data.length - sessionFieldsDataLength ];\n        System.arraycopy( data, sessionFieldsDataLength, attributesData, 0, data.length - sessionFieldsDataLength );\n\n        return new DeserializationResult( result, attributesData );\n    }\n\n    static class DeserializationResult {\n        private final MemcachedBackupSession _session;\n        private final byte[] _attributesData;\n        DeserializationResult( final MemcachedBackupSession session, final byte[] attributesData ) {\n            _session = session;\n            _attributesData = attributesData;\n        }\n        /**\n         * @return the session with fields initialized apart from the attributes.\n         */\n        MemcachedBackupSession getSession() {\n            return _session;\n        }\n        /**\n         * The serialized session attributes.\n         * @return the byte array representing the serialized session attributes.\n         */\n        byte[] getAttributesData() {\n            return _attributesData;\n        }\n    }\n\n    private static byte[] serializeId( final String id ) {\n        try {\n            return id.getBytes( \"UTF-8\" );\n        } catch ( final UnsupportedEncodingException e ) {\n            throw new RuntimeException( e );\n        }\n    }\n\n    private static byte[] serializePrincipal( final Principal principal ) {\n        ByteArrayOutputStream bos = null;\n        ObjectOutputStream oos = null;\n        try {\n            bos = new ByteArrayOutputStream();\n            oos = new ObjectOutputStream( bos );\n            SerializablePrincipal.writePrincipal((GenericPrincipal) principal, oos );\n            oos.flush();\n            return bos.toByteArray();\n        } catch ( final IOException e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            closeSilently( bos );\n            closeSilently( oos );\n        }\n    }\n\n    private static Principal deserializePrincipal( final byte[] data, final Realm realm ) {\n        ByteArrayInputStream bis = null;\n        ObjectInputStream ois = null;\n        try {\n            bis = new ByteArrayInputStream( data );\n            ois = new ObjectInputStream( bis );\n            return SerializablePrincipal.readPrincipal( ois, realm );\n        } catch ( final IOException e ) {\n            throw new IllegalArgumentException( \"Could not deserialize principal\", e );\n        } catch ( final ClassNotFoundException e ) {\n            throw new IllegalArgumentException( \"Could not deserialize principal\", e );\n        } finally {\n            closeSilently( bis );\n            closeSilently( ois );\n        }\n    }\n\n    /**\n     * Convert a number to bytes (with length of maxBytes) and write bytes into\n     * the provided byte[] data starting at the specified beginIndex.\n     *\n     * @param num\n     *            the number to encode\n     * @param data\n     *            the byte array into that the number is encoded\n     * @param beginIndex\n     *            the beginning index of data where to start encoding,\n     *            inclusive.\n     * @param maxBytes\n     *            the number of bytes to store for the number\n     * @return the next beginIndex (<code>beginIndex + maxBytes<\/code>).\n     */\n    private static int encodeNum( final long num, final byte[] data, final int beginIndex, final int maxBytes ) {\n        for ( int i = 0; i < maxBytes; i++ ) {\n            final int pos = maxBytes - i - 1; // the position of the byte in the number\n            final int idx = beginIndex + pos; // the index in the data array\n            data[idx] = (byte) ( ( num >> ( 8 * i ) ) & 0xff );\n        }\n        return beginIndex + maxBytes;\n    }\n\n    private static long decodeNum( final byte[] data, final int beginIndex, final int numBytes ) {\n        long result = 0;\n        for ( int i = 0; i < numBytes; i++ ) {\n            final byte b = data[beginIndex + i];\n            result = ( result << 8 ) | ( b < 0\n                ? 256 + b\n                : b );\n        }\n        return result;\n    }\n\n    /**\n     * Encode a boolean that can be decoded with {@link #decodeBoolean(byte[], int)}.\n     * @param b the boolean value\n     * @param data the byte array where to write the encoded byte(s) to\n     * @param index the start index in the byte array for writing.\n     * @return the incremented index that can be used next.\n     */\n    private static int encodeBoolean( final boolean b, final byte[] data, final int index ) {\n        data[index] = (byte) ( b\n            ? '1'\n            : '0' );\n        return index + 1;\n    }\n\n    private static boolean decodeBoolean( final byte[] in, final int index ) {\n        return in[index] == '1';\n    }\n\n    private static String decodeString( final byte[] data, final int beginIndex, final int length ) {\n        try {\n            final byte[] idData = new byte[length];\n            System.arraycopy( data, beginIndex, idData, 0, length );\n            return new String( idData, \"UTF-8\" );\n        } catch ( final UnsupportedEncodingException e ) {\n            throw new RuntimeException( e );\n        }\n    }\n\n    protected static int copy( final byte[] src, final byte[] dest, final int destBeginIndex ) {\n        if ( src == null ) {\n            return destBeginIndex;\n        }\n        System.arraycopy( src, 0, dest, destBeginIndex, src.length );\n        return destBeginIndex + src.length;\n    }\n\n    private static void closeSilently( final OutputStream os ) {\n        if ( os != null ) {\n            try {\n                os.close();\n            } catch ( final IOException f ) {\n                // fail silently\n            }\n        }\n    }\n\n    private static void closeSilently( final InputStream is ) {\n        if ( is != null ) {\n            try {\n                is.close();\n            } catch ( final IOException f ) {\n                // fail silently\n            }\n        }\n    }\n\n    /**\n     * The enum representing id/string mappings for the {@link Session#getAuthType()}\n     * with values defined in {@link Constants}.\n     */\n    private static enum AuthType {\n\n        NONE( (short)0, null ),\n        BASIC( (short)1, Constants.BASIC_METHOD ),\n        CLIENT_CERT( (short)2, Constants.CERT_METHOD ),\n        DIGEST( (short)3, Constants.DIGEST_METHOD ),\n        FORM( (short)4, Constants.FORM_METHOD );\n\n        private final short _id;\n        private final String _value;\n\n        private AuthType( final short id, final String value ) {\n            _id = id;\n            _value = value;\n        }\n\n        static AuthType valueOfId( final short id ) {\n            for( final AuthType authType : values() ) {\n                if ( id == authType._id ) {\n                    return authType;\n                }\n            }\n            throw new IllegalArgumentException( \"No AuthType found for id \" + id );\n        }\n\n        static AuthType valueOfValue( final String value ) {\n            for( final AuthType authType : values() ) {\n                if ( value == null && authType._value == null\n                        || value != null && value.equals( authType._value )) {\n                    return authType;\n                }\n            }\n            throw new IllegalArgumentException( \"No AuthType found for value \" + value );\n        }\n\n        /**\n         * @return the id\n         */\n        short getId() {\n            return _id;\n        }\n\n        /**\n         * @return the value\n         */\n        String getValue() {\n            return _value;\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2010 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.Principal;\nimport java.util.Arrays;\nimport java.util.Map;\n\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Realm;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.authenticator.Constants;\nimport org.apache.catalina.ha.session.SerializablePrincipal;\nimport org.apache.catalina.realm.GenericPrincipal;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\n/**\n * This service is responsible for serializing/deserializing session data\n * so that this can be stored in / loaded from memcached.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TranscoderService {\n\n    private static final Log LOG = LogFactory.getLog( TranscoderService.class );\n\n    private static final short CURRENT_VERSION = 1;\n\n    static final int NUM_BYTES = 8 // creationTime: long\n            + 8 // lastAccessedTime: long\n            + 4 // maxInactiveInterval: int\n            + 1 // isNew: boolean\n            + 1 // isValid: boolean\n            + 8; // thisAccessedTime\n\n    private final SessionAttributesTranscoder _attributesTranscoder;\n\n    /**\n     * Creates a new {@link TranscoderService}.\n     *\n     * @param attributesTranscoder the {@link SessionAttributesTranscoder} strategy to use.\n     */\n    public TranscoderService( final SessionAttributesTranscoder attributesTranscoder ) {\n        _attributesTranscoder = attributesTranscoder;\n    }\n\n    /**\n     * Serialize the given session to a byte array. This is a shortcut for\n     * <code><pre>\n     * final byte[] attributesData = serializeAttributes( session, session.getAttributes() );\n     * serialize( session, attributesData );\n     * <\/pre><\/code>\n     * The returned byte array can be deserialized using {@link #deserialize(byte[], Realm, Manager)}.\n     *\n     * @see #serializeAttributes(MemcachedBackupSession, Map)\n     * @see #serialize(MemcachedBackupSession, byte[])\n     * @see #deserialize(byte[], Realm, Manager)\n     * @param session the session to serialize.\n     * @return the serialized session data.\n     */\n    public byte[] serialize( final MemcachedBackupSession session ) {\n        final byte[] attributesData = serializeAttributes( session, session.getAttributesInternal() );\n        return serialize( session, attributesData );\n    }\n\n    /**\n     * Deserialize session data that was serialized using {@link #serialize(MemcachedBackupSession)}\n     * (or a combination of {@link #serializeAttributes(MemcachedBackupSession, Map)} and\n     * {@link #serialize(MemcachedBackupSession, byte[])}).\n     * <p>\n     * Note: the returned session already has the manager set and\n     * {@link MemcachedBackupSession#doAfterDeserialization()} is invoked. Additionally\n     * the attributes hash is set (via {@link MemcachedBackupSession#setDataHashCode(int)}).\n     * <\/p>\n     *\n     * @param data the byte array of the serialized session and its session attributes. Can be <code>null<\/code>.\n     * @param realm the realm that is used to reconstruct the principal if there was any stored in the session.\n     * @param manager the manager to set on the deserialized session.\n     *\n     * @return the deserialized {@link MemcachedBackupSession}\n     *  or <code>null<\/code> if the provided <code>byte[] data<\/code> was <code>null<\/code>.\n     */\n    public MemcachedBackupSession deserialize( final byte[] data, final Realm realm, final Manager manager ) {\n        if ( data == null ) {\n            return null;\n        }\n        try {\n            final DeserializationResult deserializationResult = TranscoderService.deserializeSessionFields( data, realm );\n            final byte[] attributesData = deserializationResult.getAttributesData();\n            final Map<String, Object> attributes = deserializeAttributes( attributesData );\n            final MemcachedBackupSession session = deserializationResult.getSession();\n            session.setAttributesInternal( attributes );\n            session.setDataHashCode( Arrays.hashCode( attributesData ) );\n            session.setManager( manager );\n            session.doAfterDeserialization();\n            return session;\n        } catch( final InvalidVersionException e ) {\n            LOG.info( \"Got session data from memcached with an unsupported version: \" + e.getVersion() );\n            // for versioning probably there will be changes in the design,\n            // with the first change and version 2 we'll see what we need\n            return null;\n        }\n    }\n\n    /**\n     * Serialize the given session attributes to a byte array, this is delegated\n     * to {@link SessionAttributesTranscoder#serializeAttributes(MemcachedBackupSession, Map)} (using\n     * the {@link SessionAttributesTranscoder} provided in the constructor of this class).\n     *\n     * @param session the session that owns the given attributes.\n     * @param attributes the attributes to serialize.\n     * @return a byte array representing the serialized attributes.\n     *\n     * @see de.javakaffee.web.msm.SessionAttributesTranscoder#serializeAttributes(MemcachedBackupSession, Map)\n     */\n    public byte[] serializeAttributes( final MemcachedBackupSession session, final Map<String, Object> attributes ) {\n        return _attributesTranscoder.serializeAttributes( session, attributes );\n    }\n\n\n\n    /**\n     * Deserialize the given byte array to session attributes, this is delegated\n     * to {@link SessionAttributesTranscoder#deserializeAttributes(byte[])} (using\n     * the {@link SessionAttributesTranscoder} provided in the constructor of this class).\n     *\n     * @param data the serialized attributes\n     * @return the deserialized attributes\n     *\n     * @see de.javakaffee.web.msm.SessionAttributesTranscoder#deserializeAttributes(byte[])\n     */\n    public Map<String, Object> deserializeAttributes( final byte[] data ) {\n        return _attributesTranscoder.deserializeAttributes( data );\n    }\n\n    /**\n     * Serialize session fields to a byte[] and create a byte[] containing both the\n     * serialized byte[] of the session fields and the provided byte[] of the serialized\n     * session attributes.\n     *\n     * @param session its fields will be serialized to a byte[]\n     * @param attributesData the serialized session attributes (e.g. from {@link #serializeAttributes(MemcachedBackupSession, Map)})\n     * @return a byte[] containing both the serialized session fields and the provided serialized session attributes\n     */\n    public byte[] serialize( final MemcachedBackupSession session, final byte[] attributesData ) {\n        final byte[] sessionData = serializeSessionFields( session );\n        final byte[] result = new byte[ sessionData.length + attributesData.length ];\n        System.arraycopy( sessionData, 0, result, 0, sessionData.length );\n        System.arraycopy( attributesData, 0, result, sessionData.length, attributesData.length );\n        return result;\n    }\n\n    // ---------------------  private/protected helper methods  -------------------\n\n\n    static byte[] serializeSessionFields( final MemcachedBackupSession session ) {\n\n        final byte[] idData = serializeId( session.getIdInternal() );\n\n        final byte[] principalData = session.getPrincipal() != null ? serializePrincipal( session.getPrincipal() ) : null;\n        final int principalDataLength = principalData != null ? principalData.length : 0;\n\n        final int sessionFieldsDataLength = 2 // short value for the version\n        // the following might change with other versions, refactoring needed then\n                + 2 // short value that stores the dataLength\n                + NUM_BYTES // bytes that store all session attributes but the id\n                + 2 // short value that stores the idData length\n                + idData.length // the number of bytes for the id\n                + 2 // short value for the authType\n                + 2 // short value that stores the principalData length\n                + principalDataLength; // the number of bytes for the principal\n        final byte[] data = new byte[sessionFieldsDataLength];\n\n        int idx = 0;\n        idx = encodeNum( CURRENT_VERSION, data, idx, 2 );\n        idx = encodeNum( sessionFieldsDataLength, data, idx, 2 );\n        idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 );\n        idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 );\n        idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 );\n        idx = encodeBoolean( session.isNewInternal(), data, idx );\n        idx = encodeBoolean( session.isValidInternal(), data, idx );\n        idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 );\n        idx = encodeNum( idData.length, data, idx, 2 );\n        idx = copy( idData, data, idx );\n        idx = encodeNum( AuthType.valueOfValue( session.getAuthType() ).getId(), data, idx, 2 );\n        idx = encodeNum( principalDataLength, data, idx, 2 );\n        copy( principalData, data, idx );\n\n        return data;\n    }\n\n    static DeserializationResult deserializeSessionFields( final byte[] data, final Realm realm ) throws InvalidVersionException {\n        final MemcachedBackupSession result = new MemcachedBackupSession();\n\n        final short version = (short) decodeNum( data, 0, 2 );\n\n        if ( version != CURRENT_VERSION ) {\n            throw new InvalidVersionException( \"The version \" + version + \" does not match the current version \" + CURRENT_VERSION, version );\n        }\n\n        final short sessionFieldsDataLength = (short) decodeNum( data, 2, 2 );\n\n        result.setCreationTimeInternal( decodeNum( data, 4, 8 ) );\n        result.setLastAccessedTimeInternal( decodeNum( data, 12, 8 ) );\n        result.setMaxInactiveInterval( (int) decodeNum( data, 20, 4 ) );\n        result.setIsNewInternal( decodeBoolean( data, 24 ) );\n        result.setIsValidInternal( decodeBoolean( data, 25 ) );\n        result.setThisAccessedTimeInternal( decodeNum( data, 26, 8 ) );\n\n        final short idLength = (short) decodeNum( data, 34, 2 );\n        result.setIdInternal( decodeString( data, 36, idLength ) );\n\n        final short authTypeId = (short)decodeNum( data, 36 + idLength, 2 );\n        result.setAuthType( AuthType.valueOfId( authTypeId ).getValue() );\n\n        final int currentIdx = 36 + idLength + 2;\n        final short principalDataLength = (short) decodeNum( data, currentIdx, 2 );\n        if ( principalDataLength > 0 ) {\n            final byte[] principalData = new byte[principalDataLength];\n            System.arraycopy( data, currentIdx + 2, principalData, 0, principalDataLength );\n            result.setPrincipal( deserializePrincipal( principalData, realm ) );\n        }\n\n        final byte[] attributesData = new byte[ data.length - sessionFieldsDataLength ];\n        System.arraycopy( data, sessionFieldsDataLength, attributesData, 0, data.length - sessionFieldsDataLength );\n\n        return new DeserializationResult( result, attributesData );\n    }\n\n    static class DeserializationResult {\n        private final MemcachedBackupSession _session;\n        private final byte[] _attributesData;\n        DeserializationResult( final MemcachedBackupSession session, final byte[] attributesData ) {\n            _session = session;\n            _attributesData = attributesData;\n        }\n        /**\n         * @return the session with fields initialized apart from the attributes.\n         */\n        MemcachedBackupSession getSession() {\n            return _session;\n        }\n        /**\n         * The serialized session attributes.\n         * @return the byte array representing the serialized session attributes.\n         */\n        byte[] getAttributesData() {\n            return _attributesData;\n        }\n    }\n\n    private static byte[] serializeId( final String id ) {\n        try {\n            return id.getBytes( \"UTF-8\" );\n        } catch ( final UnsupportedEncodingException e ) {\n            throw new RuntimeException( e );\n        }\n    }\n\n    private static byte[] serializePrincipal( final Principal principal ) {\n        ByteArrayOutputStream bos = null;\n        ObjectOutputStream oos = null;\n        try {\n            bos = new ByteArrayOutputStream();\n            oos = new ObjectOutputStream( bos );\n            SerializablePrincipal.writePrincipal((GenericPrincipal) principal, oos );\n            oos.flush();\n            return bos.toByteArray();\n        } catch ( final IOException e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            closeSilently( bos );\n            closeSilently( oos );\n        }\n    }\n\n    private static Principal deserializePrincipal( final byte[] data, final Realm realm ) {\n        ByteArrayInputStream bis = null;\n        ObjectInputStream ois = null;\n        try {\n            bis = new ByteArrayInputStream( data );\n            ois = new ObjectInputStream( bis );\n            return SerializablePrincipal.readPrincipal( ois, realm );\n        } catch ( final IOException e ) {\n            throw new IllegalArgumentException( \"Could not deserialize principal\", e );\n        } catch ( final ClassNotFoundException e ) {\n            throw new IllegalArgumentException( \"Could not deserialize principal\", e );\n        } finally {\n            closeSilently( bis );\n            closeSilently( ois );\n        }\n    }\n\n    /**\n     * Convert a number to bytes (with length of maxBytes) and write bytes into\n     * the provided byte[] data starting at the specified beginIndex.\n     *\n     * @param num\n     *            the number to encode\n     * @param data\n     *            the byte array into that the number is encoded\n     * @param beginIndex\n     *            the beginning index of data where to start encoding,\n     *            inclusive.\n     * @param maxBytes\n     *            the number of bytes to store for the number\n     * @return the next beginIndex (<code>beginIndex + maxBytes<\/code>).\n     */\n    private static int encodeNum( final long num, final byte[] data, final int beginIndex, final int maxBytes ) {\n        for ( int i = 0; i < maxBytes; i++ ) {\n            final int pos = maxBytes - i - 1; // the position of the byte in the number\n            final int idx = beginIndex + pos; // the index in the data array\n            data[idx] = (byte) ( ( num >> ( 8 * i ) ) & 0xff );\n        }\n        return beginIndex + maxBytes;\n    }\n\n    private static long decodeNum( final byte[] data, final int beginIndex, final int numBytes ) {\n        long result = 0;\n        for ( int i = 0; i < numBytes; i++ ) {\n            final byte b = data[beginIndex + i];\n            result = ( result << 8 ) | ( b < 0\n                ? 256 + b\n                : b );\n        }\n        return result;\n    }\n\n    /**\n     * Encode a boolean that can be decoded with {@link #decodeBoolean(byte[], int)}.\n     * @param b the boolean value\n     * @param data the byte array where to write the encoded byte(s) to\n     * @param index the start index in the byte array for writing.\n     * @return the incremented index that can be used next.\n     */\n    private static int encodeBoolean( final boolean b, final byte[] data, final int index ) {\n        data[index] = (byte) ( b\n            ? '1'\n            : '0' );\n        return index + 1;\n    }\n\n    private static boolean decodeBoolean( final byte[] in, final int index ) {\n        return in[index] == '1';\n    }\n\n    private static String decodeString( final byte[] data, final int beginIndex, final int length ) {\n        try {\n            final byte[] idData = new byte[length];\n            System.arraycopy( data, beginIndex, idData, 0, length );\n            return new String( idData, \"UTF-8\" );\n        } catch ( final UnsupportedEncodingException e ) {\n            throw new RuntimeException( e );\n        }\n    }\n\n    protected static int copy( final byte[] src, final byte[] dest, final int destBeginIndex ) {\n        if ( src == null ) {\n            return destBeginIndex;\n        }\n        System.arraycopy( src, 0, dest, destBeginIndex, src.length );\n        return destBeginIndex + src.length;\n    }\n\n    private static void closeSilently( final OutputStream os ) {\n        if ( os != null ) {\n            try {\n                os.close();\n            } catch ( final IOException f ) {\n                // fail silently\n            }\n        }\n    }\n\n    private static void closeSilently( final InputStream is ) {\n        if ( is != null ) {\n            try {\n                is.close();\n            } catch ( final IOException f ) {\n                // fail silently\n            }\n        }\n    }\n\n    /**\n     * The enum representing id/string mappings for the {@link Session#getAuthType()}\n     * with values defined in {@link Constants}.\n     */\n    private static enum AuthType {\n\n        NONE( (short)0, null ),\n        BASIC( (short)1, Constants.BASIC_METHOD ),\n        CLIENT_CERT( (short)2, Constants.CERT_METHOD ),\n        DIGEST( (short)3, Constants.DIGEST_METHOD ),\n        FORM( (short)4, Constants.FORM_METHOD );\n\n        private final short _id;\n        private final String _value;\n\n        private AuthType( final short id, final String value ) {\n            _id = id;\n            _value = value;\n        }\n\n        static AuthType valueOfId( final short id ) {\n            for( final AuthType authType : values() ) {\n                if ( id == authType._id ) {\n                    return authType;\n                }\n            }\n            throw new IllegalArgumentException( \"No AuthType found for id \" + id );\n        }\n\n        static AuthType valueOfValue( final String value ) {\n            for( final AuthType authType : values() ) {\n                if ( value == null && authType._value == null\n                        || value != null && value.equals( authType._value )) {\n                    return authType;\n                }\n            }\n            throw new IllegalArgumentException( \"No AuthType found for value \" + value );\n        }\n\n        /**\n         * @return the id\n         */\n        short getId() {\n            return _id;\n        }\n\n        /**\n         * @return the value\n         */\n        String getValue() {\n            return _value;\n        }\n\n    }\n\n}\n","lineNo":112}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.Header;\nimport org.apache.commons.httpclient.HeaderElement;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.PostMethod;\n\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpMethod method = new GetMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            return responseSessionId == null ? rsessionId : responseSessionId;\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static Response get( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpMethod method = new GetMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            final String bodyAsString = method.getResponseBodyAsString();\n            final String[] lines = bodyAsString.split( \"\\r\\n\" );\n            final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n            for ( final String line : lines ) {\n                final String[] keyValue = line.split( \"=\" );\n                if ( keyValue.length > 0 ) {\n                    keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n                }\n            }\n\n            return new Response( responseSessionId == null ? rsessionId : responseSessionId, keyValues );\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static String post( final HttpClient client, final int port, final String rsessionId, final String paramName, final String paramValue ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final PostMethod method = new PostMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            method.addParameter( paramName, paramValue );\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            return responseSessionId == null ? rsessionId : responseSessionId;\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static String getSessionIdFromResponse( final HttpMethod method ) {\n        final Header cookie = method.getResponseHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<?> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( false );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        final Embedded catalina = new Embedded();\n        final Engine engine = catalina.createEngine();\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( \"localhost\" );\n        engine.setJvmRoute( jvmRoute );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n\n        final String docBase = root.getFile() + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", File.separator );\n        final Host host = catalina.createHost( \"localhost\", docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        engine.setManager( sessionManager );\n\n        final Context context = catalina.createContext( \"/\", \"webapp\" );\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        host.addChild( context );\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n\n        catalina.addEngine( engine );\n\n        final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().getManager();\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _keyValues = keyValues;\n        }\n        String getSessionId() {\n            return _sessionId;\n        }\n        Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.Currency;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport javax.naming.NamingException;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Role;\nimport org.apache.catalina.User;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.core.StandardServer;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityCollection;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.realm.UserDatabaseRealm;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.catalina.users.MemoryUserDatabase;\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.Header;\nimport org.apache.commons.httpclient.HeaderElement;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.naming.NamingContext;\nimport org.junit.Assert;\n\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    private static final String USER_DATABASE = \"UserDatabase\";\n    protected static final String PASSWORD = \"secret\";\n    protected static final String USER_NAME = \"testuser\";\n    protected static final String ROLE_NAME = \"test\";\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpMethod method = new GetMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            return responseSessionId == null ? rsessionId : responseSessionId;\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static Response get( final HttpClient client, final int port, final String rsessionId )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId );\n    }\n\n    public static Response get( final HttpClient client, final int port, final String rsessionId,\n            final Credentials credentials )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId, credentials );\n    }\n\n    public static Response get( final HttpClient client, final int port, final String path, final String rsessionId ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null );\n    }\n\n    public static Response get( final HttpClient client, final int port, final String path, final String rsessionId,\n            final Credentials credentials ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://localhost:\"+ port +\"/\";\n        final String url = baseUri + ( path != null ? path : \"\" );\n        final HttpMethod method = new GetMethod( url );\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            if ( credentials != null ) {\n                client.getState().setCredentials( AuthScope.ANY, credentials );\n                method.setDoAuthentication( true );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            return readResponse( rsessionId, method );\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    private static Response readResponse( final String rsessionId, final HttpMethod method ) throws IOException {\n        final String responseSessionId = getSessionIdFromResponse( method );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        final String bodyAsString = method.getResponseBodyAsString();\n        final String[] lines = bodyAsString.split( \"\\r\\n\" );\n\n        final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n        for ( final String line : lines ) {\n            final String[] keyValue = line.split( \"=\" );\n            if ( keyValue.length > 0 ) {\n                keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n            }\n        }\n\n        final Response response = new Response( responseSessionId == null ? rsessionId : responseSessionId, keyValues );\n        return response;\n    }\n\n    public static Response post( final HttpClient client,\n            final int port,\n            final String rsessionId,\n            final String paramName,\n            final String paramValue ) throws IOException, HttpException {\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( paramName, paramValue );\n        return post( client, port, null, rsessionId, params );\n    }\n\n    public static Response post( final HttpClient client,\n            final int port,\n            final String path,\n            final String rsessionId,\n            final Map<String, String> params ) throws IOException, HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://localhost:\"+ port +\"/\";\n        final String url = baseUri + ( path != null ? path : \"\" );\n        final PostMethod method = new PostMethod( url );\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            for( final Map.Entry<String, String> param : params.entrySet() ) {\n                method.addParameter( param.getKey(), param.getValue() );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() == 302 ) {\n                final String location = method.getResponseHeader( \"Location\" ).getValue();\n                if ( !location.startsWith( baseUri ) ) {\n                    throw new RuntimeException( \"There's s.th. wrong, the location header should start with the base URI \" + baseUri +\n                            \". The location header: \" + location );\n                }\n                final String redirectPath = location.substring( baseUri.length(), location.length() );\n                return get( client, port, redirectPath, rsessionId );\n            }\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            return readResponse( rsessionId, method );\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static String getSessionIdFromResponse( final HttpMethod method ) {\n        final Header cookie = method.getResponseHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<?> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( false );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, null, loginType );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, loginType );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null, null );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute,\n            final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        final Embedded catalina = new Embedded();\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer( server );\n\n        try {\n            final NamingContext globalNamingContext = new NamingContext( new Hashtable<Object, Object>(), \"ctxt\" );\n            server.setGlobalNamingContext( globalNamingContext );\n            globalNamingContext.bind( USER_DATABASE, createUserDatabase() );\n        } catch ( final NamingException e ) {\n            throw new RuntimeException( e );\n        }\n\n        final Engine engine = catalina.createEngine();\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( \"localhost\" );\n        engine.setJvmRoute( jvmRoute );\n\n        final UserDatabaseRealm realm = new UserDatabaseRealm();\n        realm.setResourceName( USER_DATABASE );\n        engine.setRealm( realm );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n\n        final String docBase = root.getFile() + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", File.separator );\n        final Host host = catalina.createHost( \"localhost\", docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        engine.setManager( sessionManager );\n\n        final Context context = catalina.createContext( \"/\", \"webapp\" );\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        if ( loginType != null ) {\n            context.addConstraint( createSecurityConstraint( \"/*\", ROLE_NAME ) );\n            // context.addConstraint( createSecurityConstraint( \"/j_security_check\", null ) );\n            context.addSecurityRole( ROLE_NAME );\n            final LoginConfig loginConfig = loginType == LoginType.FORM\n                ? new LoginConfig( \"FORM\", null, \"/login\", \"/error\" )\n                : new LoginConfig( \"BASIC\", null, null, null );\n                context.setLoginConfig( loginConfig );\n        }\n\n        host.addChild( context );\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n\n        catalina.addEngine( engine );\n\n        final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    private static SecurityConstraint createSecurityConstraint( final String pattern, final String role ) {\n        final SecurityConstraint constraint = new SecurityConstraint();\n        final SecurityCollection securityCollection = new SecurityCollection();\n        securityCollection.addPattern( pattern );\n        constraint.addCollection( securityCollection );\n        if ( role != null ) {\n            constraint.addAuthRole( role );\n        }\n        return constraint;\n    }\n\n    public static enum LoginType {\n        BASIC, FORM\n    }\n\n    private static MemoryUserDatabase createUserDatabase() {\n        final MemoryUserDatabase userDatabase = new MemoryUserDatabase();\n        final Role role = userDatabase.createRole( ROLE_NAME, \"the role for unit tests\" );\n        final User user = userDatabase.createUser( USER_NAME, PASSWORD, \"the user for unit tests\" );\n        user.addRole( role );\n        return userDatabase;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().getManager();\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _keyValues = keyValues;\n        }\n        String getSessionId() {\n            return _sessionId;\n        }\n        Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another ) {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked ) {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    public static void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                try {\n                    assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n                } catch ( final IllegalArgumentException e ) {\n                    throw new RuntimeException( e );\n                } catch ( final IllegalAccessException e ) {\n                    throw new RuntimeException( e );\n                }\n            }\n        }\n    }\n\n}\n","lineNo":197}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.Header;\nimport org.apache.commons.httpclient.HeaderElement;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.PostMethod;\n\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpMethod method = new GetMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            return responseSessionId == null ? rsessionId : responseSessionId;\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static Response get( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpMethod method = new GetMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            final String bodyAsString = method.getResponseBodyAsString();\n            final String[] lines = bodyAsString.split( \"\\r\\n\" );\n            final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n            for ( final String line : lines ) {\n                final String[] keyValue = line.split( \"=\" );\n                if ( keyValue.length > 0 ) {\n                    keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n                }\n            }\n\n            return new Response( responseSessionId == null ? rsessionId : responseSessionId, keyValues );\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static String post( final HttpClient client, final int port, final String rsessionId, final String paramName, final String paramValue ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final PostMethod method = new PostMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            method.addParameter( paramName, paramValue );\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            return responseSessionId == null ? rsessionId : responseSessionId;\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static String getSessionIdFromResponse( final HttpMethod method ) {\n        final Header cookie = method.getResponseHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<?> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( false );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        final Embedded catalina = new Embedded();\n        final Engine engine = catalina.createEngine();\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( \"localhost\" );\n        engine.setJvmRoute( jvmRoute );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n\n        final String docBase = root.getFile() + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", File.separator );\n        final Host host = catalina.createHost( \"localhost\", docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        engine.setManager( sessionManager );\n\n        final Context context = catalina.createContext( \"/\", \"webapp\" );\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        host.addChild( context );\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n\n        catalina.addEngine( engine );\n\n        final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().getManager();\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _keyValues = keyValues;\n        }\n        String getSessionId() {\n            return _sessionId;\n        }\n        Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.Currency;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport javax.naming.NamingException;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Role;\nimport org.apache.catalina.User;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.core.StandardServer;\nimport org.apache.catalina.deploy.LoginConfig;\nimport org.apache.catalina.deploy.SecurityCollection;\nimport org.apache.catalina.deploy.SecurityConstraint;\nimport org.apache.catalina.realm.UserDatabaseRealm;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.catalina.users.MemoryUserDatabase;\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.Header;\nimport org.apache.commons.httpclient.HeaderElement;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.naming.NamingContext;\nimport org.junit.Assert;\n\nimport com.thimbleware.jmemcached.CacheImpl;\nimport com.thimbleware.jmemcached.LocalCacheElement;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap;\nimport com.thimbleware.jmemcached.storage.hash.ConcurrentLinkedHashMap.EvictionPolicy;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\n\n/**\n * Integration test utils.\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class TestUtils {\n\n    private static final String USER_DATABASE = \"UserDatabase\";\n    protected static final String PASSWORD = \"secret\";\n    protected static final String USER_NAME = \"testuser\";\n    protected static final String ROLE_NAME = \"test\";\n\n    public static String makeRequest( final HttpClient client, final int port, final String rsessionId ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        String responseSessionId;\n        final HttpMethod method = new GetMethod(\"http://localhost:\"+ port +\"/\");\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            // System.out.println( \">>>>>>>>>>: \" + method.getResponseBodyAsString() );\n            responseSessionId = getSessionIdFromResponse( method );\n            // System.out.println( \"response cookie: \" + responseSessionId );\n\n            return responseSessionId == null ? rsessionId : responseSessionId;\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static Response get( final HttpClient client, final int port, final String rsessionId )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId );\n    }\n\n    public static Response get( final HttpClient client, final int port, final String rsessionId,\n            final Credentials credentials )\n        throws IOException, HttpException {\n        return get( client, port, null, rsessionId, credentials );\n    }\n\n    public static Response get( final HttpClient client, final int port, final String path, final String rsessionId ) throws IOException,\n            HttpException {\n        return get( client, port, path, rsessionId, null );\n    }\n\n    public static Response get( final HttpClient client, final int port, final String path, final String rsessionId,\n            final Credentials credentials ) throws IOException,\n            HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://localhost:\"+ port +\"/\";\n        final String url = baseUri + ( path != null ? path : \"\" );\n        final HttpMethod method = new GetMethod( url );\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            if ( credentials != null ) {\n                client.getState().setCredentials( AuthScope.ANY, credentials );\n                method.setDoAuthentication( true );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            return readResponse( rsessionId, method );\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    private static Response readResponse( final String rsessionId, final HttpMethod method ) throws IOException {\n        final String responseSessionId = getSessionIdFromResponse( method );\n        // System.out.println( \"response cookie: \" + responseSessionId );\n\n        final String bodyAsString = method.getResponseBodyAsString();\n        final String[] lines = bodyAsString.split( \"\\r\\n\" );\n\n        final Map<String, String> keyValues = new LinkedHashMap<String, String>();\n        for ( final String line : lines ) {\n            final String[] keyValue = line.split( \"=\" );\n            if ( keyValue.length > 0 ) {\n                keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null );\n            }\n        }\n\n        final Response response = new Response( responseSessionId == null ? rsessionId : responseSessionId, keyValues );\n        return response;\n    }\n\n    public static Response post( final HttpClient client,\n            final int port,\n            final String rsessionId,\n            final String paramName,\n            final String paramValue ) throws IOException, HttpException {\n        final Map<String, String> params = new HashMap<String, String>();\n        params.put( paramName, paramValue );\n        return post( client, port, null, rsessionId, params );\n    }\n\n    public static Response post( final HttpClient client,\n            final int port,\n            final String path,\n            final String rsessionId,\n            final Map<String, String> params ) throws IOException, HttpException {\n        // System.out.println( port + \" >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>\");\n        final String baseUri = \"http://localhost:\"+ port +\"/\";\n        final String url = baseUri + ( path != null ? path : \"\" );\n        final PostMethod method = new PostMethod( url );\n        try {\n            if ( rsessionId != null ) {\n                method.setRequestHeader( \"Cookie\", \"JSESSIONID=\" + rsessionId );\n            }\n\n            for( final Map.Entry<String, String> param : params.entrySet() ) {\n                method.addParameter( param.getKey(), param.getValue() );\n            }\n\n            // System.out.println( \"cookies: \" + method.getParams().getCookiePolicy() );\n            //method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);\n            client.executeMethod( method );\n\n            if ( method.getStatusCode() == 302 ) {\n                final String location = method.getResponseHeader( \"Location\" ).getValue();\n                if ( !location.startsWith( baseUri ) ) {\n                    throw new RuntimeException( \"There's s.th. wrong, the location header should start with the base URI \" + baseUri +\n                            \". The location header: \" + location );\n                }\n                final String redirectPath = location.substring( baseUri.length(), location.length() );\n                return get( client, port, redirectPath, rsessionId );\n            }\n\n            if ( method.getStatusCode() != 200 ) {\n                throw new RuntimeException( \"GET did not return status 200, but \" + method.getStatusLine() );\n            }\n\n            return readResponse( rsessionId, method );\n\n        } finally {\n            method.releaseConnection();\n            // System.out.println( port + \" <<<<<<<<<<<<<<<<<<<<<< Client Finished <<<<<<<<<<<<<<<<<<<<<<<\");\n        }\n    }\n\n    public static String getSessionIdFromResponse( final HttpMethod method ) {\n        final Header cookie = method.getResponseHeader( \"Set-Cookie\" );\n        if ( cookie != null ) {\n            for ( final HeaderElement header : cookie.getElements() ) {\n                if ( \"JSESSIONID\".equals( header.getName() ) ) {\n                    return header.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static MemCacheDaemon<?> createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon<LocalCacheElement> daemon = new MemCacheDaemon<LocalCacheElement>();\n        final ConcurrentLinkedHashMap<String, LocalCacheElement> cacheStorage = ConcurrentLinkedHashMap.create(\n                EvictionPolicy.LRU, 100000, 1024*1024 );\n        daemon.setCache( new CacheImpl( cacheStorage ) );\n        daemon.setAddr( address );\n        daemon.setVerbose( false );\n        return daemon;\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, null, loginType );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, null );\n    }\n\n    public static Embedded createCatalina( final int port, final String memcachedNodes, final String jvmRoute, final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, 1, memcachedNodes, jvmRoute, loginType );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        return createCatalina( port, sessionTimeout, memcachedNodes, null, null );\n    }\n\n    public static Embedded createCatalina( final int port, final int sessionTimeout, final String memcachedNodes, final String jvmRoute,\n            final LoginType loginType ) throws MalformedURLException,\n            UnknownHostException, LifecycleException {\n        final Embedded catalina = new Embedded();\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer( server );\n\n        try {\n            final NamingContext globalNamingContext = new NamingContext( new Hashtable<Object, Object>(), \"ctxt\" );\n            server.setGlobalNamingContext( globalNamingContext );\n            globalNamingContext.bind( USER_DATABASE, createUserDatabase() );\n        } catch ( final NamingException e ) {\n            throw new RuntimeException( e );\n        }\n\n        final Engine engine = catalina.createEngine();\n        /* we must have a unique name for mbeans\n         */\n        engine.setName( \"engine-\" + port );\n        engine.setDefaultHost( \"localhost\" );\n        engine.setJvmRoute( jvmRoute );\n\n        final UserDatabaseRealm realm = new UserDatabaseRealm();\n        realm.setResourceName( USER_DATABASE );\n        engine.setRealm( realm );\n\n        final URL root = new URL( TestUtils.class.getResource( \"/\" ), \"../resources\" );\n\n        final String docBase = root.getFile() + File.separator + TestUtils.class.getPackage().getName().replaceAll( \"\\\\.\", File.separator );\n        final Host host = catalina.createHost( \"localhost\", docBase );\n        engine.addChild( host );\n        new File( docBase ).mkdirs();\n\n        final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager();\n        engine.setManager( sessionManager );\n\n        final Context context = catalina.createContext( \"/\", \"webapp\" );\n        context.setManager( sessionManager );\n        context.setBackgroundProcessorDelay( 1 );\n        new File( docBase + File.separator + \"webapp\" ).mkdirs();\n\n        if ( loginType != null ) {\n            context.addConstraint( createSecurityConstraint( \"/*\", ROLE_NAME ) );\n            // context.addConstraint( createSecurityConstraint( \"/j_security_check\", null ) );\n            context.addSecurityRole( ROLE_NAME );\n            final LoginConfig loginConfig = loginType == LoginType.FORM\n                ? new LoginConfig( \"FORM\", null, \"/login\", \"/error\" )\n                : new LoginConfig( \"BASIC\", null, null, null );\n                context.setLoginConfig( loginConfig );\n        }\n\n        host.addChild( context );\n\n        /* we must set the maxInactiveInterval after the context,\n         * as setContainer(context) uses the session timeout set on the context\n         */\n        sessionManager.setMemcachedNodes( memcachedNodes );\n        sessionManager.setMaxInactiveInterval( sessionTimeout ); // 1 second\n        sessionManager.setProcessExpiresFrequency( 1 ); // 1 second (factor for context.setBackgroundProcessorDelay)\n\n        catalina.addEngine( engine );\n\n        final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false );\n        catalina.addConnector( connector );\n\n        return catalina;\n    }\n\n    private static SecurityConstraint createSecurityConstraint( final String pattern, final String role ) {\n        final SecurityConstraint constraint = new SecurityConstraint();\n        final SecurityCollection securityCollection = new SecurityCollection();\n        securityCollection.addPattern( pattern );\n        constraint.addCollection( securityCollection );\n        if ( role != null ) {\n            constraint.addAuthRole( role );\n        }\n        return constraint;\n    }\n\n    public static enum LoginType {\n        BASIC, FORM\n    }\n\n    private static MemoryUserDatabase createUserDatabase() {\n        final MemoryUserDatabase userDatabase = new MemoryUserDatabase();\n        final Role role = userDatabase.createRole( ROLE_NAME, \"the role for unit tests\" );\n        final User user = userDatabase.createUser( USER_NAME, PASSWORD, \"the user for unit tests\" );\n        user.addRole( role );\n        return userDatabase;\n    }\n\n    public static MemcachedBackupSessionManager getManager( final Embedded tomcat ) {\n        return (MemcachedBackupSessionManager) tomcat.getContainer().getManager();\n    }\n\n    /**\n     * A helper class for a response with a body containing key=value pairs\n     * each in one line.\n     */\n    public static class Response {\n\n        private final String _sessionId;\n        private final Map<String, String> _keyValues;\n        public Response( final String sessionId, final Map<String, String> keyValues ) {\n            _sessionId = sessionId;\n            _keyValues = keyValues;\n        }\n        String getSessionId() {\n            return _sessionId;\n        }\n        Map<String, String> getKeyValues() {\n            return _keyValues;\n        }\n        String get( final String key ) {\n            return _keyValues.get( key );\n        }\n\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another ) {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    public static void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked ) {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    public static void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                try {\n                    assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n                } catch ( final IllegalArgumentException e ) {\n                    throw new RuntimeException( e );\n                } catch ( final IllegalAccessException e ) {\n                    throw new RuntimeException( e );\n                }\n            }\n        }\n    }\n\n}\n","lineNo":198}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:\\\\s+\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private final Random _random = new Random();\n\n    private final Log _log = LogFactory.getLog( MemcachedBackupSessionManager.class );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = false;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private Class<? extends TranscoderFactory> _transcoderFactoryClass = JavaSerializationTranscoderFactory.class;\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    // -------------------- END configuration properties --------------------\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    /*\n     * remove may be called with sessionIds that already failed before (probably\n     * because the browser makes subsequent requests with the old sessionId -\n     * the exact reason needs to be verified). These failed sessionIds should If\n     * a session is requested that we don't have locally stored each findSession\n     * invocation would trigger a memcached request - this would open the door\n     * for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     *\n     * Updated: the node status cache holds the status of each node for the\n     * configured TTL.\n     */\n    private NodeAvailabilityCache<String> _nodeAvailabilityCache;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /*\n     * we have to implement rejectedSessions - not sure why\n     */\n    private int _rejectedSessions;\n\n    private Set<String> _allNodeIds;\n    private List<String> _nodeIds;\n\n    private List<String> _failoverNodeIds;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        _log.info( getClass().getSimpleName() + \" starts initialization...\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        /* add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern, this ) );\n\n        /* init memcached\n         */\n\n        if ( !NODES_PATTERN.matcher( _memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        _nodeIds = new ArrayList<String>();\n        _allNodeIds = new HashSet<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( _memcachedNodes );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids );\n        }\n\n        initFailoverNodes();\n\n        if ( _nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        initMemcachedClient( addresses, address2Ids );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n        _nodeAvailabilityCache = createNodeAvailabilityCache( 1000 );\n\n    }\n\n    private void initMemcachedClient( final List<InetSocketAddress> addresses, final Map<InetSocketAddress, String> address2Ids ) {\n        try {\n            _memcached =\n                    new MemcachedClient( new SuffixLocatorConnectionFactory( this, new MapBasedResolver( address2Ids ),\n                            _sessionIdFormat, createTranscoderFactory() ), addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException {\n        log.info( \"Starting with transcoder factory \" + _transcoderFactoryClass.getName() );\n        final TranscoderFactory transcoderFactory = _transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Loading custom converter classes \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \", \" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private NodeAvailabilityCache<String> createNodeAvailabilityCache( final long ttlInMillis ) {\n        return new NodeAvailabilityCache<String>( _allNodeIds.size(), ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    _memcached.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private void initFailoverNodes() {\n        _failoverNodeIds = new ArrayList<String>();\n        if ( _failoverNodes != null && _failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodes = _failoverNodes.split( \" \" );\n            for ( final String failoverNode : failoverNodes ) {\n                final String nodeId = failoverNode.trim();\n                if ( !_nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + _memcachedNodes + \"'.\" );\n                }\n                _failoverNodeIds.add( nodeId );\n            }\n        }\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids ) {\n        final String nodeId = matcher.group( 1 );\n        _nodeIds.add( nodeId );\n        _allNodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), getMemcachedNodeId() );\n    }\n\n    private String getMemcachedNodeId() {\n        return _nodeIds.get( _random.nextInt( _nodeIds.size() ) );\n    }\n\n    private boolean isValidSessionIdFormat( final String sessionId ) {\n        return _sessionIdFormat.isValid( sessionId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        _log.debug( \"expireSession invoked: \" + sessionId );\n        super.expireSession( sessionId );\n        _memcached.delete( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        Session result = super.findSession( id );\n        if ( result == null && _missingSessionsCache.get( id ) == null ) {\n            result = loadFromMemcached( id );\n            if ( result != null ) {\n                add( result );\n            } else {\n                _missingSessionsCache.put( id, Boolean.TRUE );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( final String sessionId ) {\n        _log.debug( \"createSession invoked: \" + sessionId );\n\n        Session session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n            session.setId( generateSessionId() );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return ( session );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String sessionNeedsRelocate( final Session session ) {\n        final BackupSessionTask task = getOrCreateBackupSessionTask( (MemcachedBackupSession) session );\n        return task.sessionNeedsRelocate();\n    }\n\n    /**\n     * Store the provided session in memcached.\n     *\n     * @param session\n     *            the session to save\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResult}\n     */\n    public BackupResult backupSession( final Session session ) {\n        if ( _log.isInfoEnabled() ) {\n            _log.debug( \"Trying to store session in memcached: \" + session.getId() );\n        }\n\n        final BackupSessionTask task = getOrCreateBackupSessionTask( (MemcachedBackupSession) session );\n        return task.backupSession();\n    }\n\n    private BackupSessionTask getOrCreateBackupSessionTask( final MemcachedBackupSession session ) {\n        if ( session.getBackupTask() == null ) {\n            session.setBackupTask( new BackupSessionTask( session, _sessionBackupAsync, _sessionBackupTimeout,\n                    _memcached, _nodeAvailabilityCache, _nodeIds, _failoverNodeIds ) );\n        }\n        return session.getBackupTask();\n    }\n\n    private Session loadFromMemcached( final String sessionId ) {\n        if ( !isValidSessionIdFormat( sessionId ) ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeAvailabilityCache.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n            try {\n                final Session session = (Session) _memcached.get( sessionId );\n                if ( _log.isDebugEnabled() ) {\n                    if ( session == null ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, true );\n                return session;\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached: \" + e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE ) +\n                    \", node failure: \" + session.getNote( BackupSessionTask.NODE_FAILURE ) +\n                    \", id: \" + session.getId() );\n        }\n        if ( session.getNote( BackupSessionTask.NODE_FAILURE ) != Boolean.TRUE ) {\n            try {\n                _log.debug( \"Deleting session from memcached: \" + session.getId() );\n                _memcached.delete( session.getId() );\n            } catch ( final NodeFailureException e ) {\n                /* We can ignore this */\n            }\n        }\n        super.remove( session );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        try {\n            _transcoderFactoryClass = Class.forName( transcoderFactoryClassName ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.error( \"The transcoderFactoryClass (\" + transcoderFactoryClassName + \") could not be found\" );\n            throw new RuntimeException( e );\n        }\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            _memcached.shutdown();\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        _sessionBackupAsync = sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The session class used by this manager, to be able to change the session\n     * id without the whole notification lifecycle (which includes the\n     * application also).\n     */\n    public static final class MemcachedBackupSession extends StandardSession {\n\n        private static final long serialVersionUID = 1L;\n\n        private volatile transient BackupSessionTask _backupTask;\n\n        /*\n         * The hash code of the serialized byte[] of this session that is\n         * used to determine, if the session was modified.\n         */\n        private transient int _dataHashCode;\n\n        /**\n         * Creates a new instance without a given manager. This has to be\n         * assigned via {@link #setManager(Manager)} before this session is\n         * used.\n         *\n         */\n        public MemcachedBackupSession() {\n            super( null );\n        }\n\n        /**\n         * Creates a new instance with the given manager.\n         *\n         * @param manager\n         *            the manager\n         */\n        public MemcachedBackupSession( final Manager manager ) {\n            super( manager );\n        }\n\n        /**\n         * Set a new id for this session.<br/>\n         * Before setting the new id, it removes itself from the associated\n         * manager. After the new id is set, this session adds itself to the\n         * session manager.\n         *\n         * @param id\n         *            the new session id\n         */\n        protected void setIdForRelocate( final String id ) {\n\n            if ( this.id == null ) {\n                throw new IllegalStateException( \"There's no session id set.\" );\n            }\n            if ( this.manager == null ) {\n                throw new IllegalStateException( \"There's no manager set.\" );\n            }\n\n            manager.remove( this );\n            this.id = id;\n            manager.add( this );\n\n        }\n\n        @Override\n        public void setId( final String id ) {\n            super.setId( id );\n        }\n\n        /**\n         * Performs some initialization of this session that is required after\n         * deserialization. This must be invoked by custom serialization strategies\n         * that do not rely on the {@link StandardSession} serialization.\n         */\n        public void doAfterDeserialization() {\n            if ( listeners == null ) {\n                listeners = new ArrayList<Object>();\n            }\n            if ( notes == null ) {\n                notes = new Hashtable<Object, Object>();\n            }\n        }\n\n        /**\n         * The hash code of the serialized byte[] of this session that is\n         * used to determine, if the session was modified.\n         * @return\n         */\n        public int getDataHashCode() {\n            return _dataHashCode;\n        }\n\n        protected long getCreationTimeInternal() {\n            return super.creationTime;\n        }\n\n        protected void setCreationTimeInternal( final long creationTime ) {\n            super.creationTime = creationTime;\n        }\n\n        protected boolean isNewInternal() {\n            return super.isNew;\n        }\n\n        protected void setIsNewInternal( final boolean isNew ) {\n            super.isNew = isNew;\n        }\n\n        protected boolean isValidInternal() {\n            return super.isValid;\n        }\n\n        protected void setIsValidInternal( final boolean isValid ) {\n            super.isValid = isValid;\n        }\n\n        protected long getThisAccessedTimeInternal() {\n            return super.thisAccessedTime;\n        }\n\n        protected void setThisAccessedTimeInternal( final long thisAccessedTime ) {\n            super.thisAccessedTime = thisAccessedTime;\n        }\n\n        protected void setLastAccessedTimeInternal( final long lastAccessedTime ) {\n            super.lastAccessedTime = lastAccessedTime;\n        }\n\n        protected void setIdInternal( final String id ) {\n            super.id = id;\n        }\n\n        /**\n         * The backup task associated with this session if it was already set\n         * via {@link #setBackupTask(BackupSessionTask)}.\n         *\n         * @return the {@link BackupSessionTask} or <code>null<\/code>.\n         */\n        BackupSessionTask getBackupTask() {\n            return _backupTask;\n        }\n\n        /**\n         * Set the {@link BackupSessionTask} to use for this session.\n         *\n         * @param backupTask an instance of {@link BackupSessionTask}, never <code>null<\/code>.\n         */\n        void setBackupTask( final BackupSessionTask backupTask ) {\n            _backupTask = backupTask;\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\n\nimport de.javakaffee.web.msm.BackupSessionTask.BackupResult;\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\nimport de.javakaffee.web.msm.TranscoderService.DeserializationResult;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n *\n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:\\\\s+\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private final Random _random = new Random();\n\n    private final Log _log = LogFactory.getLog( MemcachedBackupSessionManager.class );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     *\n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     *\n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = false;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class is\n     * {@link JavaSerializationTranscoderFactory}.\n     */\n    private Class<? extends TranscoderFactory> _transcoderFactoryClass = JavaSerializationTranscoderFactory.class;\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    private String _customConverterClassNames;\n\n    // -------------------- END configuration properties --------------------\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    /*\n     * remove may be called with sessionIds that already failed before (probably\n     * because the browser makes subsequent requests with the old sessionId -\n     * the exact reason needs to be verified). These failed sessionIds should If\n     * a session is requested that we don't have locally stored each findSession\n     * invocation would trigger a memcached request - this would open the door\n     * for DOS attacks...\n     *\n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     *\n     * Updated: the node status cache holds the status of each node for the\n     * configured TTL.\n     */\n    private NodeAvailabilityCache<String> _nodeAvailabilityCache;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /*\n     * we have to implement rejectedSessions - not sure why\n     */\n    private int _rejectedSessions;\n\n    private Set<String> _allNodeIds;\n    private List<String> _nodeIds;\n\n    private List<String> _failoverNodeIds;\n\n    private TranscoderService _transcoderService;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     *\n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     *\n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        init( null );\n    }\n\n    /**\n     * Initialize this manager. The memcachedClient parameter is there for testing\n     * purposes. If the memcachedClient is provided it's used, otherwise a \"real\"/new\n     * memcached client is created based on the configuration (like {@link #setMemcachedNodes(String)} etc.).\n     *\n     * @param memcachedClient the memcached client to use, for normal operations this should be <code>null<\/code>.\n     */\n    void init( final MemcachedClient memcachedClient ) {\n        _log.info( getClass().getSimpleName() + \" starts initialization... (configured\" +\n        \t\t\" nodes definition \" + _memcachedNodes + \", failover nodes \" + _failoverNodes + \")\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        /* add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern, this ) );\n\n        /* init memcached\n         */\n\n        if ( !NODES_PATTERN.matcher( _memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        _nodeIds = new ArrayList<String>();\n        _allNodeIds = new HashSet<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( _memcachedNodes );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids );\n        }\n\n        initFailoverNodes();\n\n        if ( _nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        _memcached = memcachedClient != null ? memcachedClient : createMemcachedClient( addresses, address2Ids );\n\n        /* create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n        _nodeAvailabilityCache = createNodeAvailabilityCache( 1000 );\n\n        _transcoderService = createTranscoderService();\n\n        _log.info( getClass().getSimpleName() + \" finished initialization, have node ids \" + _nodeIds + \" and failover node ids \" + _failoverNodeIds );\n\n    }\n\n    private TranscoderService createTranscoderService() {\n        final TranscoderFactory transcoderFactory;\n        try {\n            transcoderFactory = createTranscoderFactory();\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create transcoder factory.\", e );\n        }\n        return new TranscoderService( transcoderFactory.createTranscoder( this ) );\n    }\n\n    private MemcachedClient createMemcachedClient( final List<InetSocketAddress> addresses, final Map<InetSocketAddress, String> address2Ids ) {\n        try {\n            return new MemcachedClient( new SuffixLocatorConnectionFactory( new MapBasedResolver( address2Ids ), _sessionIdFormat ), addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n    }\n\n    private TranscoderFactory createTranscoderFactory() throws InstantiationException, IllegalAccessException {\n        log.info( \"Starting with transcoder factory \" + _transcoderFactoryClass.getName() );\n        final TranscoderFactory transcoderFactory = _transcoderFactoryClass.newInstance();\n        transcoderFactory.setCopyCollectionsForSerialization( _copyCollectionsForSerialization );\n        if ( _customConverterClassNames != null ) {\n            _log.info( \"Loading custom converter classes \" + _customConverterClassNames );\n            transcoderFactory.setCustomConverterClassNames( _customConverterClassNames.split( \", \" ) );\n        }\n        return transcoderFactory;\n    }\n\n    private NodeAvailabilityCache<String> createNodeAvailabilityCache( final long ttlInMillis ) {\n        return new NodeAvailabilityCache<String>( _allNodeIds.size(), ttlInMillis, new CacheLoader<String>() {\n\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    _memcached.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private void initFailoverNodes() {\n        _failoverNodeIds = new ArrayList<String>();\n        if ( _failoverNodes != null && _failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodes = _failoverNodes.split( \" \" );\n            for ( final String failoverNode : failoverNodes ) {\n                final String nodeId = failoverNode.trim();\n                if ( !_nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + _memcachedNodes + \"'.\" );\n                }\n                _failoverNodeIds.add( nodeId );\n            }\n        }\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids ) {\n        final String nodeId = matcher.group( 1 );\n        _nodeIds.add( nodeId );\n        _allNodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), getMemcachedNodeId() );\n    }\n\n    private String getMemcachedNodeId() {\n        return _nodeIds.get( _random.nextInt( _nodeIds.size() ) );\n    }\n\n    private boolean isValidSessionIdFormat( final String sessionId ) {\n        return _sessionIdFormat.isValid( sessionId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        _log.debug( \"expireSession invoked: \" + sessionId );\n        super.expireSession( sessionId );\n        _memcached.delete( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     *\n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     *\n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        Session result = super.findSession( id );\n        if ( result == null && _missingSessionsCache.get( id ) == null ) {\n            result = loadFromMemcached( id );\n            if ( result != null ) {\n                add( result );\n            } else {\n                _missingSessionsCache.put( id, Boolean.TRUE );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( final String sessionId ) {\n        _log.debug( \"createSession invoked: \" + sessionId );\n\n        Session session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n            session.setId( generateSessionId() );\n\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return ( session );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String sessionNeedsRelocate( final Session session ) {\n        final BackupSessionTask task = getOrCreateBackupSessionTask( (MemcachedBackupSession) session );\n        return task.sessionNeedsRelocate();\n    }\n\n    /**\n     * Store the provided session in memcached if the session was modified\n     * or if the session needs to be relocated.\n     *\n     * @param session\n     *            the session to save\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}\n     */\n    public BackupResultStatus backupSession( final Session session ) {\n        if ( _log.isInfoEnabled() ) {\n            _log.debug( \"Trying to store session in memcached: \" + session.getId() );\n        }\n\n        final MemcachedBackupSession backupSession = (MemcachedBackupSession) session;\n\n        final BackupSessionTask task = getOrCreateBackupSessionTask( backupSession );\n\n        final Map<String, Object> attributes = backupSession.getAttributesInternal();\n\n        final byte[] attributesData = _transcoderService.serializeAttributes( backupSession, attributes );\n        final int hashCode = Arrays.hashCode( attributesData );\n        if ( backupSession.getDataHashCode() != hashCode\n                || task.sessionCookieWasRelocated() ) {\n            final byte[] data = _transcoderService.serialize( backupSession, attributesData );\n\n            final BackupResult result = task.backupSession( data, attributesData );\n            if ( result.getAttributesData() != null ) {\n                backupSession.setDataHashCode( Arrays.hashCode( result.getAttributesData() ) );\n            }\n\n            return result.getStatus();\n        } else {\n            return BackupResultStatus.SKIPPED;\n        }\n    }\n\n    private BackupSessionTask getOrCreateBackupSessionTask( final MemcachedBackupSession session ) {\n        if ( session.getBackupTask() == null ) {\n            session.setBackupTask( new BackupSessionTask( session, _transcoderService, _sessionBackupAsync, _sessionBackupTimeout,\n                    _memcached, _nodeAvailabilityCache, _nodeIds, _failoverNodeIds ) );\n        }\n        return session.getBackupTask();\n    }\n\n    private Session loadFromMemcached( final String sessionId ) {\n        if ( !isValidSessionIdFormat( sessionId ) ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeAvailabilityCache.isNodeAvailable( nodeId ) ) {\n            _log.debug( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            _log.debug( \"Loading session from memcached: \" + sessionId );\n            try {\n                final byte[] data = (byte[]) _memcached.get( sessionId );\n                if ( _log.isDebugEnabled() ) {\n                    if ( data == null ) {\n                        _log.debug( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _log.debug( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, true );\n\n                final MemcachedBackupSession session;\n                if ( data != null ) {\n                    final DeserializationResult deserializationResult = TranscoderService.deserializeSessionFields( data );\n                    final byte[] attributesData = deserializationResult.getAttributesData();\n                    final Map<String, Object> attributes = _transcoderService.deserializeAttributes( attributesData );\n                    session = deserializationResult.getSession();\n                    session.setAttributesInternal( attributes );\n                    session.setDataHashCode( Arrays.hashCode( attributesData ) );\n                    session.setManager( this );\n                    session.doAfterDeserialization();\n                } else {\n                    session = null;\n                }\n                return session;\n            } catch ( final NodeFailureException e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _log.warn( \"Could not load session with id \" + sessionId + \" from memcached.\", e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        if ( _log.isDebugEnabled() ) {\n            _log.debug( \"remove invoked, session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE ) +\n                    \", node failure: \" + session.getNote( BackupSessionTask.NODE_FAILURE ) +\n                    \", id: \" + session.getId() );\n        }\n        if ( session.getNote( BackupSessionTask.NODE_FAILURE ) != Boolean.TRUE ) {\n            try {\n                _log.debug( \"Deleting session from memcached: \" + session.getId() );\n                _memcached.delete( session.getId() );\n            } catch ( final NodeFailureException e ) {\n                /* We can ignore this */\n            }\n        }\n        super.remove( session );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     *\n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     *\n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     *\n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    /**\n     * The class of the factory that creates the\n     * {@link net.spy.memcached.transcoders.Transcoder} to use for serializing/deserializing\n     * sessions to/from memcached (requires a default/no-args constructor).\n     * The default value is the {@link JavaSerializationTranscoderFactory} class\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * After the {@link TranscoderFactory} instance was created from the specified class,\n     * {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the currently set <code>copyCollectionsForSerialization<\/code> propery, which\n     * has either still the default value (<code>false<\/code>) or the value provided via\n     * {@link #setCopyCollectionsForSerialization(boolean)}.\n     * <\/p>\n     *\n     * @param transcoderFactoryClassName the {@link TranscoderFactory} class name.\n     */\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        try {\n            _transcoderFactoryClass = Class.forName( transcoderFactoryClassName ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _log.error( \"The transcoderFactoryClass (\" + transcoderFactoryClassName + \") could not be found\" );\n            throw new RuntimeException( e );\n        }\n    }\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself. The default value is <code>false<\/code>\n     * (used if this configuration attribute is not specified).\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCopyCollectionsForSerialization(boolean)}\n     * will be invoked with the provided <code>copyCollectionsForSerialization<\/code> value.\n     * <\/p>\n     *\n     * @param copyCollectionsForSerialization\n     *            <code>true<\/code>, if iterating over collection elements shall be done\n     *            on a copy of the collection, <code>false<\/code> if the collections own iterator\n     *            shall be used.\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * Custom converter allow you to provide custom serialization of application specific\n     * types. Multiple converter classes are separated by comma (with optional space following the comma).\n     * <p>\n     * This option is useful if reflection based serialization is very verbose and you want\n     * to provide a more efficient serialization for a specific type.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the {@link TranscoderFactory}\n     * specified via {@link #setTranscoderFactoryClass(String)}: after the {@link TranscoderFactory} instance\n     * was created from the specified class, {@link TranscoderFactory#setCustomConverterClassNames(String[])}\n     * is invoked with the provided custom converter class names.\n     * <\/p>\n     * <p>Requirements regarding the specific custom converter classes depend on the\n     * actual serialization strategy, but a common requirement would be that they must\n     * provide a default/no-args constructor.<br/>\n     * For more details have a look at\n     * <a href=\"http://code.google.com/p/memcached-session-manager/wiki/SerializationStrategies\">SerializationStrategies<\/a>.\n     * <\/p>\n     *\n     * @param customConverterClassNames a list of class names separated by comma\n     */\n    public void setCustomConverter( final String customConverterClassNames ) {\n        _customConverterClassNames = customConverterClassNames;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            _memcached.shutdown();\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _log.warn( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     *\n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        _sessionBackupAsync = sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     *\n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The session class used by this manager, to be able to change the session\n     * id without the whole notification lifecycle (which includes the\n     * application also).\n     */\n    public static final class MemcachedBackupSession extends StandardSession {\n\n        private static final long serialVersionUID = 1L;\n\n        private volatile transient BackupSessionTask _backupTask;\n\n        /*\n         * The hash code of the serialized byte[] of this session that is\n         * used to determine, if the session was modified.\n         */\n        private transient int _dataHashCode;\n\n        /**\n         * Creates a new instance without a given manager. This has to be\n         * assigned via {@link #setManager(Manager)} before this session is\n         * used.\n         *\n         */\n        public MemcachedBackupSession() {\n            super( null );\n        }\n\n        /**\n         * Creates a new instance with the given manager.\n         *\n         * @param manager\n         *            the manager\n         */\n        public MemcachedBackupSession( final Manager manager ) {\n            super( manager );\n        }\n\n        /**\n         * Set a new id for this session.<br/>\n         * Before setting the new id, it removes itself from the associated\n         * manager. After the new id is set, this session adds itself to the\n         * session manager.\n         *\n         * @param id\n         *            the new session id\n         */\n        protected void setIdForRelocate( final String id ) {\n\n            if ( this.id == null ) {\n                throw new IllegalStateException( \"There's no session id set.\" );\n            }\n            if ( this.manager == null ) {\n                throw new IllegalStateException( \"There's no manager set.\" );\n            }\n\n            manager.remove( this );\n            this.id = id;\n            manager.add( this );\n\n        }\n\n        @Override\n        public void setId( final String id ) {\n            super.setId( id );\n        }\n\n        /**\n         * Performs some initialization of this session that is required after\n         * deserialization. This must be invoked by custom serialization strategies\n         * that do not rely on the {@link StandardSession} serialization.\n         */\n        public void doAfterDeserialization() {\n            if ( listeners == null ) {\n                listeners = new ArrayList<Object>();\n            }\n            if ( notes == null ) {\n                notes = new Hashtable<Object, Object>();\n            }\n        }\n\n        /**\n         * The hash code of the serialized byte[] of this sessions attributes that is\n         * used to determine, if the session was modified.\n         * @return\n         */\n        public int getDataHashCode() {\n            return _dataHashCode;\n        }\n\n        /**\n         * Set the hash code of the serialized session attributes.\n         */\n        public void setDataHashCode( final int attributesDataHashCode ) {\n            _dataHashCode = attributesDataHashCode;\n        }\n\n        protected long getCreationTimeInternal() {\n            return super.creationTime;\n        }\n\n        protected void setCreationTimeInternal( final long creationTime ) {\n            super.creationTime = creationTime;\n        }\n\n        protected boolean isNewInternal() {\n            return super.isNew;\n        }\n\n        protected void setIsNewInternal( final boolean isNew ) {\n            super.isNew = isNew;\n        }\n\n        protected boolean isValidInternal() {\n            return super.isValid;\n        }\n\n        protected void setIsValidInternal( final boolean isValid ) {\n            super.isValid = isValid;\n        }\n\n        protected long getThisAccessedTimeInternal() {\n            return super.thisAccessedTime;\n        }\n\n        protected void setThisAccessedTimeInternal( final long thisAccessedTime ) {\n            super.thisAccessedTime = thisAccessedTime;\n        }\n\n        protected void setLastAccessedTimeInternal( final long lastAccessedTime ) {\n            super.lastAccessedTime = lastAccessedTime;\n        }\n\n        protected void setIdInternal( final String id ) {\n            super.id = id;\n        }\n\n        /**\n         * The backup task associated with this session if it was already set\n         * via {@link #setBackupTask(BackupSessionTask)}.\n         *\n         * @return the {@link BackupSessionTask} or <code>null<\/code>.\n         */\n        BackupSessionTask getBackupTask() {\n            return _backupTask;\n        }\n\n        /**\n         * Set the {@link BackupSessionTask} to use for this session.\n         *\n         * @param backupTask an instance of {@link BackupSessionTask}, never <code>null<\/code>.\n         */\n        void setBackupTask( final BackupSessionTask backupTask ) {\n            _backupTask = backupTask;\n        }\n\n        @SuppressWarnings( \"unchecked\" )\n        public Map<String, Object> getAttributesInternal() {\n            return super.attributes;\n        }\n\n        void setAttributesInternal( final Map<String, Object> attributes ) {\n            super.attributes = attributes;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void removeAttributeInternal( final String name, final boolean notify ) {\n            super.removeAttributeInternal( name, notify );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean exclude( final String name ) {\n            return super.exclude( name );\n        }\n\n    }\n\n}\n","lineNo":526}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.getSession().getAttribute( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.getSession().getAttribute( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.getAttribute( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session );\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        // System.out.println( \"xml: \" + new String( bytes ) );\n        assertDeepEquals( session, _transcoder.deserialize( bytes ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testReadValueIntoObject() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        session.setId( \"foo\" );\n\n        session.setAttribute( \"person1\", createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" ) );\n        session.setAttribute( \"person2\", createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" ) );\n\n        final long start1 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final long start2 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start2 ) / 1000 );\n\n        final long start3 = System.nanoTime();\n        final byte[] json = _transcoder.serialize( session );\n        final StandardSession readJSONValue = (StandardSession) _transcoder.deserialize( json );\n        System.out.println( \"javolution-round took \" + ( System.nanoTime() - start3 ) / 1000 );\n\n        System.out.println( \"Have xml: \" + readJSONValue.getId() );\n        assertDeepEquals( readJSONValue, session );\n\n        final long start4 = System.nanoTime();\n        final StandardSession readJavaValue = javaRoundtrip( session, _manager );\n        System.out.println( \"java-round took \" + ( System.nanoTime() - start4 ) / 1000 );\n        assertDeepEquals( readJavaValue, session );\n\n        assertDeepEquals( readJSONValue, readJavaValue );\n\n        System.out.println( ToStringBuilder.reflectionToString( session ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJSONValue ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJavaValue ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.get( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.get( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.get( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session.getAttributesInternal());\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( session.getAttributesInternal(), _transcoder.deserialize( bytes ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","lineNo":365}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.getSession().getAttribute( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.getSession().getAttribute( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.getAttribute( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session );\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        // System.out.println( \"xml: \" + new String( bytes ) );\n        assertDeepEquals( session, _transcoder.deserialize( bytes ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testReadValueIntoObject() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        session.setId( \"foo\" );\n\n        session.setAttribute( \"person1\", createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" ) );\n        session.setAttribute( \"person2\", createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" ) );\n\n        final long start1 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final long start2 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start2 ) / 1000 );\n\n        final long start3 = System.nanoTime();\n        final byte[] json = _transcoder.serialize( session );\n        final StandardSession readJSONValue = (StandardSession) _transcoder.deserialize( json );\n        System.out.println( \"javolution-round took \" + ( System.nanoTime() - start3 ) / 1000 );\n\n        System.out.println( \"Have xml: \" + readJSONValue.getId() );\n        assertDeepEquals( readJSONValue, session );\n\n        final long start4 = System.nanoTime();\n        final StandardSession readJavaValue = javaRoundtrip( session, _manager );\n        System.out.println( \"java-round took \" + ( System.nanoTime() - start4 ) / 1000 );\n        assertDeepEquals( readJavaValue, session );\n\n        assertDeepEquals( readJSONValue, readJavaValue );\n\n        System.out.println( ToStringBuilder.reflectionToString( session ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJSONValue ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJavaValue ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.get( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.get( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.get( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session.getAttributesInternal());\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( session.getAttributesInternal(), _transcoder.deserialize( bytes ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","lineNo":376}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.getSession().getAttribute( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.getSession().getAttribute( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.getAttribute( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session );\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        // System.out.println( \"xml: \" + new String( bytes ) );\n        assertDeepEquals( session, _transcoder.deserialize( bytes ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testReadValueIntoObject() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        session.setId( \"foo\" );\n\n        session.setAttribute( \"person1\", createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" ) );\n        session.setAttribute( \"person2\", createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" ) );\n\n        final long start1 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final long start2 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start2 ) / 1000 );\n\n        final long start3 = System.nanoTime();\n        final byte[] json = _transcoder.serialize( session );\n        final StandardSession readJSONValue = (StandardSession) _transcoder.deserialize( json );\n        System.out.println( \"javolution-round took \" + ( System.nanoTime() - start3 ) / 1000 );\n\n        System.out.println( \"Have xml: \" + readJSONValue.getId() );\n        assertDeepEquals( readJSONValue, session );\n\n        final long start4 = System.nanoTime();\n        final StandardSession readJavaValue = javaRoundtrip( session, _manager );\n        System.out.println( \"java-round took \" + ( System.nanoTime() - start4 ) / 1000 );\n        assertDeepEquals( readJavaValue, session );\n\n        assertDeepEquals( readJSONValue, readJavaValue );\n\n        System.out.println( ToStringBuilder.reflectionToString( session ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJSONValue ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJavaValue ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.get( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.get( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.get( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session.getAttributesInternal());\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( session.getAttributesInternal(), _transcoder.deserialize( bytes ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","lineNo":387}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.getSession().getAttribute( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.getSession().getAttribute( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        \n        assertDeepEquals( deserialized, session );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.getAttribute( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session );\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        // System.out.println( \"xml: \" + new String( bytes ) );\n        assertDeepEquals( session, _transcoder.deserialize( bytes ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testReadValueIntoObject() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        session.setId( \"foo\" );\n\n        session.setAttribute( \"person1\", createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" ) );\n        session.setAttribute( \"person2\", createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" ) );\n\n        final long start1 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final long start2 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start2 ) / 1000 );\n\n        final long start3 = System.nanoTime();\n        final byte[] json = _transcoder.serialize( session );\n        final StandardSession readJSONValue = (StandardSession) _transcoder.deserialize( json );\n        System.out.println( \"javolution-round took \" + ( System.nanoTime() - start3 ) / 1000 );\n\n        System.out.println( \"Have xml: \" + readJSONValue.getId() );\n        assertDeepEquals( readJSONValue, session );\n\n        final long start4 = System.nanoTime();\n        final StandardSession readJavaValue = javaRoundtrip( session, _manager );\n        System.out.println( \"java-round took \" + ( System.nanoTime() - start4 ) / 1000 );\n        assertDeepEquals( readJavaValue, session );\n\n        assertDeepEquals( readJSONValue, readJavaValue );\n\n        System.out.println( ToStringBuilder.reflectionToString( session ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJSONValue ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJavaValue ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyXMLSerializable;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.SomeInterface;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager, true );\n    }\n\n    /**\n     * This is test for issue #34:\n     * msm-javolution-serializer: java.util.Currency gets deserialized with ReflectionFormat\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=34\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testCurrency() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final Currency orig = Currency.getInstance( \"EUR\" );\n        session.setAttribute( \"currency1\", orig );\n        session.setAttribute( \"currency2\", orig );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        \n        // Check that the transient field defaultFractionDigits is initialized correctly (that was the bug)\n        final Currency currency1 = (Currency) deserialized.get( \"currency1\" );\n        Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() );\n        Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() );\n        \n    }\n\n    /**\n     * This is test for issue #33:\n     * msm-javolution-serializer: ReflectionBinding does not honor XMLSerializable interface\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=33\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testXMLSerializableSupport() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        final String attributeName = \"myxmlserializable\";\n        session.setAttribute( attributeName, new MyXMLSerializable( Runtime.getRuntime() ) );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n        final MyXMLSerializable myXMLSerializable = (MyXMLSerializable) deserialized.get( attributeName );\n        Assert.assertNotNull( myXMLSerializable.getRuntime(), \"Transient field runtime should be initialized by XMLFormat\" +\n        \t\t\" used due to implementation of XMLSerializable.\" );\n    }\n\n    /**\n     * This is test for issue #30:\n     * msm-javolution-serializer should support serialization of java.util.Collections$UnmodifiableMap  \n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=30\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsUnmodifiable() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableList( new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) ) ) );\n        final HashMap<String, String> m = new HashMap<String, String>();\n        m.put( \"foo\", \"bar\" );\n        session.setAttribute( \"unmodifiableList\", Collections.unmodifiableMap( m ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is the test for issue #28:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilLists() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        \n        session.setAttribute( \"emptyList\", Collections.<String>emptyList() );\n        session.setAttribute( \"arrayList\", new ArrayList<String>() );\n        session.setAttribute( \"arraysAsList\", Arrays.asList( \"foo\", \"bar\" ) );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    /**\n     * This is another test for issue #28, just for maps:\n     * msm-javolution-serializer should support serialization of java.util.Collections$EmptyList\n     * \n     * See http://code.google.com/p/memcached-session-manager/issues/detail?id=28\n     * \n     * @throws Exception\n     */\n    @Test( enabled = true )\n    public void testJavaUtilCollectionsEmptyMap() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"emptyMap\", Collections.<String, String>emptyMap() );\n        session.setAttribute( \"hashMap\", new HashMap<String, String>() );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        \n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testProxy() throws Exception {\n        final SomeInterface bean = TestClasses.createProxy();\n        final byte[] bytes = serialize( bean );\n        assertDeepEquals( deserialize( bytes ), bean );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n        \n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.get( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        final Map<String, Object> deserialized =\n                _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.get( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 },\n                { long.class, 42 },\n                { Boolean.class, Boolean.TRUE },\n                { String.class, \"42\" },\n                { Class.class, String.class },\n                { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) },\n                { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) },\n                { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) },\n                { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) },\n                { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) },\n                { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } },\n                { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() },\n                { Currency.class, Currency.getInstance( \"EUR\" ) },\n                { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } },\n                { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } },\n                { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } },\n                { int[].class, new int[] { 1, 2 } },\n                { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() },\n                { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session.getAttributesInternal());\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        final Map<String, Object> deserialized = _transcoder.deserialize( _transcoder.serialize( session, session.getAttributesInternal() ) );\n        assertDeepEquals( deserialized, session.getAttributesInternal() );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session, session.getAttributesInternal() );\n        assertDeepEquals( session.getAttributesInternal(), _transcoder.deserialize( bytes ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n        \n        if ( one instanceof Currency ) {\n            // Check that the transient field defaultFractionDigits is initialized correctly (that was issue #34)\n            final Currency currency1 = ( Currency) one;\n            final Currency currency2 = ( Currency) another;\n            Assert.assertEquals( currency1.getCurrencyCode(), currency2.getCurrencyCode() );\n            Assert.assertEquals( currency1.getDefaultFractionDigits(), currency2.getDefaultFractionDigits() );\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_ID );\n            xmlReferenceResolver.setReferenceAttribute( JavolutionTranscoder.REFERENCE_ATTRIBUTE_REF_ID );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","lineNo":397}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\n\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:\\\\s+\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final String NODES_TESTED = \"nodes.tested\";\n\n    private static final String NODE_FAILURE = \"node.failure\";\n\n    private static final String ORIG_SESSION_ID = \"orig.sid\";\n\n    private static final String RELOCATE_SESSION_ID = \"relocate.sid\";\n\n    private final Random _random = new Random();\n\n    private final Logger _logger = Logger.getLogger( MemcachedBackupSessionManager.class.getName() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     * \n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes comma separated, e.g.\n     * <code>n1,n2<\/code>\n     * \n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup. Is matched\n     * against request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = false;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * TODO\n     */\n    private Class<? extends TranscoderFactory> _transcoderFactoryClass = SessionSerializingTranscoderFactory.class;\n\n    // -------------------- END configuration properties --------------------\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     * \n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    /*\n     * remove may be called with sessionIds that already failed before (probably\n     * because the browser makes subsequent requests with the old sessionId -\n     * the exact reason needs to be verified). These failed sessionIds should If\n     * a session is requested that we don't have locally stored each findSession\n     * invocation would trigger a memcached request - this would open the door\n     * for DOS attacks...\n     * \n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     * \n     * Updated: the node status cache holds the status of each node for the\n     * configured TTL.\n     */\n    private NodeAvailabilityCache<String> _nodeAvailabilityCache;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /*\n     * we have to implement rejectedSessions - not sure why\n     */\n    private int _rejectedSessions;\n\n    private Set<String> _allNodeIds;\n    private List<String> _nodeIds;\n\n    private List<String> _failoverNodeIds;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     * \n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     * \n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        _logger.info( getClass().getSimpleName() + \" starts initialization...\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        /*\n         * add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern, this ) );\n\n        /*\n         * init memcached\n         */\n\n        if ( !NODES_PATTERN.matcher( _memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        _nodeIds = new ArrayList<String>();\n        _allNodeIds = new HashSet<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( _memcachedNodes );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids );\n        }\n\n        initFailoverNodes();\n\n        if ( _nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        try {\n            log.info( \"Starting with transcoder factory \" + _transcoderFactoryClass.getName() );\n            _memcached =\n                    new MemcachedClient( new SuffixLocatorConnectionFactory( this, new MapBasedResolver( address2Ids ),\n                            _sessionIdFormat, _transcoderFactoryClass.newInstance() ), addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n\n        /*\n         * create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n        _nodeAvailabilityCache = createNodeAvailabilityCache( 1000 );\n\n        //_relocatedSessions = new LRUCache<String, String>( 100000, getMaxInactiveInterval() * 1000 );\n    }\n\n    private NodeAvailabilityCache<String> createNodeAvailabilityCache( final long ttlInMillis ) {\n        return new NodeAvailabilityCache<String>( _allNodeIds.size(), ttlInMillis, new CacheLoader<String>() {\n\n            @Override\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    _memcached.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private void initFailoverNodes() {\n        _failoverNodeIds = new ArrayList<String>();\n        if ( _failoverNodes != null && _failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodes = _failoverNodes.split( \" \" );\n            for ( final String failoverNode : failoverNodes ) {\n                final String nodeId = failoverNode.trim();\n                if ( !_nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + _memcachedNodes + \"'.\" );\n                }\n                _failoverNodeIds.add( nodeId );\n            }\n        }\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids ) {\n        final String nodeId = matcher.group( 1 );\n        _nodeIds.add( nodeId );\n        _allNodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), getMemcachedNodeId() );\n    }\n\n    private String getMemcachedNodeId() {\n        return _nodeIds.get( _random.nextInt( _nodeIds.size() ) );\n    }\n\n    private boolean isValidSessionIdFormat( final String sessionId ) {\n        return _sessionIdFormat.isValid( sessionId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        _logger.fine( \"expireSession invoked: \" + sessionId );\n        super.expireSession( sessionId );\n        _memcached.delete( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     * \n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     * \n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        Session result = super.findSession( id );\n        if ( result == null && _missingSessionsCache.get( id ) == null ) {\n            result = loadFromMemcached( id );\n            if ( result != null ) {\n                add( result );\n            } else {\n                _missingSessionsCache.put( id, Boolean.TRUE );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( final String sessionId ) {\n        _logger.fine( \"createSession invoked: \" + sessionId );\n\n        Session session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n            session.setId( generateSessionId() );\n\n            if ( _logger.isLoggable( Level.FINE ) ) {\n                _logger.fine( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return ( session );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    /**\n     * Store the provided session in memcached.\n     * \n     * @param session\n     *            the session to save\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResult}\n     */\n    public BackupResult backupSession( final Session session ) {\n        if ( _logger.isLoggable( Level.INFO ) ) {\n            _logger.fine( \"Trying to store session in memcached: \" + session.getId() );\n        }\n        try {\n\n            if ( session.getNote( RELOCATE_SESSION_ID ) != null ) {\n                _logger.info( \"Found relocate session id, setting new id on session...\" );\n                session.setNote( NODE_FAILURE, Boolean.TRUE );\n                ( (MemcachedBackupSession) session ).setIdForRelocate( session.getNote( RELOCATE_SESSION_ID ).toString() );\n                session.removeNote( RELOCATE_SESSION_ID );\n            }\n\n            storeSessionInMemcached( session );\n            return BackupResult.SUCCESS;\n        } catch ( final NodeFailureException e ) {\n            if ( _logger.isLoggable( Level.INFO ) ) {\n                _logger.info( \"Could not store session in memcached (\" + session.getId() + \")\" );\n            }\n\n            /*\n             * get the next memcached node to try\n             */\n            final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n            final String targetNodeId = getNextNodeId( nodeId, getTestedNodes( session ) );\n\n            final MemcachedBackupSession backupSession = (MemcachedBackupSession) session;\n\n            if ( targetNodeId == null ) {\n\n                _logger.warning( \"The node \" + nodeId\n                        + \" is not available and there's no node for relocation left, omitting session backup.\" );\n\n                noFailoverNodeLeft( backupSession );\n\n                return BackupResult.FAILURE;\n\n            } else {\n\n                if ( getTestedNodes( session ) == null ) {\n                    setTestedNodes( session, new HashSet<String>() );\n                }\n\n                final BackupResult backupResult = failover( backupSession, getTestedNodes( session ), targetNodeId );\n\n                return handleAndTranslateBackupResult( backupResult, session );\n            }\n        }\n    }\n\n    private BackupResult handleAndTranslateBackupResult( final BackupResult backupResult, final Session session ) {\n        switch ( backupResult ) {\n            case SUCCESS:\n\n                //_relocatedSessions.put( session.getNote( ORIG_SESSION_ID ).toString(), session.getId() );\n\n                /*\n                 * cleanup\n                 */\n                session.removeNote( ORIG_SESSION_ID );\n                session.removeNote( NODE_FAILURE );\n                session.removeNote( NODES_TESTED );\n\n                /*\n                 * and tell our client to do his part as well\n                 */\n                return BackupResult.RELOCATED;\n            default:\n                /*\n                 * just pass it up\n                 */\n                return backupResult;\n\n        }\n    }\n\n    private void setTestedNodes( final Session session, final Set<String> testedNodes ) {\n        session.setNote( NODES_TESTED, testedNodes );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private Set<String> getTestedNodes( final Session session ) {\n        return (Set<String>) session.getNote( NODES_TESTED );\n    }\n\n    /**\n     * Returns the new session id if the provided session has to be relocated.\n     * \n     * @param session\n     *            the session to check, never null.\n     * @return the new session id, if this session has to be relocated.\n     */\n    public String sessionNeedsRelocate( final Session session ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n        if ( nodeId != null && !_nodeAvailabilityCache.isNodeAvailable( nodeId ) ) {\n            final String nextNodeId = getNextNodeId( nodeId, _nodeAvailabilityCache.getUnavailableNodes() );\n            if ( nextNodeId != null ) {\n                final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), nextNodeId );\n                session.setNote( RELOCATE_SESSION_ID, newSessionId );\n                return newSessionId;\n            } else {\n                _logger.warning( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n            }\n        }\n        return null;\n    }\n\n    private BackupResult failover( final MemcachedBackupSession session, final Set<String> testedNodes, final String targetNodeId ) {\n\n        final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n\n        testedNodes.add( nodeId );\n\n        /*\n         * we must store the original session id so that we can set this if no\n         * memcached node is left for taking over\n         */\n        if ( session.getNote( ORIG_SESSION_ID ) == null ) {\n            session.setNote( ORIG_SESSION_ID, session.getId() );\n        }\n\n        /*\n         * relocate session to our memcached node...\n         * \n         * and mark it as a node-failure-session, so that remove(session) does\n         * not try to remove it from memcached... (the session is removed and\n         * added when the session id is changed)\n         */\n        session.setNote( NODE_FAILURE, Boolean.TRUE );\n        session.setIdForRelocate( _sessionIdFormat.createNewSessionId( session.getId(), targetNodeId ) );\n\n        /*\n         * invoke backup again, until we have a success or a failure\n         */\n        final BackupResult backupResult = backupSession( session );\n\n        return backupResult;\n    }\n\n    private void noFailoverNodeLeft( final MemcachedBackupSession session ) {\n\n        /*\n         * we must set the original session id in case we changed it already\n         */\n        final String origSessionId = (String) session.getNote( ORIG_SESSION_ID );\n        if ( origSessionId != null && !origSessionId.equals( session.getId() ) ) {\n            session.setIdForRelocate( origSessionId );\n        }\n\n        /*\n         * cleanup\n         */\n        session.removeNote( ORIG_SESSION_ID );\n        session.removeNote( NODE_FAILURE );\n        session.removeNote( NODES_TESTED );\n    }\n\n    /**\n     * Get the next memcached node id for session backup. The active node ids\n     * are preferred, if no active node id is left to try, a failover node id is\n     * picked. If no failover node id is left, this method returns just null.\n     * \n     * @param nodeId\n     *            the current node id\n     * @param excludedNodeIds\n     *            the node ids that were already tested and shall not be used\n     *            again. Can be null.\n     * @return the next node id or null, if no node is left.\n     */\n    protected String getNextNodeId( final String nodeId, final Set<String> excludedNodeIds ) {\n\n        String result = null;\n\n        /*\n         * first check regular nodes\n         */\n        result = getNextNodeId( nodeId, _nodeIds, excludedNodeIds );\n\n        /*\n         * we got no node from the first nodes list, so we must check the\n         * alternative node list\n         */\n        if ( result == null && _failoverNodeIds != null && !_failoverNodeIds.isEmpty() ) {\n            result = getNextNodeId( nodeId, _failoverNodeIds, excludedNodeIds );\n        }\n\n        return result;\n    }\n\n    /**\n     * Determines the next available node id from the provided node ids. The\n     * returned node id will be different from the provided nodeId and will not\n     * be contained in the excludedNodeIds.\n     * \n     * @param nodeId\n     *            the original id\n     * @param nodeIds\n     *            the node ids to choose from\n     * @param excludedNodeIds\n     *            the set of invalid node ids\n     * @return an available node or null\n     */\n    protected static String getNextNodeId( final String nodeId, final List<String> nodeIds, final Set<String> excludedNodeIds ) {\n\n        String result = null;\n\n        final int origIdx = nodeIds.indexOf( nodeId );\n        final int nodeIdsSize = nodeIds.size();\n\n        int idx = origIdx;\n        while ( result == null && !loopFinished( origIdx, idx, nodeIdsSize ) ) {\n\n            final int checkIdx = roll( idx, nodeIdsSize );\n            final String checkNodeId = nodeIds.get( checkIdx );\n\n            if ( excludedNodeIds != null && excludedNodeIds.contains( checkNodeId ) ) {\n                idx = checkIdx;\n            } else {\n                result = checkNodeId;\n            }\n\n        }\n\n        return result;\n    }\n\n    private static boolean loopFinished( final int origIdx, final int idx, final int nodeIdsSize ) {\n        return origIdx == -1\n            ? idx + 1 == nodeIdsSize\n            : roll( idx, nodeIdsSize ) == origIdx;\n    }\n\n    protected static int roll( final int idx, final int size ) {\n        return idx + 1 >= size\n            ? 0\n            : idx + 1;\n    }\n\n    private void storeSessionInMemcached( final Session session ) throws NodeFailureException {\n        final Future<Boolean> future = _memcached.set( session.getId(), getMaxInactiveInterval(), session );\n        if ( !_sessionBackupAsync ) {\n            try {\n                future.get( _sessionBackupTimeout, TimeUnit.MILLISECONDS );\n            } catch ( final Exception e ) {\n                if ( _logger.isLoggable( Level.INFO ) ) {\n                    _logger.info( \"Could not store session \" + session.getId() + \" in memcached: \" + e );\n                }\n                final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, false );\n                throw new NodeFailureException( \"Could not store session in memcached.\", nodeId );\n            }\n        }\n    }\n\n    private Session loadFromMemcached( final String sessionId ) {\n        if ( !isValidSessionIdFormat( sessionId ) ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeAvailabilityCache.isNodeAvailable( nodeId ) ) {\n            _logger.fine( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            _logger.fine( \"Loading session from memcached: \" + sessionId );\n            try {\n                final Session session = (Session) _memcached.get( sessionId );\n                if ( _logger.isLoggable( Level.FINE ) ) {\n                    if ( session == null ) {\n                        _logger.fine( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _logger.fine( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, true );\n                return session;\n            } catch ( final NodeFailureException e ) {\n                _logger.warning( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _logger.warning( \"Could not load session with id \" + sessionId + \" from memcached: \" + e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        _logger.fine( \"remove invoked,\" + \" session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE )\n                + \", node failure: \" + session.getNote( NODE_FAILURE ) + \", node failure != TRUE: \"\n                + ( session.getNote( NODE_FAILURE ) != Boolean.TRUE ) + \", id: \" + session.getId() );\n        if ( session.getNote( NODE_FAILURE ) != Boolean.TRUE ) {\n            try {\n                _logger.fine( \"Deleting session from memcached: \" + session.getId() );\n                _memcached.delete( session.getId() );\n            } catch ( final NodeFailureException e ) {\n                /* We can ignore this */\n            }\n        }\n        super.remove( session );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * \n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * \n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     * \n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        try {\n            _transcoderFactoryClass = Class.forName( transcoderFactoryClassName ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _logger.severe( \"The transcoderFactoryClass (\" + transcoderFactoryClassName + \") could not be found\" );\n            throw new RuntimeException( e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            _memcached.shutdown();\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _logger.warning( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    // ===========================  for testing  ==============================\n\n    protected void setNodeIds( final List<String> nodeIds ) {\n        _nodeIds = nodeIds;\n    }\n\n    protected void setFailoverNodeIds( final List<String> failoverNodeIds ) {\n        _failoverNodeIds = failoverNodeIds;\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     * \n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        _sessionBackupAsync = sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * \n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The session class used by this manager, to be able to change the session\n     * id without the whole notification lifecycle (which includes the\n     * application also).\n     */\n    public static final class MemcachedBackupSession extends StandardSession {\n\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Creates a new instance without a given manager. This has to be\n         * assigned via {@link #setManager(Manager)} before this session is\n         * used.\n         * \n         */\n        public MemcachedBackupSession() {\n            super( null );\n        }\n\n        /**\n         * Creates a new instance with the given manager.\n         * \n         * @param manager\n         *            the manager\n         */\n        public MemcachedBackupSession( final Manager manager ) {\n            super( manager );\n        }\n\n        /**\n         * Set a new id for this session.<br/>\n         * Before setting the new id, it removes itself from the associated\n         * manager. After the new id is set, this session adds itself to the\n         * session manager.\n         * \n         * @param id\n         *            the new session id\n         */\n        protected void setIdForRelocate( final String id ) {\n\n            if ( this.id == null ) {\n                throw new IllegalStateException( \"There's no session id set.\" );\n            }\n            if ( this.manager == null ) {\n                throw new IllegalStateException( \"There's no manager set.\" );\n            }\n\n            manager.remove( this );\n            this.id = id;\n            manager.add( this );\n\n        }\n\n        @Override\n        public void setId( final String id ) {\n            super.setId( id );\n        }\n\n        public void doAfterDeserialization() {\n            if ( listeners == null ) {\n                listeners = new ArrayList<Object>();\n            }\n            if ( notes == null ) {\n                notes = new Hashtable<Object, Object>();\n            }\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.Session;\nimport org.apache.catalina.session.ManagerBase;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.catalina.util.LifecycleSupport;\n\nimport de.javakaffee.web.msm.NodeAvailabilityCache.CacheLoader;\nimport de.javakaffee.web.msm.NodeIdResolver.MapBasedResolver;\nimport de.javakaffee.web.msm.SessionTrackerValve.SessionBackupService;\n\n/**\n * This {@link Manager} stores session in configured memcached nodes after the\n * response is finished (committed).\n * <p>\n * Use this session manager in a Context element, like this <code><pre>\n * &lt;Context path=\"/foo\"&gt;\n *     &lt;Manager className=\"de.javakaffee.web.msm.MemcachedBackupSessionManager\"\n *         memcachedNodes=\"n1.localhost:11211 n2.localhost:11212\" failoverNodes=\"n2\"\n *         requestUriIgnorePattern=\".*\\.(png|gif|jpg|css|js)$\" /&gt;\n * &lt;/Context&gt;\n * <\/pre><\/code>\n * <\/p>\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedBackupSessionManager extends ManagerBase implements Lifecycle, SessionBackupService, PropertyChangeListener {\n\n    protected static final String NAME = MemcachedBackupSessionManager.class.getSimpleName();\n\n    private static final String INFO = NAME + \"/1.0\";\n\n    private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";\n    private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );\n\n    private static final String NODES_REGEX = NODE_REGEX + \"(?:\\\\s+\" + NODE_REGEX + \")*\";\n    private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );\n\n    private static final String NODES_TESTED = \"nodes.tested\";\n\n    private static final String NODE_FAILURE = \"node.failure\";\n\n    private static final String ORIG_SESSION_ID = \"orig.sid\";\n\n    private static final String RELOCATE_SESSION_ID = \"relocate.sid\";\n\n    private final Random _random = new Random();\n\n    private final Logger _logger = Logger.getLogger( MemcachedBackupSessionManager.class.getName() );\n\n    private final LifecycleSupport _lifecycle = new LifecycleSupport( this );\n\n    private final SessionIdFormat _sessionIdFormat = new SessionIdFormat();\n\n    // -------------------- configuration properties --------------------\n\n    /**\n     * The memcached nodes space separated and with the id prefix, e.g.\n     * n1:localhost:11211 n2:localhost:11212\n     * \n     */\n    private String _memcachedNodes;\n\n    /**\n     * The ids of memcached failover nodes separated by space, e.g.\n     * <code>n1 n2<\/code>\n     * \n     */\n    private String _failoverNodes;\n\n    /**\n     * The pattern used for excluding requests from a session-backup, e.g.\n     * <code>.*\\.(png|gif|jpg|css|js)$<\/code>. Is matched against\n     * request.getRequestURI.\n     */\n    private String _requestUriIgnorePattern;\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     */\n    private boolean _sessionBackupAsync = false;\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * <\/p>\n     */\n    private int _sessionBackupTimeout = 100;\n\n    /**\n     * The class of the factory for\n     * {@link net.spy.memcached.transcoders.Transcoder}s. Default class is\n     * {@link SessionSerializingTranscoderFactory}.\n     */\n    private Class<? extends TranscoderFactory> _transcoderFactoryClass = SessionSerializingTranscoderFactory.class;\n\n    /**\n     * Specifies, if iterating over collection elements shall be done on a copy\n     * of the collection or on the collection itself.\n     * <p>\n     * This option can be useful if you have multiple requests running in\n     * parallel for the same session (e.g. AJAX) and you are using\n     * non-thread-safe collections (e.g. {@link java.util.ArrayList} or\n     * {@link java.util.HashMap}). In this case, your application might modify a\n     * collection while it's being serialized for backup in memcached.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This must be supported by the TranscoderFactory\n     * specified via {@link #setTranscoderFactoryClass(String)}.\n     * <\/p>\n     */\n    private boolean _copyCollectionsForSerialization = false;\n\n    // -------------------- END configuration properties --------------------\n\n    /*\n     * the memcached client\n     */\n    private MemcachedClient _memcached;\n\n    /*\n     * findSession may be often called in one request. If a session is requested\n     * that we don't have locally stored each findSession invocation would\n     * trigger a memcached request - this would open the door for DOS attacks...\n     * \n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     */\n    private LRUCache<String, Boolean> _missingSessionsCache;\n\n    /*\n     * remove may be called with sessionIds that already failed before (probably\n     * because the browser makes subsequent requests with the old sessionId -\n     * the exact reason needs to be verified). These failed sessionIds should If\n     * a session is requested that we don't have locally stored each findSession\n     * invocation would trigger a memcached request - this would open the door\n     * for DOS attacks...\n     * \n     * this solution: use a LRUCache with a timeout to store, which session had\n     * been requested in the last <n> millis.\n     * \n     * Updated: the node status cache holds the status of each node for the\n     * configured TTL.\n     */\n    private NodeAvailabilityCache<String> _nodeAvailabilityCache;\n\n    //private LRUCache<String, String> _relocatedSessions;\n\n    /*\n     * we have to implement rejectedSessions - not sure why\n     */\n    private int _rejectedSessions;\n\n    private Set<String> _allNodeIds;\n    private List<String> _nodeIds;\n\n    private List<String> _failoverNodeIds;\n\n    /**\n     * Return descriptive information about this Manager implementation and the\n     * corresponding version number, in the format\n     * <code>&lt;description&gt;/&lt;version&gt;<\/code>.\n     * \n     * @return the info string\n     */\n    @Override\n    public String getInfo() {\n        return INFO;\n    }\n\n    /**\n     * Return the descriptive short name of this Manager implementation.\n     * \n     * @return the short name\n     */\n    @Override\n    public String getName() {\n        return NAME;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void init() {\n        _logger.info( getClass().getSimpleName() + \" starts initialization...\" );\n\n        if ( initialized ) {\n            return;\n        }\n\n        super.init();\n\n        /*\n         * add the valve for tracking requests for that the session must be sent\n         * to memcached\n         */\n        getContainer().getPipeline().addValve( new SessionTrackerValve( _requestUriIgnorePattern, this ) );\n\n        /*\n         * init memcached\n         */\n\n        if ( !NODES_PATTERN.matcher( _memcachedNodes ).matches() ) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        _nodeIds = new ArrayList<String>();\n        _allNodeIds = new HashSet<String>();\n        final Matcher matcher = NODE_PATTERN.matcher( _memcachedNodes );\n        final List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();\n        final Map<InetSocketAddress, String> address2Ids = new HashMap<InetSocketAddress, String>();\n        while ( matcher.find() ) {\n            initHandleNodeDefinitionMatch( matcher, addresses, address2Ids );\n        }\n\n        initFailoverNodes();\n\n        if ( _nodeIds.isEmpty() ) {\n            throw new IllegalArgumentException( \"All nodes are also configured as failover nodes,\"\n                    + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\" );\n        }\n\n        try {\n            log.info( \"Starting with transcoder factory \" + _transcoderFactoryClass.getName() );\n            final TranscoderFactory transcoderFactory = _transcoderFactoryClass.newInstance();\n            _memcached =\n                    new MemcachedClient( new SuffixLocatorConnectionFactory( this, new MapBasedResolver( address2Ids ),\n                            _sessionIdFormat, transcoderFactory ), addresses );\n        } catch ( final Exception e ) {\n            throw new RuntimeException( \"Could not create memcached client\", e );\n        }\n\n        /*\n         * create the missing sessions cache\n         */\n        _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 );\n        _nodeAvailabilityCache = createNodeAvailabilityCache( 1000 );\n\n        //_relocatedSessions = new LRUCache<String, String>( 100000, getMaxInactiveInterval() * 1000 );\n    }\n\n    private NodeAvailabilityCache<String> createNodeAvailabilityCache( final long ttlInMillis ) {\n        return new NodeAvailabilityCache<String>( _allNodeIds.size(), ttlInMillis, new CacheLoader<String>() {\n\n            @Override\n            public boolean isNodeAvailable( final String key ) {\n                try {\n                    _memcached.get( _sessionIdFormat.createSessionId( \"ping\", key ) );\n                    return true;\n                } catch ( final Exception e ) {\n                    return false;\n                }\n            }\n\n        } );\n    }\n\n    private void initFailoverNodes() {\n        _failoverNodeIds = new ArrayList<String>();\n        if ( _failoverNodes != null && _failoverNodes.trim().length() != 0 ) {\n            final String[] failoverNodes = _failoverNodes.split( \" \" );\n            for ( final String failoverNode : failoverNodes ) {\n                final String nodeId = failoverNode.trim();\n                if ( !_nodeIds.remove( nodeId ) ) {\n                    throw new IllegalArgumentException( \"Invalid failover node id \" + nodeId + \": \"\n                            + \"not existing in memcachedNodes '\" + _memcachedNodes + \"'.\" );\n                }\n                _failoverNodeIds.add( nodeId );\n            }\n        }\n    }\n\n    private void initHandleNodeDefinitionMatch( final Matcher matcher, final List<InetSocketAddress> addresses,\n            final Map<InetSocketAddress, String> address2Ids ) {\n        final String nodeId = matcher.group( 1 );\n        _nodeIds.add( nodeId );\n        _allNodeIds.add( nodeId );\n\n        final String hostname = matcher.group( 2 );\n        final int port = Integer.parseInt( matcher.group( 3 ) );\n        final InetSocketAddress address = new InetSocketAddress( hostname, port );\n        addresses.add( address );\n\n        address2Ids.put( address, nodeId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setContainer( final Container container ) {\n\n        // De-register from the old Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            ( (Context) this.container ).removePropertyChangeListener( this );\n        }\n\n        // Default processing provided by our superclass\n        super.setContainer( container );\n\n        // Register with the new Container (if any)\n        if ( this.container != null && this.container instanceof Context ) {\n            setMaxInactiveInterval( ( (Context) this.container ).getSessionTimeout() * 60 );\n            ( (Context) this.container ).addPropertyChangeListener( this );\n        }\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected synchronized String generateSessionId() {\n        return _sessionIdFormat.createSessionId( super.generateSessionId(), getMemcachedNodeId() );\n    }\n\n    private String getMemcachedNodeId() {\n        return _nodeIds.get( _random.nextInt( _nodeIds.size() ) );\n    }\n\n    private boolean isValidSessionIdFormat( final String sessionId ) {\n        return _sessionIdFormat.isValid( sessionId );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void expireSession( final String sessionId ) {\n        _logger.fine( \"expireSession invoked: \" + sessionId );\n        super.expireSession( sessionId );\n        _memcached.delete( sessionId );\n    }\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null<\/code>.\n     * \n     * @param id\n     *            The session id for the session to be returned\n     * @return the session or <code>null<\/code> if no session was found locally\n     *         or in memcached.\n     * \n     * @exception IllegalStateException\n     *                if a new session cannot be instantiated for any reason\n     * @exception IOException\n     *                if an input/output error occurs while processing this\n     *                request\n     */\n    @Override\n    public Session findSession( final String id ) throws IOException {\n        Session result = super.findSession( id );\n        if ( result == null && _missingSessionsCache.get( id ) == null ) {\n            result = loadFromMemcached( id );\n            if ( result != null ) {\n                add( result );\n            } else {\n                _missingSessionsCache.put( id, Boolean.TRUE );\n            }\n        }\n        //        if ( result == null ) {\n        //            final String relocatedSessionId = _relocatedSessions.get( id );\n        //            if ( relocatedSessionId != null ) {\n        //                result = findSession( relocatedSessionId );\n        //            }\n        //        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Session createSession( final String sessionId ) {\n        _logger.fine( \"createSession invoked: \" + sessionId );\n\n        Session session = null;\n\n        if ( sessionId != null ) {\n            session = loadFromMemcached( sessionId );\n        }\n\n        if ( session == null ) {\n\n            session = createEmptySession();\n            session.setNew( true );\n            session.setValid( true );\n            session.setCreationTime( System.currentTimeMillis() );\n            session.setMaxInactiveInterval( this.maxInactiveInterval );\n            session.setId( generateSessionId() );\n\n            if ( _logger.isLoggable( Level.FINE ) ) {\n                _logger.fine( \"Created new session with id \" + session.getId() );\n            }\n\n        }\n\n        sessionCounter++;\n\n        return ( session );\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MemcachedBackupSession createEmptySession() {\n        return new MemcachedBackupSession( this );\n    }\n\n    /**\n     * Store the provided session in memcached.\n     * \n     * @param session\n     *            the session to save\n     * @return the {@link SessionTrackerValve.SessionBackupService.BackupResult}\n     */\n    public BackupResult backupSession( final Session session ) {\n        if ( _logger.isLoggable( Level.INFO ) ) {\n            _logger.fine( \"Trying to store session in memcached: \" + session.getId() );\n        }\n        try {\n\n            if ( session.getNote( RELOCATE_SESSION_ID ) != null ) {\n                _logger.info( \"Found relocate session id, setting new id on session...\" );\n                session.setNote( NODE_FAILURE, Boolean.TRUE );\n                ( (MemcachedBackupSession) session ).setIdForRelocate( session.getNote( RELOCATE_SESSION_ID ).toString() );\n                session.removeNote( RELOCATE_SESSION_ID );\n            }\n\n            storeSessionInMemcached( session );\n            return BackupResult.SUCCESS;\n        } catch ( final NodeFailureException e ) {\n            if ( _logger.isLoggable( Level.INFO ) ) {\n                _logger.info( \"Could not store session in memcached (\" + session.getId() + \")\" );\n            }\n\n            /*\n             * get the next memcached node to try\n             */\n            final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n            final String targetNodeId = getNextNodeId( nodeId, getTestedNodes( session ) );\n\n            final MemcachedBackupSession backupSession = (MemcachedBackupSession) session;\n\n            if ( targetNodeId == null ) {\n\n                _logger.warning( \"The node \" + nodeId\n                        + \" is not available and there's no node for relocation left, omitting session backup.\" );\n\n                noFailoverNodeLeft( backupSession );\n\n                return BackupResult.FAILURE;\n\n            } else {\n\n                if ( getTestedNodes( session ) == null ) {\n                    setTestedNodes( session, new HashSet<String>() );\n                }\n\n                final BackupResult backupResult = failover( backupSession, getTestedNodes( session ), targetNodeId );\n\n                return handleAndTranslateBackupResult( backupResult, session );\n            }\n        }\n    }\n\n    private BackupResult handleAndTranslateBackupResult( final BackupResult backupResult, final Session session ) {\n        switch ( backupResult ) {\n            case SUCCESS:\n\n                //_relocatedSessions.put( session.getNote( ORIG_SESSION_ID ).toString(), session.getId() );\n\n                /*\n                 * cleanup\n                 */\n                session.removeNote( ORIG_SESSION_ID );\n                session.removeNote( NODE_FAILURE );\n                session.removeNote( NODES_TESTED );\n\n                /*\n                 * and tell our client to do his part as well\n                 */\n                return BackupResult.RELOCATED;\n            default:\n                /*\n                 * just pass it up\n                 */\n                return backupResult;\n\n        }\n    }\n\n    private void setTestedNodes( final Session session, final Set<String> testedNodes ) {\n        session.setNote( NODES_TESTED, testedNodes );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private Set<String> getTestedNodes( final Session session ) {\n        return (Set<String>) session.getNote( NODES_TESTED );\n    }\n\n    /**\n     * Returns the new session id if the provided session has to be relocated.\n     * \n     * @param session\n     *            the session to check, never null.\n     * @return the new session id, if this session has to be relocated.\n     */\n    public String sessionNeedsRelocate( final Session session ) {\n        final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n        if ( nodeId != null && !_nodeAvailabilityCache.isNodeAvailable( nodeId ) ) {\n            final String nextNodeId = getNextNodeId( nodeId, _nodeAvailabilityCache.getUnavailableNodes() );\n            if ( nextNodeId != null ) {\n                final String newSessionId = _sessionIdFormat.createNewSessionId( session.getId(), nextNodeId );\n                session.setNote( RELOCATE_SESSION_ID, newSessionId );\n                return newSessionId;\n            } else {\n                _logger.warning( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\" );\n            }\n        }\n        return null;\n    }\n\n    private BackupResult failover( final MemcachedBackupSession session, final Set<String> testedNodes, final String targetNodeId ) {\n\n        final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n\n        testedNodes.add( nodeId );\n\n        /*\n         * we must store the original session id so that we can set this if no\n         * memcached node is left for taking over\n         */\n        if ( session.getNote( ORIG_SESSION_ID ) == null ) {\n            session.setNote( ORIG_SESSION_ID, session.getId() );\n        }\n\n        /*\n         * relocate session to our memcached node...\n         * \n         * and mark it as a node-failure-session, so that remove(session) does\n         * not try to remove it from memcached... (the session is removed and\n         * added when the session id is changed)\n         */\n        session.setNote( NODE_FAILURE, Boolean.TRUE );\n        session.setIdForRelocate( _sessionIdFormat.createNewSessionId( session.getId(), targetNodeId ) );\n\n        /*\n         * invoke backup again, until we have a success or a failure\n         */\n        final BackupResult backupResult = backupSession( session );\n\n        return backupResult;\n    }\n\n    private void noFailoverNodeLeft( final MemcachedBackupSession session ) {\n\n        /*\n         * we must set the original session id in case we changed it already\n         */\n        final String origSessionId = (String) session.getNote( ORIG_SESSION_ID );\n        if ( origSessionId != null && !origSessionId.equals( session.getId() ) ) {\n            session.setIdForRelocate( origSessionId );\n        }\n\n        /*\n         * cleanup\n         */\n        session.removeNote( ORIG_SESSION_ID );\n        session.removeNote( NODE_FAILURE );\n        session.removeNote( NODES_TESTED );\n    }\n\n    /**\n     * Get the next memcached node id for session backup. The active node ids\n     * are preferred, if no active node id is left to try, a failover node id is\n     * picked. If no failover node id is left, this method returns just null.\n     * \n     * @param nodeId\n     *            the current node id\n     * @param excludedNodeIds\n     *            the node ids that were already tested and shall not be used\n     *            again. Can be null.\n     * @return the next node id or null, if no node is left.\n     */\n    protected String getNextNodeId( final String nodeId, final Set<String> excludedNodeIds ) {\n\n        String result = null;\n\n        /*\n         * first check regular nodes\n         */\n        result = getNextNodeId( nodeId, _nodeIds, excludedNodeIds );\n\n        /*\n         * we got no node from the first nodes list, so we must check the\n         * alternative node list\n         */\n        if ( result == null && _failoverNodeIds != null && !_failoverNodeIds.isEmpty() ) {\n            result = getNextNodeId( nodeId, _failoverNodeIds, excludedNodeIds );\n        }\n\n        return result;\n    }\n\n    /**\n     * Determines the next available node id from the provided node ids. The\n     * returned node id will be different from the provided nodeId and will not\n     * be contained in the excludedNodeIds.\n     * \n     * @param nodeId\n     *            the original id\n     * @param nodeIds\n     *            the node ids to choose from\n     * @param excludedNodeIds\n     *            the set of invalid node ids\n     * @return an available node or null\n     */\n    protected static String getNextNodeId( final String nodeId, final List<String> nodeIds, final Set<String> excludedNodeIds ) {\n\n        String result = null;\n\n        final int origIdx = nodeIds.indexOf( nodeId );\n        final int nodeIdsSize = nodeIds.size();\n\n        int idx = origIdx;\n        while ( result == null && !loopFinished( origIdx, idx, nodeIdsSize ) ) {\n\n            final int checkIdx = roll( idx, nodeIdsSize );\n            final String checkNodeId = nodeIds.get( checkIdx );\n\n            if ( excludedNodeIds != null && excludedNodeIds.contains( checkNodeId ) ) {\n                idx = checkIdx;\n            } else {\n                result = checkNodeId;\n            }\n\n        }\n\n        return result;\n    }\n\n    private static boolean loopFinished( final int origIdx, final int idx, final int nodeIdsSize ) {\n        return origIdx == -1\n            ? idx + 1 == nodeIdsSize\n            : roll( idx, nodeIdsSize ) == origIdx;\n    }\n\n    protected static int roll( final int idx, final int size ) {\n        return idx + 1 >= size\n            ? 0\n            : idx + 1;\n    }\n\n    private void storeSessionInMemcached( final Session session ) throws NodeFailureException {\n        final Future<Boolean> future = _memcached.set( session.getId(), getMaxInactiveInterval(), session );\n        if ( !_sessionBackupAsync ) {\n            try {\n                future.get( _sessionBackupTimeout, TimeUnit.MILLISECONDS );\n            } catch ( final Exception e ) {\n                if ( _logger.isLoggable( Level.INFO ) ) {\n                    _logger.info( \"Could not store session \" + session.getId() + \" in memcached: \" + e );\n                }\n                final String nodeId = _sessionIdFormat.extractMemcachedId( session.getId() );\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, false );\n                throw new NodeFailureException( \"Could not store session in memcached.\", nodeId );\n            }\n        }\n    }\n\n    private Session loadFromMemcached( final String sessionId ) {\n        if ( !isValidSessionIdFormat( sessionId ) ) {\n            return null;\n        }\n        final String nodeId = _sessionIdFormat.extractMemcachedId( sessionId );\n        if ( !_nodeAvailabilityCache.isNodeAvailable( nodeId ) ) {\n            _logger.fine( \"Asked for session \" + sessionId + \", but the related\"\n                    + \" memcached node is still marked as unavailable (won't load from memcached).\" );\n        } else {\n            _logger.fine( \"Loading session from memcached: \" + sessionId );\n            try {\n                final Session session = (Session) _memcached.get( sessionId );\n                if ( _logger.isLoggable( Level.FINE ) ) {\n                    if ( session == null ) {\n                        _logger.fine( \"Session \" + sessionId + \" not found in memcached.\" );\n                    } else {\n                        _logger.fine( \"Found session with id \" + sessionId );\n                    }\n                }\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, true );\n                return session;\n            } catch ( final NodeFailureException e ) {\n                _logger.warning( \"Could not load session with id \" + sessionId + \" from memcached.\" );\n                _nodeAvailabilityCache.setNodeAvailable( nodeId, false );\n            } catch ( final Exception e ) {\n                _logger.warning( \"Could not load session with id \" + sessionId + \" from memcached: \" + e );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove( final Session session ) {\n        _logger.fine( \"remove invoked,\" + \" session.relocate:  \" + session.getNote( SessionTrackerValve.RELOCATE )\n                + \", node failure: \" + session.getNote( NODE_FAILURE ) + \", node failure != TRUE: \"\n                + ( session.getNote( NODE_FAILURE ) != Boolean.TRUE ) + \", id: \" + session.getId() );\n        if ( session.getNote( NODE_FAILURE ) != Boolean.TRUE ) {\n            try {\n                _logger.fine( \"Deleting session from memcached: \" + session.getId() );\n                _memcached.delete( session.getId() );\n            } catch ( final NodeFailureException e ) {\n                /* We can ignore this */\n            }\n        }\n        super.remove( session );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getRejectedSessions() {\n        return _rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void load() throws ClassNotFoundException, IOException {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setRejectedSessions( final int rejectedSessions ) {\n        _rejectedSessions = rejectedSessions;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unload() throws IOException {\n    }\n\n    /**\n     * Set the memcached nodes.\n     * <p>\n     * E.g. <code>n1.localhost:11211 n2.localhost:11212<\/code>\n     * <\/p>\n     * \n     * @param memcachedNodes\n     *            the memcached node definitions, whitespace separated\n     */\n    public void setMemcachedNodes( final String memcachedNodes ) {\n        _memcachedNodes = memcachedNodes;\n    }\n\n    /**\n     * The node ids of memcached nodes, that shall only be used for session\n     * backup by this tomcat/manager, if there are no other memcached nodes\n     * left. Node ids are separated by whitespace.\n     * <p>\n     * E.g. <code>n1 n2<\/code>\n     * <\/p>\n     * \n     * @param failoverNodes\n     *            the failoverNodes to set, whitespace separated\n     */\n    public void setFailoverNodes( final String failoverNodes ) {\n        _failoverNodes = failoverNodes;\n    }\n\n    /**\n     * Set the regular expression for request uris to ignore for session backup.\n     * This should include static resources like images, in the case they are\n     * served by tomcat.\n     * <p>\n     * E.g. <code>.*\\.(png|gif|jpg|css|js)$<\/code>\n     * <\/p>\n     * \n     * @param requestUriIgnorePattern\n     *            the requestUriIgnorePattern to set\n     * @author Martin Grotzke\n     */\n    public void setRequestUriIgnorePattern( final String requestUriIgnorePattern ) {\n        _requestUriIgnorePattern = requestUriIgnorePattern;\n    }\n\n    public void setTranscoderFactoryClass( final String transcoderFactoryClassName ) {\n        try {\n            _transcoderFactoryClass = Class.forName( transcoderFactoryClassName ).asSubclass( TranscoderFactory.class );\n        } catch ( final ClassNotFoundException e ) {\n            _logger.severe( \"The transcoderFactoryClass (\" + transcoderFactoryClassName + \") could not be found\" );\n            throw new RuntimeException( e );\n        }\n    }\n\n    /**\n     * @param copyCollectionsForSerialization\n     *            specifies, if iterating over collection elements shall be done\n     *            on a copy of the collection or on the collection itself\n     */\n    public void setCopyCollectionsForSerialization( final boolean copyCollectionsForSerialization ) {\n        _copyCollectionsForSerialization = copyCollectionsForSerialization;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.addLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public LifecycleListener[] findLifecycleListeners() {\n        return _lifecycle.findLifecycleListeners();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void removeLifecycleListener( final LifecycleListener arg0 ) {\n        _lifecycle.removeLifecycleListener( arg0 );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void start() throws LifecycleException {\n        if ( !initialized ) {\n            init();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void stop() throws LifecycleException {\n        if ( initialized ) {\n            _memcached.shutdown();\n            destroy();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void propertyChange( final PropertyChangeEvent event ) {\n\n        // Validate the source of this event\n        if ( !( event.getSource() instanceof Context ) ) {\n            return;\n        }\n\n        // Process a relevant property change\n        if ( event.getPropertyName().equals( \"sessionTimeout\" ) ) {\n            try {\n                setMaxInactiveInterval( ( (Integer) event.getNewValue() ).intValue() * 60 );\n            } catch ( final NumberFormatException e ) {\n                _logger.warning( \"standardManager.sessionTimeout: \" + event.getNewValue().toString() );\n            }\n        }\n\n    }\n\n    // ===========================  for testing  ==============================\n\n    protected void setNodeIds( final List<String> nodeIds ) {\n        _nodeIds = nodeIds;\n    }\n\n    protected void setFailoverNodeIds( final List<String> failoverNodeIds ) {\n        _failoverNodeIds = failoverNodeIds;\n    }\n\n    /**\n     * Specifies if the session shall be stored asynchronously in memcached as\n     * {@link MemcachedClient#set(String, int, Object)} supports it. If this is\n     * false, the timeout set via {@link #setSessionBackupTimeout(int)} is\n     * evaluated.\n     * <p>\n     * Notice: if the session backup is done asynchronously, it is possible that\n     * a session cannot be stored in memcached and we don't notice that -\n     * therefore the session would not get relocated to another memcached node.\n     * <\/p>\n     * <p>\n     * By default this property is set to <code>false<\/code> - the session\n     * backup is performed synchronously.\n     * <\/p>\n     * \n     * @param sessionBackupAsync\n     *            the sessionBackupAsync to set\n     */\n    public void setSessionBackupAsync( final boolean sessionBackupAsync ) {\n        _sessionBackupAsync = sessionBackupAsync;\n    }\n\n    /**\n     * The timeout in milliseconds after that a session backup is considered as\n     * beeing failed.\n     * <p>\n     * This property is only evaluated if sessions are stored synchronously (set\n     * via {@link #setSessionBackupAsync(boolean)}).\n     * <\/p>\n     * <p>\n     * The default value is <code>100<\/code> millis.\n     * \n     * @param sessionBackupTimeout\n     *            the sessionBackupTimeout to set (milliseconds)\n     */\n    public void setSessionBackupTimeout( final int sessionBackupTimeout ) {\n        _sessionBackupTimeout = sessionBackupTimeout;\n    }\n\n    /**\n     * The session class used by this manager, to be able to change the session\n     * id without the whole notification lifecycle (which includes the\n     * application also).\n     */\n    public static final class MemcachedBackupSession extends StandardSession {\n\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Creates a new instance without a given manager. This has to be\n         * assigned via {@link #setManager(Manager)} before this session is\n         * used.\n         * \n         */\n        public MemcachedBackupSession() {\n            super( null );\n        }\n\n        /**\n         * Creates a new instance with the given manager.\n         * \n         * @param manager\n         *            the manager\n         */\n        public MemcachedBackupSession( final Manager manager ) {\n            super( manager );\n        }\n\n        /**\n         * Set a new id for this session.<br/>\n         * Before setting the new id, it removes itself from the associated\n         * manager. After the new id is set, this session adds itself to the\n         * session manager.\n         * \n         * @param id\n         *            the new session id\n         */\n        protected void setIdForRelocate( final String id ) {\n\n            if ( this.id == null ) {\n                throw new IllegalStateException( \"There's no session id set.\" );\n            }\n            if ( this.manager == null ) {\n                throw new IllegalStateException( \"There's no manager set.\" );\n            }\n\n            manager.remove( this );\n            this.id = id;\n            manager.add( this );\n\n        }\n\n        @Override\n        public void setId( final String id ) {\n            super.setId( id );\n        }\n\n        public void doAfterDeserialization() {\n            if ( listeners == null ) {\n                listeners = new ArrayList<Object>();\n            }\n            if ( notes == null ) {\n                notes = new Hashtable<Object, Object>();\n            }\n        }\n\n    }\n\n}\n","lineNo":288}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.getAttribute( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 }, { long.class, 42 }, { String.class, \"42\" }, { Long.class, new Long( 42 ) },\n                { Integer.class, new Integer( 42 ) }, { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) }, { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) }, { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) }, { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) }, { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } }, { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() }, { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } }, { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } }, { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } }, { int[].class, new int[] { 1, 2 } }, { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() }, { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        //        System.out.println(new String(_transcoder.serialize( session )));\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        System.out.println(new String(_transcoder.serialize( session )));\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        // System.out.println( \"xml: \" + new String( bytes ) );\n        assertDeepEquals( session, _transcoder.deserialize( bytes ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testReadValueIntoObject() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        session.setId( \"foo\" );\n\n        session.setAttribute( \"person1\", createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" ) );\n        session.setAttribute( \"person2\", createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" ) );\n\n        final long start1 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final long start2 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start2 ) / 1000 );\n\n        final long start3 = System.nanoTime();\n        final byte[] json = _transcoder.serialize( session );\n        final StandardSession readJSONValue = (StandardSession) _transcoder.deserialize( json );\n        System.out.println( \"javolution-round took \" + ( System.nanoTime() - start3 ) / 1000 );\n\n        System.out.println( \"Have xml: \" + readJSONValue.getId() );\n        assertDeepEquals( readJSONValue, session );\n\n        final long start4 = System.nanoTime();\n        final StandardSession readJavaValue = javaRoundtrip( session, _manager );\n        System.out.println( \"java-round took \" + ( System.nanoTime() - start4 ) / 1000 );\n        assertDeepEquals( readJavaValue, session );\n\n        assertDeepEquals( readJSONValue, readJavaValue );\n\n        System.out.println( ToStringBuilder.reflectionToString( session ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJSONValue ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJavaValue ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another )\n        throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ) );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport static de.javakaffee.web.msm.serializer.javolution.TestClasses.createPerson;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport javolution.xml.XMLObjectReader;\nimport javolution.xml.XMLObjectWriter;\nimport javolution.xml.XMLReferenceResolver;\nimport javolution.xml.stream.XMLStreamException;\n\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.loader.WebappLoader;\nimport org.apache.catalina.session.StandardSession;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.mutable.MutableInt;\nimport org.jmock.Mock;\nimport org.jmock.cglib.MockObjectTestCase;\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager.MemcachedBackupSession;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Container;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.CounterHolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Email;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Holder;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderArray;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.HolderList;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.MyContainer;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person;\nimport de.javakaffee.web.msm.serializer.javolution.TestClasses.Person.Gender;\n\n/**\n * Test for {@link JavolutionTranscoder}\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class JavolutionTranscoderTest extends MockObjectTestCase {\n\n    private MemcachedBackupSessionManager _manager;\n    private JavolutionTranscoder _transcoder;\n\n    @BeforeTest\n    protected void beforeTest() {\n        _manager = new MemcachedBackupSessionManager();\n\n        final StandardContext container = new StandardContext();\n        _manager.setContainer( container );\n\n        final Mock webappLoaderControl = mock( WebappLoader.class );\n        final WebappLoader webappLoader = (WebappLoader) webappLoaderControl.proxy();\n        webappLoaderControl.expects( once() ).method( \"setContainer\" ).withAnyArguments();\n        webappLoaderControl.expects( atLeastOnce() ).method( \"getClassLoader\" ).will(\n                returnValue( Thread.currentThread().getContextClassLoader() ) );\n        Assert.assertNotNull( webappLoader.getClassLoader(), \"Webapp Classloader is null.\" );\n        _manager.getContainer().setLoader( webappLoader );\n\n        Assert.assertNotNull( _manager.getContainer().getLoader().getClassLoader(), \"Classloader is null.\" );\n\n        _transcoder = new JavolutionTranscoder( _manager );\n    }\n\n    @Test( enabled = true )\n    public void testInnerClass() throws Exception {\n        final Container container = TestClasses.createContainer( \"some content\" );\n        assertDeepEquals( deserialize( serialize( container ) ), container );\n    }\n\n    @DataProvider( name = \"sharedObjectIdentityProvider\" )\n    protected Object[][] createSharedObjectIdentityProviderData() {\n        return new Object[][] { { AtomicInteger.class.getSimpleName(), new AtomicInteger( 42 ) },\n                { Email.class.getSimpleName(), new Email( \"foo bar\", \"foo.bar@example.com\" ) } };\n    }\n\n    @Test( enabled = true )\n    public <T> void testSharedObjectIdentity_CounterHolder() throws Exception {\n\n        final AtomicInteger sharedObject = new AtomicInteger( 42 );\n        final CounterHolder holder1 = new CounterHolder( sharedObject );\n        final CounterHolder holder2 = new CounterHolder( sharedObject );\n        final CounterHolderArray holderHolder = new CounterHolderArray( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"hh\", holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        final CounterHolderArray hhd = (CounterHolderArray) deserialized.getAttribute( \"hh\" );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentityWithArray( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> holderHolder = new HolderArray<T>( holder1, holder2 );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderArray<T> hhd = (HolderArray<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders[0].item == hhd.holders[1].item );\n\n    }\n\n    @Test( enabled = true, dataProvider = \"sharedObjectIdentityProvider\" )\n    public <T> void testSharedObjectIdentity( final String name, final T sharedObject ) throws Exception {\n\n        final Holder<T> holder1 = new Holder<T>( sharedObject );\n        final Holder<T> holder2 = new Holder<T>( sharedObject );\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> holderHolder = new HolderList<T>( new ArrayList<Holder<T>>( Arrays.asList( holder1, holder2 ) ) );\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( name, holderHolder );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        final MemcachedBackupSession deserialized =\n                (MemcachedBackupSession) _transcoder.deserialize( _transcoder.serialize( session ) );\n        assertDeepEquals( deserialized, session );\n\n        @SuppressWarnings( \"unchecked\" )\n        final HolderList<T> hhd = (HolderList<T>) deserialized.getAttribute( name );\n\n        Assert.assertTrue( hhd.holders.get( 0 ).item == hhd.holders.get( 1 ).item );\n\n    }\n\n    @DataProvider( name = \"typesAsSessionAttributesProvider\" )\n    protected Object[][] createTypesAsSessionAttributesData() {\n        return new Object[][] { { int.class, 42 }, { long.class, 42 }, { Boolean.class, Boolean.TRUE }, { String.class, \"42\" },\n                { Long.class, new Long( 42 ) }, { Integer.class, new Integer( 42 ) }, { Character.class, new Character( 'c' ) },\n                { Byte.class, new Byte( \"b\".getBytes()[0] ) }, { Double.class, new Double( 42d ) },\n                { Float.class, new Float( 42f ) }, { Short.class, new Short( (short) 42 ) },\n                { BigDecimal.class, new BigDecimal( 42 ) }, { AtomicInteger.class, new AtomicInteger( 42 ) },\n                { AtomicLong.class, new AtomicLong( 42 ) }, { MutableInt.class, new MutableInt( 42 ) },\n                { Integer[].class, new Integer[] { 42 } }, { Date.class, new Date( System.currentTimeMillis() - 10000 ) },\n                { Calendar.class, Calendar.getInstance() }, { ArrayList.class, new ArrayList<String>( Arrays.asList( \"foo\" ) ) },\n                { int[].class, new int[] { 1, 2 } }, { long[].class, new long[] { 1, 2 } },\n                { short[].class, new short[] { 1, 2 } }, { float[].class, new float[] { 1, 2 } },\n                { double[].class, new double[] { 1, 2 } }, { int[].class, new int[] { 1, 2 } }, { byte[].class, \"42\".getBytes() },\n                { char[].class, \"42\".toCharArray() }, { String[].class, new String[] { \"23\", \"42\" } },\n                { Person[].class, new Person[] { createPerson( \"foo bar\", Gender.MALE, 42 ) } } };\n    }\n\n    @Test( enabled = true, dataProvider = \"typesAsSessionAttributesProvider\" )\n    public <T> void testTypesAsSessionAttributes( final Class<T> type, final T instance ) throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( type.getSimpleName(), instance );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        System.out.println( new String( bytes ) );\n        assertDeepEquals( _transcoder.deserialize( bytes ), session );\n    }\n\n    @Test( enabled = true )\n    public void testTypesInContainerClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( MyContainer.class.getSimpleName(), new MyContainer() );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testClassWithoutDefaultConstructor() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"no-default constructor\", TestClasses.createClassWithoutDefaultConstructor( \"foo\" ) );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testPrivateClass() throws Exception {\n\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"pc\", TestClasses.createPrivateClass( \"foo\" ) );\n\n        System.out.println( new String( _transcoder.serialize( session ) ) );\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCollections() throws Exception {\n        final MemcachedBackupSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setAttribute( \"foo\", new EntityWithCollections() );\n\n        assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session );\n    }\n\n    @Test( enabled = true )\n    public void testCyclicDependencies() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        final Person p1 = createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" );\n        final Person p2 = createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" );\n        p1.addFriend( p2 );\n        p2.addFriend( p1 );\n\n        session.setAttribute( \"person1\", p1 );\n        session.setAttribute( \"person2\", p2 );\n\n        final byte[] bytes = _transcoder.serialize( session );\n        // System.out.println( \"xml: \" + new String( bytes ) );\n        assertDeepEquals( session, _transcoder.deserialize( bytes ) );\n\n    }\n\n    @Test( enabled = true )\n    public void testReadValueIntoObject() throws Exception {\n        final StandardSession session = _manager.createEmptySession();\n        session.setValid( true );\n        session.setCreationTime( System.currentTimeMillis() );\n        getField( StandardSession.class, \"lastAccessedTime\" ).set( session, System.currentTimeMillis() + 100 );\n        session.setMaxInactiveInterval( 600 );\n\n        session.setId( \"foo\" );\n\n        session.setAttribute( \"person1\", createPerson( \"foo bar\", Gender.MALE, 42, \"foo.bar@example.org\", \"foo.bar@example.com\" ) );\n        session.setAttribute( \"person2\", createPerson( \"bar baz\", Gender.FEMALE, 42, \"bar.baz@example.org\", \"bar.baz@example.com\" ) );\n\n        final long start1 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final long start2 = System.nanoTime();\n        _transcoder.serialize( session );\n        System.out.println( \"javolution ser took \" + ( System.nanoTime() - start2 ) / 1000 );\n\n        final long start3 = System.nanoTime();\n        final byte[] json = _transcoder.serialize( session );\n        final StandardSession readJSONValue = (StandardSession) _transcoder.deserialize( json );\n        System.out.println( \"javolution-round took \" + ( System.nanoTime() - start3 ) / 1000 );\n\n        System.out.println( \"Have xml: \" + readJSONValue.getId() );\n        assertDeepEquals( readJSONValue, session );\n\n        final long start4 = System.nanoTime();\n        final StandardSession readJavaValue = javaRoundtrip( session, _manager );\n        System.out.println( \"java-round took \" + ( System.nanoTime() - start4 ) / 1000 );\n        assertDeepEquals( readJavaValue, session );\n\n        assertDeepEquals( readJSONValue, readJavaValue );\n\n        System.out.println( ToStringBuilder.reflectionToString( session ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJSONValue ) );\n        System.out.println( ToStringBuilder.reflectionToString( readJavaValue ) );\n\n    }\n\n    public static class EntityWithCollections {\n        private final String[] _bars;\n        private final List<String> _foos;\n        private final Map<String, Integer> _bazens;\n\n        public EntityWithCollections() {\n            _bars = new String[] { \"foo\", \"bar\" };\n            _foos = new ArrayList<String>( Arrays.asList( \"foo\", \"bar\" ) );\n            _bazens = new HashMap<String, Integer>();\n            _bazens.put( \"foo\", 1 );\n            _bazens.put( \"bar\", 2 );\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode( _bars );\n            result = prime * result + ( ( _bazens == null )\n                ? 0\n                : _bazens.hashCode() );\n            result = prime * result + ( ( _foos == null )\n                ? 0\n                : _foos.hashCode() );\n            return result;\n        }\n\n        @Override\n        public boolean equals( final Object obj ) {\n            if ( this == obj )\n                return true;\n            if ( obj == null )\n                return false;\n            if ( getClass() != obj.getClass() )\n                return false;\n            final EntityWithCollections other = (EntityWithCollections) obj;\n            if ( !Arrays.equals( _bars, other._bars ) )\n                return false;\n            if ( _bazens == null ) {\n                if ( other._bazens != null )\n                    return false;\n            } else if ( !_bazens.equals( other._bazens ) )\n                return false;\n            if ( _foos == null ) {\n                if ( other._foos != null )\n                    return false;\n            } else if ( !_foos.equals( other._foos ) )\n                return false;\n            return true;\n        }\n    }\n\n    private Field getField( final Class<?> clazz, final String name ) throws NoSuchFieldException {\n        final Field field = clazz.getDeclaredField( name );\n        field.setAccessible( true );\n        return field;\n    }\n\n    /*\n     * person2=Person [_gender=FEMALE, _name=bar baz, _props={email0=Email\n     * [_email=bar.baz@example.org, _name=bar baz], email1=Email\n     * [_email=bar.baz@example.com, _name=bar baz]}], person1=Person\n     * [_gender=MALE, _name=foo bar, _props={email0=Email\n     * [_email=foo.bar@example.org, _name=foo bar], email1=Email\n     * [_email=foo.bar@example.com, _name=foo bar]}]}\n     * \n     * but was: person2={name=bar baz, props={email0={name=bar baz,\n     * email=bar.baz@example.org}, email1={name=bar baz,\n     * email=bar.baz@example.com}}, gender=FEMALE} person1={name=foo bar,\n     * props={email0={name=foo bar, email=foo.bar@example.org}, email1={name=foo\n     * bar, email=foo.bar@example.com}}, gender=MALE}}\n     */\n\n    private void assertDeepEquals( final Object one, final Object another ) throws Exception {\n        assertDeepEquals( one, another, new IdentityHashMap<Object, Object>() );\n    }\n\n    private void assertDeepEquals( final Object one, final Object another, final Map<Object, Object> alreadyChecked )\n        throws Exception {\n        if ( one == another ) {\n            return;\n        }\n        if ( one == null && another != null || one != null && another == null ) {\n            Assert.fail( \"One of both is null: \" + one + \", \" + another );\n        }\n        if ( alreadyChecked.containsKey( one ) ) {\n            return;\n        }\n        alreadyChecked.put( one, another );\n\n        Assert.assertEquals( one.getClass(), another.getClass() );\n        if ( one.getClass().isPrimitive() || one instanceof String || one instanceof Character || one instanceof Boolean ) {\n            Assert.assertEquals( one, another );\n            return;\n        }\n\n        if ( Map.class.isAssignableFrom( one.getClass() ) ) {\n            final Map<?, ?> m1 = (Map<?, ?>) one;\n            final Map<?, ?> m2 = (Map<?, ?>) another;\n            Assert.assertEquals( m1.size(), m2.size() );\n            for ( final Map.Entry<?, ?> entry : m1.entrySet() ) {\n                assertDeepEquals( entry.getValue(), m2.get( entry.getKey() ) );\n            }\n            return;\n        }\n\n        if ( Number.class.isAssignableFrom( one.getClass() ) ) {\n            Assert.assertEquals( ( (Number) one ).longValue(), ( (Number) another ).longValue() );\n            return;\n        }\n\n        Class<? extends Object> clazz = one.getClass();\n        while ( clazz != null ) {\n            assertEqualDeclaredFields( clazz, one, another, alreadyChecked );\n            clazz = clazz.getSuperclass();\n        }\n\n    }\n\n    private void assertEqualDeclaredFields( final Class<? extends Object> clazz, final Object one, final Object another,\n            final Map<Object, Object> alreadyChecked ) throws Exception, IllegalAccessException {\n        for ( final Field field : clazz.getDeclaredFields() ) {\n            field.setAccessible( true );\n            if ( !Modifier.isTransient( field.getModifiers() ) ) {\n                assertDeepEquals( field.get( one ), field.get( another ), alreadyChecked );\n            }\n        }\n    }\n\n    private StandardSession javaRoundtrip( final StandardSession session, final MemcachedBackupSessionManager manager )\n        throws IOException, ClassNotFoundException {\n\n        final long start1 = System.nanoTime();\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream( bos );\n        session.writeObjectData( oos );\n        oos.close();\n        bos.close();\n        System.out.println( \"java-ser took \" + ( System.nanoTime() - start1 ) / 1000 );\n\n        final ByteArrayInputStream bis = new ByteArrayInputStream( bos.toByteArray() );\n        final ObjectInputStream ois = new ObjectInputStream( bis );\n        final StandardSession readSession = manager.createEmptySession();\n        readSession.readObjectData( ois );\n        ois.close();\n        bis.close();\n\n        return readSession;\n    }\n\n    protected byte[] serialize( final Object o ) {\n        if ( o == null ) {\n            throw new NullPointerException( \"Can't serialize null\" );\n        }\n\n        XMLObjectWriter writer = null;\n        try {\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            writer = XMLObjectWriter.newInstance( bos );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( \"__refId\" );\n            writer.setReferenceResolver( xmlReferenceResolver );\n            writer.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            writer.write( o, \"session\" );\n            writer.flush();\n            return bos.toByteArray();\n        } catch ( final Exception e ) {\n            throw new IllegalArgumentException( \"Non-serializable object\", e );\n        } finally {\n            try {\n                writer.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n\n    }\n\n    protected Object deserialize( final byte[] in ) {\n        XMLObjectReader reader = null;\n        try {\n            final ByteArrayInputStream bis = new ByteArrayInputStream( in );\n            reader = XMLObjectReader.newInstance( bis );\n            final XMLReferenceResolver xmlReferenceResolver = new XMLReferenceResolver();\n            xmlReferenceResolver.setIdentifierAttribute( \"__refId\" );\n            reader.setReferenceResolver( xmlReferenceResolver );\n            reader.setBinding( new ReflectionBinding( getClass().getClassLoader() ) );\n            if ( !reader.hasNext() ) {\n                throw new IllegalStateException( \"reader has no input\" );\n            }\n            return reader.read( \"session\" );\n        } catch ( final RuntimeException e ) {\n            throw e;\n        } catch ( final javolution.xml.stream.XMLStreamException e ) {\n            throw new RuntimeException( e );\n        } finally {\n            try {\n                reader.close();\n            } catch ( final XMLStreamException e ) {\n                // fail silently\n            }\n        }\n    }\n\n}\n","lineNo":207}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javolution.text.CharArray;\nimport javolution.xml.XMLFormat;\nimport javolution.xml.sax.Attributes;\nimport javolution.xml.stream.XMLStreamException;\nimport javolution.xml.stream.XMLStreamReader;\nimport sun.reflect.ReflectionFactory;\n\n/**\n * An {@link XMLFormat} that provides the binding for a certain class to to/from\n * xml based on reflection.\n * <p>\n * When serializing an object to xml, the values of the declared fields are read\n * (including inherited fields) from the object. Fields marked as\n * <code>transient<\/code> or <code>static<\/code> are omitted.\n * <\/p>\n * <p>\n * During deserialization, first all attributes contained in the xml are read\n * and written to the object. Afterwards the fields that are bound to elements\n * are checked for contained xml elements and in this case the values are\n * written to the object.\n * <\/p>\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ReflectionFormat<T> extends XMLFormat<T> {\n\n    private static final Logger LOG = Logger.getLogger( ReflectionFormat.class.getName() );\n    \n    private static final Map<Class<?>, XMLNumberFormat<?>> _numberFormats = new ConcurrentHashMap<Class<?>, XMLNumberFormat<?>>();\n    private static final ReflectionFactory REFLECTION_FACTORY = ReflectionFactory.getReflectionFactory();\n    private static final Object[] INITARGS = new Object[0];\n\n    private final Constructor<T> _constructor;\n    private final Collection<Field> _attributes;\n    private final Collection<Field> _elements;\n    private final Map<String, Field> _attributesMap;\n\n    /**\n     * Creates a new instance for the provided class.\n     * \n     * @param clazz\n     *            the Class that is supported by this {@link XMLFormat}.\n     * @param classLoader \n     */\n    @SuppressWarnings( \"unchecked\" )\n    public ReflectionFormat( final Class<T> clazz, final ClassLoader classLoader ) {\n\n        try {\n            _constructor = REFLECTION_FACTORY.newConstructorForSerialization(clazz, Object.class.getDeclaredConstructor(new Class[0]));\n            _constructor.setAccessible( true );\n        } catch ( final SecurityException e ) {\n            throw new RuntimeException( e );\n        } catch ( final NoSuchMethodException e ) {\n            throw new RuntimeException( e );\n        }\n        \n\n        final AttributesAndElements fields = allFields( clazz );\n\n        _attributes = fields.attributes;\n        _elements = fields.elements;\n\n        _attributesMap = new ConcurrentHashMap<String, Field>( _attributes.size() + 1 );\n        for ( final Field attribute : _attributes ) {\n            _attributesMap.put( attribute.getName(), attribute );\n        }\n    }\n\n    private AttributesAndElements allFields( final Class<T> cls ) {\n        final AttributesAndElements result = new AttributesAndElements();\n        Class<? super T> clazz = cls;\n        while ( clazz != null ) {\n            addDeclaredFields( clazz, result );\n            clazz = clazz.getSuperclass();\n        }\n        return result;\n    }\n\n    private void addDeclaredFields( final Class<? super T> clazz, final AttributesAndElements result ) {\n        final Field[] declaredFields = clazz.getDeclaredFields();\n        for ( final Field field : declaredFields ) {\n            if ( !Modifier.isTransient( field.getModifiers() ) && !Modifier.isStatic( field.getModifiers() ) ) {\n                field.setAccessible( true );\n                result.add( field );\n            }\n        }\n    }\n\n    static class AttributesAndElements {\n        private final Collection<Field> attributes;\n        private final Collection<Field> elements;\n\n        AttributesAndElements() {\n            attributes = new ArrayList<Field>();\n            elements = new ArrayList<Field>();\n        }\n\n        void add( final Field field ) {\n            if ( isAttribute( field ) ) {\n                attributes.add( field );\n            } else {\n                elements.add( field );\n            }\n        }\n    }\n\n    protected static boolean isAttribute( final Field field ) {\n        return isAttribute( field.getType() );\n    }\n\n    protected static boolean isAttribute( final Class<?> clazz ) {\n        return clazz.isPrimitive() || clazz == String.class || Number.class.isAssignableFrom( clazz ) || clazz.isEnum();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n        try {\n            return _constructor.newInstance( INITARGS );\n        } catch ( final Exception e ) {\n            throw new XMLStreamException( e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void read( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        readAttributes( input, obj );\n        readElements( input, obj );\n    }\n\n    private void readAttributes( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        final Attributes attributes = input.getAttributes();\n        for ( int i = 0; i < attributes.getLength(); i++ ) {\n            final CharArray name = attributes.getLocalName( i );\n            if ( !name.equals( \"class\" ) && !name.equals( JavolutionTranscoder.REF_ID ) ) {\n                final Field field = _attributesMap.get( name.toString() );\n                if ( field != null ) {\n                    setFieldFromAttribute( obj, field, input );\n                } else {\n                    LOG.warning( \"Did not find field \" + name + \", attribute value is \" + attributes.getValue( i ) );\n                }\n            }\n        }\n    }\n\n    private void readElements( final javolution.xml.XMLFormat.InputElement input, final T obj ) {\n        for ( final Field field : _elements ) {\n            final XMLStreamReader reader = input.getStreamReader();\n            reader.getEventType();\n\n            try {\n                final Object value = input.get( field.getName() );\n                field.set( obj, value );\n            } catch ( final Exception e ) {\n                LOG.log( Level.SEVERE, \"Could not set field value for field \" + field, e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write( final T obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException {\n        writeAttributes( obj, output );\n        writeElements( obj, output );\n    }\n\n    private void writeAttributes( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _attributes ) {\n            setAttributeFromField( obj, field, output );\n        }\n    }\n\n    private void writeElements( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _elements ) {\n            writeElement( obj, field, output );\n        }\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private void writeElement( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            final Object object = field.get( obj );\n            if ( object != null ) {\n                if ( field.getType().isArray() ) {\n                    addArray( object, field.getName(), output );\n                } else if ( Collection.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Collection<?>) object, field.getName(), (Class<Collection<?>>) object.getClass() );\n                } else if ( Map.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Map<?, ?>) object, field.getName(), (Class<Map<?, ?>>) object.getClass() );\n                } else {\n                    output.add( object, field.getName() );\n                }\n            }\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not write element for field.\", e );\n        }\n    }\n    \n    private void addArray( final Object obj, final String name, final OutputElement output ) throws XMLStreamException {\n        final Class<?> cls = obj.getClass();\n        if ( cls == int[].class ) {\n            output.add( (int[])obj, name, int[].class );\n        }\n        else if ( cls == long[].class ) {\n            output.add( (long[])obj, name, long[].class );\n        }\n        else if ( cls == short[].class ) {\n            output.add( (short[])obj, name, short[].class );\n        }\n        else if ( cls == float[].class ) {\n            output.add( (float[])obj, name, float[].class );\n        }\n        else if ( cls == double[].class ) {\n            output.add( (double[])obj, name, double[].class );\n        }\n        else if ( cls == char[].class ) {\n            output.add( (char[])obj, name, char[].class );\n        }\n        else if ( cls == byte[].class ) {\n            output.add( (byte[])obj, name, byte[].class );\n        }\n        else {\n            output.add( (Object[])obj, name, Object[].class );\n        }\n        \n    }\n\n    private void setAttributeFromField( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            \n            if ( field.getType().isPrimitive() ) {\n                if ( field.getType() == boolean.class ) {\n                    output.setAttribute( field.getName(), field.getBoolean( obj ) );\n                } else if ( field.getType() == int.class ) {\n                    output.setAttribute( field.getName(), field.getInt( obj ) );\n                } else if ( field.getType() == long.class ) {\n                    output.setAttribute( field.getName(), field.getLong( obj ) );\n                } else if ( field.getType() == float.class ) {\n                    output.setAttribute( field.getName(), field.getFloat( obj ) );\n                } else if ( field.getType() == double.class ) {\n                    output.setAttribute( field.getName(), field.getDouble( obj ) );\n                } else if ( field.getType() == byte.class ) {\n                    output.setAttribute( field.getName(), field.getByte( obj ) );\n                } else if ( field.getType() == char.class ) {\n                    output.setAttribute( field.getName(), field.getChar( obj ) );\n                } else if ( field.getType() == short.class ) {\n                    output.setAttribute( field.getName(), field.getShort( obj ) );\n                }\n            } else {\n\n                final Object object = field.get( obj );\n                \n                if ( object != null ) {\n                    if ( field.getType() == String.class || Number.class.isAssignableFrom( field.getType() ) ) {\n                        output.setAttribute( field.getName(), object.toString() );\n                    } else if ( field.getType().isEnum() ) {\n                        output.setAttribute( field.getName(), ( (Enum<?>) object ).name() );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + field.getType() );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not set attribute from field value.\", e );\n        }\n    }\n\n    private void setFieldFromAttribute( final T obj, final Field field, final javolution.xml.XMLFormat.InputElement input ) {\n        \n        try {\n\n            final String fieldName = field.getName();\n            if ( field.getType().isPrimitive() ) {\n\n                if ( field.getType() == boolean.class ) {\n                    field.setBoolean( obj, input.getAttribute( fieldName, false ) );\n                } else if ( field.getType() == int.class ) {\n                    field.setInt( obj, input.getAttribute( fieldName, 0 ) );\n                } else if ( field.getType() == long.class ) {\n                    field.setLong( obj, input.getAttribute( fieldName, (long) 0 ) );\n                } else if ( field.getType() == float.class ) {\n                    field.setFloat( obj, input.getAttribute( fieldName, (float) 0 ) );\n                } else if ( field.getType() == double.class ) {\n                    field.setDouble( obj, input.getAttribute( fieldName, (double) 0 ) );\n                } else if ( field.getType() == byte.class ) {\n                    field.setByte( obj, input.getAttribute( fieldName, (Byte) null ) );\n                } else if ( field.getType() == char.class ) {\n                    field.setChar( obj, (char) input.getAttribute( fieldName, (char) 0 ) );\n                } else if ( field.getType() == short.class ) {\n                    field.setShort( obj, input.getAttribute( fieldName, (Short) null ) );\n                }\n            } else if ( field.getType().isEnum() ) {\n                final String value = input.getAttribute( fieldName, (String) null );\n                if ( value != null ) {\n                    @SuppressWarnings( \"unchecked\" )\n                    final Enum enumValue = Enum.valueOf( field.getType().asSubclass( Enum.class ), value );\n                    field.set( obj, enumValue );\n                }\n            } else {\n\n                final Object object = input.getAttribute( fieldName );\n\n                if ( object != null ) {\n                    if ( field.getType() == String.class ) {\n                        field.set( obj, input.getAttribute( fieldName, (String) null ) );\n                    } else if ( field.getType().isAssignableFrom( Boolean.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Boolean) null ) );\n                    } else if ( field.getType().isAssignableFrom( Integer.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Integer) null ) );\n                    } else if ( field.getType().isAssignableFrom( Long.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Long) null ) );\n                    } else if ( field.getType().isAssignableFrom( Short.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Short) null ) );\n                    } else if ( field.getType().isAssignableFrom( Double.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Double) null ) );\n                    } else if ( field.getType().isAssignableFrom( Float.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Float) null ) );\n                    } else if ( field.getType().isAssignableFrom( Byte.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Byte) null ) );\n                    } else if ( Number.class.isAssignableFrom( field.getType() ) ) {\n                        final XMLNumberFormat<?> format = getNumberFormat( field.getType() );\n                        field.set( obj, format.newInstanceFromAttribute( input, fieldName ) );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + field.getType() );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Caught exception when trying to set field from attribute.\", e );\n        }\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> getNumberFormat( final Class<T> clazz ) {\n        XMLNumberFormat<?> result = _numberFormats.get( clazz );\n        if ( result == null ) {\n            result = createNumberFormat( clazz );\n            _numberFormats.put( clazz, result );\n        }\n        return (XMLNumberFormat<T>) result;\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> createNumberFormat( final Class<T> clazz ) {\n        try {\n            for( final Constructor<?> constructor : clazz.getConstructors() ) {\n                final Class<?>[] parameterTypes = constructor.getParameterTypes();\n                if ( parameterTypes.length == 1 ) {\n                    if ( parameterTypes[0] == long.class ) {\n                        return new XMLNumberLongFormat<T>( (Constructor<T>) constructor );\n                    }\n                    if ( parameterTypes[0] == int.class ) {\n                        return new XMLNumberIntFormat<T>( (Constructor<T>) constructor );\n                    }\n                }\n            }\n        } catch ( final Exception e ) {\n            throw new RuntimeException( e );\n        }\n        throw new IllegalArgumentException( \"No suitable constructor found for class \" + clazz.getName() + \".\\n\" +\n                \"Available constructors: \" + clazz.getConstructors() );\n    }\n    \n    /**\n     * The base class for number formats.\n     * \n     * @param <T> the number type.\n     */\n    static abstract class XMLNumberFormat<T> extends XMLFormat<T> {\n        \n        private final Constructor<T> _constructor;\n\n        public XMLNumberFormat( final Constructor<T> constructor ) {\n            _constructor = constructor;\n        }\n        \n        /**\n         * Creates a new instance from the associated constructor. The provided class is ignored, just\n         * the provided {@link InputElement} is used to read the value which will be passed to the constructor.\n         * \n         * @param clazz can be null for this {@link XMLFormat} implementation\n         * @param xml the input element for the object to create.\n         * @return a new number instance.\n         */\n        @Override\n        public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return newInstanceFromAttribute( xml, \"value\" );\n        }\n\n        /**\n         * Creates a new instance from an already associated constructor. The provided {@link InputElement} is\n         * used to read the value from the attribute with the provided name. The value read will be passed to the\n         * constructor of the object to create.\n         * \n         * @param xml the input element for the object to create.\n         * @param name the attribute name to read the value from.\n         * @return a new number instance.\n         */\n        public T newInstanceFromAttribute( final javolution.xml.XMLFormat.InputElement xml, final String name )\n            throws XMLStreamException {\n            final Object value = getAttribute( name, xml );\n            try {\n                return _constructor.newInstance( value );\n            } catch ( final Exception e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n        \n        protected abstract Object getAttribute( String name, InputElement xml ) throws XMLStreamException;\n\n        /**\n         * Does not perform anything, as the number is already created in {@link #newInstance(Class, javolution.xml.XMLFormat.InputElement)}.\n         * \n         * @param xml the input element\n         * @param the obj the created number object\n         */\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final T obj ) throws XMLStreamException {\n            // nothing to do...\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write( final T obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"value\", obj.toString() );\n        }\n        \n    }\n    \n    static class XMLNumberIntFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberIntFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0 );\n        }\n        \n    }\n    \n    static class XMLNumberLongFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberLongFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0L );\n        }\n        \n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javolution.text.CharArray;\nimport javolution.xml.XMLFormat;\nimport javolution.xml.sax.Attributes;\nimport javolution.xml.stream.XMLStreamException;\nimport javolution.xml.stream.XMLStreamReader;\nimport sun.reflect.ReflectionFactory;\n\n/**\n * An {@link XMLFormat} that provides the binding for a certain class to to/from\n * xml based on reflection.\n * <p>\n * When serializing an object to xml, the values of the declared fields are read\n * (including inherited fields) from the object. Fields marked as\n * <code>transient<\/code> or <code>static<\/code> are omitted.\n * <\/p>\n * <p>\n * During deserialization, first all attributes contained in the xml are read\n * and written to the object. Afterwards the fields that are bound to elements\n * are checked for contained xml elements and in this case the values are\n * written to the object.\n * <\/p>\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ReflectionFormat<T> extends XMLFormat<T> {\n\n    private static final Logger LOG = Logger.getLogger( ReflectionFormat.class.getName() );\n    \n    private static final Map<Class<?>, XMLNumberFormat<?>> _numberFormats = new ConcurrentHashMap<Class<?>, XMLNumberFormat<?>>();\n    private static final ReflectionFactory REFLECTION_FACTORY = ReflectionFactory.getReflectionFactory();\n    private static final Object[] INITARGS = new Object[0];\n\n    private final Constructor<T> _constructor;\n    private final Collection<Field> _attributes;\n    private final Collection<Field> _elements;\n    private final Map<String, Field> _attributesMap;\n\n    /**\n     * Creates a new instance for the provided class.\n     * \n     * @param clazz\n     *            the Class that is supported by this {@link XMLFormat}.\n     * @param classLoader \n     */\n    @SuppressWarnings( \"unchecked\" )\n    public ReflectionFormat( final Class<T> clazz, final ClassLoader classLoader ) {\n\n        try {\n            _constructor = REFLECTION_FACTORY.newConstructorForSerialization(clazz, Object.class.getDeclaredConstructor(new Class[0]));\n            _constructor.setAccessible( true );\n        } catch ( final SecurityException e ) {\n            throw new RuntimeException( e );\n        } catch ( final NoSuchMethodException e ) {\n            throw new RuntimeException( e );\n        }\n        \n\n        final AttributesAndElements fields = allFields( clazz );\n\n        _attributes = fields.attributes;\n        _elements = fields.elements;\n\n        _attributesMap = new ConcurrentHashMap<String, Field>( _attributes.size() + 1 );\n        for ( final Field attribute : _attributes ) {\n            _attributesMap.put( attribute.getName(), attribute );\n        }\n    }\n\n    private AttributesAndElements allFields( final Class<T> cls ) {\n        final AttributesAndElements result = new AttributesAndElements();\n        Class<? super T> clazz = cls;\n        while ( clazz != null ) {\n            addDeclaredFields( clazz, result );\n            clazz = clazz.getSuperclass();\n        }\n        return result;\n    }\n\n    private void addDeclaredFields( final Class<? super T> clazz, final AttributesAndElements result ) {\n        final Field[] declaredFields = clazz.getDeclaredFields();\n        for ( final Field field : declaredFields ) {\n            if ( !Modifier.isTransient( field.getModifiers() ) && !Modifier.isStatic( field.getModifiers() ) ) {\n                field.setAccessible( true );\n                result.add( field );\n            }\n        }\n    }\n\n    static class AttributesAndElements {\n        private final Collection<Field> attributes;\n        private final Collection<Field> elements;\n\n        AttributesAndElements() {\n            attributes = new ArrayList<Field>();\n            elements = new ArrayList<Field>();\n        }\n\n        void add( final Field field ) {\n            if ( isAttribute( field ) ) {\n                attributes.add( field );\n            } else {\n                elements.add( field );\n            }\n        }\n    }\n\n    protected static boolean isAttribute( final Field field ) {\n        return isAttribute( field.getType() );\n    }\n\n    protected static boolean isAttribute( final Class<?> clazz ) {\n        return clazz.isPrimitive()\n                || clazz.isEnum()\n                || clazz == String.class\n                || clazz == Boolean.class\n                || clazz == Integer.class\n                || clazz == Long.class\n                || clazz == Short.class\n                || clazz == Double.class\n                || clazz == Float.class\n                || clazz == Character.class\n                || clazz == Byte.class;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n        try {\n            return _constructor.newInstance( INITARGS );\n        } catch ( final Exception e ) {\n            throw new XMLStreamException( e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void read( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        readAttributes( input, obj );\n        readElements( input, obj );\n    }\n\n    private void readAttributes( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        final Attributes attributes = input.getAttributes();\n        for ( int i = 0; i < attributes.getLength(); i++ ) {\n            final CharArray name = attributes.getLocalName( i );\n            if ( !name.equals( \"class\" ) && !name.equals( JavolutionTranscoder.REF_ID ) ) {\n                final Field field = _attributesMap.get( name.toString() );\n                if ( field != null ) {\n                    setFieldFromAttribute( obj, field, input );\n                } else {\n                    LOG.warning( \"Did not find field \" + name + \", attribute value is \" + attributes.getValue( i ) );\n                }\n            }\n        }\n    }\n\n    private void readElements( final javolution.xml.XMLFormat.InputElement input, final T obj ) {\n        for ( final Field field : _elements ) {\n            final XMLStreamReader reader = input.getStreamReader();\n            reader.getEventType();\n\n            try {\n                final Object value = input.get( field.getName() );\n                field.set( obj, value );\n            } catch ( final Exception e ) {\n                LOG.log( Level.SEVERE, \"Could not set field value for field \" + field, e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write( final T obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException {\n        writeAttributes( obj, output );\n        writeElements( obj, output );\n    }\n\n    private void writeAttributes( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _attributes ) {\n            setAttributeFromField( obj, field, output );\n        }\n    }\n\n    private void writeElements( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _elements ) {\n            writeElement( obj, field, output );\n        }\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private void writeElement( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            final Object object = field.get( obj );\n            if ( object != null ) {\n                if ( field.getType().isArray() ) {\n                    addArray( object, field.getName(), output );\n                } else if ( Collection.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Collection<?>) object, field.getName(), (Class<Collection<?>>) object.getClass() );\n                } else if ( Map.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Map<?, ?>) object, field.getName(), (Class<Map<?, ?>>) object.getClass() );\n                } else {\n                    output.add( object, field.getName() );\n                }\n            }\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not write element for field.\", e );\n        }\n    }\n    \n    private void addArray( final Object obj, final String name, final OutputElement output ) throws XMLStreamException {\n        final Class<?> cls = obj.getClass();\n        if ( cls == int[].class ) {\n            output.add( (int[])obj, name, int[].class );\n        }\n        else if ( cls == long[].class ) {\n            output.add( (long[])obj, name, long[].class );\n        }\n        else if ( cls == short[].class ) {\n            output.add( (short[])obj, name, short[].class );\n        }\n        else if ( cls == float[].class ) {\n            output.add( (float[])obj, name, float[].class );\n        }\n        else if ( cls == double[].class ) {\n            output.add( (double[])obj, name, double[].class );\n        }\n        else if ( cls == char[].class ) {\n            output.add( (char[])obj, name, char[].class );\n        }\n        else if ( cls == byte[].class ) {\n            output.add( (byte[])obj, name, byte[].class );\n        }\n        else {\n            output.add( (Object[])obj, name, Object[].class );\n        }\n        \n    }\n\n    private void setAttributeFromField( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            \n            final Class<?> fieldType = field.getType();\n            if ( fieldType.isPrimitive() ) {\n                if ( fieldType == boolean.class ) {\n                    output.setAttribute( field.getName(), field.getBoolean( obj ) );\n                } else if ( fieldType == int.class ) {\n                    output.setAttribute( field.getName(), field.getInt( obj ) );\n                } else if ( fieldType == long.class ) {\n                    output.setAttribute( field.getName(), field.getLong( obj ) );\n                } else if ( fieldType == float.class ) {\n                    output.setAttribute( field.getName(), field.getFloat( obj ) );\n                } else if ( fieldType == double.class ) {\n                    output.setAttribute( field.getName(), field.getDouble( obj ) );\n                } else if ( fieldType == byte.class ) {\n                    output.setAttribute( field.getName(), field.getByte( obj ) );\n                } else if ( fieldType == char.class ) {\n                    output.setAttribute( field.getName(), field.getChar( obj ) );\n                } else if ( fieldType == short.class ) {\n                    output.setAttribute( field.getName(), field.getShort( obj ) );\n                }\n            } else {\n\n                final Object object = field.get( obj );\n                \n                if ( object != null ) {\n                    if ( fieldType == String.class || fieldType == Character.class || Number.class.isAssignableFrom( fieldType ) ) {\n                        output.setAttribute( field.getName(), object.toString() );\n                    } else if ( fieldType.isEnum() ) {\n                        output.setAttribute( field.getName(), ( (Enum<?>) object ).name() );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + fieldType );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not set attribute from field value.\", e );\n        }\n    }\n\n    private void setFieldFromAttribute( final T obj, final Field field, final javolution.xml.XMLFormat.InputElement input ) {\n        \n        try {\n\n            final String fieldName = field.getName();\n            final Class<?> fieldType = field.getType();\n            if ( fieldType.isPrimitive() ) {\n\n                if ( fieldType == boolean.class ) {\n                    field.setBoolean( obj, input.getAttribute( fieldName, false ) );\n                } else if ( fieldType == int.class ) {\n                    field.setInt( obj, input.getAttribute( fieldName, 0 ) );\n                } else if ( fieldType == long.class ) {\n                    field.setLong( obj, input.getAttribute( fieldName, (long) 0 ) );\n                } else if ( fieldType == float.class ) {\n                    field.setFloat( obj, input.getAttribute( fieldName, (float) 0 ) );\n                } else if ( fieldType == double.class ) {\n                    field.setDouble( obj, input.getAttribute( fieldName, (double) 0 ) );\n                } else if ( fieldType == byte.class ) {\n                    field.setByte( obj, input.getAttribute( fieldName, (Byte) null ) );\n                } else if ( fieldType == char.class ) {\n                    field.setChar( obj, (char) input.getAttribute( fieldName, (char) 0 ) );\n                } else if ( fieldType == short.class ) {\n                    field.setShort( obj, input.getAttribute( fieldName, (Short) null ) );\n                }\n            } else if ( fieldType.isEnum() ) {\n                final String value = input.getAttribute( fieldName, (String) null );\n                if ( value != null ) {\n                    @SuppressWarnings( \"unchecked\" )\n                    final Enum enumValue = Enum.valueOf( fieldType.asSubclass( Enum.class ), value );\n                    field.set( obj, enumValue );\n                }\n            } else {\n\n                final CharArray object = input.getAttribute( fieldName );\n\n                if ( object != null ) {\n                    if ( fieldType == String.class ) {\n                        field.set( obj, input.getAttribute( fieldName, (String) null ) );\n                    } else if ( fieldType.isAssignableFrom( Boolean.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Boolean) null ) );\n                    } else if ( fieldType.isAssignableFrom( Integer.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Integer) null ) );\n                    } else if ( fieldType.isAssignableFrom( Long.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Long) null ) );\n                    } else if ( fieldType.isAssignableFrom( Short.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Short) null ) );\n                    } else if ( fieldType.isAssignableFrom( Double.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Double) null ) );\n                    } else if ( fieldType.isAssignableFrom( Float.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Float) null ) );\n                    } else if ( fieldType.isAssignableFrom( Byte.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Byte) null ) );\n                    } else if ( fieldType.isAssignableFrom( Character.class ) ) {\n                        field.set( obj, Character.valueOf( object.charAt( 0 ) ) );\n                    } else if ( Number.class.isAssignableFrom( fieldType ) ) {\n                        final XMLNumberFormat<?> format = getNumberFormat( fieldType );\n                        field.set( obj, format.newInstanceFromAttribute( input, fieldName ) );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + fieldType );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Caught exception when trying to set field from attribute.\", e );\n        }\n    }\n    \n    /**\n     * Used to determine, if the given class can be serialized using the\n     * {@link XMLNumberFormat}.\n     * @param clazz the class that is to be checked\n     * @return\n     */\n    static boolean isNumberFormat( final Class<?> clazz ) {\n        return Number.class.isAssignableFrom( clazz );\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> getNumberFormat( final Class<T> clazz ) {\n        XMLNumberFormat<?> result = _numberFormats.get( clazz );\n        if ( result == null ) {\n            result = createNumberFormat( clazz );\n            _numberFormats.put( clazz, result );\n        }\n        return (XMLNumberFormat<T>) result;\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> createNumberFormat( final Class<T> clazz ) {\n        try {\n            for( final Constructor<?> constructor : clazz.getConstructors() ) {\n                final Class<?>[] parameterTypes = constructor.getParameterTypes();\n                if ( parameterTypes.length == 1 ) {\n                    if ( parameterTypes[0] == long.class ) {\n                        return new XMLNumberLongFormat<T>( (Constructor<T>) constructor );\n                    }\n                    if ( parameterTypes[0] == int.class ) {\n                        return new XMLNumberIntFormat<T>( (Constructor<T>) constructor );\n                    }\n                }\n            }\n        } catch ( final Exception e ) {\n            throw new RuntimeException( e );\n        }\n        throw new IllegalArgumentException( \"No suitable constructor found for class \" + clazz.getName() + \".\\n\" +\n                \"Available constructors: \" + clazz.getConstructors() );\n    }\n    \n    /**\n     * The base class for number formats.\n     * \n     * @param <T> the number type.\n     */\n    static abstract class XMLNumberFormat<T> extends XMLFormat<T> {\n        \n        private final Constructor<T> _constructor;\n\n        public XMLNumberFormat( final Constructor<T> constructor ) {\n            _constructor = constructor;\n        }\n        \n        /**\n         * Creates a new instance from the associated constructor. The provided class is ignored, just\n         * the provided {@link InputElement} is used to read the value which will be passed to the constructor.\n         * \n         * @param clazz can be null for this {@link XMLFormat} implementation\n         * @param xml the input element for the object to create.\n         * @return a new number instance.\n         */\n        @Override\n        public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return newInstanceFromAttribute( xml, \"value\" );\n        }\n\n        /**\n         * Creates a new instance from an already associated constructor. The provided {@link InputElement} is\n         * used to read the value from the attribute with the provided name. The value read will be passed to the\n         * constructor of the object to create.\n         * \n         * @param xml the input element for the object to create.\n         * @param name the attribute name to read the value from.\n         * @return a new number instance.\n         */\n        public T newInstanceFromAttribute( final javolution.xml.XMLFormat.InputElement xml, final String name )\n            throws XMLStreamException {\n            final Object value = getAttribute( name, xml );\n            try {\n                return _constructor.newInstance( value );\n            } catch ( final Exception e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n        \n        protected abstract Object getAttribute( String name, InputElement xml ) throws XMLStreamException;\n\n        /**\n         * Does not perform anything, as the number is already created in {@link #newInstance(Class, javolution.xml.XMLFormat.InputElement)}.\n         * \n         * @param xml the input element\n         * @param the obj the created number object\n         */\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final T obj ) throws XMLStreamException {\n            // nothing to do...\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write( final T obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"value\", obj.toString() );\n        }\n        \n    }\n    \n    static class XMLNumberIntFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberIntFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0 );\n        }\n        \n    }\n    \n    static class XMLNumberLongFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberLongFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0L );\n        }\n        \n    }\n\n}\n","lineNo":276}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javolution.text.CharArray;\nimport javolution.xml.XMLFormat;\nimport javolution.xml.sax.Attributes;\nimport javolution.xml.stream.XMLStreamException;\nimport javolution.xml.stream.XMLStreamReader;\nimport sun.reflect.ReflectionFactory;\n\n/**\n * An {@link XMLFormat} that provides the binding for a certain class to to/from\n * xml based on reflection.\n * <p>\n * When serializing an object to xml, the values of the declared fields are read\n * (including inherited fields) from the object. Fields marked as\n * <code>transient<\/code> or <code>static<\/code> are omitted.\n * <\/p>\n * <p>\n * During deserialization, first all attributes contained in the xml are read\n * and written to the object. Afterwards the fields that are bound to elements\n * are checked for contained xml elements and in this case the values are\n * written to the object.\n * <\/p>\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ReflectionFormat<T> extends XMLFormat<T> {\n\n    private static final Logger LOG = Logger.getLogger( ReflectionFormat.class.getName() );\n    \n    private static final Map<Class<?>, XMLNumberFormat<?>> _numberFormats = new ConcurrentHashMap<Class<?>, XMLNumberFormat<?>>();\n    private static final ReflectionFactory REFLECTION_FACTORY = ReflectionFactory.getReflectionFactory();\n    private static final Object[] INITARGS = new Object[0];\n\n    private final Constructor<T> _constructor;\n    private final Collection<Field> _attributes;\n    private final Collection<Field> _elements;\n    private final Map<String, Field> _attributesMap;\n\n    /**\n     * Creates a new instance for the provided class.\n     * \n     * @param clazz\n     *            the Class that is supported by this {@link XMLFormat}.\n     * @param classLoader \n     */\n    @SuppressWarnings( \"unchecked\" )\n    public ReflectionFormat( final Class<T> clazz, final ClassLoader classLoader ) {\n\n        try {\n            _constructor = REFLECTION_FACTORY.newConstructorForSerialization(clazz, Object.class.getDeclaredConstructor(new Class[0]));\n            _constructor.setAccessible( true );\n        } catch ( final SecurityException e ) {\n            throw new RuntimeException( e );\n        } catch ( final NoSuchMethodException e ) {\n            throw new RuntimeException( e );\n        }\n        \n\n        final AttributesAndElements fields = allFields( clazz );\n\n        _attributes = fields.attributes;\n        _elements = fields.elements;\n\n        _attributesMap = new ConcurrentHashMap<String, Field>( _attributes.size() + 1 );\n        for ( final Field attribute : _attributes ) {\n            _attributesMap.put( attribute.getName(), attribute );\n        }\n    }\n\n    private AttributesAndElements allFields( final Class<T> cls ) {\n        final AttributesAndElements result = new AttributesAndElements();\n        Class<? super T> clazz = cls;\n        while ( clazz != null ) {\n            addDeclaredFields( clazz, result );\n            clazz = clazz.getSuperclass();\n        }\n        return result;\n    }\n\n    private void addDeclaredFields( final Class<? super T> clazz, final AttributesAndElements result ) {\n        final Field[] declaredFields = clazz.getDeclaredFields();\n        for ( final Field field : declaredFields ) {\n            if ( !Modifier.isTransient( field.getModifiers() ) && !Modifier.isStatic( field.getModifiers() ) ) {\n                field.setAccessible( true );\n                result.add( field );\n            }\n        }\n    }\n\n    static class AttributesAndElements {\n        private final Collection<Field> attributes;\n        private final Collection<Field> elements;\n\n        AttributesAndElements() {\n            attributes = new ArrayList<Field>();\n            elements = new ArrayList<Field>();\n        }\n\n        void add( final Field field ) {\n            if ( isAttribute( field ) ) {\n                attributes.add( field );\n            } else {\n                elements.add( field );\n            }\n        }\n    }\n\n    protected static boolean isAttribute( final Field field ) {\n        return isAttribute( field.getType() );\n    }\n\n    protected static boolean isAttribute( final Class<?> clazz ) {\n        return clazz.isPrimitive() || clazz == String.class || Number.class.isAssignableFrom( clazz ) || clazz.isEnum();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n        try {\n            return _constructor.newInstance( INITARGS );\n        } catch ( final Exception e ) {\n            throw new XMLStreamException( e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void read( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        readAttributes( input, obj );\n        readElements( input, obj );\n    }\n\n    private void readAttributes( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        final Attributes attributes = input.getAttributes();\n        for ( int i = 0; i < attributes.getLength(); i++ ) {\n            final CharArray name = attributes.getLocalName( i );\n            if ( !name.equals( \"class\" ) && !name.equals( JavolutionTranscoder.REF_ID ) ) {\n                final Field field = _attributesMap.get( name.toString() );\n                if ( field != null ) {\n                    setFieldFromAttribute( obj, field, input );\n                } else {\n                    LOG.warning( \"Did not find field \" + name + \", attribute value is \" + attributes.getValue( i ) );\n                }\n            }\n        }\n    }\n\n    private void readElements( final javolution.xml.XMLFormat.InputElement input, final T obj ) {\n        for ( final Field field : _elements ) {\n            final XMLStreamReader reader = input.getStreamReader();\n            reader.getEventType();\n\n            try {\n                final Object value = input.get( field.getName() );\n                field.set( obj, value );\n            } catch ( final Exception e ) {\n                LOG.log( Level.SEVERE, \"Could not set field value for field \" + field, e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write( final T obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException {\n        writeAttributes( obj, output );\n        writeElements( obj, output );\n    }\n\n    private void writeAttributes( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _attributes ) {\n            setAttributeFromField( obj, field, output );\n        }\n    }\n\n    private void writeElements( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _elements ) {\n            writeElement( obj, field, output );\n        }\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private void writeElement( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            final Object object = field.get( obj );\n            if ( object != null ) {\n                if ( field.getType().isArray() ) {\n                    addArray( object, field.getName(), output );\n                } else if ( Collection.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Collection<?>) object, field.getName(), (Class<Collection<?>>) object.getClass() );\n                } else if ( Map.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Map<?, ?>) object, field.getName(), (Class<Map<?, ?>>) object.getClass() );\n                } else {\n                    output.add( object, field.getName() );\n                }\n            }\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not write element for field.\", e );\n        }\n    }\n    \n    private void addArray( final Object obj, final String name, final OutputElement output ) throws XMLStreamException {\n        final Class<?> cls = obj.getClass();\n        if ( cls == int[].class ) {\n            output.add( (int[])obj, name, int[].class );\n        }\n        else if ( cls == long[].class ) {\n            output.add( (long[])obj, name, long[].class );\n        }\n        else if ( cls == short[].class ) {\n            output.add( (short[])obj, name, short[].class );\n        }\n        else if ( cls == float[].class ) {\n            output.add( (float[])obj, name, float[].class );\n        }\n        else if ( cls == double[].class ) {\n            output.add( (double[])obj, name, double[].class );\n        }\n        else if ( cls == char[].class ) {\n            output.add( (char[])obj, name, char[].class );\n        }\n        else if ( cls == byte[].class ) {\n            output.add( (byte[])obj, name, byte[].class );\n        }\n        else {\n            output.add( (Object[])obj, name, Object[].class );\n        }\n        \n    }\n\n    private void setAttributeFromField( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            \n            if ( field.getType().isPrimitive() ) {\n                if ( field.getType() == boolean.class ) {\n                    output.setAttribute( field.getName(), field.getBoolean( obj ) );\n                } else if ( field.getType() == int.class ) {\n                    output.setAttribute( field.getName(), field.getInt( obj ) );\n                } else if ( field.getType() == long.class ) {\n                    output.setAttribute( field.getName(), field.getLong( obj ) );\n                } else if ( field.getType() == float.class ) {\n                    output.setAttribute( field.getName(), field.getFloat( obj ) );\n                } else if ( field.getType() == double.class ) {\n                    output.setAttribute( field.getName(), field.getDouble( obj ) );\n                } else if ( field.getType() == byte.class ) {\n                    output.setAttribute( field.getName(), field.getByte( obj ) );\n                } else if ( field.getType() == char.class ) {\n                    output.setAttribute( field.getName(), field.getChar( obj ) );\n                } else if ( field.getType() == short.class ) {\n                    output.setAttribute( field.getName(), field.getShort( obj ) );\n                }\n            } else {\n\n                final Object object = field.get( obj );\n                \n                if ( object != null ) {\n                    if ( field.getType() == String.class || Number.class.isAssignableFrom( field.getType() ) ) {\n                        output.setAttribute( field.getName(), object.toString() );\n                    } else if ( field.getType().isEnum() ) {\n                        output.setAttribute( field.getName(), ( (Enum<?>) object ).name() );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + field.getType() );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not set attribute from field value.\", e );\n        }\n    }\n\n    private void setFieldFromAttribute( final T obj, final Field field, final javolution.xml.XMLFormat.InputElement input ) {\n        \n        try {\n\n            final String fieldName = field.getName();\n            if ( field.getType().isPrimitive() ) {\n\n                if ( field.getType() == boolean.class ) {\n                    field.setBoolean( obj, input.getAttribute( fieldName, false ) );\n                } else if ( field.getType() == int.class ) {\n                    field.setInt( obj, input.getAttribute( fieldName, 0 ) );\n                } else if ( field.getType() == long.class ) {\n                    field.setLong( obj, input.getAttribute( fieldName, (long) 0 ) );\n                } else if ( field.getType() == float.class ) {\n                    field.setFloat( obj, input.getAttribute( fieldName, (float) 0 ) );\n                } else if ( field.getType() == double.class ) {\n                    field.setDouble( obj, input.getAttribute( fieldName, (double) 0 ) );\n                } else if ( field.getType() == byte.class ) {\n                    field.setByte( obj, input.getAttribute( fieldName, (Byte) null ) );\n                } else if ( field.getType() == char.class ) {\n                    field.setChar( obj, (char) input.getAttribute( fieldName, (char) 0 ) );\n                } else if ( field.getType() == short.class ) {\n                    field.setShort( obj, input.getAttribute( fieldName, (Short) null ) );\n                }\n            } else if ( field.getType().isEnum() ) {\n                final String value = input.getAttribute( fieldName, (String) null );\n                if ( value != null ) {\n                    @SuppressWarnings( \"unchecked\" )\n                    final Enum enumValue = Enum.valueOf( field.getType().asSubclass( Enum.class ), value );\n                    field.set( obj, enumValue );\n                }\n            } else {\n\n                final Object object = input.getAttribute( fieldName );\n\n                if ( object != null ) {\n                    if ( field.getType() == String.class ) {\n                        field.set( obj, input.getAttribute( fieldName, (String) null ) );\n                    } else if ( field.getType().isAssignableFrom( Boolean.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Boolean) null ) );\n                    } else if ( field.getType().isAssignableFrom( Integer.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Integer) null ) );\n                    } else if ( field.getType().isAssignableFrom( Long.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Long) null ) );\n                    } else if ( field.getType().isAssignableFrom( Short.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Short) null ) );\n                    } else if ( field.getType().isAssignableFrom( Double.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Double) null ) );\n                    } else if ( field.getType().isAssignableFrom( Float.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Float) null ) );\n                    } else if ( field.getType().isAssignableFrom( Byte.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Byte) null ) );\n                    } else if ( Number.class.isAssignableFrom( field.getType() ) ) {\n                        final XMLNumberFormat<?> format = getNumberFormat( field.getType() );\n                        field.set( obj, format.newInstanceFromAttribute( input, fieldName ) );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + field.getType() );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Caught exception when trying to set field from attribute.\", e );\n        }\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> getNumberFormat( final Class<T> clazz ) {\n        XMLNumberFormat<?> result = _numberFormats.get( clazz );\n        if ( result == null ) {\n            result = createNumberFormat( clazz );\n            _numberFormats.put( clazz, result );\n        }\n        return (XMLNumberFormat<T>) result;\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> createNumberFormat( final Class<T> clazz ) {\n        try {\n            for( final Constructor<?> constructor : clazz.getConstructors() ) {\n                final Class<?>[] parameterTypes = constructor.getParameterTypes();\n                if ( parameterTypes.length == 1 ) {\n                    if ( parameterTypes[0] == long.class ) {\n                        return new XMLNumberLongFormat<T>( (Constructor<T>) constructor );\n                    }\n                    if ( parameterTypes[0] == int.class ) {\n                        return new XMLNumberIntFormat<T>( (Constructor<T>) constructor );\n                    }\n                }\n            }\n        } catch ( final Exception e ) {\n            throw new RuntimeException( e );\n        }\n        throw new IllegalArgumentException( \"No suitable constructor found for class \" + clazz.getName() + \".\\n\" +\n                \"Available constructors: \" + clazz.getConstructors() );\n    }\n    \n    /**\n     * The base class for number formats.\n     * \n     * @param <T> the number type.\n     */\n    static abstract class XMLNumberFormat<T> extends XMLFormat<T> {\n        \n        private final Constructor<T> _constructor;\n\n        public XMLNumberFormat( final Constructor<T> constructor ) {\n            _constructor = constructor;\n        }\n        \n        /**\n         * Creates a new instance from the associated constructor. The provided class is ignored, just\n         * the provided {@link InputElement} is used to read the value which will be passed to the constructor.\n         * \n         * @param clazz can be null for this {@link XMLFormat} implementation\n         * @param xml the input element for the object to create.\n         * @return a new number instance.\n         */\n        @Override\n        public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return newInstanceFromAttribute( xml, \"value\" );\n        }\n\n        /**\n         * Creates a new instance from an already associated constructor. The provided {@link InputElement} is\n         * used to read the value from the attribute with the provided name. The value read will be passed to the\n         * constructor of the object to create.\n         * \n         * @param xml the input element for the object to create.\n         * @param name the attribute name to read the value from.\n         * @return a new number instance.\n         */\n        public T newInstanceFromAttribute( final javolution.xml.XMLFormat.InputElement xml, final String name )\n            throws XMLStreamException {\n            final Object value = getAttribute( name, xml );\n            try {\n                return _constructor.newInstance( value );\n            } catch ( final Exception e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n        \n        protected abstract Object getAttribute( String name, InputElement xml ) throws XMLStreamException;\n\n        /**\n         * Does not perform anything, as the number is already created in {@link #newInstance(Class, javolution.xml.XMLFormat.InputElement)}.\n         * \n         * @param xml the input element\n         * @param the obj the created number object\n         */\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final T obj ) throws XMLStreamException {\n            // nothing to do...\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write( final T obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"value\", obj.toString() );\n        }\n        \n    }\n    \n    static class XMLNumberIntFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberIntFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0 );\n        }\n        \n    }\n    \n    static class XMLNumberLongFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberLongFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0L );\n        }\n        \n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.serializer.javolution;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javolution.text.CharArray;\nimport javolution.xml.XMLFormat;\nimport javolution.xml.sax.Attributes;\nimport javolution.xml.stream.XMLStreamException;\nimport javolution.xml.stream.XMLStreamReader;\nimport sun.reflect.ReflectionFactory;\n\n/**\n * An {@link XMLFormat} that provides the binding for a certain class to to/from\n * xml based on reflection.\n * <p>\n * When serializing an object to xml, the values of the declared fields are read\n * (including inherited fields) from the object. Fields marked as\n * <code>transient<\/code> or <code>static<\/code> are omitted.\n * <\/p>\n * <p>\n * During deserialization, first all attributes contained in the xml are read\n * and written to the object. Afterwards the fields that are bound to elements\n * are checked for contained xml elements and in this case the values are\n * written to the object.\n * <\/p>\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n */\npublic class ReflectionFormat<T> extends XMLFormat<T> {\n\n    private static final Logger LOG = Logger.getLogger( ReflectionFormat.class.getName() );\n    \n    private static final Map<Class<?>, XMLNumberFormat<?>> _numberFormats = new ConcurrentHashMap<Class<?>, XMLNumberFormat<?>>();\n    private static final ReflectionFactory REFLECTION_FACTORY = ReflectionFactory.getReflectionFactory();\n    private static final Object[] INITARGS = new Object[0];\n\n    private final Constructor<T> _constructor;\n    private final Collection<Field> _attributes;\n    private final Collection<Field> _elements;\n    private final Map<String, Field> _attributesMap;\n\n    /**\n     * Creates a new instance for the provided class.\n     * \n     * @param clazz\n     *            the Class that is supported by this {@link XMLFormat}.\n     * @param classLoader \n     */\n    @SuppressWarnings( \"unchecked\" )\n    public ReflectionFormat( final Class<T> clazz, final ClassLoader classLoader ) {\n\n        try {\n            _constructor = REFLECTION_FACTORY.newConstructorForSerialization(clazz, Object.class.getDeclaredConstructor(new Class[0]));\n            _constructor.setAccessible( true );\n        } catch ( final SecurityException e ) {\n            throw new RuntimeException( e );\n        } catch ( final NoSuchMethodException e ) {\n            throw new RuntimeException( e );\n        }\n        \n\n        final AttributesAndElements fields = allFields( clazz );\n\n        _attributes = fields.attributes;\n        _elements = fields.elements;\n\n        _attributesMap = new ConcurrentHashMap<String, Field>( _attributes.size() + 1 );\n        for ( final Field attribute : _attributes ) {\n            _attributesMap.put( attribute.getName(), attribute );\n        }\n    }\n\n    private AttributesAndElements allFields( final Class<T> cls ) {\n        final AttributesAndElements result = new AttributesAndElements();\n        Class<? super T> clazz = cls;\n        while ( clazz != null ) {\n            addDeclaredFields( clazz, result );\n            clazz = clazz.getSuperclass();\n        }\n        return result;\n    }\n\n    private void addDeclaredFields( final Class<? super T> clazz, final AttributesAndElements result ) {\n        final Field[] declaredFields = clazz.getDeclaredFields();\n        for ( final Field field : declaredFields ) {\n            if ( !Modifier.isTransient( field.getModifiers() ) && !Modifier.isStatic( field.getModifiers() ) ) {\n                field.setAccessible( true );\n                result.add( field );\n            }\n        }\n    }\n\n    static class AttributesAndElements {\n        private final Collection<Field> attributes;\n        private final Collection<Field> elements;\n\n        AttributesAndElements() {\n            attributes = new ArrayList<Field>();\n            elements = new ArrayList<Field>();\n        }\n\n        void add( final Field field ) {\n            if ( isAttribute( field ) ) {\n                attributes.add( field );\n            } else {\n                elements.add( field );\n            }\n        }\n    }\n\n    protected static boolean isAttribute( final Field field ) {\n        return isAttribute( field.getType() );\n    }\n\n    protected static boolean isAttribute( final Class<?> clazz ) {\n        return clazz.isPrimitive()\n                || clazz.isEnum()\n                || clazz == String.class\n                || clazz == Boolean.class\n                || clazz == Integer.class\n                || clazz == Long.class\n                || clazz == Short.class\n                || clazz == Double.class\n                || clazz == Float.class\n                || clazz == Character.class\n                || clazz == Byte.class;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n        try {\n            return _constructor.newInstance( INITARGS );\n        } catch ( final Exception e ) {\n            throw new XMLStreamException( e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void read( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        readAttributes( input, obj );\n        readElements( input, obj );\n    }\n\n    private void readAttributes( final javolution.xml.XMLFormat.InputElement input, final T obj ) throws XMLStreamException {\n        final Attributes attributes = input.getAttributes();\n        for ( int i = 0; i < attributes.getLength(); i++ ) {\n            final CharArray name = attributes.getLocalName( i );\n            if ( !name.equals( \"class\" ) && !name.equals( JavolutionTranscoder.REF_ID ) ) {\n                final Field field = _attributesMap.get( name.toString() );\n                if ( field != null ) {\n                    setFieldFromAttribute( obj, field, input );\n                } else {\n                    LOG.warning( \"Did not find field \" + name + \", attribute value is \" + attributes.getValue( i ) );\n                }\n            }\n        }\n    }\n\n    private void readElements( final javolution.xml.XMLFormat.InputElement input, final T obj ) {\n        for ( final Field field : _elements ) {\n            final XMLStreamReader reader = input.getStreamReader();\n            reader.getEventType();\n\n            try {\n                final Object value = input.get( field.getName() );\n                field.set( obj, value );\n            } catch ( final Exception e ) {\n                LOG.log( Level.SEVERE, \"Could not set field value for field \" + field, e );\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write( final T obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException {\n        writeAttributes( obj, output );\n        writeElements( obj, output );\n    }\n\n    private void writeAttributes( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _attributes ) {\n            setAttributeFromField( obj, field, output );\n        }\n    }\n\n    private void writeElements( final T obj, final javolution.xml.XMLFormat.OutputElement output ) {\n        for ( final Field field : _elements ) {\n            writeElement( obj, field, output );\n        }\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    private void writeElement( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            final Object object = field.get( obj );\n            if ( object != null ) {\n                if ( field.getType().isArray() ) {\n                    addArray( object, field.getName(), output );\n                } else if ( Collection.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Collection<?>) object, field.getName(), (Class<Collection<?>>) object.getClass() );\n                } else if ( Map.class.isAssignableFrom( field.getType() ) ) {\n                    output.add( (Map<?, ?>) object, field.getName(), (Class<Map<?, ?>>) object.getClass() );\n                } else {\n                    output.add( object, field.getName() );\n                }\n            }\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not write element for field.\", e );\n        }\n    }\n    \n    private void addArray( final Object obj, final String name, final OutputElement output ) throws XMLStreamException {\n        final Class<?> cls = obj.getClass();\n        if ( cls == int[].class ) {\n            output.add( (int[])obj, name, int[].class );\n        }\n        else if ( cls == long[].class ) {\n            output.add( (long[])obj, name, long[].class );\n        }\n        else if ( cls == short[].class ) {\n            output.add( (short[])obj, name, short[].class );\n        }\n        else if ( cls == float[].class ) {\n            output.add( (float[])obj, name, float[].class );\n        }\n        else if ( cls == double[].class ) {\n            output.add( (double[])obj, name, double[].class );\n        }\n        else if ( cls == char[].class ) {\n            output.add( (char[])obj, name, char[].class );\n        }\n        else if ( cls == byte[].class ) {\n            output.add( (byte[])obj, name, byte[].class );\n        }\n        else {\n            output.add( (Object[])obj, name, Object[].class );\n        }\n        \n    }\n\n    private void setAttributeFromField( final T obj, final Field field, final javolution.xml.XMLFormat.OutputElement output ) {\n        try {\n            \n            final Class<?> fieldType = field.getType();\n            if ( fieldType.isPrimitive() ) {\n                if ( fieldType == boolean.class ) {\n                    output.setAttribute( field.getName(), field.getBoolean( obj ) );\n                } else if ( fieldType == int.class ) {\n                    output.setAttribute( field.getName(), field.getInt( obj ) );\n                } else if ( fieldType == long.class ) {\n                    output.setAttribute( field.getName(), field.getLong( obj ) );\n                } else if ( fieldType == float.class ) {\n                    output.setAttribute( field.getName(), field.getFloat( obj ) );\n                } else if ( fieldType == double.class ) {\n                    output.setAttribute( field.getName(), field.getDouble( obj ) );\n                } else if ( fieldType == byte.class ) {\n                    output.setAttribute( field.getName(), field.getByte( obj ) );\n                } else if ( fieldType == char.class ) {\n                    output.setAttribute( field.getName(), field.getChar( obj ) );\n                } else if ( fieldType == short.class ) {\n                    output.setAttribute( field.getName(), field.getShort( obj ) );\n                }\n            } else {\n\n                final Object object = field.get( obj );\n                \n                if ( object != null ) {\n                    if ( fieldType == String.class || fieldType == Character.class || Number.class.isAssignableFrom( fieldType ) ) {\n                        output.setAttribute( field.getName(), object.toString() );\n                    } else if ( fieldType.isEnum() ) {\n                        output.setAttribute( field.getName(), ( (Enum<?>) object ).name() );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + fieldType );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Could not set attribute from field value.\", e );\n        }\n    }\n\n    private void setFieldFromAttribute( final T obj, final Field field, final javolution.xml.XMLFormat.InputElement input ) {\n        \n        try {\n\n            final String fieldName = field.getName();\n            final Class<?> fieldType = field.getType();\n            if ( fieldType.isPrimitive() ) {\n\n                if ( fieldType == boolean.class ) {\n                    field.setBoolean( obj, input.getAttribute( fieldName, false ) );\n                } else if ( fieldType == int.class ) {\n                    field.setInt( obj, input.getAttribute( fieldName, 0 ) );\n                } else if ( fieldType == long.class ) {\n                    field.setLong( obj, input.getAttribute( fieldName, (long) 0 ) );\n                } else if ( fieldType == float.class ) {\n                    field.setFloat( obj, input.getAttribute( fieldName, (float) 0 ) );\n                } else if ( fieldType == double.class ) {\n                    field.setDouble( obj, input.getAttribute( fieldName, (double) 0 ) );\n                } else if ( fieldType == byte.class ) {\n                    field.setByte( obj, input.getAttribute( fieldName, (Byte) null ) );\n                } else if ( fieldType == char.class ) {\n                    field.setChar( obj, (char) input.getAttribute( fieldName, (char) 0 ) );\n                } else if ( fieldType == short.class ) {\n                    field.setShort( obj, input.getAttribute( fieldName, (Short) null ) );\n                }\n            } else if ( fieldType.isEnum() ) {\n                final String value = input.getAttribute( fieldName, (String) null );\n                if ( value != null ) {\n                    @SuppressWarnings( \"unchecked\" )\n                    final Enum enumValue = Enum.valueOf( fieldType.asSubclass( Enum.class ), value );\n                    field.set( obj, enumValue );\n                }\n            } else {\n\n                final CharArray object = input.getAttribute( fieldName );\n\n                if ( object != null ) {\n                    if ( fieldType == String.class ) {\n                        field.set( obj, input.getAttribute( fieldName, (String) null ) );\n                    } else if ( fieldType.isAssignableFrom( Boolean.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Boolean) null ) );\n                    } else if ( fieldType.isAssignableFrom( Integer.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Integer) null ) );\n                    } else if ( fieldType.isAssignableFrom( Long.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Long) null ) );\n                    } else if ( fieldType.isAssignableFrom( Short.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Short) null ) );\n                    } else if ( fieldType.isAssignableFrom( Double.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Double) null ) );\n                    } else if ( fieldType.isAssignableFrom( Float.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Float) null ) );\n                    } else if ( fieldType.isAssignableFrom( Byte.class ) ) {\n                        field.set( obj, input.getAttribute( fieldName, (Byte) null ) );\n                    } else if ( fieldType.isAssignableFrom( Character.class ) ) {\n                        field.set( obj, Character.valueOf( object.charAt( 0 ) ) );\n                    } else if ( Number.class.isAssignableFrom( fieldType ) ) {\n                        final XMLNumberFormat<?> format = getNumberFormat( fieldType );\n                        field.set( obj, format.newInstanceFromAttribute( input, fieldName ) );\n                    } else {\n                        throw new IllegalArgumentException( \"Not yet supported as attribute: \" + fieldType );\n                    }\n                }\n            }\n\n        } catch ( final Exception e ) {\n            LOG.log( Level.SEVERE, \"Caught exception when trying to set field from attribute.\", e );\n        }\n    }\n    \n    /**\n     * Used to determine, if the given class can be serialized using the\n     * {@link XMLNumberFormat}.\n     * @param clazz the class that is to be checked\n     * @return\n     */\n    static boolean isNumberFormat( final Class<?> clazz ) {\n        return Number.class.isAssignableFrom( clazz );\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> getNumberFormat( final Class<T> clazz ) {\n        XMLNumberFormat<?> result = _numberFormats.get( clazz );\n        if ( result == null ) {\n            result = createNumberFormat( clazz );\n            _numberFormats.put( clazz, result );\n        }\n        return (XMLNumberFormat<T>) result;\n    }\n    \n    @SuppressWarnings( \"unchecked\" )\n    static <T> XMLNumberFormat<T> createNumberFormat( final Class<T> clazz ) {\n        try {\n            for( final Constructor<?> constructor : clazz.getConstructors() ) {\n                final Class<?>[] parameterTypes = constructor.getParameterTypes();\n                if ( parameterTypes.length == 1 ) {\n                    if ( parameterTypes[0] == long.class ) {\n                        return new XMLNumberLongFormat<T>( (Constructor<T>) constructor );\n                    }\n                    if ( parameterTypes[0] == int.class ) {\n                        return new XMLNumberIntFormat<T>( (Constructor<T>) constructor );\n                    }\n                }\n            }\n        } catch ( final Exception e ) {\n            throw new RuntimeException( e );\n        }\n        throw new IllegalArgumentException( \"No suitable constructor found for class \" + clazz.getName() + \".\\n\" +\n                \"Available constructors: \" + clazz.getConstructors() );\n    }\n    \n    /**\n     * The base class for number formats.\n     * \n     * @param <T> the number type.\n     */\n    static abstract class XMLNumberFormat<T> extends XMLFormat<T> {\n        \n        private final Constructor<T> _constructor;\n\n        public XMLNumberFormat( final Constructor<T> constructor ) {\n            _constructor = constructor;\n        }\n        \n        /**\n         * Creates a new instance from the associated constructor. The provided class is ignored, just\n         * the provided {@link InputElement} is used to read the value which will be passed to the constructor.\n         * \n         * @param clazz can be null for this {@link XMLFormat} implementation\n         * @param xml the input element for the object to create.\n         * @return a new number instance.\n         */\n        @Override\n        public T newInstance( final Class<T> clazz, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return newInstanceFromAttribute( xml, \"value\" );\n        }\n\n        /**\n         * Creates a new instance from an already associated constructor. The provided {@link InputElement} is\n         * used to read the value from the attribute with the provided name. The value read will be passed to the\n         * constructor of the object to create.\n         * \n         * @param xml the input element for the object to create.\n         * @param name the attribute name to read the value from.\n         * @return a new number instance.\n         */\n        public T newInstanceFromAttribute( final javolution.xml.XMLFormat.InputElement xml, final String name )\n            throws XMLStreamException {\n            final Object value = getAttribute( name, xml );\n            try {\n                return _constructor.newInstance( value );\n            } catch ( final Exception e ) {\n                throw new XMLStreamException( e );\n            }\n        }\n        \n        protected abstract Object getAttribute( String name, InputElement xml ) throws XMLStreamException;\n\n        /**\n         * Does not perform anything, as the number is already created in {@link #newInstance(Class, javolution.xml.XMLFormat.InputElement)}.\n         * \n         * @param xml the input element\n         * @param the obj the created number object\n         */\n        @Override\n        public void read( final javolution.xml.XMLFormat.InputElement xml, final T obj ) throws XMLStreamException {\n            // nothing to do...\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write( final T obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException {\n            xml.setAttribute( \"value\", obj.toString() );\n        }\n        \n    }\n    \n    static class XMLNumberIntFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberIntFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0 );\n        }\n        \n    }\n    \n    static class XMLNumberLongFormat<T> extends XMLNumberFormat<T> {\n        \n        public XMLNumberLongFormat( final Constructor<T> constructor ) {\n            super( constructor );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException {\n            return xml.getAttribute( name, 0L );\n        }\n        \n    }\n\n}\n","lineNo":320}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.spy.memcached.MemcachedNode;\nimport net.spy.memcached.NodeLocator;\nimport net.spy.memcached.ops.Operation;\n\n/**\n * Locates nodes based on their id which is a part of the sessionId (key).\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SuffixBasedNodeLocator implements NodeLocator {\n    \n    // private final Logger _logger = Logger.getLogger( SuffixBasedNodeLocator.class.getName() );\n\n    private final List<MemcachedNode> _nodes;\n    private final NodeIdResolver _resolver;\n    private final Map<String, MemcachedNode> _nodesMap;\n    private final SessionIdFormat _sessionIdFormat;\n\n    /**\n     * Create a new {@link SuffixBasedNodeLocator}.\n     * @param nodes the nodes to select from.\n     * @param resolver used to resolve the node id for the address of a memcached node.\n     * @param sessionIdFormat used to extract the node id from the session id.\n     */\n    public SuffixBasedNodeLocator( List<MemcachedNode> nodes,\n            NodeIdResolver resolver,\n            SessionIdFormat sessionIdFormat ) {\n        _nodes = nodes;\n        _resolver = resolver;\n        \n        final Map<String,MemcachedNode> map = new HashMap<String, MemcachedNode>( nodes.size(), 1 );\n        for ( int i = 0; i < nodes.size(); i++ ) {\n            final MemcachedNode memcachedNode = nodes.get( i );\n            final String nodeId = resolver.getNodeId( (InetSocketAddress) memcachedNode.getSocketAddress() );\n            map.put( nodeId, memcachedNode );\n        }\n        _nodesMap = map;\n        \n        _sessionIdFormat = sessionIdFormat;\n    }\n\n    @Override\n    public Collection<MemcachedNode> getAll() {\n        return _nodesMap.values();\n    }\n\n    @Override\n    public MemcachedNode getPrimary( String key ) {\n        final MemcachedNode result = _nodesMap.get( getNodeId( key ) );\n        if ( result == null ) {\n            throw new IllegalArgumentException( \"No node found for key \" + key );\n        }\n        return result;\n    }\n\n    private String getNodeId( String key ) {\n        return _sessionIdFormat.extractMemcachedId( key );\n    }\n\n    @Override\n    public Iterator<MemcachedNode> getSequence( String key ) {\n        throw new NodeFailureException( \"The node \" + getNodeId( key ) + \" is not available.\" );\n    }\n\n    @Override\n    public NodeLocator getReadonlyCopy() {\n        final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>();\n        for ( MemcachedNode node : _nodes ) {\n            nodes.add( new MyMemcachedNodeROImpl( node ) );\n        }\n        return new SuffixBasedNodeLocator( nodes, _resolver, _sessionIdFormat );\n    }\n    \n    static class MyMemcachedNodeROImpl implements MemcachedNode {\n\n        private final MemcachedNode _root;\n\n        public MyMemcachedNodeROImpl(MemcachedNode node) {\n            _root = node;\n        }\n\n        @Override\n        public String toString() {\n            return _root.toString();\n        }\n\n        public void addOp(Operation op) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void connected() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void copyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fillWriteBuffer(boolean optimizeGets) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fixupOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getBytesRemainingToWrite() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketChannel getChannel() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public ByteBuffer getRbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getReconnectCount() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getSelectionOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SelectionKey getSk() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketAddress getSocketAddress() {\n            return _root.getSocketAddress();\n        }\n\n        public ByteBuffer getWbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean isActive() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void reconnecting() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void registerChannel(SocketChannel ch, SelectionKey selectionKey) {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setChannel(SocketChannel to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setSk(SelectionKey to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setupResend() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void transitionWriteItem() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int writeSome() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n\n        public Collection<Operation> destroyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.spy.memcached.MemcachedNode;\nimport net.spy.memcached.NodeLocator;\nimport net.spy.memcached.ops.Operation;\n\n/**\n * Locates nodes based on their id which is a part of the sessionId (key).\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SuffixBasedNodeLocator implements NodeLocator {\n    \n    // private final Logger _logger = Logger.getLogger( SuffixBasedNodeLocator.class.getName() );\n\n    private final List<MemcachedNode> _nodes;\n    private final NodeIdResolver _resolver;\n    private final Map<String, MemcachedNode> _nodesMap;\n    private final SessionIdFormat _sessionIdFormat;\n\n    /**\n     * Create a new {@link SuffixBasedNodeLocator}.\n     * @param nodes the nodes to select from.\n     * @param resolver used to resolve the node id for the address of a memcached node.\n     * @param sessionIdFormat used to extract the node id from the session id.\n     */\n    public SuffixBasedNodeLocator( List<MemcachedNode> nodes,\n            NodeIdResolver resolver,\n            SessionIdFormat sessionIdFormat ) {\n        _nodes = nodes;\n        _resolver = resolver;\n        \n        final Map<String,MemcachedNode> map = new HashMap<String, MemcachedNode>( nodes.size(), 1 );\n        for ( int i = 0; i < nodes.size(); i++ ) {\n            final MemcachedNode memcachedNode = nodes.get( i );\n            final String nodeId = resolver.getNodeId( (InetSocketAddress) memcachedNode.getSocketAddress() );\n            map.put( nodeId, memcachedNode );\n        }\n        _nodesMap = map;\n        \n        _sessionIdFormat = sessionIdFormat;\n    }\n\n    @Override\n    public Collection<MemcachedNode> getAll() {\n        return _nodesMap.values();\n    }\n\n    @Override\n    public MemcachedNode getPrimary( String key ) {\n        final MemcachedNode result = _nodesMap.get( getNodeId( key ) );\n        if ( result == null ) {\n            throw new IllegalArgumentException( \"No node found for key \" + key );\n        }\n        return result;\n    }\n\n    private String getNodeId( String key ) {\n        return _sessionIdFormat.extractMemcachedId( key );\n    }\n\n    @Override\n    public Iterator<MemcachedNode> getSequence( String key ) {\n        final String nodeId = getNodeId( key );\n        throw new NodeFailureException( \"The node \" + nodeId + \" is not available.\", nodeId );\n    }\n\n    @Override\n    public NodeLocator getReadonlyCopy() {\n        final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>();\n        for ( MemcachedNode node : _nodes ) {\n            nodes.add( new MyMemcachedNodeROImpl( node ) );\n        }\n        return new SuffixBasedNodeLocator( nodes, _resolver, _sessionIdFormat );\n    }\n    \n    static class MyMemcachedNodeROImpl implements MemcachedNode {\n\n        private final MemcachedNode _root;\n\n        public MyMemcachedNodeROImpl(MemcachedNode node) {\n            _root = node;\n        }\n\n        @Override\n        public String toString() {\n            return _root.toString();\n        }\n\n        public void addOp(Operation op) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void connected() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void copyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fillWriteBuffer(boolean optimizeGets) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fixupOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getBytesRemainingToWrite() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketChannel getChannel() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public ByteBuffer getRbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getReconnectCount() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getSelectionOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SelectionKey getSk() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketAddress getSocketAddress() {\n            return _root.getSocketAddress();\n        }\n\n        public ByteBuffer getWbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean isActive() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void reconnecting() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void registerChannel(SocketChannel ch, SelectionKey selectionKey) {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setChannel(SocketChannel to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setSk(SelectionKey to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setupResend() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void transitionWriteItem() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int writeSome() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n\n        public Collection<Operation> destroyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n}\n","lineNo":94}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.createDaemon;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.SimpleHttpConnectionManager;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.NodeIdResolver;\nimport de.javakaffee.web.msm.SessionIdFormat;\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing memcached failover.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedFailoverIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( MemcachedFailoverIntegrationTest.class );\n\n    private MemCacheDaemon _daemon1;\n    private MemCacheDaemon _daemon2;\n    private MemcachedClient _memcached;\n    \n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private SimpleHttpConnectionManager _connectionManager;\n\n    private HttpClient _httpClient;\n\n    private String _nodeId1;\n\n    private String _nodeId2;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n\n        final InetSocketAddress address1 = new InetSocketAddress( \"localhost\", 21211 );\n        _daemon1 = createDaemon( address1 );\n        _daemon1.start();\n        \n        final InetSocketAddress address2 = new InetSocketAddress( \"localhost\", 21212 );\n        _daemon2 = createDaemon( address2 );\n        _daemon2.start();\n        \n        _nodeId1 = \"n1\";\n        _nodeId2 = \"n2\";\n        try {\n            final String memcachedNodes = toString( _nodeId1, address1 ) + \" \" + toString( _nodeId2, address2 );\n            _tomcat1 = createCatalina( _portTomcat1, 10, memcachedNodes );\n            _tomcat1.start();\n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        _memcached = new MemcachedClient(\n                new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager(),\n                        NodeIdResolver.node( _nodeId1, address1 ).node( _nodeId2, address2 ).build(),\n                        new SessionIdFormat() ),\n                Arrays.asList( address1, address2 ) );\n        \n        _connectionManager = new SimpleHttpConnectionManager( true );\n        _httpClient = new HttpClient( _connectionManager );\n    }\n\n    private String toString( final String nodeId, final InetSocketAddress address ) {\n        return nodeId + \":\" + address.getHostName() + \":\" + address.getPort();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        if ( _daemon1.isRunning() ) _daemon1.stop();\n        if ( _daemon2.isRunning() ) _daemon2.stop();\n        _tomcat1.stop();\n        _connectionManager.shutdown();\n    }\n    \n    /**\n     * Tests, that relocated sessions are no longer available under the old/former\n     * session id.\n     * @throws IOException \n     * @throws HttpException \n     * \n     * @throws IOException \n     * @throws InterruptedException \n     */\n    @Test\n    public void testRelocateSession() throws HttpException, IOException {\n        final String sid1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sid1 );\n        final String firstNode = sid1.substring( sid1.lastIndexOf( '-' ) + 1 );\n        assertNotNull( \"No node id encoded in session id.\", sid1 );\n        \n        /* shutdown memcached node 1\n         */\n        _daemon1.stop();\n\n        final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 );\n        final String secondNode = sid2.substring( sid2.lastIndexOf( '-' ) + 1 );\n        final String expectedNode = firstNode.equals( _nodeId1 ) ? _nodeId2 : _nodeId1;\n\n        assertEquals( \"Unexpected nodeId\", expectedNode, secondNode );\n        \n        assertEquals( \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + expectedNode,\n                sid2 );\n        \n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.createDaemon;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.SimpleHttpConnectionManager;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.NodeIdResolver;\nimport de.javakaffee.web.msm.SessionIdFormat;\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing memcached failover.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedFailoverIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( MemcachedFailoverIntegrationTest.class );\n\n    private MemCacheDaemon _daemon1;\n    private MemCacheDaemon _daemon2;\n    private MemcachedClient _memcached;\n    \n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private SimpleHttpConnectionManager _connectionManager;\n\n    private HttpClient _httpClient;\n\n    private String _nodeId1;\n\n    private String _nodeId2;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n\n        final InetSocketAddress address1 = new InetSocketAddress( \"localhost\", 21211 );\n        _daemon1 = createDaemon( address1 );\n        _daemon1.start();\n        \n        final InetSocketAddress address2 = new InetSocketAddress( \"localhost\", 21212 );\n        _daemon2 = createDaemon( address2 );\n        _daemon2.start();\n        \n        _nodeId1 = \"n1\";\n        _nodeId2 = \"n2\";\n        try {\n            final String memcachedNodes = toString( _nodeId1, address1 ) + \" \" + toString( _nodeId2, address2 );\n            _tomcat1 = createCatalina( _portTomcat1, 10, memcachedNodes );\n            _tomcat1.start();\n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        _memcached = new MemcachedClient(\n                new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager(),\n                        NodeIdResolver.node( _nodeId1, address1 ).node( _nodeId2, address2 ).build(),\n                        new SessionIdFormat() ),\n                Arrays.asList( address1, address2 ) );\n        \n        _connectionManager = new SimpleHttpConnectionManager( true );\n        _httpClient = new HttpClient( _connectionManager );\n    }\n\n    private String toString( final String nodeId, final InetSocketAddress address ) {\n        return nodeId + \":\" + address.getHostName() + \":\" + address.getPort();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        if ( _daemon1.isRunning() ) _daemon1.stop();\n        if ( _daemon2.isRunning() ) _daemon2.stop();\n        _tomcat1.stop();\n        _connectionManager.shutdown();\n    }\n    \n    /**\n     * Tests, that relocated sessions are no longer available under the old/former\n     * session id.\n     * @throws IOException \n     * @throws HttpException \n     * \n     * @throws IOException \n     * @throws InterruptedException \n     */\n    @Test\n    public void testRelocateSession() throws HttpException, IOException {\n        final String sid1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sid1 );\n        final String firstNode = sid1.substring( sid1.lastIndexOf( '-' ) + 1 );\n        assertNotNull( \"No node id encoded in session id.\", sid1 );\n        \n        /* shutdown appropriate memcached node\n         */\n        final boolean node1 = firstNode.equals( _nodeId1 );\n        if ( node1 ) {\n            _daemon1.stop();\n        }\n        else {\n            _daemon2.stop();\n        }\n\n        final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 );\n        final String secondNode = sid2.substring( sid2.lastIndexOf( '-' ) + 1 );\n        final String expectedNode = node1 ? _nodeId2 : _nodeId1;\n\n        assertEquals( \"Unexpected nodeId.\", expectedNode, secondNode );\n        \n        assertEquals( \"Unexpected sessionId, sid1: \" + sid1 + \", sid2: \" + sid2,\n                sid1.substring( 0, sid1.indexOf( \"-\" ) + 1 ) + expectedNode,\n                sid2 );\n        \n    }\n\n}\n","lineNo":138}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport net.spy.memcached.MemcachedNode;\nimport net.spy.memcached.NodeLocator;\nimport net.spy.memcached.ops.Operation;\n\n/**\n * Locates nodes based on a suffix appended to the sessionId (key), which is\n * used as the index of the nodes of this locator.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SuffixBasedNodeLocator implements NodeLocator {\n    \n    private final Logger _logger = Logger.getLogger( SuffixBasedNodeLocator.class.getName() );\n\n    private final List<MemcachedNode> _nodes;\n    private final Map<String, MemcachedNode> _nodesMap;\n    private final SessionIdFormat _sessionIdFormat;\n\n    public SuffixBasedNodeLocator( List<MemcachedNode> nodes, SessionIdFormat sessionIdFormat ) {\n        _nodes = nodes;\n        \n        final Map<String,MemcachedNode> map = new HashMap<String, MemcachedNode>( nodes.size(), 1 );\n        for ( int i = 0; i < nodes.size(); i++ ) {\n            map.put( String.valueOf( i ), nodes.get( i ) );\n        }\n        _nodesMap = map;\n        \n        _sessionIdFormat = sessionIdFormat;\n    }\n\n    @Override\n    public Collection<MemcachedNode> getAll() {\n        return _nodesMap.values();\n    }\n\n    @Override\n    public MemcachedNode getPrimary( String key ) {\n        final MemcachedNode result = _nodesMap.get( getNodeId( key ) );\n        if ( result == null ) {\n            throw new IllegalArgumentException( \"No node found for key \" + key );\n        }\n        return result;\n    }\n\n    private String getNodeId( String key ) {\n        return _sessionIdFormat.extractMemcachedId( key );\n    }\n\n    @Override\n    public Iterator<MemcachedNode> getSequence( String key ) {\n        String targetIdx = getNextNodeId( key );\n        throw new RelocationException( \"The node \" + getNodeId( key ) + \" is not available, we could move to node \" + targetIdx, targetIdx );\n    }\n\n    protected String getNextNodeId( String key ) {\n        /* just for simplicity: we know that the node id is the index\n         * so we use this knowledge (insteaf of getting the node from the map\n         * and the index of the node etc.\n         */\n        String nodeId = getNodeId( key );\n        int idx = Integer.parseInt( nodeId );\n        int targetIdx;\n        if ( idx < 0 ) {\n            _logger.warning( \"Got a nodeId < 0, this is not valid\" );\n            // TODO: introduce some random here\n            targetIdx = 0;\n        }\n        else if ( idx >= _nodes.size() ) {\n            _logger.warning( \"Got a nodeId > number of nodes, this is not valid\" );\n            // TODO: introduce some random here\n            targetIdx = 0;\n        }\n        else if ( idx + 1 == _nodes.size() && idx != 0 ) {\n            /* we have the last node, so the next node is the first node\n             */\n            targetIdx = 0;\n        }\n        else {\n            targetIdx = idx + 1 % _nodes.size();\n            if ( targetIdx == idx ) {\n                /* we have only a single node - game over\n                 */\n                throw new UnavailableNodeException( \"The node \" + nodeId + \" is not available and there's no node for relocation left.\", nodeId );\n            }\n        }\n        return String.valueOf( targetIdx );\n    }\n\n    @Override\n    public NodeLocator getReadonlyCopy() {\n        final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>();\n        for ( MemcachedNode node : _nodes ) {\n            nodes.add( new MyMemcachedNodeROImpl( node ) );\n        }\n        return new SuffixBasedNodeLocator( nodes, _sessionIdFormat );\n    }\n    \n    static class MyMemcachedNodeROImpl implements MemcachedNode {\n\n        private final MemcachedNode _root;\n\n        public MyMemcachedNodeROImpl(MemcachedNode node) {\n            _root = node;\n        }\n\n        @Override\n        public String toString() {\n            return _root.toString();\n        }\n\n        public void addOp(Operation op) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void connected() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void copyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fillWriteBuffer(boolean optimizeGets) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fixupOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getBytesRemainingToWrite() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketChannel getChannel() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public ByteBuffer getRbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getReconnectCount() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getSelectionOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SelectionKey getSk() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketAddress getSocketAddress() {\n            return _root.getSocketAddress();\n        }\n\n        public ByteBuffer getWbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean isActive() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void reconnecting() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void registerChannel(SocketChannel ch, SelectionKey selectionKey) {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setChannel(SocketChannel to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setSk(SelectionKey to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setupResend() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void transitionWriteItem() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int writeSome() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n\n        public Collection<Operation> destroyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.spy.memcached.MemcachedNode;\nimport net.spy.memcached.NodeLocator;\nimport net.spy.memcached.ops.Operation;\n\n/**\n * Locates nodes based on their id which is a part of the sessionId (key).\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\nclass SuffixBasedNodeLocator implements NodeLocator {\n    \n    // private final Logger _logger = Logger.getLogger( SuffixBasedNodeLocator.class.getName() );\n\n    private final List<MemcachedNode> _nodes;\n    private final NodeIdResolver _resolver;\n    private final Map<String, MemcachedNode> _nodesMap;\n    private final SessionIdFormat _sessionIdFormat;\n\n    /**\n     * Create a new {@link SuffixBasedNodeLocator}.\n     * @param nodes the nodes to select from.\n     * @param resolver used to resolve the node id for the address of a memcached node.\n     * @param sessionIdFormat used to extract the node id from the session id.\n     */\n    public SuffixBasedNodeLocator( List<MemcachedNode> nodes,\n            NodeIdResolver resolver,\n            SessionIdFormat sessionIdFormat ) {\n        _nodes = nodes;\n        _resolver = resolver;\n        \n        final Map<String,MemcachedNode> map = new HashMap<String, MemcachedNode>( nodes.size(), 1 );\n        for ( int i = 0; i < nodes.size(); i++ ) {\n            final MemcachedNode memcachedNode = nodes.get( i );\n            final String nodeId = resolver.getNodeId( (InetSocketAddress) memcachedNode.getSocketAddress() );\n            map.put( nodeId, memcachedNode );\n        }\n        _nodesMap = map;\n        \n        _sessionIdFormat = sessionIdFormat;\n    }\n\n    @Override\n    public Collection<MemcachedNode> getAll() {\n        return _nodesMap.values();\n    }\n\n    @Override\n    public MemcachedNode getPrimary( String key ) {\n        final MemcachedNode result = _nodesMap.get( getNodeId( key ) );\n        if ( result == null ) {\n            throw new IllegalArgumentException( \"No node found for key \" + key );\n        }\n        return result;\n    }\n\n    private String getNodeId( String key ) {\n        return _sessionIdFormat.extractMemcachedId( key );\n    }\n\n    @Override\n    public Iterator<MemcachedNode> getSequence( String key ) {\n        throw new NodeFailureException( \"The node \" + getNodeId( key ) + \" is not available.\" );\n    }\n\n    @Override\n    public NodeLocator getReadonlyCopy() {\n        final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>();\n        for ( MemcachedNode node : _nodes ) {\n            nodes.add( new MyMemcachedNodeROImpl( node ) );\n        }\n        return new SuffixBasedNodeLocator( nodes, _resolver, _sessionIdFormat );\n    }\n    \n    static class MyMemcachedNodeROImpl implements MemcachedNode {\n\n        private final MemcachedNode _root;\n\n        public MyMemcachedNodeROImpl(MemcachedNode node) {\n            _root = node;\n        }\n\n        @Override\n        public String toString() {\n            return _root.toString();\n        }\n\n        public void addOp(Operation op) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void connected() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void copyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fillWriteBuffer(boolean optimizeGets) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void fixupOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getBytesRemainingToWrite() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketChannel getChannel() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation getCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public ByteBuffer getRbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getReconnectCount() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int getSelectionOps() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SelectionKey getSk() {\n            throw new UnsupportedOperationException();\n        }\n\n        public SocketAddress getSocketAddress() {\n            return _root.getSocketAddress();\n        }\n\n        public ByteBuffer getWbuf() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean hasWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public boolean isActive() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void reconnecting() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void registerChannel(SocketChannel ch, SelectionKey selectionKey) {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentReadOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Operation removeCurrentWriteOp() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setChannel(SocketChannel to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setSk(SelectionKey to) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void setupResend() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void transitionWriteItem() {\n            throw new UnsupportedOperationException();\n        }\n\n        public int writeSome() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n\n        public Collection<Operation> destroyInputQueue() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n}\n","lineNo":65}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport junit.framework.Assert;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.thimbleware.jmemcached.Cache;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.LRUCacheStorageDelegate;\n\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing tomcat failover (tomcats failing).\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class TomcatFailoverIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( TomcatFailoverIntegrationTest.class );\n\n    private MemCacheDaemon _daemon;\n    private MemcachedClient _client;\n    \n    private Embedded _tomcat1;\n    private Embedded _tomcat2;\n\n    private int _portTomcat1;\n    private int _portTomcat2;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n        _portTomcat2 = 8889;\n        \n        final int port = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", port );\n        _daemon = createDaemon( address );\n        _daemon.start(); \n        \n        try {\n            final String memcachedNodes = \"localhost:\" + port;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes );\n            _tomcat1.start();\n    \n            _tomcat2 = createCatalina( _portTomcat2, memcachedNodes );\n            _tomcat2.start();\n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        _client = new MemcachedClient(\n                //new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager() ),\n                Arrays.asList( address ) );\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        _daemon.stop();\n        _tomcat1.stop();\n        _tomcat2.stop();\n    }\n    \n    @Test\n    public void testConnectDaemon() throws IOException, InterruptedException {\n        _client.set( \"foo\", 3600, \"bar\" );\n        Assert.assertEquals( \"bar\", _client.get( \"foo\" ) );\n    }\n    \n//    /**\n//     * Tests that when two tomcats are running and one tomcat fails the other tomcat can\n//     * take over the session.\n//     * @throws IOException\n//     * @throws InterruptedException\n//     */\n//    @Test\n//    public void testTomcatFailover() throws IOException, InterruptedException {\n//        final SimpleHttpConnectionManager connectionManager = new SimpleHttpConnectionManager( true );\n//        try {\n//            final HttpClient client = new HttpClient( connectionManager );\n//    \n//            final String sessionId1 = makeRequest( client, _portTomcat1, null );\n//            \n//            Thread.sleep( 200 );\n//            \n//            Assert.assertNotNull( _client.get( sessionId1 ) );\n//            \n//            final String sessionId2 = makeRequest( client, _portTomcat2, sessionId1 );\n//            \n//            Assert.assertEquals( sessionId1, sessionId2 );\n//        } finally {\n//            connectionManager.shutdown();\n//        }\n//        \n//    }\n    \n    private MemCacheDaemon createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon daemon = new MemCacheDaemon();\n        final LRUCacheStorageDelegate cacheStorage = new LRUCacheStorageDelegate(1000, 1024*1024, 1024000);\n        daemon.setCache(new Cache(cacheStorage));\n        daemon.setAddr( address );\n        daemon.setVerbose(true);\n        return daemon;\n    }\n\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.createDaemon;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport junit.framework.Assert;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.SimpleHttpConnectionManager;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.thimbleware.jmemcached.MemCacheDaemon;\n\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing tomcat failover (tomcats failing).\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class TomcatFailoverIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( TomcatFailoverIntegrationTest.class );\n\n    private MemCacheDaemon _daemon;\n    private MemcachedClient _client;\n    \n    private Embedded _tomcat1;\n    private Embedded _tomcat2;\n\n    private int _portTomcat1;\n    private int _portTomcat2;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n        _portTomcat2 = 8889;\n        \n        final int port = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", port );\n        _daemon = createDaemon( address );\n        _daemon.start(); \n        \n        try {\n            final String memcachedNodes = \"localhost:\" + port;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes );\n            _tomcat1.start();\n    \n            _tomcat2 = createCatalina( _portTomcat2, memcachedNodes );\n            _tomcat2.start();\n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        _client = new MemcachedClient(\n                new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager() ),\n                Arrays.asList( address ) );\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        _daemon.stop();\n        _tomcat1.stop();\n        _tomcat2.stop();\n    }\n    \n    @Test\n    public void testConnectDaemon() throws IOException, InterruptedException {\n        final Object value = \"bar\";\n        _client.set( \"foo.0\", 3600, value );\n        Assert.assertEquals( value, _client.get( \"foo.0\" ) );\n    }\n    \n    /**\n     * Tests that when two tomcats are running and one tomcat fails the other tomcat can\n     * take over the session.\n     * @throws IOException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testTomcatFailover() throws IOException, InterruptedException {\n        final SimpleHttpConnectionManager connectionManager = new SimpleHttpConnectionManager( true );\n        try {\n            final HttpClient client = new HttpClient( connectionManager );\n    \n            final String sessionId1 = makeRequest( client, _portTomcat1, null );\n            \n            Thread.sleep( 10 );\n            \n            final Object session = _client.get( sessionId1 );\n            Assert.assertNotNull( session );\n            \n            final String sessionId2 = makeRequest( client, _portTomcat2, sessionId1 );\n            \n            Assert.assertEquals( sessionId1, sessionId2 );\n            \n            Thread.sleep( 10 );\n            \n        } finally {\n            connectionManager.shutdown();\n        }\n        \n    }\n\n\n}\n","lineNo":101}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertNull;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.SimpleHttpConnectionManager;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.jgroups.blocks.MemcachedConnector;\nimport org.jgroups.blocks.PartitionedHashMap;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport de.javakaffee.web.msm.MemcachedBackupSessionManager;\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing basic session manager functionality.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedSessionManagerIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( MemcachedSessionManagerIntegrationTest.class );\n    \n    private MemcachedClient _memcached;\n    private PartitionedHashMap<String,byte[]> _map;\n    private MemcachedConnector _connector;\n    \n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private SimpleHttpConnectionManager _connectionManager;\n\n    private HttpClient _httpClient;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n        \n        final int port = 21211;\n\n        _map = new PartitionedHashMap<String,byte[]>( \"tcp.xml\", getClass().getSimpleName() );\n        _connector = new MemcachedConnector( InetAddress.getLocalHost(), port, _map);\n        _connector.setThreadPoolCoreThreads(1);\n        _connector.setThreadPoolMaxThreads(5);\n        _map.start();\n        _connector.start();\n        \n        try {\n        final String memcachedNodes = \"localhost:\" + port;\n        _tomcat1 = createCatalina( _portTomcat1, memcachedNodes );\n        _tomcat1.start();\n        \n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        _memcached = new MemcachedClient(\n                new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager() ),\n                Arrays.asList( new InetSocketAddress( \"localhost\", port ) ) );\n        \n        _connectionManager = new SimpleHttpConnectionManager( true );\n        _httpClient = new HttpClient( _connectionManager );\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        _connector.stop();\n        _map.stop();\n        _tomcat1.stop();\n        _connectionManager.shutdown();\n    }\n    \n    @Test\n    public void testSessionAvailableInMemcached() throws IOException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sessionId1 );\n        Thread.sleep( 50 );\n        assertNotNull( \"Session not available in memcached.\", _memcached.get( sessionId1 ) );\n    }\n    \n    @Test\n    public void testExpiredSessionRemovedFromMemcached() throws IOException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sessionId1 );\n        \n        /* wait some time, as processExpires runs every second and the maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n        \n        assertNull( \"Expired sesion still existing in memcached\", _memcached.get( sessionId1 ) );\n    }\n    \n    @Test\n    public void testInvalidSessionNotFound() throws IOException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sessionId1 );\n        \n        /* wait some time, as processExpires runs every second and the maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( \"Expired session returned\", sessionId1, sessionId2 );\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertNull;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.Manager;\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.SimpleHttpConnectionManager;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.thimbleware.jmemcached.Cache;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.LRUCacheStorageDelegate;\n\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing basic session manager functionality.\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class MemcachedSessionManagerIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( MemcachedSessionManagerIntegrationTest.class );\n\n    private MemCacheDaemon _daemon;\n    private MemcachedClient _memcached;\n    \n    private Embedded _tomcat1;\n\n    private int _portTomcat1;\n\n    private SimpleHttpConnectionManager _connectionManager;\n\n    private HttpClient _httpClient;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n        \n        final int port = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", port );\n        _daemon = createDaemon( address );\n        _daemon.start(); \n        \n        try {\n            final String memcachedNodes = \"localhost:\" + port;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes );\n            _tomcat1.start();\n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        final Manager manager = _tomcat1.getContainer().getManager();\n//        if ( manager == null ) {\n//            throw new IllegalStateException( \"The manager is not existing!\" );\n//        }\n        _memcached = new MemcachedClient(\n                new SuffixLocatorConnectionFactory( manager ),\n                Arrays.asList( new InetSocketAddress( \"localhost\", port ) ) );\n        \n        _connectionManager = new SimpleHttpConnectionManager( true );\n        _httpClient = new HttpClient( _connectionManager );\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        _daemon.stop();\n        _tomcat1.stop();\n        _connectionManager.shutdown();\n    }\n    \n    @Test\n    public void testSessionAvailableInMemcached() throws IOException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sessionId1 );\n        Thread.sleep( 50 );\n        assertNotNull( \"Session not available in memcached.\", _memcached.get( sessionId1 ) );\n    }\n    \n    @Test\n    public void testExpiredSessionRemovedFromMemcached() throws IOException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sessionId1 );\n        \n        /* wait some time, as processExpires runs every second and the maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n        \n        assertNull( \"Expired sesion still existing in memcached\", _memcached.get( sessionId1 ) );\n    }\n    \n    @Test\n    public void testInvalidSessionNotFound() throws IOException, InterruptedException {\n        final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null );\n        assertNotNull( \"No session created.\", sessionId1 );\n        \n        /* wait some time, as processExpires runs every second and the maxInactiveTime is set to 1 sec...\n         */\n        Thread.sleep( 2100 );\n\n        final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 );\n        assertNotSame( \"Expired session returned\", sessionId1, sessionId2 );\n    }\n    \n    private MemCacheDaemon createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon daemon = new MemCacheDaemon();\n        final LRUCacheStorageDelegate cacheStorage = new LRUCacheStorageDelegate(1000, 1024*1024, 1024000);\n        daemon.setCache(new Cache(cacheStorage));\n        daemon.setAddr( address );\n        daemon.setVerbose(true);\n        return daemon;\n    }\n\n}\n","lineNo":89}
{"Smelly Sample":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\nimport static de.javakaffee.web.msm.integration.TestUtils.makeRequest;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport junit.framework.Assert;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.SimpleHttpConnectionManager;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.jgroups.blocks.MemcachedConnector;\nimport org.jgroups.blocks.PartitionedHashMap;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing tomcat failover (tomcats failing).\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class TomcatFailoverIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( TomcatFailoverIntegrationTest.class );\n    \n    private MemcachedClient _client;\n    private PartitionedHashMap<String,byte[]> _map;\n    private MemcachedConnector _connector;\n    \n    private Embedded _tomcat1;\n    private Embedded _tomcat2;\n\n    private int _portTomcat1;\n    private int _portTomcat2;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n        _portTomcat2 = 8889;\n        \n        final int port = 21211;\n\n        _map = new PartitionedHashMap<String,byte[]>( \"tcp.xml\", getClass().getSimpleName() );\n        _connector = new MemcachedConnector( InetAddress.getLocalHost(), port, _map);\n        _connector.setThreadPoolCoreThreads(1);\n        _connector.setThreadPoolMaxThreads(5);\n        _map.start();\n        _connector.start();\n        \n        try {\n        final String memcachedNodes = \"localhost:\" + port;\n        _tomcat1 = createCatalina( _portTomcat1, memcachedNodes );\n        _tomcat1.start();\n\n        _tomcat2 = createCatalina( _portTomcat2, memcachedNodes );\n        _tomcat2.start();\n        \n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        _client = new MemcachedClient(\n                new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager() ),\n                Arrays.asList( new InetSocketAddress( \"localhost\", port ) ) );\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        _connector.stop();\n        _map.stop();\n        _tomcat1.stop();\n        _tomcat2.stop();\n    }\n    \n//    @Test\n//    public void testConnectDaemon() throws IOException, InterruptedException {\n//        _client.set( \"foo\", 3600000, \"bar\" );\n//        Assert.assertEquals( \"bar\", _client.get( \"foo\" ) );\n//    }\n    \n    /**\n     * Tests that when two tomcats are running and one tomcat fails the other tomcat can\n     * take over the session.\n     * @throws IOException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testTomcatFailover() throws IOException, InterruptedException {\n        final SimpleHttpConnectionManager connectionManager = new SimpleHttpConnectionManager( true );\n        try {\n            final HttpClient client = new HttpClient( connectionManager );\n    \n            final String sessionId1 = makeRequest( client, _portTomcat1, null );\n            \n            Thread.sleep( 200 );\n            \n            Assert.assertNotNull( _client.get( sessionId1 ) );\n            \n            final String sessionId2 = makeRequest( client, _portTomcat2, sessionId1 );\n            \n            Assert.assertEquals( sessionId1, sessionId2 );\n        } finally {\n            connectionManager.shutdown();\n        }\n        \n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Martin Grotzke\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage de.javakaffee.web.msm.integration;\n\nimport static de.javakaffee.web.msm.integration.TestUtils.createCatalina;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\n\nimport junit.framework.Assert;\nimport net.spy.memcached.MemcachedClient;\n\nimport org.apache.catalina.startup.Embedded;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.thimbleware.jmemcached.Cache;\nimport com.thimbleware.jmemcached.MemCacheDaemon;\nimport com.thimbleware.jmemcached.storage.hash.LRUCacheStorageDelegate;\n\nimport de.javakaffee.web.msm.SuffixLocatorConnectionFactory;\n\n/**\n * Integration test testing tomcat failover (tomcats failing).\n * \n * @author <a href=\"mailto:martin.grotzke@javakaffee.de\">Martin Grotzke<\/a>\n * @version $Id$\n */\npublic class TomcatFailoverIntegrationTest {\n    \n    private static final Log LOG = LogFactory\n            .getLog( TomcatFailoverIntegrationTest.class );\n\n    private MemCacheDaemon _daemon;\n    private MemcachedClient _client;\n    \n    private Embedded _tomcat1;\n    private Embedded _tomcat2;\n\n    private int _portTomcat1;\n    private int _portTomcat2;\n\n    @Before\n    public void setUp() throws Throwable {\n\n        _portTomcat1 = 8888;\n        _portTomcat2 = 8889;\n        \n        final int port = 21211;\n\n        final InetSocketAddress address = new InetSocketAddress( \"localhost\", port );\n        _daemon = createDaemon( address );\n        _daemon.start(); \n        \n        try {\n            final String memcachedNodes = \"localhost:\" + port;\n            _tomcat1 = createCatalina( _portTomcat1, memcachedNodes );\n            _tomcat1.start();\n    \n            _tomcat2 = createCatalina( _portTomcat2, memcachedNodes );\n            _tomcat2.start();\n        } catch( Throwable e ) {\n            LOG.error( \"could not start tomcat.\", e );\n            throw e;\n        }\n        \n        _client = new MemcachedClient(\n                //new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager() ),\n                Arrays.asList( address ) );\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        _daemon.stop();\n        _tomcat1.stop();\n        _tomcat2.stop();\n    }\n    \n    @Test\n    public void testConnectDaemon() throws IOException, InterruptedException {\n        _client.set( \"foo\", 3600, \"bar\" );\n        Assert.assertEquals( \"bar\", _client.get( \"foo\" ) );\n    }\n    \n//    /**\n//     * Tests that when two tomcats are running and one tomcat fails the other tomcat can\n//     * take over the session.\n//     * @throws IOException\n//     * @throws InterruptedException\n//     */\n//    @Test\n//    public void testTomcatFailover() throws IOException, InterruptedException {\n//        final SimpleHttpConnectionManager connectionManager = new SimpleHttpConnectionManager( true );\n//        try {\n//            final HttpClient client = new HttpClient( connectionManager );\n//    \n//            final String sessionId1 = makeRequest( client, _portTomcat1, null );\n//            \n//            Thread.sleep( 200 );\n//            \n//            Assert.assertNotNull( _client.get( sessionId1 ) );\n//            \n//            final String sessionId2 = makeRequest( client, _portTomcat2, sessionId1 );\n//            \n//            Assert.assertEquals( sessionId1, sessionId2 );\n//        } finally {\n//            connectionManager.shutdown();\n//        }\n//        \n//    }\n    \n    private MemCacheDaemon createDaemon( final InetSocketAddress address ) throws IOException {\n        final MemCacheDaemon daemon = new MemCacheDaemon();\n        final LRUCacheStorageDelegate cacheStorage = new LRUCacheStorageDelegate(1000, 1024*1024, 1024000);\n        daemon.setCache(new Cache(cacheStorage));\n        daemon.setAddr( address );\n        daemon.setVerbose(true);\n        return daemon;\n    }\n\n\n}\n","lineNo":69}
