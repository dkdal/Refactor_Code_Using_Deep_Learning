{"Smelly Sample":"/*\n * Copyright (C) 2009, 2010 Jayway AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.simpligility.maven.plugins.android;\n\nimport com.android.SdkConstants;\nimport com.android.annotations.Nullable;\nimport com.android.sdklib.AndroidTargetHash;\nimport com.android.sdklib.AndroidVersion;\nimport com.android.sdklib.BuildToolInfo;\nimport com.android.sdklib.IAndroidTarget;\nimport com.android.sdklib.SdkManager;\nimport com.android.sdklib.repository.FullRevision;\nimport com.android.utils.NullLogger;\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\nimport org.codehaus.plexus.interpolation.os.Os;\n\n/**\n * Represents an Android SDK.\n * \n * @author hugo.josefson@jayway.com\n * @author Manfred Moser <manfred@simpligility.com>\n */\npublic class AndroidSdk\n{\n    /**\n     * the default API level for the SDK used as a fall back if none is supplied, \n     * should ideally point to the latest available version\n     */\n    private static final String DEFAULT_ANDROID_API_LEVEL = \"22\";\n    /**\n     * property file in each platform folder with details about platform.\n     */\n    private static final String SOURCE_PROPERTIES_FILENAME = \"source.properties\";\n    /**\n     * property name for the sdk tools revision in sdk/tools/lib source.properties\n     */\n    private static final String SDK_TOOLS_REVISION_PROPERTY = \"Pkg.Revision\";\n\n    /**\n     * folder name for the sdk sub folder that contains the different platform versions.\n     */\n    private static final String PLATFORMS_FOLDER_NAME = \"platforms\";\n\n    private static final String PARAMETER_MESSAGE = \"Please provide a proper Android SDK directory path as \"\n            + \"configuration parameter <sdk><path>...<\/path><\/sdk> in the plugin <configuration/>. As an alternative,\"\n            + \" you may add the parameter to commandline: -Dandroid.sdk.path=... or set environment variable \"\n            + AbstractAndroidMojo.ENV_ANDROID_HOME + \".\";\n\n    private final File sdkPath;\n    private File platformToolsPath;\n    private File toolsPath;\n\n    private final IAndroidTarget androidTarget;\n    private SdkManager sdkManager;\n    private int sdkMajorVersion;\n    private String buildToolsVersion;\n\n    public AndroidSdk( File sdkPath, String apiLevel )\n    {\n        this( sdkPath, apiLevel, null );\n    }\n\n    public AndroidSdk( File sdkPath, String apiLevel, @Nullable String buildToolsVersion )\n    {\n        this.sdkPath = sdkPath;\n        this.buildToolsVersion = buildToolsVersion;\n\n        if ( sdkPath != null )\n        {\n            sdkManager = SdkManager.createManager( sdkPath.getPath(), new NullLogger() );\n            platformToolsPath = new File( sdkPath, SdkConstants.FD_PLATFORM_TOOLS );\n            toolsPath = new File( sdkPath, SdkConstants.FD_TOOLS );\n\n            if ( sdkManager == null )\n            {\n                throw invalidSdkException( sdkPath, apiLevel );\n            }\n        }\n        loadSDKToolsMajorVersion();\n\n        if ( apiLevel == null )\n        {\n            apiLevel = DEFAULT_ANDROID_API_LEVEL;\n        }\n\n        androidTarget = findPlatformByApiLevel( apiLevel );\n        if ( androidTarget == null )\n        {\n            throw invalidSdkException( sdkPath, apiLevel );\n        }\n    }\n\n    private InvalidSdkException invalidSdkException( File sdkPath, String platformOrApiLevel )\n    {\n        throw new InvalidSdkException( \"Invalid SDK: Platform/API level \" + platformOrApiLevel\n                + \" not available. This command should give you all you need:\\n\" + sdkPath.getAbsolutePath()\n                + File.separator + \"tools\" + File.separator + \"android update sdk --no-ui --obsolete --force\" );\n    }\n\n    private IAndroidTarget findPlatformByApiLevel( String apiLevel )\n    {\n        // try find by api level first\n        AndroidVersion version = null;\n        try\n        {\n            version = new AndroidVersion( apiLevel );\n            String hashString = AndroidTargetHash.getPlatformHashString( version );\n            IAndroidTarget target = sdkManager.getTargetFromHashString( hashString );\n\n            if ( target != null )\n            {\n                return target;\n            }\n        }\n        catch ( AndroidVersion.AndroidVersionException ignore )\n        {\n            throw new InvalidSdkException( \"Error AndroidVersion: \" + ignore.getMessage() );\n        }\n\n        // fallback to searching for platform on standard Android platforms (isPlatform() is true)\n        for ( IAndroidTarget t: sdkManager.getTargets() )\n        {\n            if ( t.isPlatform() && t.getVersionName().equals( apiLevel ) )\n            {\n                return t;\n            }\n        }\n        return null;\n    }\n\n    private void assertPathIsDirectory( final File path )\n    {\n        if ( path == null )\n        {\n            throw new InvalidSdkException( PARAMETER_MESSAGE );\n        }\n        if ( !path.isDirectory() )\n        {\n            throw new InvalidSdkException( \"Path \\\"\" + path + \"\\\" is not a directory. \" + PARAMETER_MESSAGE );\n        }\n    }\n\n    /**\n     * Get the aapt tool path.\n     *\n     * @return\n     */\n    public String getAaptPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.AAPT );\n    }\n\n    /**\n     * Get the aild tool path\n     * @return\n     */\n    public String getAidlPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.AIDL );\n    }\n\n    /**\n     * Get the path for dx.jar\n     * @return\n     */\n    public String getDxJarPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.DX_JAR );\n    }\n\n    /**\n     * Get the android debug tool path (adb).\n     *\n     * @return\n     */\n    public String getAdbPath()\n    {\n        return getPathForPlatformTool( SdkConstants.FN_ADB );\n    }\n\n    /**\n     * Get the android zipalign path.\n     *\n     * @return\n     */\n    public String getZipalignPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.ZIP_ALIGN );\n    }\n\n    /**\n     * Get the android lint path.\n     * \n     * @return\n     */\n    public String getLintPath()\n    {\n        return getPathForTool( \"lint\" + ext( \".bat\", \"\" ) );\n    }\n\n    /**\n     * Get the android monkey runner path.\n     * \n     * @return\n     */\n    public String getMonkeyRunnerPath()\n    {\n        return getPathForTool( \"monkeyrunner\" + ext( \".bat\", \"\" ) );\n    }\n\n    /**\n     * Get the apkbuilder path.\n     *\n     * @return\n     */\n    public String getApkBuilderPath()\n    {\n        return getPathForTool( \"apkbuilder\" + ext( \".bat\", \"\" ) );\n    }\n\n    /**\n     * Get the android tool path.\n     *\n     * @return\n     */\n    public String getAndroidPath()\n    {\n        return getPathForTool( SdkConstants.androidCmdName() );\n    }\n\n    /**\n     * Get the path to the tools directory.\n     * @return\n     */\n    public File getToolsPath()\n    {\n        return toolsPath;\n    }\n\n    private String getPathForBuildTool( BuildToolInfo.PathId pathId )\n    {\n        return getBuildToolInfo().getPath( pathId );\n    }\n    \n    private BuildToolInfo getBuildToolInfo()\n    {\n        if ( buildToolsVersion != null && !buildToolsVersion.equals( \"\" ) )\n        {\n            return sdkManager.getBuildTool( FullRevision.parseRevision( buildToolsVersion ) );\n        }\n\n        if ( androidTarget != null )\n        {\n            BuildToolInfo buildToolInfo = androidTarget.getBuildToolInfo();\n            if ( buildToolInfo != null ) \n            {\n                return buildToolInfo;\n            }\n        }\n        // if no valid target is defined, or it has no build tools installed, try to use the latest\n        BuildToolInfo latestBuildToolInfo = sdkManager.getLatestBuildTool();\n        if ( latestBuildToolInfo == null )\n        {\n            throw new InvalidSdkException( \"Invalid SDK: Build-tools not found. Check the content of '\" \n                + sdkPath.getAbsolutePath() + File.separator + \"build-tools', or run '\" \n                + sdkPath.getAbsolutePath() + File.separator + \"tools\" + File.separator \n                + \"android sdk' to install them\" );\n        }\n        return latestBuildToolInfo;\n    }\n\n    private String getPathForPlatformTool( String tool )\n    {\n        return new File( platformToolsPath, tool ).getAbsolutePath();\n    }\n\n    private String getPathForTool( String tool )\n    {\n        return new File( toolsPath, tool ).getAbsolutePath();\n    }\n\n    private static String ext( String windowsExtension, String nonWindowsExtension )\n    {\n        if ( SdkConstants.currentPlatform() == SdkConstants.PLATFORM_WINDOWS )\n        {\n            return windowsExtension;\n        }\n        else\n        {\n            return nonWindowsExtension;\n        }\n    }\n\n    /**\n     * Returns the complete path for <code>framework.aidl<\/code>, based on this SDK.\n     * \n     * @return the complete path as a <code>String<\/code>, including the filename.\n     */\n    public String getPathForFrameworkAidl()\n    {\n        return androidTarget.getPath( IAndroidTarget.ANDROID_AIDL );\n    }\n\n    /**\n     * Returns the mainDexClasses script file, based on this SDK and OS.\n     * Assumes that the script is in build-tools\\VERSION\\ directory.\n     * \n     * <b>NOTE<\/b>: This file is found in version 21.1.1+ of build-tools.  \n     * \n     * @return mainDexClasses file\n     * @throws MojoExecutionException when the file is not found \n     */\n    public File getMainDexClasses() throws MojoExecutionException \n    {\n        final File location = getBuildToolInfo().getLocation();\n        String mainDexClassesScript = \"mainDexClasses\";   \n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) ) \n        {\n            mainDexClassesScript += \".bat\";   \n        }               \n        File mainDexClasses = new File( location, mainDexClassesScript );\n        if ( !mainDexClasses.exists() ) \n        {\n            throw new MojoExecutionException( \"No \" + mainDexClassesScript + \" found in \" + location );\n        }\n        return mainDexClasses;\n    }\n\n    /**\n     * Resolves the android.jar from this SDK.\n     * \n     * @return a <code>File<\/code> pointing to the android.jar file.\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     *             if the file can not be resolved.\n     */\n    public File getAndroidJar() throws MojoExecutionException\n    {\n        final String androidJarPath = androidTarget.getPath( IAndroidTarget.ANDROID_JAR );\n        if ( androidJarPath == null )\n        {\n            throw new MojoExecutionException( \"No AndroidJar found for \" + androidTarget );\n        }\n        return new File ( androidJarPath );\n    }\n  \n    /**\n     * Resolves the path for this SDK.\n     * \n     * @return a <code>File<\/code> pointing to the SDk Directory.\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     *             if the file can not be resolved.\n     */\n    public File getSdkPath() throws MojoExecutionException\n    {\n        if ( sdkPath.exists() )\n        {\n            return sdkPath;\n        }\n        throw new MojoExecutionException( \"Can't find the SDK directory : \" + sdkPath.getAbsolutePath() );\n    }\n\n    /**\n     * This method returns the previously specified version. However, if none have been specified it returns the\n     * \"latest\" version.\n     */\n    public File getPlatform()\n    {\n        assertPathIsDirectory( sdkPath );\n\n        final File platformsDirectory = new File( sdkPath, PLATFORMS_FOLDER_NAME );\n        assertPathIsDirectory( platformsDirectory );\n\n        final File platformDirectory;\n        if ( androidTarget == null )\n        {\n            IAndroidTarget latestTarget = null;\n            for ( IAndroidTarget target:  sdkManager.getTargets() )\n            {\n                if ( target.isPlatform() )\n                {\n                    if ( latestTarget == null\n                            || target.getVersion().getApiLevel() > latestTarget.getVersion().getApiLevel() )\n                    {\n                        latestTarget = target;\n                    }\n                }\n            }\n            platformDirectory = new File ( latestTarget.getLocation() );\n        }\n        else\n        {\n            platformDirectory = new File( androidTarget.getLocation() );\n        }\n        assertPathIsDirectory( platformDirectory );\n        return platformDirectory;\n    }\n\n    /**\n     * Loads the SDK Tools version\n     */\n    private void loadSDKToolsMajorVersion()\n    {\n        File propFile = new File( sdkPath, \"tools/\" + SOURCE_PROPERTIES_FILENAME );\n        Properties properties = new Properties();\n        try\n        {\n            properties.load( new FileInputStream( propFile ) );\n        }\n        catch ( IOException e )\n        {\n            throw new InvalidSdkException( \"Error reading \" + propFile.getAbsoluteFile() );\n        }\n\n        if ( properties.containsKey( SDK_TOOLS_REVISION_PROPERTY ) )\n        {\n            try\n            {\n                String versionString = properties.getProperty( SDK_TOOLS_REVISION_PROPERTY );\n                String majorVersion;\n                if ( versionString.matches( \".*[\\\\.| ].*\" ) )\n                {\n                    String[] versions = versionString.split( \"[\\\\.| ]\" );\n                    majorVersion = versions[ 0 ];\n                }\n                else\n                {\n                    majorVersion = versionString;\n                }\n                sdkMajorVersion = Integer.parseInt( majorVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new InvalidSdkException( \"Error - The property '\" + SDK_TOOLS_REVISION_PROPERTY\n                        + \"' in the SDK source.properties file  number is not an Integer: \"\n                        + properties.getProperty( SDK_TOOLS_REVISION_PROPERTY ) );\n            }\n        }\n    }\n\n    /**\n     * Returns the version of the SDK Tools.\n     * \n     * @return\n     */\n    public int getSdkMajorVersion()\n    {\n        return sdkMajorVersion;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009, 2010 Jayway AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.simpligility.maven.plugins.android;\n\nimport com.android.SdkConstants;\nimport com.android.annotations.Nullable;\nimport com.android.sdklib.AndroidTargetHash;\nimport com.android.sdklib.AndroidVersion;\nimport com.android.sdklib.BuildToolInfo;\nimport com.android.sdklib.IAndroidTarget;\nimport com.android.sdklib.SdkManager;\nimport com.android.sdklib.repository.FullRevision;\nimport com.android.utils.NullLogger;\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\nimport org.codehaus.plexus.interpolation.os.Os;\n\n/**\n * Represents an Android SDK.\n * \n * @author hugo.josefson@jayway.com\n * @author Manfred Moser <manfred@simpligility.com>\n */\npublic class AndroidSdk\n{\n    /**\n     * the default API level for the SDK used as a fall back if none is supplied, \n     * should ideally point to the latest available version\n     */\n    private static final String DEFAULT_ANDROID_API_LEVEL = \"22\";\n    /**\n     * property file in each platform folder with details about platform.\n     */\n    private static final String SOURCE_PROPERTIES_FILENAME = \"source.properties\";\n    /**\n     * property name for the sdk tools revision in sdk/tools/lib source.properties\n     */\n    private static final String SDK_TOOLS_REVISION_PROPERTY = \"Pkg.Revision\";\n\n    /**\n     * folder name for the sdk sub folder that contains the different platform versions.\n     */\n    private static final String PLATFORMS_FOLDER_NAME = \"platforms\";\n\n    private static final String PARAMETER_MESSAGE = \"Please provide a proper Android SDK directory path as \"\n            + \"configuration parameter <sdk><path>...<\/path><\/sdk> in the plugin <configuration/>. As an alternative,\"\n            + \" you may add the parameter to commandline: -Dandroid.sdk.path=... or set environment variable \"\n            + AbstractAndroidMojo.ENV_ANDROID_HOME + \".\";\n\n    private final File sdkPath;\n    private File platformToolsPath;\n    private File toolsPath;\n\n    private final IAndroidTarget androidTarget;\n    private SdkManager sdkManager;\n    private int sdkMajorVersion;\n    private String buildToolsVersion;\n\n    public AndroidSdk( File sdkPath, String apiLevel )\n    {\n        this( sdkPath, apiLevel, null );\n    }\n\n    public AndroidSdk( File sdkPath, String apiLevel, @Nullable String buildToolsVersion )\n    {\n        this.sdkPath = sdkPath;\n        this.buildToolsVersion = buildToolsVersion;\n\n        if ( sdkPath != null )\n        {\n            sdkManager = SdkManager.createManager( sdkPath.getPath(), new NullLogger() );\n            platformToolsPath = new File( sdkPath, SdkConstants.FD_PLATFORM_TOOLS );\n            toolsPath = new File( sdkPath, SdkConstants.FD_TOOLS );\n\n            if ( sdkManager == null )\n            {\n                throw invalidSdkException( sdkPath, apiLevel );\n            }\n        }\n        loadSDKToolsMajorVersion();\n\n        if ( apiLevel == null )\n        {\n            apiLevel = DEFAULT_ANDROID_API_LEVEL;\n        }\n\n        androidTarget = findPlatformByApiLevel( apiLevel );\n        if ( androidTarget == null )\n        {\n            throw invalidSdkException( sdkPath, apiLevel );\n        }\n    }\n\n    private InvalidSdkException invalidSdkException( File sdkPath, String platformOrApiLevel )\n    {\n        throw new InvalidSdkException( \"Invalid SDK: Platform/API level \" + platformOrApiLevel\n                + \" not available. This command should give you all you need:\\n\" + sdkPath.getAbsolutePath()\n                + File.separator + \"tools\" + File.separator + \"android update sdk --no-ui --obsolete --force\" );\n    }\n\n    private IAndroidTarget findPlatformByApiLevel( String apiLevel )\n    {\n        // try find by api level first\n        AndroidVersion version = null;\n        try\n        {\n            version = new AndroidVersion( apiLevel );\n            String hashString = AndroidTargetHash.getPlatformHashString( version );\n            IAndroidTarget target = sdkManager.getTargetFromHashString( hashString );\n\n            if ( target != null )\n            {\n                return target;\n            }\n        }\n        catch ( AndroidVersion.AndroidVersionException ignore )\n        {\n            throw new InvalidSdkException( \"Error AndroidVersion: \" + ignore.getMessage() );\n        }\n\n        // fallback to searching for platform on standard Android platforms (isPlatform() is true)\n        for ( IAndroidTarget t: sdkManager.getTargets() )\n        {\n            if ( t.isPlatform() && t.getVersionName().equals( apiLevel ) )\n            {\n                return t;\n            }\n        }\n        return null;\n    }\n\n    private void assertPathIsDirectory( final File path )\n    {\n        if ( path == null )\n        {\n            throw new InvalidSdkException( PARAMETER_MESSAGE );\n        }\n        if ( !path.isDirectory() )\n        {\n            throw new InvalidSdkException( \"Path \\\"\" + path + \"\\\" is not a directory. \" + PARAMETER_MESSAGE );\n        }\n    }\n\n    /**\n     * Get the aapt tool path.\n     *\n     * @return\n     */\n    public String getAaptPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.AAPT );\n    }\n\n    /**\n     * Get the aild tool path\n     * @return\n     */\n    public String getAidlPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.AIDL );\n    }\n\n    /**\n     * Get the path for dx.jar\n     * @return\n     */\n    public String getDxJarPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.DX_JAR );\n    }\n\n    /**\n     * Get the android debug tool path (adb).\n     *\n     * @return\n     */\n    public String getAdbPath()\n    {\n        return getPathForPlatformTool( SdkConstants.FN_ADB );\n    }\n\n    /**\n     * Get the android zipalign path.\n     *\n     * @return\n     */\n    public String getZipalignPath()\n    {\n        return getPathForBuildTool( BuildToolInfo.PathId.ZIP_ALIGN );\n    }\n\n    /**\n     * Get the android lint path.\n     * \n     * @return\n     */\n    public String getLintPath()\n    {\n        return getPathForTool( \"lint\" + ext( \".bat\", \"\" ) );\n    }\n\n    /**\n     * Get the android monkey runner path.\n     * \n     * @return\n     */\n    public String getMonkeyRunnerPath()\n    {\n        return getPathForTool( \"monkeyrunner\" + ext( \".bat\", \"\" ) );\n    }\n\n    /**\n     * Get the apkbuilder path.\n     *\n     * @return\n     */\n    public String getApkBuilderPath()\n    {\n        return getPathForTool( \"apkbuilder\" + ext( \".bat\", \"\" ) );\n    }\n\n    /**\n     * Get the android tool path.\n     *\n     * @return\n     */\n    public String getAndroidPath()\n    {\n        return getPathForTool( SdkConstants.androidCmdName() );\n    }\n\n    /**\n     * Get the path to the tools directory.\n     * @return\n     */\n    public File getToolsPath()\n    {\n        return toolsPath;\n    }\n\n    private String getPathForBuildTool( BuildToolInfo.PathId pathId )\n    {\n        return getBuildToolInfo().getPath( pathId );\n    }\n    \n    private BuildToolInfo getBuildToolInfo()\n    {\n        //First we use the build tools specified in the pom file\n        if ( buildToolsVersion != null && !buildToolsVersion.equals( \"\" ) )\n        {\n            BuildToolInfo buildToolInfo = sdkManager.getBuildTool( FullRevision.parseRevision( buildToolsVersion ) );\n            if ( buildToolInfo != null )\n            {\n                return buildToolInfo;\n            }\n            //Since we cannot find the build tool specified by the user we make it fail\n            // instead of using the latest build tool version\n            throw new InvalidSdkException( \"Invalid SDK: Build-tools \" + buildToolsVersion + \" not found.\"\n                    + \" Check your Android SDK to install the build tools \" + buildToolsVersion );\n        }\n\n        if ( androidTarget != null )\n        {\n            BuildToolInfo buildToolInfo = androidTarget.getBuildToolInfo();\n            if ( buildToolInfo != null ) \n            {\n                return buildToolInfo;\n            }\n        }\n        // if no valid target is defined, or it has no build tools installed, try to use the latest\n        BuildToolInfo latestBuildToolInfo = sdkManager.getLatestBuildTool();\n        if ( latestBuildToolInfo == null )\n        {\n            throw new InvalidSdkException( \"Invalid SDK: Build-tools not found. Check the content of '\" \n                + sdkPath.getAbsolutePath() + File.separator + \"build-tools', or run '\" \n                + sdkPath.getAbsolutePath() + File.separator + \"tools\" + File.separator \n                + \"android sdk' to install them\" );\n        }\n        return latestBuildToolInfo;\n    }\n\n    private String getPathForPlatformTool( String tool )\n    {\n        return new File( platformToolsPath, tool ).getAbsolutePath();\n    }\n\n    private String getPathForTool( String tool )\n    {\n        return new File( toolsPath, tool ).getAbsolutePath();\n    }\n\n    private static String ext( String windowsExtension, String nonWindowsExtension )\n    {\n        if ( SdkConstants.currentPlatform() == SdkConstants.PLATFORM_WINDOWS )\n        {\n            return windowsExtension;\n        }\n        else\n        {\n            return nonWindowsExtension;\n        }\n    }\n\n    /**\n     * Returns the complete path for <code>framework.aidl<\/code>, based on this SDK.\n     * \n     * @return the complete path as a <code>String<\/code>, including the filename.\n     */\n    public String getPathForFrameworkAidl()\n    {\n        return androidTarget.getPath( IAndroidTarget.ANDROID_AIDL );\n    }\n\n    /**\n     * Returns the mainDexClasses script file, based on this SDK and OS.\n     * Assumes that the script is in build-tools\\VERSION\\ directory.\n     * \n     * <b>NOTE<\/b>: This file is found in version 21.1.1+ of build-tools.  \n     * \n     * @return mainDexClasses file\n     * @throws MojoExecutionException when the file is not found \n     */\n    public File getMainDexClasses() throws MojoExecutionException \n    {\n        final File location = getBuildToolInfo().getLocation();\n        String mainDexClassesScript = \"mainDexClasses\";   \n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) ) \n        {\n            mainDexClassesScript += \".bat\";   \n        }               \n        File mainDexClasses = new File( location, mainDexClassesScript );\n        if ( !mainDexClasses.exists() ) \n        {\n            throw new MojoExecutionException( \"No \" + mainDexClassesScript + \" found in \" + location );\n        }\n        return mainDexClasses;\n    }\n\n    /**\n     * Resolves the android.jar from this SDK.\n     * \n     * @return a <code>File<\/code> pointing to the android.jar file.\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     *             if the file can not be resolved.\n     */\n    public File getAndroidJar() throws MojoExecutionException\n    {\n        final String androidJarPath = androidTarget.getPath( IAndroidTarget.ANDROID_JAR );\n        if ( androidJarPath == null )\n        {\n            throw new MojoExecutionException( \"No AndroidJar found for \" + androidTarget );\n        }\n        return new File ( androidJarPath );\n    }\n  \n    /**\n     * Resolves the path for this SDK.\n     * \n     * @return a <code>File<\/code> pointing to the SDk Directory.\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     *             if the file can not be resolved.\n     */\n    public File getSdkPath() throws MojoExecutionException\n    {\n        if ( sdkPath.exists() )\n        {\n            return sdkPath;\n        }\n        throw new MojoExecutionException( \"Can't find the SDK directory : \" + sdkPath.getAbsolutePath() );\n    }\n\n    /**\n     * This method returns the previously specified version. However, if none have been specified it returns the\n     * \"latest\" version.\n     */\n    public File getPlatform()\n    {\n        assertPathIsDirectory( sdkPath );\n\n        final File platformsDirectory = new File( sdkPath, PLATFORMS_FOLDER_NAME );\n        assertPathIsDirectory( platformsDirectory );\n\n        final File platformDirectory;\n        if ( androidTarget == null )\n        {\n            IAndroidTarget latestTarget = null;\n            for ( IAndroidTarget target:  sdkManager.getTargets() )\n            {\n                if ( target.isPlatform() )\n                {\n                    if ( latestTarget == null\n                            || target.getVersion().getApiLevel() > latestTarget.getVersion().getApiLevel() )\n                    {\n                        latestTarget = target;\n                    }\n                }\n            }\n            platformDirectory = new File ( latestTarget.getLocation() );\n        }\n        else\n        {\n            platformDirectory = new File( androidTarget.getLocation() );\n        }\n        assertPathIsDirectory( platformDirectory );\n        return platformDirectory;\n    }\n\n    /**\n     * Loads the SDK Tools version\n     */\n    private void loadSDKToolsMajorVersion()\n    {\n        File propFile = new File( sdkPath, \"tools/\" + SOURCE_PROPERTIES_FILENAME );\n        Properties properties = new Properties();\n        try\n        {\n            properties.load( new FileInputStream( propFile ) );\n        }\n        catch ( IOException e )\n        {\n            throw new InvalidSdkException( \"Error reading \" + propFile.getAbsoluteFile() );\n        }\n\n        if ( properties.containsKey( SDK_TOOLS_REVISION_PROPERTY ) )\n        {\n            try\n            {\n                String versionString = properties.getProperty( SDK_TOOLS_REVISION_PROPERTY );\n                String majorVersion;\n                if ( versionString.matches( \".*[\\\\.| ].*\" ) )\n                {\n                    String[] versions = versionString.split( \"[\\\\.| ]\" );\n                    majorVersion = versions[ 0 ];\n                }\n                else\n                {\n                    majorVersion = versionString;\n                }\n                sdkMajorVersion = Integer.parseInt( majorVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new InvalidSdkException( \"Error - The property '\" + SDK_TOOLS_REVISION_PROPERTY\n                        + \"' in the SDK source.properties file  number is not an Integer: \"\n                        + properties.getProperty( SDK_TOOLS_REVISION_PROPERTY ) );\n            }\n        }\n    }\n\n    /**\n     * Returns the version of the SDK Tools.\n     * \n     * @return\n     */\n    public int getSdkMajorVersion()\n    {\n        return sdkMajorVersion;\n    }\n}\n","lineNo":268}
{"Smelly Sample":"package com.jayway.maven.plugins.android.standalonemojos;\n\nimport com.android.SdkConstants;\nimport com.android.annotations.NonNull;\nimport com.android.builder.core.AndroidBuilder;\nimport com.android.ide.common.process.JavaProcessExecutor;\nimport com.android.ide.common.process.ProcessExecutor;\nimport com.android.ide.common.process.ProcessOutputHandler;\nimport com.android.manifmerger.ManifestMerger2;\nimport com.jayway.maven.plugins.android.AbstractAndroidMojo;\nimport com.jayway.maven.plugins.android.common.AndroidExtension;\nimport com.jayway.maven.plugins.android.common.MavenManifestDependency;\nimport com.jayway.maven.plugins.android.configuration.ManifestMerger;\nimport com.jayway.maven.plugins.android.configuration.UsesSdk;\nimport com.jayway.maven.plugins.android.configuration.VersionGenerator;\nimport com.jayway.maven.plugins.android.phase01generatesources.MavenILogger;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Manifest Merger V2 <code>AndroidManifest.xml<\/code> file.\n * http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger\n *\n * @author Benoit Billington <benoit.billington@gmail.com>\n */\n@Mojo( name = \"manifest-merger\", defaultPhase = LifecyclePhase.PROCESS_RESOURCES )\npublic class ManifestMergerMojo extends AbstractAndroidMojo\n{\n\n    /**\n     * Configuration for the manifest-update goal.\n     * <p>\n     * You can configure this mojo to update the following basic manifestMerger attributes:\n     * <\/p>\n     * <p>\n     * <code>android:versionName<\/code> on the <code>manifestMerger<\/code> element.\n     * <code>android:versionCode<\/code> on the <code>manifestMerger<\/code> element.\n     * <\/p>\n     * <p>\n     * You can configure attributes in the plugin configuration like so\n     * <p/>\n     * <pre>\n     *   &lt;plugin&gt;\n     *     &lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;\n     *     &lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;\n     *     &lt;executions&gt;\n     *       &lt;execution&gt;\n     *         &lt;id&gt;merge-manifest&lt;/id&gt;\n     *         &lt;goals&gt;\n     *           &lt;goal&gt;manifest-merger&lt;/goal&gt;\n     *         &lt;/goals&gt;\n     *         &lt;configuration&gt;\n     *           &lt;manifestMerger&gt;\n     *             &lt;versionName&gt;&lt;/versionName&gt;\n     *             &lt;versionCode&gt;123&lt;/versionCode&gt;\n     *             &lt;versionCodeUpdateFromVersion&gt;true|false&lt;/versionCodeUpdateFromVersion&gt;\n     *             &lt;mergeLibraries&gt;true|false&lt;/mergeLibraries&gt;\n     *             &lt;mergeReportFile&gt;${project.build.directory}/ManifestMergeReport.txt&lt;/mergeReportFile&gt;\n     *             &lt;usesSdk&gt;\n     *               &lt;minSdkVersion&gt;14&lt;/minSdkVersion&gt;\n     *               &lt;targetSdkVersion&gt;21&lt;/targetSdkVersion&gt;\n     *             &lt;/usesSdk&gt;\n     *           &lt;/manifestMerger&gt;\n     *         &lt;/configuration&gt;\n     *       &lt;/execution&gt;\n     *     &lt;/executions&gt;\n     *   &lt;/plugin&gt;\n     * <\/pre>\n     * <p/>\n     * or use properties set in the pom or settings file or supplied as command line parameter. Add\n     * \"android.\" in front of the property name for command line usage. All parameters follow a\n     * manifestMerger.* naming convention.\n     * <p/>\n     */\n    @Parameter\n    private ManifestMerger manifestMerger;\n\n    /**\n     * Update the <code>android:versionName<\/code> with the specified parameter. If left empty it\n     * will use the version number of the project. Exposed via the project property\n     * <code>android.manifestMerger.versionName<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionName\", defaultValue = \"${project.version}\" )\n    protected String manifestVersionName;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute with the specified parameter. Exposed via\n     * the project property <code>android.manifestMerger.versionCode<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionCode\", defaultValue = \"1\" )\n    protected Integer manifestVersionCode;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute automatically from the project version\n     * e.g 3.2.1 will become version code 3002001. As described in this blog post\n     * http://www.simpligility.com/2010/11/release-version-management-for-your-android-application/\n     * but done without using resource filtering. The value is exposed via the project property\n     * property <code>android.manifest.versionCodeUpdateFromVersion<\/code> and the resulting value\n     * as <code>android.manifest.versionCode<\/code>.\n     * For the purpose of generating the versionCode, if a version element is missing it is presumed to be 0.\n     * The maximum values for the version increment and version minor values are 999,\n     * the version major should be no larger than 2000.  Any other suffixes do not\n     * participate in the version code generation.\n     */\n    @Parameter( property = \"android.manifest.versionCodeUpdateFromVersion\", defaultValue = \"false\" )\n    protected Boolean manifestVersionCodeUpdateFromVersion = false;\n\n    /**\n     * The number of digits per version element. Must be specified as a comma/semicolon separated list of\n     * digits, one for each version element, Exposed via the project property\n     * <code>android.manifestMerger.versionDigits<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionDigits\", defaultValue = \"4,3,3\" )\n    protected String manifestVersionDigits;\n\n    /**\n     * Merge Manifest with library projects. Exposed via the project property\n     * <code>android.manifestMerger.mergeLibraries<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.mergeLibraries\", defaultValue = \"false\" )\n    protected Boolean manifestMergeLibraries;\n\n    /**\n     * Merge Manifest with library projects. Exposed via the project property\n     * <code>android.manifestMerger.mergeLibraries<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.mergeReportFile\" )\n    protected File manifestMergeReportFile;\n\n    /**\n     *  Update the uses-sdk tag. It can be configured to change: <code>android:minSdkVersion<\/code>,\n     *  <code>android:maxSdkVersion<\/code> and <code>android:targetSdkVersion<\/code>\n     */\n    protected UsesSdk manifestUsesSdk;\n    private Boolean parsedVersionCodeUpdateFromVersion;\n    private String parsedVersionDigits;\n    private Boolean parsedMergeLibraries;\n    private String parsedVersionName;\n    private Integer parsedVersionCode;\n    private UsesSdk parsedUsesSdk;\n    private File parsedMergeReportFile;\n\n    /**\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     * @throws org.apache.maven.plugin.MojoFailureException\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        if ( ! AndroidExtension.isAndroidPackaging( project.getPackaging() ) )\n        {\n            return; // skip, not an android project.\n        }\n\n        if ( androidManifestFile == null )\n        {\n            getLog().debug( \"skip, no androidmanifest.xml defined (androidManifestFile rare case)\" );\n            return; // skip, no androidmanifest.xml defined (rare case)\n        }\n\n        parseConfiguration();\n\n        getLog().info( \"Attempting to update manifest \" + androidManifestFile );\n        getLog().debug( \"    usesSdk=\" + parsedUsesSdk );\n        getLog().debug( \"    versionName=\" + parsedVersionName );\n        getLog().debug( \"    versionCode=\" + parsedVersionCode );\n        getLog().debug( \"    usesSdk=\" + parsedUsesSdk );\n        getLog().debug( \"    versionCodeUpdateFromVersion=\" + parsedVersionCodeUpdateFromVersion );\n        getLog().debug( \"    versionDigits=\" + parsedVersionDigits );\n        getLog().debug( \"    mergeLibraries=\" + parsedMergeLibraries );\n        getLog().debug( \"    mergeReportFile=\" + parsedMergeReportFile );\n\n        if ( ! androidManifestFile.exists() )\n        {\n            return; // skip, no AndroidManifest.xml file found.\n        }\n\n        getLog().debug( \"Using manifest merger V2\" );\n        manifestMergerV2();\n    }\n\n    private void parseConfiguration()\n    {\n        // manifestMerger element found in plugin config in pom\n        if ( manifestMerger != null )\n        {\n            if ( StringUtils.isNotEmpty( manifestMerger.getVersionName() ) )\n            {\n                parsedVersionName = manifestMerger.getVersionName();\n            }\n            else\n            {\n                parsedVersionName = manifestVersionName;\n            }\n            if ( manifestMerger.getVersionCode() != null )\n            {\n                parsedVersionCode = manifestMerger.getVersionCode();\n            }\n            else\n            {\n                parsedVersionCode = manifestVersionCode;\n            }\n            if ( manifestMerger.getVersionCodeUpdateFromVersion() != null )\n            {\n                parsedVersionCodeUpdateFromVersion = manifestMerger.getVersionCodeUpdateFromVersion();\n            }\n            else\n            {\n                parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n            }\n            if ( manifestMerger.getVersionDigits() != null )\n            {\n                parsedVersionDigits = manifestMerger.getVersionDigits();\n            }\n            else\n            {\n                parsedVersionDigits = manifestVersionDigits;\n            }\n            if ( manifestMerger.getUsesSdk() != null )\n            {\n                parsedUsesSdk = manifestMerger.getUsesSdk();\n            }\n            else\n            {\n                parsedUsesSdk = manifestUsesSdk;\n            }\n            if ( manifestMerger.getMergeLibraries() != null )\n            {\n                parsedMergeLibraries = manifestMerger.getMergeLibraries();\n            }\n            else\n            {\n                parsedMergeLibraries = manifestMergeLibraries;\n            }\n            if ( manifestMerger.getMergeReportFile() != null )\n            {\n                parsedMergeReportFile = manifestMerger.getMergeReportFile();\n            }\n            else\n            {\n                parsedMergeReportFile = manifestMergeReportFile;\n            }\n        }\n        else\n        {\n            parsedVersionName = manifestVersionName;\n            parsedVersionCode = manifestVersionCode;\n            parsedUsesSdk = manifestUsesSdk;\n            parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n            parsedVersionDigits = manifestVersionDigits;\n            parsedMergeLibraries = manifestMergeLibraries;\n            parsedMergeReportFile = manifestMergeReportFile;\n        }\n    }\n\n\n    public void manifestMergerV2() throws MojoExecutionException, MojoFailureException\n    {\n//        @NonNull ProcessExecutor processExecutor,\n//        @NonNull JavaProcessExecutor javaProcessExecutor,\n//        @NonNull ProcessOutputHandler processOutputHandler,\n        // we might have to make one of each for the Android Maven Plugin in general and then just use them here... \n        // e.g. the class com.android.ide.common.process.DefaultProcessExecutor could be adapted\n        AndroidBuilder builder = new AndroidBuilder( project.toString(), \"created by Android Maven Plugin\",\n                null, null, null, new MavenILogger( getLog() ), false );\n\n        String minSdkVersion = null;\n        String targetSdkVersion = null;\n        int versionCode;\n        if ( parsedUsesSdk != null )\n        {\n            minSdkVersion = parsedUsesSdk.getMinSdkVersion();\n            targetSdkVersion = parsedUsesSdk.getTargetSdkVersion();\n        }\n        if ( parsedVersionCodeUpdateFromVersion )\n        {\n            VersionGenerator gen = new VersionGenerator( parsedVersionDigits );\n            \n            versionCode = gen.generate( parsedVersionName );\n        }\n        else\n        {\n            versionCode = parsedVersionCode;\n        }\n        List<MavenManifestDependency> manifestDependencies = new ArrayList<MavenManifestDependency>();\n\n        if ( parsedMergeLibraries )\n        {\n            final Set<Artifact> allArtifacts = project.getDependencyArtifacts();\n            Set<Artifact> dependencyArtifacts = getArtifactResolverHelper().getFilteredArtifacts( allArtifacts );\n\n            for ( Artifact dependency : dependencyArtifacts )\n            {\n                final File unpackedLibFolder = getUnpackedLibFolder( dependency );\n                final File manifestFile = new File( unpackedLibFolder, SdkConstants.FN_ANDROID_MANIFEST_XML );\n                if ( manifestFile.exists() )\n                {\n                    manifestDependencies.add( new MavenManifestDependency( manifestFile,\n                            manifestFile.getAbsolutePath(), new ArrayList<MavenManifestDependency>() ) );\n                }\n            }\n        }\n\n        builder.mergeManifests(\n                androidManifestFile, new ArrayList<File>(), manifestDependencies, \"\",\n                versionCode, parsedVersionName,\n                minSdkVersion, targetSdkVersion, null,\n                destinationManifestFile.getPath(), ManifestMerger2.MergeType.APPLICATION,\n                new HashMap<String, String>(), parsedMergeReportFile );\n\n    }\n\n}\n","Method after Refactoring":"package com.jayway.maven.plugins.android.standalonemojos;\n\nimport com.android.SdkConstants;\nimport com.android.builder.core.AndroidBuilder;\nimport com.android.ide.common.process.DefaultProcessExecutor;\nimport com.android.ide.common.process.LoggedProcessOutputHandler;\nimport com.android.manifmerger.ManifestMerger2;\nimport com.android.utils.ILogger;\nimport com.jayway.maven.plugins.android.AbstractAndroidMojo;\nimport com.jayway.maven.plugins.android.DefaultJavaProcessExecutor;\nimport com.jayway.maven.plugins.android.common.AndroidExtension;\nimport com.jayway.maven.plugins.android.common.MavenManifestDependency;\nimport com.jayway.maven.plugins.android.configuration.ManifestMerger;\nimport com.jayway.maven.plugins.android.configuration.UsesSdk;\nimport com.jayway.maven.plugins.android.configuration.VersionGenerator;\nimport com.jayway.maven.plugins.android.phase01generatesources.MavenILogger;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Manifest Merger V2 <code>AndroidManifest.xml<\/code> file.\n * http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger\n *\n * @author Benoit Billington <benoit.billington@gmail.com>\n */\n@Mojo( name = \"manifest-merger\", defaultPhase = LifecyclePhase.PROCESS_RESOURCES )\npublic class ManifestMergerMojo extends AbstractAndroidMojo\n{\n\n    /**\n     * Configuration for the manifest-update goal.\n     * <p>\n     * You can configure this mojo to update the following basic manifestMerger attributes:\n     * <\/p>\n     * <p>\n     * <code>android:versionName<\/code> on the <code>manifestMerger<\/code> element.\n     * <code>android:versionCode<\/code> on the <code>manifestMerger<\/code> element.\n     * <\/p>\n     * <p>\n     * You can configure attributes in the plugin configuration like so\n     * <p/>\n     * <pre>\n     *   &lt;plugin&gt;\n     *     &lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;\n     *     &lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;\n     *     &lt;executions&gt;\n     *       &lt;execution&gt;\n     *         &lt;id&gt;merge-manifest&lt;/id&gt;\n     *         &lt;goals&gt;\n     *           &lt;goal&gt;manifest-merger&lt;/goal&gt;\n     *         &lt;/goals&gt;\n     *         &lt;configuration&gt;\n     *           &lt;manifestMerger&gt;\n     *             &lt;versionName&gt;&lt;/versionName&gt;\n     *             &lt;versionCode&gt;123&lt;/versionCode&gt;\n     *             &lt;versionCodeUpdateFromVersion&gt;true|false&lt;/versionCodeUpdateFromVersion&gt;\n     *             &lt;mergeLibraries&gt;true|false&lt;/mergeLibraries&gt;\n     *             &lt;mergeReportFile&gt;${project.build.directory}/ManifestMergeReport.txt&lt;/mergeReportFile&gt;\n     *             &lt;usesSdk&gt;\n     *               &lt;minSdkVersion&gt;14&lt;/minSdkVersion&gt;\n     *               &lt;targetSdkVersion&gt;21&lt;/targetSdkVersion&gt;\n     *             &lt;/usesSdk&gt;\n     *           &lt;/manifestMerger&gt;\n     *         &lt;/configuration&gt;\n     *       &lt;/execution&gt;\n     *     &lt;/executions&gt;\n     *   &lt;/plugin&gt;\n     * <\/pre>\n     * <p/>\n     * or use properties set in the pom or settings file or supplied as command line parameter. Add\n     * \"android.\" in front of the property name for command line usage. All parameters follow a\n     * manifestMerger.* naming convention.\n     * <p/>\n     */\n    @Parameter\n    private ManifestMerger manifestMerger;\n\n    /**\n     * Update the <code>android:versionName<\/code> with the specified parameter. If left empty it\n     * will use the version number of the project. Exposed via the project property\n     * <code>android.manifestMerger.versionName<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionName\", defaultValue = \"${project.version}\" )\n    protected String manifestVersionName;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute with the specified parameter. Exposed via\n     * the project property <code>android.manifestMerger.versionCode<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionCode\", defaultValue = \"1\" )\n    protected Integer manifestVersionCode;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute automatically from the project version\n     * e.g 3.2.1 will become version code 3002001. As described in this blog post\n     * http://www.simpligility.com/2010/11/release-version-management-for-your-android-application/\n     * but done without using resource filtering. The value is exposed via the project property\n     * property <code>android.manifest.versionCodeUpdateFromVersion<\/code> and the resulting value\n     * as <code>android.manifest.versionCode<\/code>.\n     * For the purpose of generating the versionCode, if a version element is missing it is presumed to be 0.\n     * The maximum values for the version increment and version minor values are 999,\n     * the version major should be no larger than 2000.  Any other suffixes do not\n     * participate in the version code generation.\n     */\n    @Parameter( property = \"android.manifest.versionCodeUpdateFromVersion\", defaultValue = \"false\" )\n    protected Boolean manifestVersionCodeUpdateFromVersion = false;\n\n    /**\n     * The number of digits per version element. Must be specified as a comma/semicolon separated list of\n     * digits, one for each version element, Exposed via the project property\n     * <code>android.manifestMerger.versionDigits<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionDigits\", defaultValue = \"4,3,3\" )\n    protected String manifestVersionDigits;\n\n    /**\n     * Merge Manifest with library projects. Exposed via the project property\n     * <code>android.manifestMerger.mergeLibraries<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.mergeLibraries\", defaultValue = \"false\" )\n    protected Boolean manifestMergeLibraries;\n\n    /**\n     * Merge Manifest with library projects. Exposed via the project property\n     * <code>android.manifestMerger.mergeLibraries<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.mergeReportFile\" )\n    protected File manifestMergeReportFile;\n\n    /**\n     *  Update the uses-sdk tag. It can be configured to change: <code>android:minSdkVersion<\/code>,\n     *  <code>android:maxSdkVersion<\/code> and <code>android:targetSdkVersion<\/code>\n     */\n    protected UsesSdk manifestUsesSdk;\n    private Boolean parsedVersionCodeUpdateFromVersion;\n    private String parsedVersionDigits;\n    private Boolean parsedMergeLibraries;\n    private String parsedVersionName;\n    private Integer parsedVersionCode;\n    private UsesSdk parsedUsesSdk;\n    private File parsedMergeReportFile;\n\n    /**\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     * @throws org.apache.maven.plugin.MojoFailureException\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        if ( ! AndroidExtension.isAndroidPackaging( project.getPackaging() ) )\n        {\n            return; // skip, not an android project.\n        }\n\n        if ( androidManifestFile == null )\n        {\n            getLog().debug( \"skip, no androidmanifest.xml defined (androidManifestFile rare case)\" );\n            return; // skip, no androidmanifest.xml defined (rare case)\n        }\n\n        parseConfiguration();\n\n        getLog().info( \"Attempting to update manifest \" + androidManifestFile );\n        getLog().debug( \"    usesSdk=\" + parsedUsesSdk );\n        getLog().debug( \"    versionName=\" + parsedVersionName );\n        getLog().debug( \"    versionCode=\" + parsedVersionCode );\n        getLog().debug( \"    usesSdk=\" + parsedUsesSdk );\n        getLog().debug( \"    versionCodeUpdateFromVersion=\" + parsedVersionCodeUpdateFromVersion );\n        getLog().debug( \"    versionDigits=\" + parsedVersionDigits );\n        getLog().debug( \"    mergeLibraries=\" + parsedMergeLibraries );\n        getLog().debug( \"    mergeReportFile=\" + parsedMergeReportFile );\n\n        if ( ! androidManifestFile.exists() )\n        {\n            return; // skip, no AndroidManifest.xml file found.\n        }\n\n        getLog().debug( \"Using manifest merger V2\" );\n        manifestMergerV2();\n    }\n\n    private void parseConfiguration()\n    {\n        // manifestMerger element found in plugin config in pom\n        if ( manifestMerger != null )\n        {\n            if ( StringUtils.isNotEmpty( manifestMerger.getVersionName() ) )\n            {\n                parsedVersionName = manifestMerger.getVersionName();\n            }\n            else\n            {\n                parsedVersionName = manifestVersionName;\n            }\n            if ( manifestMerger.getVersionCode() != null )\n            {\n                parsedVersionCode = manifestMerger.getVersionCode();\n            }\n            else\n            {\n                parsedVersionCode = manifestVersionCode;\n            }\n            if ( manifestMerger.getVersionCodeUpdateFromVersion() != null )\n            {\n                parsedVersionCodeUpdateFromVersion = manifestMerger.getVersionCodeUpdateFromVersion();\n            }\n            else\n            {\n                parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n            }\n            if ( manifestMerger.getVersionDigits() != null )\n            {\n                parsedVersionDigits = manifestMerger.getVersionDigits();\n            }\n            else\n            {\n                parsedVersionDigits = manifestVersionDigits;\n            }\n            if ( manifestMerger.getUsesSdk() != null )\n            {\n                parsedUsesSdk = manifestMerger.getUsesSdk();\n            }\n            else\n            {\n                parsedUsesSdk = manifestUsesSdk;\n            }\n            if ( manifestMerger.getMergeLibraries() != null )\n            {\n                parsedMergeLibraries = manifestMerger.getMergeLibraries();\n            }\n            else\n            {\n                parsedMergeLibraries = manifestMergeLibraries;\n            }\n            if ( manifestMerger.getMergeReportFile() != null )\n            {\n                parsedMergeReportFile = manifestMerger.getMergeReportFile();\n            }\n            else\n            {\n                parsedMergeReportFile = manifestMergeReportFile;\n            }\n        }\n        else\n        {\n            parsedVersionName = manifestVersionName;\n            parsedVersionCode = manifestVersionCode;\n            parsedUsesSdk = manifestUsesSdk;\n            parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n            parsedVersionDigits = manifestVersionDigits;\n            parsedMergeLibraries = manifestMergeLibraries;\n            parsedMergeReportFile = manifestMergeReportFile;\n        }\n    }\n\n\n    public void manifestMergerV2() throws MojoExecutionException, MojoFailureException\n    {\n        ILogger logger = new MavenILogger( getLog() );\n        AndroidBuilder builder = new AndroidBuilder( project.toString(), \"created by Android Maven Plugin\",\n                new DefaultProcessExecutor( logger ),\n                new DefaultJavaProcessExecutor( logger ),\n                new LoggedProcessOutputHandler( logger ),\n                logger, false );\n\n        String minSdkVersion = null;\n        String targetSdkVersion = null;\n        int versionCode;\n        if ( parsedUsesSdk != null )\n        {\n            minSdkVersion = parsedUsesSdk.getMinSdkVersion();\n            targetSdkVersion = parsedUsesSdk.getTargetSdkVersion();\n        }\n        if ( parsedVersionCodeUpdateFromVersion )\n        {\n            VersionGenerator gen = new VersionGenerator( parsedVersionDigits );\n            \n            versionCode = gen.generate( parsedVersionName );\n        }\n        else\n        {\n            versionCode = parsedVersionCode;\n        }\n        List<MavenManifestDependency> manifestDependencies = new ArrayList<MavenManifestDependency>();\n\n        if ( parsedMergeLibraries )\n        {\n            final Set<Artifact> allArtifacts = project.getDependencyArtifacts();\n            Set<Artifact> dependencyArtifacts = getArtifactResolverHelper().getFilteredArtifacts( allArtifacts );\n\n            for ( Artifact dependency : dependencyArtifacts )\n            {\n                final File unpackedLibFolder = getUnpackedLibFolder( dependency );\n                final File manifestFile = new File( unpackedLibFolder, SdkConstants.FN_ANDROID_MANIFEST_XML );\n                if ( manifestFile.exists() )\n                {\n                    manifestDependencies.add( new MavenManifestDependency( manifestFile,\n                            manifestFile.getAbsolutePath(), new ArrayList<MavenManifestDependency>() ) );\n                }\n            }\n        }\n\n        builder.mergeManifests(\n                androidManifestFile, new ArrayList<File>(), manifestDependencies, \"\",\n                versionCode, parsedVersionName,\n                minSdkVersion, targetSdkVersion, null,\n                destinationManifestFile.getPath(), null, ManifestMerger2.MergeType.APPLICATION,\n                new HashMap<String, String>(), parsedMergeReportFile );\n\n    }\n\n}\n","lineNo":270}
{"Smelly Sample":"package com.jayway.maven.plugins.android.standalonemojos;\n\nimport com.android.builder.core.AndroidBuilder;\nimport com.android.builder.dependency.ManifestDependency;\nimport com.android.manifmerger.ManifestMerger2;\nimport com.jayway.maven.plugins.android.AbstractAndroidMojo;\nimport com.jayway.maven.plugins.android.common.AndroidExtension;\nimport com.jayway.maven.plugins.android.configuration.ManifestMerger;\nimport com.jayway.maven.plugins.android.configuration.UsesSdk;\nimport com.jayway.maven.plugins.android.phase01generatesources.MavenILogger;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n/**\n * Manifest Merger V2 <code>AndroidManifest.xml<\/code> file.\n * http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger\n *\n * @author Benoit Billington <benoit.billington@gmail.com>\n */\n@Mojo( name = \"manifest-merger\", defaultPhase = LifecyclePhase.PROCESS_RESOURCES )\npublic class ManifestMergerMojo extends AbstractAndroidMojo\n{\n\n    // version encoding\n    private static final int NUMBER_OF_DIGITS_FOR_VERSION_POSITION = 3;\n\n    /**\n     * Configuration for the manifest-update goal.\n     * <p>\n     * You can configure this mojo to update the following basic manifestMerger attributes:\n     * <\/p>\n     * <p>\n     * <code>android:versionName<\/code> on the <code>manifestMerger<\/code> element.\n     * <code>android:versionCode<\/code> on the <code>manifestMerger<\/code> element.\n     * <\/p>\n     * <p>\n     * You can configure attributes in the plugin configuration like so\n     * <p/>\n     * <pre>\n     *   &lt;plugin&gt;\n     *     &lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;\n     *     &lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;\n     *     &lt;executions&gt;\n     *       &lt;execution&gt;\n     *         &lt;id&gt;merge-manifest&lt;/id&gt;\n     *         &lt;goals&gt;\n     *           &lt;goal&gt;manifest-merger&lt;/goal&gt;\n     *         &lt;/goals&gt;\n     *         &lt;configuration&gt;\n     *           &lt;manifestMerger&gt;\n     *             &lt;versionName&gt;&lt;/versionName&gt;\n     *             &lt;versionCode&gt;123&lt;/versionCode&gt;\n     *             &lt;versionCodeUpdateFromVersion&gt;true|false&lt;/versionCodeUpdateFromVersion&gt;\n     *             &lt;usesSdk&gt;\n     *               &lt;minSdkVersion&gt;14&lt;/minSdkVersion&gt;\n     *               &lt;targetSdkVersion&gt;21&lt;/targetSdkVersion&gt;\n     *             &lt;/versionCode&gt;\n     *           &lt;/manifestMerger&gt;\n     *         &lt;/configuration&gt;\n     *       &lt;/execution&gt;\n     *     &lt;/executions&gt;\n     *   &lt;/plugin&gt;\n     * <\/pre>\n     * <p/>\n     * or use properties set in the pom or settings file or supplied as command line parameter. Add\n     * \"android.\" in front of the property name for command line usage. All parameters follow a\n     * manifestMerger.* naming convention.\n     * <p/>\n     */\n    @Parameter\n    private ManifestMerger manifestMerger;\n\n    /**\n     * Update the <code>android:versionName<\/code> with the specified parameter. If left empty it\n     * will use the version number of the project. Exposed via the project property\n     * <code>android.manifestMerger.versionName<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionName\", defaultValue = \"${project.version}\" )\n    protected String manifestVersionName;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute with the specified parameter. Exposed via\n     * the project property <code>android.manifestMerger.versionCode<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionCode\", defaultValue = \"1\" )\n    protected Integer manifestVersionCode;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute automatically from the project version\n     * e.g 3.2.1 will become version code 3002001. As described in this blog post\n     * http://www.simpligility.com/2010/11/release-version-management-for-your-android-application/\n     * but done without using resource filtering. The value is exposed via the project property\n     * property <code>android.manifest.versionCodeUpdateFromVersion<\/code> and the resulting value\n     * as <code>android.manifest.versionCode<\/code>.\n     * For the purpose of generating the versionCode, if a version element is missing it is presumed to be 0.\n     * The maximum values for the version increment and version minor values are 999,\n     * the version major should be no larger than 2000.  Any other suffixes do not\n     * participate in the version code generation.\n     */\n    @Parameter( property = \"android.manifest.versionCodeUpdateFromVersion\", defaultValue = \"false\" )\n    protected Boolean manifestVersionCodeUpdateFromVersion = false;\n\n    /**\n     *  Update the uses-sdk tag. It can be configured to change: <code>android:minSdkVersion<\/code>,\n     *  <code>android:maxSdkVersion<\/code> and <code>android:targetSdkVersion<\/code>\n     */\n    protected UsesSdk manifestUsesSdk;\n    private Boolean parsedVersionCodeUpdateFromVersion;\n    private String parsedVersionName;\n    private Integer parsedVersionCode;\n    private UsesSdk parsedUsesSdk;\n\n    /**\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     * @throws org.apache.maven.plugin.MojoFailureException\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        if ( ! AndroidExtension.isAndroidPackaging( project.getPackaging() ) )\n        {\n            return; // skip, not an android project.\n        }\n\n        if ( sourceManifestFile == null )\n        {\n            getLog().debug( \"skip, no androidmanifest.xml defined (sourceManifestFile rare case)\" );\n            return; // skip, no androidmanifest.xml defined (rare case)\n        }\n\n        parseConfiguration();\n\n        getLog().info( \"Attempting to update manifest \" + sourceManifestFile );\n        getLog().debug( \"    usesSdk=\" + parsedUsesSdk );\n        getLog().debug( \"    versionName=\" + parsedVersionName );\n        getLog().debug( \"    versionCode=\" + parsedVersionCode );\n        getLog().debug( \"    parsedUsesSdk=\" + parsedUsesSdk );\n\n        if ( ! sourceManifestFile.exists() )\n        {\n            return; // skip, no AndroidManifest.xml file found.\n        }\n\n        getLog().debug( \"Using manifest merger V2\" );\n        manifestMergerV2();\n    }\n\n    private void parseConfiguration()\n    {\n        // manifestMerger element found in plugin config in pom\n        if ( manifestMerger != null )\n        {\n            if ( StringUtils.isNotEmpty( manifestMerger.getVersionName() ) )\n            {\n                parsedVersionName = manifestMerger.getVersionName();\n            }\n            else\n            {\n                parsedVersionName = manifestVersionName;\n            }\n            if ( manifestMerger.getVersionCode() != null )\n            {\n                parsedVersionCode = manifestMerger.getVersionCode();\n            }\n            else\n            {\n                parsedVersionCode = manifestVersionCode;\n            }\n            if ( manifestMerger.getVersionCodeUpdateFromVersion() != null )\n            {\n                parsedVersionCodeUpdateFromVersion = manifestMerger.getVersionCodeUpdateFromVersion();\n            }\n            else\n            {\n                parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n            }\n            if ( manifestMerger.getUsesSdk() != null )\n            {\n                parsedUsesSdk = manifestMerger.getUsesSdk();\n            }\n            else\n            {\n                parsedUsesSdk = manifestUsesSdk;\n            }\n        }\n        else\n        {\n            parsedVersionName = manifestVersionName;\n            parsedVersionCode = manifestVersionCode;\n            parsedUsesSdk = manifestUsesSdk;\n            parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n        }\n    }\n\n\n    public void manifestMergerV2() throws MojoExecutionException, MojoFailureException\n    {\n        AndroidBuilder builder = new AndroidBuilder( project.toString(), \"created by Android Maven Plugin\",\n                new MavenILogger( getLog() ), false );\n\n        String minSdkVersion = null;\n        String targetSdkVersion = null;\n        int versionCode;\n        if ( parsedUsesSdk != null )\n        {\n            minSdkVersion = parsedUsesSdk.getMinSdkVersion();\n            targetSdkVersion = parsedUsesSdk.getTargetSdkVersion();\n        }\n        if ( parsedVersionCodeUpdateFromVersion )\n        {\n            versionCode = generateVersionCodeFromVersionName( parsedVersionName );\n        }\n        else\n        {\n            versionCode = parsedVersionCode;\n        }\n\n        builder.mergeManifests(\n                sourceManifestFile, new ArrayList<File>(), new ArrayList<ManifestDependency>(), \"\",\n                versionCode, parsedVersionName,\n                minSdkVersion, targetSdkVersion, null,\n                androidManifestFile.getPath(), ManifestMerger2.MergeType.APPLICATION,\n                new HashMap<String, String>(), null );\n\n    }\n\n    private int generateVersionCodeFromVersionName( String versionName )\n    {\n        String[] versionNameDigits = versionName.replaceAll( \"[^0-9.]\", \"\" ).split( \"\\\\.\" );\n\n        int versionCode = 0;\n        for ( int i = 0; i < versionNameDigits.length; i++ )\n        {\n            double digitMultiplayer = Math.pow( 10, i * NUMBER_OF_DIGITS_FOR_VERSION_POSITION );\n            String versionDigit = versionNameDigits[versionNameDigits.length - i - 1 ];\n            versionCode += Integer.valueOf( versionDigit ) * digitMultiplayer;\n        }\n        return versionCode;\n    }\n\n}\n","Method after Refactoring":"package com.jayway.maven.plugins.android.standalonemojos;\n\nimport com.android.SdkConstants;\nimport com.android.builder.core.AndroidBuilder;\nimport com.android.manifmerger.ManifestMerger2;\nimport com.jayway.maven.plugins.android.AbstractAndroidMojo;\nimport com.jayway.maven.plugins.android.common.AndroidExtension;\nimport com.jayway.maven.plugins.android.common.MavenManifestDependency;\nimport com.jayway.maven.plugins.android.configuration.ManifestMerger;\nimport com.jayway.maven.plugins.android.configuration.UsesSdk;\nimport com.jayway.maven.plugins.android.phase01generatesources.MavenILogger;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Manifest Merger V2 <code>AndroidManifest.xml<\/code> file.\n * http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger\n *\n * @author Benoit Billington <benoit.billington@gmail.com>\n */\n@Mojo( name = \"manifest-merger\", defaultPhase = LifecyclePhase.PROCESS_RESOURCES )\npublic class ManifestMergerMojo extends AbstractAndroidMojo\n{\n\n    // version encoding\n    private static final int NUMBER_OF_DIGITS_FOR_VERSION_POSITION = 3;\n\n    /**\n     * Configuration for the manifest-update goal.\n     * <p>\n     * You can configure this mojo to update the following basic manifestMerger attributes:\n     * <\/p>\n     * <p>\n     * <code>android:versionName<\/code> on the <code>manifestMerger<\/code> element.\n     * <code>android:versionCode<\/code> on the <code>manifestMerger<\/code> element.\n     * <\/p>\n     * <p>\n     * You can configure attributes in the plugin configuration like so\n     * <p/>\n     * <pre>\n     *   &lt;plugin&gt;\n     *     &lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;\n     *     &lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;\n     *     &lt;executions&gt;\n     *       &lt;execution&gt;\n     *         &lt;id&gt;merge-manifest&lt;/id&gt;\n     *         &lt;goals&gt;\n     *           &lt;goal&gt;manifest-merger&lt;/goal&gt;\n     *         &lt;/goals&gt;\n     *         &lt;configuration&gt;\n     *           &lt;manifestMerger&gt;\n     *             &lt;versionName&gt;&lt;/versionName&gt;\n     *             &lt;versionCode&gt;123&lt;/versionCode&gt;\n     *             &lt;versionCodeUpdateFromVersion&gt;true|false&lt;/versionCodeUpdateFromVersion&gt;\n     *             &lt;mergeLibraries&gt;true|false&lt;/mergeLibraries&gt;\n     *             &lt;usesSdk&gt;\n     *               &lt;minSdkVersion&gt;14&lt;/minSdkVersion&gt;\n     *               &lt;targetSdkVersion&gt;21&lt;/targetSdkVersion&gt;\n     *             &lt;/versionCode&gt;\n     *           &lt;/manifestMerger&gt;\n     *         &lt;/configuration&gt;\n     *       &lt;/execution&gt;\n     *     &lt;/executions&gt;\n     *   &lt;/plugin&gt;\n     * <\/pre>\n     * <p/>\n     * or use properties set in the pom or settings file or supplied as command line parameter. Add\n     * \"android.\" in front of the property name for command line usage. All parameters follow a\n     * manifestMerger.* naming convention.\n     * <p/>\n     */\n    @Parameter\n    private ManifestMerger manifestMerger;\n\n    /**\n     * Update the <code>android:versionName<\/code> with the specified parameter. If left empty it\n     * will use the version number of the project. Exposed via the project property\n     * <code>android.manifestMerger.versionName<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionName\", defaultValue = \"${project.version}\" )\n    protected String manifestVersionName;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute with the specified parameter. Exposed via\n     * the project property <code>android.manifestMerger.versionCode<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.versionCode\", defaultValue = \"1\" )\n    protected Integer manifestVersionCode;\n\n    /**\n     * Update the <code>android:versionCode<\/code> attribute automatically from the project version\n     * e.g 3.2.1 will become version code 3002001. As described in this blog post\n     * http://www.simpligility.com/2010/11/release-version-management-for-your-android-application/\n     * but done without using resource filtering. The value is exposed via the project property\n     * property <code>android.manifest.versionCodeUpdateFromVersion<\/code> and the resulting value\n     * as <code>android.manifest.versionCode<\/code>.\n     * For the purpose of generating the versionCode, if a version element is missing it is presumed to be 0.\n     * The maximum values for the version increment and version minor values are 999,\n     * the version major should be no larger than 2000.  Any other suffixes do not\n     * participate in the version code generation.\n     */\n    @Parameter( property = \"android.manifest.versionCodeUpdateFromVersion\", defaultValue = \"false\" )\n    protected Boolean manifestVersionCodeUpdateFromVersion = false;\n\n    /**\n     * Merge Manifest with library projects. Exposed via the project property\n     * <code>android.manifestMerger.mergeLibraries<\/code>.\n     */\n    @Parameter( property = \"android.manifestMerger.mergeLibraries\", defaultValue = \"false\" )\n    protected Boolean manifestMergeLibraries;\n\n    /**\n     *  Update the uses-sdk tag. It can be configured to change: <code>android:minSdkVersion<\/code>,\n     *  <code>android:maxSdkVersion<\/code> and <code>android:targetSdkVersion<\/code>\n     */\n    protected UsesSdk manifestUsesSdk;\n    private Boolean parsedVersionCodeUpdateFromVersion;\n    private Boolean parsedMergeLibraries;\n    private String parsedVersionName;\n    private Integer parsedVersionCode;\n    private UsesSdk parsedUsesSdk;\n\n    /**\n     * @throws org.apache.maven.plugin.MojoExecutionException\n     * @throws org.apache.maven.plugin.MojoFailureException\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        if ( ! AndroidExtension.isAndroidPackaging( project.getPackaging() ) )\n        {\n            return; // skip, not an android project.\n        }\n\n        if ( sourceManifestFile == null )\n        {\n            getLog().debug( \"skip, no androidmanifest.xml defined (sourceManifestFile rare case)\" );\n            return; // skip, no androidmanifest.xml defined (rare case)\n        }\n\n        parseConfiguration();\n\n        getLog().info( \"Attempting to update manifest \" + sourceManifestFile );\n        getLog().debug( \"    usesSdk=\" + parsedUsesSdk );\n        getLog().debug( \"    versionName=\" + parsedVersionName );\n        getLog().debug( \"    versionCode=\" + parsedVersionCode );\n        getLog().debug( \"    usesSdk=\" + parsedUsesSdk );\n        getLog().debug( \"    versionCodeUpdateFromVersion=\" + parsedVersionCodeUpdateFromVersion );\n        getLog().debug( \"    mergeLibraries=\" + parsedMergeLibraries );\n\n        if ( ! sourceManifestFile.exists() )\n        {\n            return; // skip, no AndroidManifest.xml file found.\n        }\n\n        getLog().debug( \"Using manifest merger V2\" );\n        manifestMergerV2();\n    }\n\n    private void parseConfiguration()\n    {\n        // manifestMerger element found in plugin config in pom\n        if ( manifestMerger != null )\n        {\n            if ( StringUtils.isNotEmpty( manifestMerger.getVersionName() ) )\n            {\n                parsedVersionName = manifestMerger.getVersionName();\n            }\n            else\n            {\n                parsedVersionName = manifestVersionName;\n            }\n            if ( manifestMerger.getVersionCode() != null )\n            {\n                parsedVersionCode = manifestMerger.getVersionCode();\n            }\n            else\n            {\n                parsedVersionCode = manifestVersionCode;\n            }\n            if ( manifestMerger.getVersionCodeUpdateFromVersion() != null )\n            {\n                parsedVersionCodeUpdateFromVersion = manifestMerger.getVersionCodeUpdateFromVersion();\n            }\n            else\n            {\n                parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n            }\n            if ( manifestMerger.getUsesSdk() != null )\n            {\n                parsedUsesSdk = manifestMerger.getUsesSdk();\n            }\n            else\n            {\n                parsedUsesSdk = manifestUsesSdk;\n            }\n            if ( manifestMerger.getMergeLibraries() != null )\n            {\n                parsedMergeLibraries = manifestMerger.getMergeLibraries();\n            }\n            else\n            {\n                parsedMergeLibraries = manifestMergeLibraries;\n            }\n        }\n        else\n        {\n            parsedVersionName = manifestVersionName;\n            parsedVersionCode = manifestVersionCode;\n            parsedUsesSdk = manifestUsesSdk;\n            parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion;\n            parsedMergeLibraries = manifestMergeLibraries;\n        }\n    }\n\n\n    public void manifestMergerV2() throws MojoExecutionException, MojoFailureException\n    {\n        AndroidBuilder builder = new AndroidBuilder( project.toString(), \"created by Android Maven Plugin\",\n                new MavenILogger( getLog() ), false );\n\n        String minSdkVersion = null;\n        String targetSdkVersion = null;\n        int versionCode;\n        if ( parsedUsesSdk != null )\n        {\n            minSdkVersion = parsedUsesSdk.getMinSdkVersion();\n            targetSdkVersion = parsedUsesSdk.getTargetSdkVersion();\n        }\n        if ( parsedVersionCodeUpdateFromVersion )\n        {\n            versionCode = generateVersionCodeFromVersionName( parsedVersionName );\n        }\n        else\n        {\n            versionCode = parsedVersionCode;\n        }\n        List<MavenManifestDependency> manifestDependencies = new ArrayList<MavenManifestDependency>();\n\n        if ( parsedMergeLibraries )\n        {\n            final Set<Artifact> allArtifacts = project.getDependencyArtifacts();\n            Set<Artifact> dependencyArtifacts = getArtifactResolverHelper().getFilteredArtifacts( allArtifacts );\n\n            for ( Artifact dependency : dependencyArtifacts )\n            {\n                final File unpackedLibFolder = getUnpackedLibFolder( dependency );\n                final File manifestFile = new File( unpackedLibFolder, SdkConstants.FN_ANDROID_MANIFEST_XML );\n                if ( manifestFile.exists() )\n                {\n                    manifestDependencies.add( new MavenManifestDependency( manifestFile,\n                            manifestFile.getAbsolutePath(), new ArrayList<MavenManifestDependency>() ) );\n                }\n            }\n        }\n\n        builder.mergeManifests(\n                sourceManifestFile, new ArrayList<File>(), manifestDependencies, \"\",\n                versionCode, parsedVersionName,\n                minSdkVersion, targetSdkVersion, null,\n                androidManifestFile.getPath(), ManifestMerger2.MergeType.APPLICATION,\n                new HashMap<String, String>(), null );\n\n    }\n\n    private int generateVersionCodeFromVersionName( String versionName )\n    {\n        String[] versionNameDigits = versionName.replaceAll( \"[^0-9.]\", \"\" ).split( \"\\\\.\" );\n\n        int versionCode = 0;\n        for ( int i = 0; i < versionNameDigits.length; i++ )\n        {\n            double digitMultiplayer = Math.pow( 10, i * NUMBER_OF_DIGITS_FOR_VERSION_POSITION );\n            String versionDigit = versionNameDigits[versionNameDigits.length - i - 1 ];\n            versionCode += Integer.valueOf( versionDigit ) * digitMultiplayer;\n        }\n        return versionCode;\n    }\n\n}\n","lineNo":248}
