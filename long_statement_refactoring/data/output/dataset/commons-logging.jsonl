{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.logging;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.lang.ref.WeakReference;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceConfigurationError;\nimport java.util.ServiceLoader;\n\n/**\n * Factory for creating {@link Log} instances, with discovery and\n * configuration features similar to that employed by standard Java APIs\n * such as JAXP.\n * <p>\n * <strong>IMPLEMENTATION NOTE<\/strong> - This implementation is heavily\n * based on the SAXParserFactory and DocumentBuilderFactory implementations\n * (corresponding to the JAXP pluggability APIs) found in Apache Xerces.\n */\npublic abstract class LogFactory {\n    // Implementation note re AccessController usage\n    //\n    // It is important to keep code invoked via an AccessController to small\n    // auditable blocks. Such code must carefully evaluate all user input\n    // (parameters, system properties, config file contents, etc). As an\n    // example, a Log implementation should not write to its logfile\n    // with an AccessController anywhere in the call stack, otherwise an\n    // insecure application could configure the log implementation to write\n    // to a protected file using the privileges granted to JCL rather than\n    // to the calling application.\n    //\n    // Under no circumstance should a non-private method return data that is\n    // retrieved via an AccessController. That would allow an insecure app\n    // to invoke that method and obtain data that it is not permitted to have.\n    //\n    // Invoking user-supplied code with an AccessController set is not a major\n    // issue (eg invoking the constructor of the class specified by\n    // HASHTABLE_IMPLEMENTATION_PROPERTY). That class will be in a different\n    // trust domain, and therefore must have permissions to do whatever it\n    // is trying to do regardless of the permissions granted to JCL. There is\n    // a slight issue in that untrusted code may point that environment var\n    // to another trusted library, in which case the code runs if both that\n    // lib and JCL have the necessary permissions even when the untrusted\n    // caller does not. That's a pretty hard route to exploit though.\n\n    \n    /**\n     * The name ({@code priority}) of the key in the config file used to\n     * specify the priority of that particular config file. The associated value\n     * is a floating-point number; higher values take priority over lower values.\n     */\n    public static final String PRIORITY_KEY = \"priority\";\n\n    /**\n     * The name ({@code use_tccl}) of the key in the config file used\n     * to specify whether logging classes should be loaded via the thread\n     * context class loader (TCCL), or not. By default, the TCCL is used.\n     */\n    public static final String TCCL_KEY = \"use_tccl\";\n\n    /**\n     * The name ({@code org.apache.commons.logging.LogFactory}) of the property\n     * used to identify the LogFactory implementation\n     * class name. This can be used as a system property, or as an entry in a\n     * configuration properties file.\n     */\n    public static final String FACTORY_PROPERTY = \"org.apache.commons.logging.LogFactory\";\n\n    private static final String FACTORY_LOG4J_API = \"org.apache.commons.logging.impl.Log4jApiLogFactory\";\n    private static final String LOG4J_API_LOGGER = \"org.apache.logging.log4j.Logger\";\n    private static final String LOG4J_TO_SLF4J_BRIDGE = \"org.apache.logging.slf4j.SLF4JProvider\";\n\n    private static final String FACTORY_SLF4J = \"org.apache.commons.logging.impl.Slf4jLogFactory\";\n    private static final String SLF4J_API_LOGGER = \"org.slf4j.Logger\";\n\n    /**\n     * The fully qualified class name of the fallback {@code LogFactory}\n     * implementation class to use, if no other can be found.\n     */\n    public static final String FACTORY_DEFAULT = \"org.apache.commons.logging.impl.LogFactoryImpl\";\n\n    /**\n     * The name ({@code commons-logging.properties}) of the properties file to search for.\n     */\n    public static final String FACTORY_PROPERTIES = \"commons-logging.properties\";\n\n    /**\n     * JDK1.3+ <a href=\"http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider\">\n     * 'Service Provider' specification<\/a>.\n     */\n    protected static final String SERVICE_ID =\n        \"META-INF/services/org.apache.commons.logging.LogFactory\";\n\n    /**\n     * The name ({@code org.apache.commons.logging.diagnostics.dest})\n     * of the property used to enable internal commons-logging\n     * diagnostic output, in order to get information on what logging\n     * implementations are being discovered, what classloaders they\n     * are loaded through, etc.\n     * <p>\n     * If a system property of this name is set then the value is\n     * assumed to be the name of a file. The special strings\n     * STDOUT or STDERR (case-sensitive) indicate output to\n     * System.out and System.err respectively.\n     * <p>\n     * Diagnostic logging should be used only to debug problematic\n     * configurations and should not be set in normal production use.\n     */\n    public static final String DIAGNOSTICS_DEST_PROPERTY =\n        \"org.apache.commons.logging.diagnostics.dest\";\n\n    /**\n     * When null (the usual case), no diagnostic output will be\n     * generated by LogFactory or LogFactoryImpl. When non-null,\n     * interesting events will be written to the specified object.\n     */\n    private static final PrintStream DIAGNOSTICS_STREAM;\n\n    /**\n     * A string that gets prefixed to every message output by the\n     * logDiagnostic method, so that users can clearly see which\n     * LogFactory class is generating the output.\n     */\n    private static final String diagnosticPrefix;\n\n    /**\n     * Setting this system property\n     * ({@code org.apache.commons.logging.LogFactory.HashtableImpl})\n     * value allows the {@code Hashtable} used to store\n     * classloaders to be substituted by an alternative implementation.\n     * <p>\n     * <strong>Note:<\/strong> {@code LogFactory} will print:\n     * <pre>\n     * [ERROR] LogFactory: Load of custom hashtable failed\n     * <\/pre>\n     * to system error and then continue using a standard Hashtable.\n     * <p>\n     * <strong>Usage:<\/strong> Set this property when Java is invoked\n     * and {@code LogFactory} will attempt to load a new instance\n     * of the given implementation class.\n     * For example, running the following ant scriplet:\n     * <pre>\n     *  &lt;java classname=\"${test.runner}\" fork=\"yes\" failonerror=\"${test.failonerror}\"&gt;\n     *     ...\n     *     &lt;sysproperty\n     *        key=\"org.apache.commons.logging.LogFactory.HashtableImpl\"\n     *        value=\"org.apache.commons.logging.AltHashtable\"/&gt;\n     *  &lt;/java&gt;\n     * <\/pre>\n     * will mean that {@code LogFactory} will load an instance of\n     * {@code org.apache.commons.logging.AltHashtable}.\n     * <p>\n     * A typical use case is to allow a custom\n     * Hashtable implementation using weak references to be substituted.\n     * This will allow classloaders to be garbage collected without\n     * the need to release them (on 1.3+ JVMs only, of course ;).\n     */\n    public static final String HASHTABLE_IMPLEMENTATION_PROPERTY =\n        \"org.apache.commons.logging.LogFactory.HashtableImpl\";\n\n    /** Name used to load the weak hashtable implementation by names. */\n    private static final String WEAK_HASHTABLE_CLASSNAME =\n        \"org.apache.commons.logging.impl.WeakHashtable\";\n\n    /**\n     * A reference to the classloader that loaded this class. This is the\n     * same as LogFactory.class.getClassLoader(). However computing this\n     * value isn't quite as simple as that, as we potentially need to use\n     * AccessControllers etc. It's more efficient to compute it once and\n     * cache it here.\n     */\n    private static final WeakReference<ClassLoader> thisClassLoaderRef;\n\n    /**\n     * Maximum number of {@link ServiceLoader} errors to ignore, while\n     * looking for an implementation.\n     */\n    private static final int MAX_BROKEN_SERVICES = 3;\n\n    \n    /**\n     * The previously constructed {@code LogFactory} instances, keyed by\n     * the {@code ClassLoader} with which it was created.\n     */\n    protected static Hashtable<ClassLoader, LogFactory> factories;\n\n    \n    /**\n     * Previously constructed {@code LogFactory} instance as in the\n     * {@code factories} map, but for the case where\n     * {@code getClassLoader} returns {@code null}.\n     * This can happen when:\n     * <ul>\n     * <li>using JDK1.1 and the calling code is loaded via the system\n     *  classloader (very common)<\/li>\n     * <li>using JDK1.2+ and the calling code is loaded via the boot\n     *  classloader (only likely for embedded systems work).<\/li>\n     * <\/ul>\n     * Note that {@code factories} is a <i>Hashtable<\/i> (not a HashMap),\n     * and hashtables don't allow null as a key.\n     * @deprecated since 1.1.2\n     */\n    @Deprecated\n    protected static volatile LogFactory nullClassLoaderFactory;\n\n    /**\n     * Remember this factory, so later calls to LogFactory.getCachedFactory\n     * can return the previously created object (together with all its\n     * cached Log objects).\n     *\n     * @param classLoader should be the current context classloader. Note that\n     *  this can be null under some circumstances; this is ok.\n     * @param factory should be the factory to cache. This should never be null.\n     */\n    private static void cacheFactory(final ClassLoader classLoader, final LogFactory factory) {\n        // Ideally we would assert(factory != null) here. However reporting\n        // errors from within a logging implementation is a little tricky!\n\n        if (factory != null) {\n            if (classLoader == null) {\n                nullClassLoaderFactory = factory;\n            } else {\n                factories.put(classLoader, factory);\n            }\n        }\n    }\n\n    /**\n     * Implements the operations described in the Javadoc for newFactory.\n     *\n     * @param factoryClassName Factory class.\n     * @param classLoader      used to load the specified factory class. This is expected to be either the TCCL or the class loader which loaded this class.\n     *                         Note that the class loader which loaded this class might be \"null\" (for example, the boot loader) for embedded systems.\n     * @return either a LogFactory object or a LogConfigurationException object.\n     * @since 1.1\n     */\n    protected static Object createFactory(final String factoryClassName, final ClassLoader classLoader) {\n        // This will be used to diagnose bad configurations\n        // and allow a useful message to be sent to the user\n        Class logFactoryClass = null;\n        try {\n            if (classLoader != null) {\n                try {\n                    // First the given class loader param (thread class loader)\n\n                    // Warning: must typecast here & allow exception\n                    // to be generated/caught & recast properly.\n                    logFactoryClass = classLoader.loadClass(factoryClassName);\n                    if (LogFactory.class.isAssignableFrom(logFactoryClass)) {\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"Loaded class \" + logFactoryClass.getName() + \" from classloader \" + objectId(classLoader));\n                        }\n                    } else //\n                    // This indicates a problem with the ClassLoader tree.\n                    // An incompatible ClassLoader was used to load the\n                    // implementation.\n                    // As the same classes\n                    // must be available in multiple class loaders,\n                    // it is very likely that multiple JCL jars are present.\n                    // The most likely fix for this\n                    // problem is to remove the extra JCL jars from the\n                    // ClassLoader hierarchy.\n                    //\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\"Factory class \" + logFactoryClass.getName() + \" loaded from classloader \" + objectId(logFactoryClass.getClassLoader())\n                                + \" does not extend '\" + LogFactory.class.getName() + \"' as loaded by this classloader.\");\n                        logHierarchy(\"[BAD CL TREE] \", classLoader);\n                    }\n\n                    return logFactoryClass.getConstructor().newInstance();\n\n                } catch (final ClassNotFoundException ex) {\n                    if (classLoader == thisClassLoaderRef.get()) {\n                        // Nothing more to try, onwards.\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"Unable to locate any class called '\" + factoryClassName + \"' via classloader \" + objectId(classLoader));\n                        }\n                        throw ex;\n                    }\n                    // ignore exception, continue\n                } catch (final NoClassDefFoundError e) {\n                    if (classLoader == thisClassLoaderRef.get()) {\n                        // Nothing more to try, onwards.\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"Class '\" + factoryClassName + \"' cannot be loaded\" + \" via classloader \" + objectId(classLoader)\n                                    + \" - it depends on some other class that cannot be found.\");\n                        }\n                        throw e;\n                    }\n                    // ignore exception, continue\n                } catch (final ClassCastException e) {\n                    if (classLoader == thisClassLoaderRef.get()) {\n                        // There's no point in falling through to the code below that\n                        // tries again with thisClassLoaderRef, because we've just tried\n                        // loading with that loader (not the TCCL). Just throw an\n                        // appropriate exception here.\n\n                        final boolean implementsLogFactory = implementsLogFactory(logFactoryClass);\n\n                        //\n                        // Construct a good message: users may not actual expect that a custom implementation\n                        // has been specified. Several well known containers use this mechanism to adapt JCL\n                        // to their native logging system.\n                        //\n                        final StringBuilder msg = new StringBuilder();\n                        msg.append(\"The application has specified that a custom LogFactory implementation \");\n                        msg.append(\"should be used but Class '\");\n                        msg.append(factoryClassName);\n                        msg.append(\"' cannot be converted to '\");\n                        msg.append(LogFactory.class.getName());\n                        msg.append(\"'. \");\n                        if (implementsLogFactory) {\n                            msg.append(\"The conflict is caused by the presence of multiple LogFactory classes \");\n                            msg.append(\"in incompatible classloaders. \");\n                            msg.append(\"Background can be found in http://commons.apache.org/logging/tech.html. \");\n                            msg.append(\"If you have not explicitly specified a custom LogFactory then it is likely \");\n                            msg.append(\"that the container has set one without your knowledge. \");\n                            msg.append(\"In this case, consider using the commons-logging-adapters.jar file or \");\n                            msg.append(\"specifying the standard LogFactory from the command line. \");\n                        } else {\n                            msg.append(\"Please check the custom implementation. \");\n                        }\n                        msg.append(\"Help can be found @http://commons.apache.org/logging/troubleshooting.html.\");\n\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(msg.toString());\n                        }\n\n                        throw new ClassCastException(msg.toString());\n                    }\n\n                    // Ignore exception, continue. Presumably the classloader was the\n                    // TCCL; the code below will try to load the class via thisClassLoaderRef.\n                    // This will handle the case where the original calling class is in\n                    // a shared classpath but the TCCL has a copy of LogFactory and the\n                    // specified LogFactory implementation; we will fall back to using the\n                    // LogFactory implementation from the same classloader as this class.\n                    //\n                    // Issue: this doesn't handle the reverse case, where this LogFactory\n                    // is in the webapp, and the specified LogFactory implementation is\n                    // in a shared classpath. In that case:\n                    // (a) the class really does implement LogFactory (bad log msg above)\n                    // (b) the fallback code will result in exactly the same problem.\n                }\n            }\n\n            /*\n             * At this point, either classLoader == null, OR classLoader was unable to load factoryClass.\n             *\n             * In either case, we call Class.forName, which is equivalent to LogFactory.class.getClassLoader().load(name), that is, we ignore the classloader\n             * parameter the caller passed, and fall back to trying the classloader associated with this class. See the javadoc for the newFactory method for\n             * more info on the consequences of this.\n             *\n             * Notes: * LogFactory.class.getClassLoader() may return 'null' if LogFactory is loaded by the bootstrap classloader.\n             */\n            // Warning: must typecast here & allow exception\n            // to be generated/caught & recast properly.\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\n                        \"Unable to load factory class via classloader \" + objectId(classLoader) + \" - trying the classloader associated with this LogFactory.\");\n            }\n            logFactoryClass = Class.forName(factoryClassName);\n            return logFactoryClass.newInstance();\n        } catch (final Exception e) {\n            // Check to see if we've got a bad configuration\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"Unable to create LogFactory instance.\");\n            }\n            if (logFactoryClass != null && !LogFactory.class.isAssignableFrom(logFactoryClass)) {\n                return new LogConfigurationException(\"The chosen LogFactory implementation does not extend LogFactory.\" + \" Please check your configuration.\",\n                        e);\n            }\n            return new LogConfigurationException(e);\n        }\n    }\n\n    /**\n     * Create the hashtable which will be used to store a map of\n     * (context-classloader -> logfactory-object). Version 1.2+ of Java\n     * supports \"weak references\", allowing a custom Hashtable class\n     * to be used which uses only weak references to its keys. Using weak\n     * references can fix memory leaks on webapp unload in some cases (though\n     * not all). Version 1.1 of Java does not support weak references, so we\n     * must dynamically determine which we are using. And just for fun, this\n     * code also supports the ability for a system property to specify an\n     * arbitrary Hashtable implementation name.\n     * <p>\n     * Note that the correct way to ensure no memory leaks occur is to ensure\n     * that LogFactory.release(contextClassLoader) is called whenever a\n     * webapp is undeployed.\n     */\n    private static Hashtable<ClassLoader, LogFactory> createFactoryStore() {\n        Hashtable<ClassLoader, LogFactory> result = null;\n        String storeImplementationClass;\n        try {\n            storeImplementationClass = getSystemProperty(HASHTABLE_IMPLEMENTATION_PROPERTY, null);\n        } catch (final SecurityException ex) {\n            // Permissions don't allow this to be accessed. Default to the \"modern\"\n            // weak hashtable implementation if it is available.\n            storeImplementationClass = null;\n        }\n\n        if (storeImplementationClass == null) {\n            storeImplementationClass = WEAK_HASHTABLE_CLASSNAME;\n        }\n        try {\n            final Class<Hashtable<ClassLoader, LogFactory>> implementationClass = (Class<Hashtable<ClassLoader, LogFactory>>) Class\n                    .forName(storeImplementationClass);\n            result = implementationClass.getConstructor().newInstance();\n        } catch (final Throwable t) {\n            handleThrowable(t); // may re-throw t\n\n            // ignore\n            if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) {\n                // if the user's trying to set up a custom implementation, give a clue\n                if (isDiagnosticsEnabled()) {\n                    // use internal logging to issue the warning\n                    logDiagnostic(\"[ERROR] LogFactory: Load of custom Hashtable failed\");\n                } else {\n                    // we *really* want this output, even if diagnostics weren't\n                    // explicitly enabled by the user.\n                    System.err.println(\"[ERROR] LogFactory: Load of custom Hashtable failed\");\n                }\n            }\n        }\n        if (result == null) {\n            result = new Hashtable<>();\n        }\n        return result;\n    }\n\n    /**\n     * Return the thread context class loader if available; otherwise return null.\n     * <p>\n     * Most/all code should call getContextClassLoaderInternal rather than\n     * calling this method directly.\n     * <p>\n     * The thread context class loader is available for JDK 1.2\n     * or later, if certain security conditions are met.\n     * <p>\n     * Note that no internal logging is done within this method because\n     * this method is called every time LogFactory.getLogger() is called,\n     * and we don't want too much output generated here.\n     *\n     * @throws LogConfigurationException if a suitable class loader\n     *  cannot be identified.\n     * @return the thread's context classloader or {@code null} if the java security\n     *  policy forbids access to the context classloader from one of the classes\n     *  in the current call stack.\n     * @since 1.1\n     */\n    protected static ClassLoader directGetContextClassLoader() throws LogConfigurationException {\n        ClassLoader classLoader = null;\n\n        try {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        } catch (final SecurityException ignore) {\n            //\n            // getContextClassLoader() throws SecurityException when\n            // the context class loader isn't an ancestor of the\n            // calling class's class loader, or if security\n            // permissions are restricted.\n            //\n            // We ignore this exception to be consistent with the previous\n            // behavior (e.g. 1.1.3 and earlier).\n            //\n            // ignore\n        }\n\n        // Return the selected class loader\n        return classLoader;\n    }\n\n    /**\n     * Check cached factories (keyed by contextClassLoader)\n     *\n     * @param contextClassLoader is the context classloader associated\n     * with the current thread. This allows separate LogFactory objects\n     * per component within a container, provided each component has\n     * a distinct context classloader set. This parameter may be null\n     * in JDK1.1, and in embedded systems where jcl-using code is\n     * placed in the bootclasspath.\n     *\n     * @return the factory associated with the specified classloader if\n     *  one has previously been created, or null if this is the first time\n     *  we have seen this particular classloader.\n     */\n    private static LogFactory getCachedFactory(final ClassLoader contextClassLoader) {\n        if (contextClassLoader == null) {\n            // We have to handle this specially, as factories is a Hashtable\n            // and those don't accept null as a key value.\n            //\n            // nb: nullClassLoaderFactory might be null. That's ok.\n            return nullClassLoaderFactory;\n        }\n        return factories.get(contextClassLoader);\n    }\n\n    \n    /**\n     * Safely get access to the classloader for the specified class.\n     * <p>\n     * Theoretically, calling getClassLoader can throw a security exception,\n     * and so should be done under an AccessController in order to provide\n     * maximum flexibility. However in practice people don't appear to use\n     * security policies that forbid getClassLoader calls. So for the moment\n     * all code is written to call this method rather than Class.getClassLoader,\n     * so that we could put AccessController stuff in this method without any\n     * disruption later if we need to.\n     * <\/p>\n     * <p>\n     * Even when using an AccessController, however, this method can still\n     * throw SecurityException. Commons Logging basically relies on the\n     * ability to access classloaders. A policy that forbids all\n     * classloader access will also prevent commons-logging from working:\n     * currently this method will throw an exception preventing the entire app\n     * from starting up. Maybe it would be good to detect this situation and\n     * just disable all commons-logging? Not high priority though - as stated\n     * above, security policies that prevent classloader access aren't common.\n     * <\/p>\n     * <p>\n     * Note that returning an object fetched via an AccessController would\n     * technically be a security flaw anyway; untrusted code that has access\n     * to a trusted JCL library could use it to fetch the classloader for\n     * a class even when forbidden to do so directly.\n     * <\/p>\n     *\n     * @param clazz Class.\n     * @return a ClassLoader.\n     *\n     * @since 1.1\n     */\n    protected static ClassLoader getClassLoader(final Class<?> clazz) {\n        try {\n            return clazz.getClassLoader();\n        } catch (final SecurityException ex) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"Unable to get classloader for class '\" + clazz + \"' due to security restrictions - \" + ex.getMessage());\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Locate a user-provided configuration file.\n     * <p>\n     * The classpath of the specified classLoader (usually the context classloader)\n     * is searched for properties files of the specified name. If none is found,\n     * null is returned. If more than one is found, then the file with the greatest\n     * value for its PRIORITY property is returned. If multiple files have the\n     * same PRIORITY value then the first in the classpath is returned.\n     * <p>\n     * This differs from the 1.0.x releases; those always use the first one found.\n     * However as the priority is a new field, this change is backwards compatible.\n     * <p>\n     * The purpose of the priority field is to allow a webserver administrator to\n     * override logging settings in all webapps by placing a commons-logging.properties\n     * file in a shared classpath location with a priority > 0; this overrides any\n     * commons-logging.properties files without priorities which are in the\n     * webapps. Webapps can also use explicit priorities to override a configuration\n     * file in the shared classpath if needed.\n     */\n    private static Properties getConfigurationFile(final ClassLoader classLoader, final String fileName) {\n        Properties props = null;\n        double priority = 0.0;\n        URL propsUrl = null;\n        try {\n            final Enumeration<URL> urls = getResources(classLoader, fileName);\n\n            if (urls == null) {\n                return null;\n            }\n\n            while (urls.hasMoreElements()) {\n                final URL url = urls.nextElement();\n\n                final Properties newProps = getProperties(url);\n                if (newProps != null) {\n                    if (props == null) {\n                        propsUrl = url;\n                        props = newProps;\n                        final String priorityStr = props.getProperty(PRIORITY_KEY);\n                        priority = 0.0;\n                        if (priorityStr != null) {\n                            priority = Double.parseDouble(priorityStr);\n                        }\n\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"[LOOKUP] Properties file found at '\" + url + \"'\" + \" with priority \" + priority);\n                        }\n                    } else {\n                        final String newPriorityStr = newProps.getProperty(PRIORITY_KEY);\n                        double newPriority = 0.0;\n                        if (newPriorityStr != null) {\n                            newPriority = Double.parseDouble(newPriorityStr);\n                        }\n\n                        if (newPriority > priority) {\n                            if (isDiagnosticsEnabled()) {\n                                logDiagnostic(\"[LOOKUP] Properties file at '\" + url + \"'\" + \" with priority \" + newPriority + \" overrides file at '\" + propsUrl\n                                        + \"'\" + \" with priority \" + priority);\n                            }\n\n                            propsUrl = url;\n                            props = newProps;\n                            priority = newPriority;\n                        } else if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"[LOOKUP] Properties file at '\" + url + \"'\" + \" with priority \" + newPriority + \" does not override file at '\"\n                                    + propsUrl + \"'\" + \" with priority \" + priority);\n                        }\n                    }\n\n                }\n            }\n        } catch (final SecurityException e) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"SecurityException thrown while trying to find/read config files.\");\n            }\n        }\n\n        if (isDiagnosticsEnabled()) {\n            if (props == null) {\n                logDiagnostic(\"[LOOKUP] No properties file of name '\" + fileName + \"' found.\");\n            } else {\n                logDiagnostic(\"[LOOKUP] Properties file of name '\" + fileName + \"' found at '\" + propsUrl + '\"');\n            }\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the current context classloader.\n     * <p>\n     * In versions prior to 1.1, this method did not use an AccessController.\n     * In version 1.1, an AccessController wrapper was incorrectly added to\n     * this method, causing a minor security flaw.\n     * <p>\n     * In version 1.1.1 this change was reverted; this method no longer uses\n     * an AccessController. User code wishing to obtain the context classloader\n     * must invoke this method via AccessController.doPrivileged if it needs\n     * support for that.\n     *\n     * @return the context classloader associated with the current thread,\n     *  or null if security doesn't allow it.\n     * @throws LogConfigurationException if there was some weird error while\n     *  attempting to get the context classloader.\n     */\n    protected static ClassLoader getContextClassLoader() throws LogConfigurationException {\n        return directGetContextClassLoader();\n    }\n\n    \n    /**\n     * Calls LogFactory.directGetContextClassLoader under the control of an\n     * AccessController class. This means that java code running under a\n     * security manager that forbids access to ClassLoaders will still work\n     * if this class is given appropriate privileges, even when the caller\n     * doesn't have such privileges. Without using an AccessController, the\n     * the entire call stack must have the privilege before the call is\n     * allowed.\n     *\n     * @return the context classloader associated with the current thread,\n     *  or null if security doesn't allow it.\n     * @throws LogConfigurationException if there was some weird error while\n     *  attempting to get the context classloader.\n     */\n    private static ClassLoader getContextClassLoaderInternal() throws LogConfigurationException {\n        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) LogFactory::directGetContextClassLoader);\n    }\n\n    /**\n     * Constructs (if necessary) and return a {@code LogFactory} instance, using the following ordered lookup procedure to determine the name of the\n     * implementation class to be loaded.\n     * <ul>\n     * <li>The {@code org.apache.commons.logging.LogFactory} system property.<\/li>\n     * <li>The JDK 1.3 Service Discovery mechanism<\/li>\n     * <li>Use the properties file {@code commons-logging.properties} file, if found in the class path of this class. The configuration file is in standard\n     * {@code java.util.Properties} format and contains the fully qualified name of the implementation class with the key being the system property defined\n     * above.<\/li>\n     * <li>Fall back to a default implementation class ({@code org.apache.commons.logging.impl.LogFactoryImpl}).<\/li>\n     * <\/ul>\n     * <p>\n     * <em>NOTE<\/em> - If the properties file method of identifying the {@code LogFactory} implementation class is utilized, all of the properties defined in\n     * this file will be set as configuration attributes on the corresponding {@code LogFactory} instance.\n     * <\/p>\n     * <p>\n     * <em>NOTE<\/em> - In a multi-threaded environment it is possible that two different instances will be returned for the same classloader environment.\n     * <\/p>\n     *\n     * @return a {@code LogFactory}.\n     * @throws LogConfigurationException if the implementation class is not available or cannot be instantiated.\n     */\n    public static LogFactory getFactory() throws LogConfigurationException {\n        // Identify the class loader we will be using\n        final ClassLoader contextClassLoader = getContextClassLoaderInternal();\n\n\n        // This is an odd enough situation to report about. This\n        // output will be a nuisance on JDK1.1, as the system\n        // class loader is null in that environment.\n        if (contextClassLoader == null && isDiagnosticsEnabled()) {\n            logDiagnostic(\"Context classloader is null.\");\n        }\n\n        // Return any previously registered factory for this class loader\n        LogFactory factory = getCachedFactory(contextClassLoader);\n        if (factory != null) {\n            return factory;\n        }\n\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\n                    \"[LOOKUP] LogFactory implementation requested for the first time for context classloader \" +\n                    objectId(contextClassLoader));\n            logHierarchy(\"[LOOKUP] \", contextClassLoader);\n        }\n\n        // Load properties file.\n        //\n        // If the properties file exists, then its contents are used as\n        // \"attributes\" on the LogFactory implementation class. One particular\n        // property may also control which LogFactory concrete subclass is\n        // used, but only if other discovery mechanisms fail..\n        //\n        // As the properties file (if it exists) will be used one way or\n        // another in the end we may as well look for it first.\n\n        final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);\n\n        // Determine whether we will be using the thread context class loader to\n        // load logging classes or not by checking the loaded properties file (if any).\n        ClassLoader baseClassLoader = contextClassLoader;\n        if (props != null) {\n            final String useTCCLStr = props.getProperty(TCCL_KEY);\n            // The Boolean.valueOf(useTCCLStr).booleanValue() formulation\n            // is required for Java 1.2 compatibility.\n            if (useTCCLStr != null && !Boolean.parseBoolean(useTCCLStr)) {\n                // Don't use current context class loader when locating any\n                // LogFactory or Log classes, just use the class that loaded\n                // this abstract class. When this class is deployed in a shared\n                // classpath of a container, it means webapps cannot deploy their\n                // own logging implementations. It also means that it is up to the\n                // implementation whether to load library-specific config files\n                // from the TCCL or not.\n                baseClassLoader = thisClassLoaderRef.get();\n            }\n        }\n\n        // Determine which concrete LogFactory subclass to use.\n        // First, try a global system property\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"[LOOKUP] Looking for system property [\" + FACTORY_PROPERTY +\n                          \"] to define the LogFactory subclass to use...\");\n        }\n\n        try {\n            final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null);\n            if (factoryClass != null) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\"[LOOKUP] Creating an instance of LogFactory class '\" + factoryClass +\n                                  \"' as specified by system property \" + FACTORY_PROPERTY);\n                }\n                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);\n            } else if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] No system property [\" + FACTORY_PROPERTY + \"] defined.\");\n            }\n        } catch (final SecurityException e) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] A security exception occurred while trying to create an\" +\n                              \" instance of the custom factory class\" + \": [\" + trim(e.getMessage()) +\n                              \"]. Trying alternative implementations...\");\n            }\n            // ignore\n        } catch (final RuntimeException e) {\n            // This is not consistent with the behavior when a bad LogFactory class is\n            // specified in a services file.\n            //\n            // One possible exception that can occur here is a ClassCastException when\n            // the specified class wasn't castable to this LogFactory type.\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] An exception occurred while trying to create an\" +\n                              \" instance of the custom factory class\" + \": [\" +\n                              trim(e.getMessage()) +\n                              \"] as specified by a system property.\");\n            }\n            throw e;\n        }\n\n        // Second, try to find a service by using the JDK1.3 class\n        // discovery mechanism, which involves putting a file with the name\n        // of an interface class in the META-INF/services directory, where the\n        // contents of the file is a single line specifying a concrete class\n        // that implements the desired interface.\n\n        if (factory == null) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] Using ServiceLoader  to define the LogFactory subclass to use...\");\n            }\n            try {\n                final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class);\n                final Iterator<LogFactory> iterator = serviceLoader.iterator();\n\n                int i = MAX_BROKEN_SERVICES;\n                while (factory == null && i-- > 0) {\n                    try {\n                        if (iterator.hasNext()) {\n                            factory = iterator.next();\n                        }\n                    } catch (final ServiceConfigurationError | LinkageError ex) {\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"[LOOKUP] An exception occurred while trying to find an\" +\n                                    \" instance of LogFactory\" +\n                                    \": [\" + trim(ex.getMessage()) +\n                                    \"]. Trying alternative implementations...\");\n                        }\n                    }\n                }\n            } catch (final Exception ex) {\n                // note: if the specified LogFactory class wasn't compatible with LogFactory\n                // for some reason, a ClassCastException will be caught here, and attempts will\n                // continue to find a compatible class.\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\n                        \"[LOOKUP] A security exception occurred while trying to create an\" +\n                        \" instance of the custom factory class\" +\n                        \": [\" + trim(ex.getMessage()) +\n                        \"]. Trying alternative implementations...\");\n                }\n                // ignore\n            }\n        }\n\n        // Third try looking into the properties file read earlier (if found)\n\n        if (factory == null) {\n            if (props != null) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\n                        \"[LOOKUP] Looking in properties file for entry with key '\" + FACTORY_PROPERTY +\n                        \"' to define the LogFactory subclass to use...\");\n                }\n                final String factoryClass = props.getProperty(FACTORY_PROPERTY);\n                if (factoryClass != null) {\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\n                            \"[LOOKUP] Properties file specifies LogFactory subclass '\" + factoryClass + \"'\");\n                    }\n                    factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);\n\n                    // TODO: think about whether we need to handle exceptions from newFactory\n                } else {\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\"[LOOKUP] Properties file has no entry specifying LogFactory subclass.\");\n                    }\n                }\n            } else if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] No properties file available to determine\" + \" LogFactory subclass from..\");\n            }\n        }\n\n        // Fourth, try one of the 3 provided factories\n\n        try {\n            // We prefer Log4j API, since it does not stringify objects.\n            if (factory == null && isClassAvailable(LOG4J_API_LOGGER, baseClassLoader)) {\n                // If the Log4j API is redirected to SLF4J, we use SLF4J directly.\n                if (isClassAvailable(LOG4J_TO_SLF4J_BRIDGE, baseClassLoader)) {\n                    logDiagnostic(\n                            \"[LOOKUP] Log4j API to SLF4J redirection detected. Loading the SLF4J LogFactory implementation '\" + FACTORY_SLF4J + \"'.\");\n                    factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader);\n                } else {\n                    logDiagnostic(\"[LOOKUP] Log4j API detected. Loading the Log4j API LogFactory implementation '\" + FACTORY_LOG4J_API + \"'.\");\n                    factory = newFactory(FACTORY_LOG4J_API, baseClassLoader, contextClassLoader);\n                }\n            }\n\n            if (factory == null && isClassAvailable(SLF4J_API_LOGGER, baseClassLoader)) {\n                logDiagnostic(\"[LOOKUP] SLF4J detected. Loading the SLF4J LogFactory implementation '\" + FACTORY_SLF4J + \"'.\");\n                factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader);\n            }\n        } catch (final Exception e) {\n            logDiagnostic(\"[LOOKUP] An exception occurred while creating LogFactory: \" + e.getMessage());\n        }\n\n        if (factory == null) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\n                    \"[LOOKUP] Loading the default LogFactory implementation '\" + FACTORY_DEFAULT +\n                    \"' via the same classloader that loaded this LogFactory\" +\n                    \" class (ie not looking in the context classloader).\");\n            }\n\n            // Note: unlike the above code which can try to load custom LogFactory\n            // implementations via the TCCL, we don't try to load the default LogFactory\n            // implementation via the context classloader because:\n            // * that can cause problems (see comments in newFactory method)\n            // * no-one should be customising the code of the default class\n            // Yes, we do give up the ability for the child to ship a newer\n            // version of the LogFactoryImpl class and have it used dynamically\n            // by an old LogFactory class in the parent, but that isn't\n            // necessarily a good idea anyway.\n            factory = newFactory(FACTORY_DEFAULT, thisClassLoaderRef.get(), contextClassLoader);\n        }\n\n        if (factory != null) {\n            /**\n             * Always cache using context class loader.\n             */\n            cacheFactory(contextClassLoader, factory);\n\n            if (props != null) {\n                final Enumeration<?> names = props.propertyNames();\n                while (names.hasMoreElements()) {\n                    final String name = Objects.toString(names.nextElement(), null);\n                    final String value = props.getProperty(name);\n                    factory.setAttribute(name, value);\n                }\n            }\n        }\n\n        return factory;\n    }\n\n    /**\n     * Convenience method to return a named logger, without the application having to care about factories.\n     *\n     * @param clazz Class from which a log name will be derived\n     * @return a named logger.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public static Log getLog(final Class<?> clazz) throws LogConfigurationException {\n        return getFactory().getInstance(clazz);\n    }\n\n    /**\n     * Convenience method to return a named logger, without the application having to care about factories.\n     *\n     * @param name Logical name of the {@code Log} instance to be returned (the meaning of this name is only known to the underlying logging implementation that\n     *             is being wrapped)\n     * @return a named logger.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public static Log getLog(final String name) throws LogConfigurationException {\n        return getFactory().getInstance(name);\n    }\n\n    /**\n     * Given a URL that refers to a .properties file, load that file.\n     * This is done under an AccessController so that this method will\n     * succeed when this jarfile is privileged but the caller is not.\n     * This method must therefore remain private to avoid security issues.\n     * <p>\n     * {@code Null} is returned if the URL cannot be opened.\n     */\n    private static Properties getProperties(final URL url) {\n        return AccessController.doPrivileged((PrivilegedAction<Properties>) () -> {\n            // We must ensure that useCaches is set to false, as the\n            // default behavior of java is to cache file handles, and\n            // this \"locks\" files, preventing hot-redeploy on windows.\n            try {\n                final URLConnection connection = url.openConnection();\n                connection.setUseCaches(false);\n                try (InputStream stream = connection.getInputStream()) {\n                    if (stream != null) {\n                        final Properties props = new Properties();\n                        props.load(stream);\n                        return props;\n                    }\n                } catch (final IOException e) {\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\"Unable to close stream for URL \" + url);\n                    }\n                }\n            } catch (final IOException e) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\"Unable to read URL \" + url);\n                }\n            }\n\n            return null;\n        });\n    }\n\n    /**\n     * Given a file name, return an enumeration of URLs pointing to\n     * all the occurrences of that file name in the classpath.\n     * <p>\n     * This is just like ClassLoader.getResources except that the\n     * operation is done under an AccessController so that this method will\n     * succeed when this jarfile is privileged but the caller is not.\n     * This method must therefore remain private to avoid security issues.\n     * <p>\n     * If no instances are found, an Enumeration is returned whose\n     * hasMoreElements method returns false (ie an \"empty\" enumeration).\n     * If resources could not be listed for some reason, null is returned.\n     */\n    private static Enumeration<URL> getResources(final ClassLoader loader, final String name) {\n        return AccessController.doPrivileged((PrivilegedAction<Enumeration<URL>>) () -> {\n            try {\n                if (loader != null) {\n                    return loader.getResources(name);\n                }\n                return ClassLoader.getSystemResources(name);\n            } catch (final IOException e) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\"Exception while trying to find configuration file \" + name + \":\" + e.getMessage());\n                }\n                return null;\n            } catch (final NoSuchMethodError e) {\n                // we must be running on a 1.1 JVM which doesn't support\n                // ClassLoader.getSystemResources; just return null in\n                // this case.\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Read the specified system property, using an AccessController so that\n     * the property can be read if JCL has been granted the appropriate\n     * security rights even if the calling code has not.\n     * <p>\n     * Take care not to expose the value returned by this method to the\n     * calling application in any way; otherwise the calling app can use that\n     * info to access data that should not be available to it.\n     */\n    private static String getSystemProperty(final String key, final String def)\n            throws SecurityException {\n        return AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(key, def));\n    }\n\n    \n    /**\n     * Checks whether the supplied Throwable is one that needs to be\n     * re-thrown and ignores all others.\n     *\n     * The following errors are re-thrown:\n     * <ul>\n     *   <li>ThreadDeath<\/li>\n     *   <li>VirtualMachineError<\/li>\n     * <\/ul>\n     *\n     * @param t the Throwable to check\n     */\n    protected static void handleThrowable(final Throwable t) {\n        if (t instanceof ThreadDeath) {\n            throw (ThreadDeath) t;\n        }\n        if (t instanceof VirtualMachineError) {\n            throw (VirtualMachineError) t;\n        }\n        // All other instances of Throwable will be silently ignored\n    }\n\n    /**\n     * Determines whether the given class actually implements {@code LogFactory}.\n     * Diagnostic information is also logged.\n     * <p>\n     * <strong>Usage:<\/strong> to diagnose whether a classloader conflict is the cause\n     * of incompatibility. The test used is whether the class is assignable from\n     * the {@code LogFactory} class loaded by the class's classloader.\n     * @param logFactoryClass {@code Class} which may implement {@code LogFactory}\n     * @return true if the {@code logFactoryClass} does extend\n     * {@code LogFactory} when that class is loaded via the same\n     * classloader that loaded the {@code logFactoryClass}.\n     */\n    private static boolean implementsLogFactory(final Class logFactoryClass) {\n        boolean implementsLogFactory = false;\n        if (logFactoryClass != null) {\n            try {\n                final ClassLoader logFactoryClassLoader = logFactoryClass.getClassLoader();\n                if (logFactoryClassLoader == null) {\n                    logDiagnostic(\"[CUSTOM LOG FACTORY] was loaded by the boot classloader\");\n                } else {\n                    logHierarchy(\"[CUSTOM LOG FACTORY] \", logFactoryClassLoader);\n                    final Class factoryFromCustomLoader = Class.forName(\"org.apache.commons.logging.LogFactory\", false, logFactoryClassLoader);\n                    implementsLogFactory = factoryFromCustomLoader.isAssignableFrom(logFactoryClass);\n                    if (implementsLogFactory) {\n                        logDiagnostic(\n                                \"[CUSTOM LOG FACTORY] \" + logFactoryClass.getName() + \" implements LogFactory but was loaded by an incompatible classloader.\");\n                    } else {\n                        logDiagnostic(\"[CUSTOM LOG FACTORY] \" + logFactoryClass.getName() + \" does not implement LogFactory.\");\n                    }\n                }\n            } catch (final SecurityException e) {\n                //\n                // The application is running within a hostile security environment.\n                // This will make it very hard to diagnose issues with JCL.\n                // Consider running less securely whilst debugging this issue.\n                //\n                logDiagnostic(\"[CUSTOM LOG FACTORY] SecurityException caught trying to determine whether \"\n                        + \"the compatibility was caused by a class loader conflict: \" + e.getMessage());\n            } catch (final LinkageError e) {\n                //\n                // This should be an unusual circumstance.\n                // LinkageError's usually indicate that a dependent class has incompatibly changed.\n                // Another possibility may be an exception thrown by an initializer.\n                // Time for a clean rebuild?\n                //\n                logDiagnostic(\"[CUSTOM LOG FACTORY] LinkageError caught trying to determine whether \"\n                        + \"the compatibility was caused by a class loader conflict: \" + e.getMessage());\n            } catch (final ClassNotFoundException e) {\n                //\n                // LogFactory cannot be loaded by the classloader which loaded the custom factory implementation.\n                // The custom implementation is not viable until this is corrected.\n                // Ensure that the JCL jar and the custom class are available from the same classloader.\n                // Running with diagnostics on should give information about the classloaders used\n                // to load the custom factory.\n                //\n                logDiagnostic(\"[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by the class loader which loaded \"\n                        + \"the custom LogFactory implementation. Is the custom factory in the right class loader?\");\n            }\n        }\n        return implementsLogFactory;\n    }\n\n    /**\n     * Determines whether the user wants internal diagnostic output. If so,\n     * returns an appropriate writer object. Users can enable diagnostic\n     * output by setting the system property named {@link #DIAGNOSTICS_DEST_PROPERTY} to\n     * a file name, or the special values STDOUT or STDERR.\n     */\n    private static PrintStream initDiagnostics() {\n        String dest;\n        try {\n            dest = getSystemProperty(DIAGNOSTICS_DEST_PROPERTY, null);\n            if (dest == null) {\n                return null;\n            }\n        } catch (final SecurityException ex) {\n            // We must be running in some very secure environment.\n            // We just have to assume output is not wanted..\n            return null;\n        }\n\n        if (dest.equals(\"STDOUT\")) {\n            return System.out;\n        }\n        if (dest.equals(\"STDERR\")) {\n            return System.err;\n        }\n        try {\n            // open the file in append mode\n            final FileOutputStream fos = new FileOutputStream(dest, true);\n            return new PrintStream(fos);\n        } catch (final IOException ex) {\n            // We should report this to the user - but how?\n            return null;\n        }\n    }\n\n    private static boolean isClassAvailable(final String className, final ClassLoader classLoader) {\n        final ClassLoader loader = LogFactory.class.getClassLoader();\n        logDiagnostic(\"Checking if class '\" + className + \"' is available in class loader \" + objectId(loader));\n        try {\n            Class.forName(className, true, classLoader);\n            return true;\n        } catch (final ClassNotFoundException | LinkageError e) {\n            logDiagnostic(\"Failed to load class '\" + className + \"' from class loader \" + objectId(loader) + \": \" + e.getMessage());\n        }\n        return false;\n    }\n\n    /**\n     * Indicates true if the user has enabled internal logging.\n     * <p>\n     * By the way, sorry for the incorrect grammar, but calling this method\n     * areDiagnosticsEnabled just isn't java beans style.\n     *\n     * @return true if calls to logDiagnostic will have any effect.\n     * @since 1.1\n     */\n    protected static boolean isDiagnosticsEnabled() {\n        return DIAGNOSTICS_STREAM != null;\n    }\n\n    /**\n     * Generate useful diagnostics regarding the classloader tree for\n     * the specified class.\n     * <p>\n     * As an example, if the specified class was loaded via a webapp's\n     * classloader, then you may get the following output:\n     * <pre>\n     * Class com.acme.Foo was loaded via classloader 11111\n     * ClassLoader tree: 11111 -> 22222 (SYSTEM) -> 33333 -> BOOT\n     * <\/pre>\n     * <p>\n     * This method returns immediately if isDiagnosticsEnabled()\n     * returns false.\n     *\n     * @param clazz is the class whose classloader + tree are to be\n     * output.\n     */\n    private static void logClassLoaderEnvironment(final Class<?> clazz) {\n        if (!isDiagnosticsEnabled()) {\n            return;\n        }\n\n        try {\n            // Deliberately use System.getProperty here instead of getSystemProperty; if\n            // the overall security policy for the calling application forbids access to\n            // these variables then we do not want to output them to the diagnostic stream.\n            logDiagnostic(\"[ENV] Extension directories (java.ext.dir): \" + System.getProperty(\"java.ext.dir\"));\n            logDiagnostic(\"[ENV] Application classpath (java.class.path): \" + System.getProperty(\"java.class.path\"));\n        } catch (final SecurityException ex) {\n            logDiagnostic(\"[ENV] Security setting prevent interrogation of system classpaths.\");\n        }\n\n        final String className = clazz.getName();\n        ClassLoader classLoader;\n\n        try {\n            classLoader = getClassLoader(clazz);\n        } catch (final SecurityException ex) {\n            // not much useful diagnostics we can print here!\n            logDiagnostic(\"[ENV] Security forbids determining the classloader for \" + className);\n            return;\n        }\n\n        logDiagnostic(\"[ENV] Class \" + className + \" was loaded via classloader \" + objectId(classLoader));\n        logHierarchy(\"[ENV] Ancestry of classloader which loaded \" + className + \" is \", classLoader);\n    }\n\n    /**\n     * Write the specified message to the internal logging destination.\n     * <p>\n     * Note that this method is private; concrete subclasses of this class\n     * should not call it because the diagnosticPrefix string this\n     * method puts in front of all its messages is LogFactory@....,\n     * while subclasses should put SomeSubClass@...\n     * <p>\n     * Subclasses should instead compute their own prefix, then call\n     * logRawDiagnostic. Note that calling isDiagnosticsEnabled is\n     * fine for subclasses.\n     * <p>\n     * Note that it is safe to call this method before initDiagnostics\n     * is called; any output will just be ignored (as isDiagnosticsEnabled\n     * will return false).\n     *\n     * @param msg is the diagnostic message to be output.\n     */\n    private static void logDiagnostic(final String msg) {\n        if (DIAGNOSTICS_STREAM != null) {\n            DIAGNOSTICS_STREAM.print(diagnosticPrefix);\n            DIAGNOSTICS_STREAM.println(msg);\n            DIAGNOSTICS_STREAM.flush();\n        }\n    }\n\n    /**\n     * Logs diagnostic messages about the given classloader\n     * and it's hierarchy. The prefix is prepended to the message\n     * and is intended to make it easier to understand the logs.\n     * @param prefix\n     * @param classLoader\n     */\n    private static void logHierarchy(final String prefix, ClassLoader classLoader) {\n        if (!isDiagnosticsEnabled()) {\n            return;\n        }\n        ClassLoader systemClassLoader;\n        if (classLoader != null) {\n            final String classLoaderString = classLoader.toString();\n            logDiagnostic(prefix + objectId(classLoader) + \" == '\" + classLoaderString + \"'\");\n        }\n\n        try {\n            systemClassLoader = ClassLoader.getSystemClassLoader();\n        } catch (final SecurityException ex) {\n            logDiagnostic(prefix + \"Security forbids determining the system classloader.\");\n            return;\n        }\n        if (classLoader != null) {\n            final StringBuilder buf = new StringBuilder(prefix + \"ClassLoader tree:\");\n            for(;;) {\n                buf.append(objectId(classLoader));\n                if (classLoader == systemClassLoader) {\n                    buf.append(\" (SYSTEM) \");\n                }\n\n                try {\n                    classLoader = classLoader.getParent();\n                } catch (final SecurityException ex) {\n                    buf.append(\" --> SECRET\");\n                    break;\n                }\n\n                buf.append(\" --> \");\n                if (classLoader == null) {\n                    buf.append(\"BOOT\");\n                    break;\n                }\n            }\n            logDiagnostic(buf.toString());\n        }\n    }\n\n    /**\n     * Write the specified message to the internal logging destination.\n     *\n     * @param msg is the diagnostic message to be output.\n     * @since 1.1\n     */\n    protected static final void logRawDiagnostic(final String msg) {\n        if (DIAGNOSTICS_STREAM != null) {\n            DIAGNOSTICS_STREAM.println(msg);\n            DIAGNOSTICS_STREAM.flush();\n        }\n    }\n\n    /**\n     * Method provided for backwards compatibility; see newFactory version that\n     * takes 3 parameters.\n     * <p>\n     * This method would only ever be called in some rather odd situation.\n     * Note that this method is static, so overriding in a subclass doesn't\n     * have any effect unless this method is called from a method in that\n     * subclass. However this method only makes sense to use from the\n     * getFactory method, and as that is almost always invoked via\n     * LogFactory.getFactory, any custom definition in a subclass would be\n     * pointless. Only a class with a custom getFactory method, then invoked\n     * directly via CustomFactoryImpl.getFactory or similar would ever call\n     * this. Anyway, it's here just in case, though the \"managed class loader\"\n     * value output to the diagnostics will not report the correct value.\n     * <\/p>\n     *\n     * @param factoryClass factory class.\n     * @param classLoader class loader.\n     * @return a LogFactory.\n     */\n    protected static LogFactory newFactory(final String factoryClass,\n                                           final ClassLoader classLoader) {\n        return newFactory(factoryClass, classLoader, null);\n    }\n\n    /**\n     * Return a new instance of the specified {@code LogFactory} implementation class, loaded by the specified class loader. If that fails, try the class loader\n     * used to load this (abstract) LogFactory.\n     * <p>\n     * <b>ClassLoader conflicts<\/b>\n     * <\/p>\n     * <p>\n     * Note that there can be problems if the specified ClassLoader is not the same as the classloader that loaded this class, that is, when loading a concrete\n     * LogFactory subclass via a context classloader.\n     * <\/p>\n     * <p>\n     * The problem is the same one that can occur when loading a concrete Log subclass via a context classloader.\n     * <\/p>\n     * <p>\n     * The problem occurs when code running in the context classloader calls class X which was loaded via a parent classloader, and class X then calls\n     * LogFactory.getFactory (either directly or via LogFactory.getLog). Because class X was loaded via the parent, it binds to LogFactory loaded via the\n     * parent. When the code in this method finds some LogFactoryYYYY class in the child (context) classloader, and there also happens to be a LogFactory class\n     * defined in the child classloader, then LogFactoryYYYY will be bound to LogFactory@childloader. It cannot be cast to LogFactory@parentloader, that is,\n     * this method cannot return the object as the desired type. Note that it doesn't matter if the LogFactory class in the child classloader is identical to\n     * the LogFactory class in the parent classloader, they are not compatible.\n     * <\/p>\n     * <p>\n     * The solution taken here is to simply print out an error message when this occurs then throw an exception. The deployer of the application must ensure\n     * they remove all occurrences of the LogFactory class from the child classloader in order to resolve the issue. Note that they do not have to move the\n     * custom LogFactory subclass; that is ok as long as the only LogFactory class it can find to bind to is in the parent classloader.\n     * <\/p>\n     *\n     * @param factoryClass       Fully qualified name of the {@code LogFactory} implementation class\n     * @param classLoader        ClassLoader from which to load this class\n     * @param contextClassLoader is the context that this new factory will manage logging for.\n     * @return a new instance of the specified {@code LogFactory}.\n     * @throws LogConfigurationException if a suitable instance cannot be created\n     * @since 1.1\n     */\n    protected static LogFactory newFactory(final String factoryClass,\n                                           final ClassLoader classLoader,\n                                           final ClassLoader contextClassLoader)\n        throws LogConfigurationException {\n        // Note that any unchecked exceptions thrown by the createFactory\n        // method will propagate out of this method; in particular a\n        // ClassCastException can be thrown.\n        final Object result = AccessController.doPrivileged(\n            (PrivilegedAction) () -> createFactory(factoryClass, classLoader));\n\n        if (result instanceof LogConfigurationException) {\n            final LogConfigurationException ex = (LogConfigurationException) result;\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"An error occurred while loading the factory class:\" + ex.getMessage());\n            }\n            throw ex;\n        }\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"Created object \" + objectId(result) + \" to manage classloader \" +\n                          objectId(contextClassLoader));\n        }\n        return (LogFactory) result;\n    }\n\n    /**\n     * Returns a string that uniquely identifies the specified object, including\n     * its class.\n     * <p>\n     * The returned string is of form \"className@hashCode\", that is, is the same as\n     * the return value of the Object.toString() method, but works even when\n     * the specified object's class has overridden the toString method.\n     * <\/p>\n     *\n     * @param o may be null.\n     * @return a string of form className@hashCode, or \"null\" if param o is null.\n     * @since 1.1\n     */\n    public static String objectId(final Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.getClass().getName() + \"@\" + System.identityHashCode(o);\n    }\n\n    /**\n     * Release any internal references to previously created {@link LogFactory}\n     * instances that have been associated with the specified class loader\n     * (if any), after calling the instance method {@code release()} on\n     * each of them.\n     *\n     * @param classLoader ClassLoader for which to release the LogFactory\n     */\n    public static void release(final ClassLoader classLoader) {\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"Releasing factory for classloader \" + objectId(classLoader));\n        }\n        // factories is not final and could be replaced in this block.\n        final Hashtable<ClassLoader, LogFactory> factories = LogFactory.factories;\n        synchronized (factories) {\n            if (classLoader == null) {\n                if (nullClassLoaderFactory != null) {\n                    nullClassLoaderFactory.release();\n                    nullClassLoaderFactory = null;\n                }\n            } else {\n                final LogFactory factory = factories.get(classLoader);\n                if (factory != null) {\n                    factory.release();\n                    factories.remove(classLoader);\n                }\n            }\n        }\n    }\n\n    /**\n     * Release any internal references to previously created {@link LogFactory}\n     * instances, after calling the instance method {@code release()} on\n     * each of them.  This is useful in environments like servlet containers,\n     * which implement application reloading by throwing away a ClassLoader.\n     * Dangling references to objects in that class loader would prevent\n     * garbage collection.\n     */\n    public static void releaseAll() {\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"Releasing factory for all classloaders.\");\n        }\n        // factories is not final and could be replaced in this block.\n        final Hashtable<ClassLoader, LogFactory> factories = LogFactory.factories;\n        synchronized (factories) {\n            final Enumeration<LogFactory> elements = factories.elements();\n            while (elements.hasMoreElements()) {\n                final LogFactory element = elements.nextElement();\n                element.release();\n            }\n            factories.clear();\n\n            if (nullClassLoaderFactory != null) {\n                nullClassLoaderFactory.release();\n                nullClassLoaderFactory = null;\n            }\n        }\n    }\n\n    /** Utility method to safely trim a string. */\n    private static String trim(final String src) {\n        if (src == null) {\n            return null;\n        }\n        return src.trim();\n    }\n\n    /**\n     * Protected constructor that is not available for public use.\n     */\n    protected LogFactory() {\n    }\n\n    /**\n     * Return the configuration attribute with the specified name (if any),\n     * or {@code null} if there is no such attribute.\n     *\n     * @param name Name of the attribute to return\n     * @return the configuration attribute with the specified name.\n     */\n    public abstract Object getAttribute(String name);\n\n    /**\n     * Gets an array containing the names of all currently defined configuration attributes. If there are no such attributes, a zero length array is returned.\n     *\n     * @return an array containing the names of all currently defined configuration attributes\n     */\n    public abstract String[] getAttributeNames();\n\n    /**\n     * Convenience method to derive a name from the specified class and call {@code getInstance(String)} with it.\n     *\n     * @param clazz Class for which a suitable Log name will be derived\n     * @return a name from the specified class.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public abstract Log getInstance(Class<?> clazz) throws LogConfigurationException;\n\n    /**\n     * Constructs (if necessary) and return a {@code Log} instance, using the factory's current set of configuration attributes.\n     * <p>\n     * <strong>NOTE<\/strong> - Depending upon the implementation of the {@code LogFactory} you are using, the {@code Log} instance you are returned may or may\n     * not be local to the current application, and may or may not be returned again on a subsequent call with the same name argument.\n     * <\/p>\n     *\n     * @param name Logical name of the {@code Log} instance to be returned (the meaning of this name is only known to the underlying logging implementation that\n     *             is being wrapped)\n     * @return a {@code Log} instance.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public abstract Log getInstance(String name)\n        throws LogConfigurationException;\n\n    /**\n     * Release any internal references to previously created {@link Log}\n     * instances returned by this factory.  This is useful in environments\n     * like servlet containers, which implement application reloading by\n     * throwing away a ClassLoader.  Dangling references to objects in that\n     * class loader would prevent garbage collection.\n     */\n    public abstract void release();\n\n    /**\n     * Remove any configuration attribute associated with the specified name.\n     * If there is no such attribute, no action is taken.\n     *\n     * @param name Name of the attribute to remove\n     */\n    public abstract void removeAttribute(String name);\n    \n    /**\n     * Sets the configuration attribute with the specified name.  Calling\n     * this with a {@code null} value is equivalent to calling\n     * {@code removeAttribute(name)}.\n     *\n     * @param name Name of the attribute to set\n     * @param value Value of the attribute to set, or {@code null}\n     *  to remove any setting for this attribute\n     */\n    public abstract void setAttribute(String name, Object value);\n\n    //\n    // We can't do this in the class constructor, as there are many\n    // static methods on this class that can be called before any\n    // LogFactory instances are created, and they depend upon this\n    // stuff having been set up.\n    //\n    // Note that this block must come after any variable declarations used\n    // by any methods called from this block, as we want any static initializer\n    // associated with the variable to run first. If static initializers for\n    // variables run after this code, then (a) their value might be needed\n    // by methods called from here, and (b) they might *override* any value\n    // computed here!\n    //\n    // So the wisest thing to do is just to place this code at the very end\n    // of the class file.\n\n    static {\n        // note: it's safe to call methods before initDiagnostics (though\n        // diagnostic output gets discarded).\n        final ClassLoader thisClassLoader = getClassLoader(LogFactory.class);\n        thisClassLoaderRef = new WeakReference<>(thisClassLoader);\n        // In order to avoid confusion where multiple instances of JCL are\n        // being used via different classloaders within the same app, we\n        // ensure each logged message has a prefix of form\n        // [LogFactory from classloader OID]\n        //\n        // Note that this prefix should be kept consistent with that\n        // in LogFactoryImpl. However here we don't need to output info\n        // about the actual *instance* of LogFactory, as all methods that\n        // output diagnostics from this class are static.\n        String classLoaderName;\n        try {\n            if (thisClassLoader == null) {\n                classLoaderName = \"BOOTLOADER\";\n            } else {\n                classLoaderName = objectId(thisClassLoader);\n            }\n        } catch (final SecurityException e) {\n            classLoaderName = \"UNKNOWN\";\n        }\n        diagnosticPrefix = \"[LogFactory from \" + classLoaderName + \"] \";\n        DIAGNOSTICS_STREAM = initDiagnostics();\n        logClassLoaderEnvironment(LogFactory.class);\n        factories = createFactoryStore();\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"BOOTSTRAP COMPLETED\");\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.logging;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.lang.ref.WeakReference;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceConfigurationError;\nimport java.util.ServiceLoader;\n\n/**\n * Factory for creating {@link Log} instances, with discovery and\n * configuration features similar to that employed by standard Java APIs\n * such as JAXP.\n * <p>\n * <strong>IMPLEMENTATION NOTE<\/strong> - This implementation is heavily\n * based on the SAXParserFactory and DocumentBuilderFactory implementations\n * (corresponding to the JAXP pluggability APIs) found in Apache Xerces.\n */\npublic abstract class LogFactory {\n    // Implementation note re AccessController usage\n    //\n    // It is important to keep code invoked via an AccessController to small\n    // auditable blocks. Such code must carefully evaluate all user input\n    // (parameters, system properties, config file contents, etc). As an\n    // example, a Log implementation should not write to its logfile\n    // with an AccessController anywhere in the call stack, otherwise an\n    // insecure application could configure the log implementation to write\n    // to a protected file using the privileges granted to JCL rather than\n    // to the calling application.\n    //\n    // Under no circumstance should a non-private method return data that is\n    // retrieved via an AccessController. That would allow an insecure app\n    // to invoke that method and obtain data that it is not permitted to have.\n    //\n    // Invoking user-supplied code with an AccessController set is not a major\n    // issue (eg invoking the constructor of the class specified by\n    // HASHTABLE_IMPLEMENTATION_PROPERTY). That class will be in a different\n    // trust domain, and therefore must have permissions to do whatever it\n    // is trying to do regardless of the permissions granted to JCL. There is\n    // a slight issue in that untrusted code may point that environment var\n    // to another trusted library, in which case the code runs if both that\n    // lib and JCL have the necessary permissions even when the untrusted\n    // caller does not. That's a pretty hard route to exploit though.\n\n    \n    /**\n     * The name ({@code priority}) of the key in the config file used to\n     * specify the priority of that particular config file. The associated value\n     * is a floating-point number; higher values take priority over lower values.\n     */\n    public static final String PRIORITY_KEY = \"priority\";\n\n    /**\n     * The name ({@code use_tccl}) of the key in the config file used\n     * to specify whether logging classes should be loaded via the thread\n     * context class loader (TCCL), or not. By default, the TCCL is used.\n     */\n    public static final String TCCL_KEY = \"use_tccl\";\n\n    /**\n     * The name ({@code org.apache.commons.logging.LogFactory}) of the property\n     * used to identify the LogFactory implementation\n     * class name. This can be used as a system property, or as an entry in a\n     * configuration properties file.\n     */\n    public static final String FACTORY_PROPERTY = \"org.apache.commons.logging.LogFactory\";\n\n    private static final String FACTORY_LOG4J_API = \"org.apache.commons.logging.impl.Log4jApiLogFactory\";\n    private static final String LOG4J_API_LOGGER = \"org.apache.logging.log4j.Logger\";\n    private static final String LOG4J_TO_SLF4J_BRIDGE = \"org.apache.logging.slf4j.SLF4JProvider\";\n\n    private static final String FACTORY_SLF4J = \"org.apache.commons.logging.impl.Slf4jLogFactory\";\n    private static final String SLF4J_API_LOGGER = \"org.slf4j.Logger\";\n\n    /**\n     * The fully qualified class name of the fallback {@code LogFactory}\n     * implementation class to use, if no other can be found.\n     */\n    public static final String FACTORY_DEFAULT = \"org.apache.commons.logging.impl.LogFactoryImpl\";\n\n    /**\n     * The name ({@code commons-logging.properties}) of the properties file to search for.\n     */\n    public static final String FACTORY_PROPERTIES = \"commons-logging.properties\";\n\n    /**\n     * JDK1.3+ <a href=\"http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider\">\n     * 'Service Provider' specification<\/a>.\n     */\n    protected static final String SERVICE_ID =\n        \"META-INF/services/org.apache.commons.logging.LogFactory\";\n\n    /**\n     * The name ({@code org.apache.commons.logging.diagnostics.dest})\n     * of the property used to enable internal commons-logging\n     * diagnostic output, in order to get information on what logging\n     * implementations are being discovered, what classloaders they\n     * are loaded through, etc.\n     * <p>\n     * If a system property of this name is set then the value is\n     * assumed to be the name of a file. The special strings\n     * STDOUT or STDERR (case-sensitive) indicate output to\n     * System.out and System.err respectively.\n     * <p>\n     * Diagnostic logging should be used only to debug problematic\n     * configurations and should not be set in normal production use.\n     */\n    public static final String DIAGNOSTICS_DEST_PROPERTY =\n        \"org.apache.commons.logging.diagnostics.dest\";\n\n    /**\n     * When null (the usual case), no diagnostic output will be\n     * generated by LogFactory or LogFactoryImpl. When non-null,\n     * interesting events will be written to the specified object.\n     */\n    private static final PrintStream DIAGNOSTICS_STREAM;\n\n    /**\n     * A string that gets prefixed to every message output by the\n     * logDiagnostic method, so that users can clearly see which\n     * LogFactory class is generating the output.\n     */\n    private static final String diagnosticPrefix;\n\n    /**\n     * Setting this system property\n     * ({@code org.apache.commons.logging.LogFactory.HashtableImpl})\n     * value allows the {@code Hashtable} used to store\n     * classloaders to be substituted by an alternative implementation.\n     * <p>\n     * <strong>Note:<\/strong> {@code LogFactory} will print:\n     * <pre>\n     * [ERROR] LogFactory: Load of custom hashtable failed\n     * <\/pre>\n     * to system error and then continue using a standard Hashtable.\n     * <p>\n     * <strong>Usage:<\/strong> Set this property when Java is invoked\n     * and {@code LogFactory} will attempt to load a new instance\n     * of the given implementation class.\n     * For example, running the following ant scriplet:\n     * <pre>\n     *  &lt;java classname=\"${test.runner}\" fork=\"yes\" failonerror=\"${test.failonerror}\"&gt;\n     *     ...\n     *     &lt;sysproperty\n     *        key=\"org.apache.commons.logging.LogFactory.HashtableImpl\"\n     *        value=\"org.apache.commons.logging.AltHashtable\"/&gt;\n     *  &lt;/java&gt;\n     * <\/pre>\n     * will mean that {@code LogFactory} will load an instance of\n     * {@code org.apache.commons.logging.AltHashtable}.\n     * <p>\n     * A typical use case is to allow a custom\n     * Hashtable implementation using weak references to be substituted.\n     * This will allow classloaders to be garbage collected without\n     * the need to release them (on 1.3+ JVMs only, of course ;).\n     */\n    public static final String HASHTABLE_IMPLEMENTATION_PROPERTY =\n        \"org.apache.commons.logging.LogFactory.HashtableImpl\";\n\n    /** Name used to load the weak hashtable implementation by names. */\n    private static final String WEAK_HASHTABLE_CLASSNAME =\n        \"org.apache.commons.logging.impl.WeakHashtable\";\n\n    /**\n     * A reference to the classloader that loaded this class. This is the\n     * same as LogFactory.class.getClassLoader(). However computing this\n     * value isn't quite as simple as that, as we potentially need to use\n     * AccessControllers etc. It's more efficient to compute it once and\n     * cache it here.\n     */\n    private static final WeakReference<ClassLoader> thisClassLoaderRef;\n\n    /**\n     * Maximum number of {@link ServiceLoader} errors to ignore, while\n     * looking for an implementation.\n     */\n    private static final int MAX_BROKEN_SERVICES = 3;\n\n    \n    /**\n     * The previously constructed {@code LogFactory} instances, keyed by\n     * the {@code ClassLoader} with which it was created.\n     */\n    protected static Hashtable<ClassLoader, LogFactory> factories;\n\n    \n    /**\n     * Previously constructed {@code LogFactory} instance as in the\n     * {@code factories} map, but for the case where\n     * {@code getClassLoader} returns {@code null}.\n     * This can happen when:\n     * <ul>\n     * <li>using JDK1.1 and the calling code is loaded via the system\n     *  classloader (very common)<\/li>\n     * <li>using JDK1.2+ and the calling code is loaded via the boot\n     *  classloader (only likely for embedded systems work).<\/li>\n     * <\/ul>\n     * Note that {@code factories} is a <i>Hashtable<\/i> (not a HashMap),\n     * and hashtables don't allow null as a key.\n     * @deprecated since 1.1.2\n     */\n    @Deprecated\n    protected static volatile LogFactory nullClassLoaderFactory;\n\n    /**\n     * Remember this factory, so later calls to LogFactory.getCachedFactory\n     * can return the previously created object (together with all its\n     * cached Log objects).\n     *\n     * @param classLoader should be the current context classloader. Note that\n     *  this can be null under some circumstances; this is ok.\n     * @param factory should be the factory to cache. This should never be null.\n     */\n    private static void cacheFactory(final ClassLoader classLoader, final LogFactory factory) {\n        // Ideally we would assert(factory != null) here. However reporting\n        // errors from within a logging implementation is a little tricky!\n\n        if (factory != null) {\n            if (classLoader == null) {\n                nullClassLoaderFactory = factory;\n            } else {\n                factories.put(classLoader, factory);\n            }\n        }\n    }\n\n    /**\n     * Implements the operations described in the Javadoc for newFactory.\n     *\n     * @param factoryClassName Factory class.\n     * @param classLoader      used to load the specified factory class. This is expected to be either the TCCL or the class loader which loaded this class.\n     *                         Note that the class loader which loaded this class might be \"null\" (for example, the boot loader) for embedded systems.\n     * @return either a LogFactory object or a LogConfigurationException object.\n     * @since 1.1\n     */\n    protected static Object createFactory(final String factoryClassName, final ClassLoader classLoader) {\n        // This will be used to diagnose bad configurations\n        // and allow a useful message to be sent to the user\n        Class logFactoryClass = null;\n        try {\n            if (classLoader != null) {\n                try {\n                    // First the given class loader param (thread class loader)\n\n                    // Warning: must typecast here & allow exception\n                    // to be generated/caught & recast properly.\n                    logFactoryClass = classLoader.loadClass(factoryClassName);\n                    if (LogFactory.class.isAssignableFrom(logFactoryClass)) {\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"Loaded class \" + logFactoryClass.getName() + \" from classloader \" + objectId(classLoader));\n                        }\n                    } else //\n                    // This indicates a problem with the ClassLoader tree.\n                    // An incompatible ClassLoader was used to load the\n                    // implementation.\n                    // As the same classes\n                    // must be available in multiple class loaders,\n                    // it is very likely that multiple JCL jars are present.\n                    // The most likely fix for this\n                    // problem is to remove the extra JCL jars from the\n                    // ClassLoader hierarchy.\n                    //\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\"Factory class \" + logFactoryClass.getName() + \" loaded from classloader \" + objectId(logFactoryClass.getClassLoader())\n                                + \" does not extend '\" + LogFactory.class.getName() + \"' as loaded by this classloader.\");\n                        logHierarchy(\"[BAD CL TREE] \", classLoader);\n                    }\n\n                    return logFactoryClass.getConstructor().newInstance();\n\n                } catch (final ClassNotFoundException ex) {\n                    if (classLoader == thisClassLoaderRef.get()) {\n                        // Nothing more to try, onwards.\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"Unable to locate any class called '\" + factoryClassName + \"' via classloader \" + objectId(classLoader));\n                        }\n                        throw ex;\n                    }\n                    // ignore exception, continue\n                } catch (final NoClassDefFoundError e) {\n                    if (classLoader == thisClassLoaderRef.get()) {\n                        // Nothing more to try, onwards.\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"Class '\" + factoryClassName + \"' cannot be loaded\" + \" via classloader \" + objectId(classLoader)\n                                    + \" - it depends on some other class that cannot be found.\");\n                        }\n                        throw e;\n                    }\n                    // ignore exception, continue\n                } catch (final ClassCastException e) {\n                    if (classLoader == thisClassLoaderRef.get()) {\n                        // There's no point in falling through to the code below that\n                        // tries again with thisClassLoaderRef, because we've just tried\n                        // loading with that loader (not the TCCL). Just throw an\n                        // appropriate exception here.\n\n                        final boolean implementsLogFactory = implementsLogFactory(logFactoryClass);\n\n                        //\n                        // Construct a good message: users may not actual expect that a custom implementation\n                        // has been specified. Several well known containers use this mechanism to adapt JCL\n                        // to their native logging system.\n                        //\n                        final StringBuilder msg = new StringBuilder();\n                        msg.append(\"The application has specified that a custom LogFactory implementation \");\n                        msg.append(\"should be used but Class '\");\n                        msg.append(factoryClassName);\n                        msg.append(\"' cannot be converted to '\");\n                        msg.append(LogFactory.class.getName());\n                        msg.append(\"'. \");\n                        if (implementsLogFactory) {\n                            msg.append(\"The conflict is caused by the presence of multiple LogFactory classes \");\n                            msg.append(\"in incompatible classloaders. \");\n                            msg.append(\"Background can be found in http://commons.apache.org/logging/tech.html. \");\n                            msg.append(\"If you have not explicitly specified a custom LogFactory then it is likely \");\n                            msg.append(\"that the container has set one without your knowledge. \");\n                            msg.append(\"In this case, consider using the commons-logging-adapters.jar file or \");\n                            msg.append(\"specifying the standard LogFactory from the command line. \");\n                        } else {\n                            msg.append(\"Please check the custom implementation. \");\n                        }\n                        msg.append(\"Help can be found @http://commons.apache.org/logging/troubleshooting.html.\");\n\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(msg.toString());\n                        }\n\n                        throw new ClassCastException(msg.toString());\n                    }\n\n                    // Ignore exception, continue. Presumably the classloader was the\n                    // TCCL; the code below will try to load the class via thisClassLoaderRef.\n                    // This will handle the case where the original calling class is in\n                    // a shared classpath but the TCCL has a copy of LogFactory and the\n                    // specified LogFactory implementation; we will fall back to using the\n                    // LogFactory implementation from the same classloader as this class.\n                    //\n                    // Issue: this doesn't handle the reverse case, where this LogFactory\n                    // is in the webapp, and the specified LogFactory implementation is\n                    // in a shared classpath. In that case:\n                    // (a) the class really does implement LogFactory (bad log msg above)\n                    // (b) the fallback code will result in exactly the same problem.\n                }\n            }\n\n            /*\n             * At this point, either classLoader == null, OR classLoader was unable to load factoryClass.\n             *\n             * In either case, we call Class.forName, which is equivalent to LogFactory.class.getClassLoader().load(name), that is, we ignore the classloader\n             * parameter the caller passed, and fall back to trying the classloader associated with this class. See the javadoc for the newFactory method for\n             * more info on the consequences of this.\n             *\n             * Notes: * LogFactory.class.getClassLoader() may return 'null' if LogFactory is loaded by the bootstrap classloader.\n             */\n            // Warning: must typecast here & allow exception\n            // to be generated/caught & recast properly.\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\n                        \"Unable to load factory class via classloader \" + objectId(classLoader) + \" - trying the classloader associated with this LogFactory.\");\n            }\n            logFactoryClass = Class.forName(factoryClassName);\n            return logFactoryClass.newInstance();\n        } catch (final Exception e) {\n            // Check to see if we've got a bad configuration\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"Unable to create LogFactory instance.\");\n            }\n            if (logFactoryClass != null && !LogFactory.class.isAssignableFrom(logFactoryClass)) {\n                return new LogConfigurationException(\"The chosen LogFactory implementation does not extend LogFactory.\" + \" Please check your configuration.\",\n                        e);\n            }\n            return new LogConfigurationException(e);\n        }\n    }\n\n    /**\n     * Create the hashtable which will be used to store a map of\n     * (context-classloader -> logfactory-object). Version 1.2+ of Java\n     * supports \"weak references\", allowing a custom Hashtable class\n     * to be used which uses only weak references to its keys. Using weak\n     * references can fix memory leaks on webapp unload in some cases (though\n     * not all). Version 1.1 of Java does not support weak references, so we\n     * must dynamically determine which we are using. And just for fun, this\n     * code also supports the ability for a system property to specify an\n     * arbitrary Hashtable implementation name.\n     * <p>\n     * Note that the correct way to ensure no memory leaks occur is to ensure\n     * that LogFactory.release(contextClassLoader) is called whenever a\n     * webapp is undeployed.\n     */\n    private static Hashtable<ClassLoader, LogFactory> createFactoryStore() {\n        Hashtable<ClassLoader, LogFactory> result = null;\n        String storeImplementationClass;\n        try {\n            storeImplementationClass = getSystemProperty(HASHTABLE_IMPLEMENTATION_PROPERTY, null);\n        } catch (final SecurityException ex) {\n            // Permissions don't allow this to be accessed. Default to the \"modern\"\n            // weak hashtable implementation if it is available.\n            storeImplementationClass = null;\n        }\n\n        if (storeImplementationClass == null) {\n            storeImplementationClass = WEAK_HASHTABLE_CLASSNAME;\n        }\n        try {\n            final Class<Hashtable<ClassLoader, LogFactory>> implementationClass = (Class<Hashtable<ClassLoader, LogFactory>>) Class\n                    .forName(storeImplementationClass);\n            result = implementationClass.getConstructor().newInstance();\n        } catch (final Throwable t) {\n            handleThrowable(t); // may re-throw t\n\n            // ignore\n            if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) {\n                // if the user's trying to set up a custom implementation, give a clue\n                if (isDiagnosticsEnabled()) {\n                    // use internal logging to issue the warning\n                    logDiagnostic(\"[ERROR] LogFactory: Load of custom Hashtable failed\");\n                } else {\n                    // we *really* want this output, even if diagnostics weren't\n                    // explicitly enabled by the user.\n                    System.err.println(\"[ERROR] LogFactory: Load of custom Hashtable failed\");\n                }\n            }\n        }\n        if (result == null) {\n            result = new Hashtable<>();\n        }\n        return result;\n    }\n\n    /**\n     * Return the thread context class loader if available; otherwise return null.\n     * <p>\n     * Most/all code should call getContextClassLoaderInternal rather than\n     * calling this method directly.\n     * <p>\n     * The thread context class loader is available for JDK 1.2\n     * or later, if certain security conditions are met.\n     * <p>\n     * Note that no internal logging is done within this method because\n     * this method is called every time LogFactory.getLogger() is called,\n     * and we don't want too much output generated here.\n     *\n     * @throws LogConfigurationException if a suitable class loader\n     *  cannot be identified.\n     * @return the thread's context classloader or {@code null} if the java security\n     *  policy forbids access to the context classloader from one of the classes\n     *  in the current call stack.\n     * @since 1.1\n     */\n    protected static ClassLoader directGetContextClassLoader() throws LogConfigurationException {\n        ClassLoader classLoader = null;\n\n        try {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        } catch (final SecurityException ignore) {\n            //\n            // getContextClassLoader() throws SecurityException when\n            // the context class loader isn't an ancestor of the\n            // calling class's class loader, or if security\n            // permissions are restricted.\n            //\n            // We ignore this exception to be consistent with the previous\n            // behavior (e.g. 1.1.3 and earlier).\n            //\n            // ignore\n        }\n\n        // Return the selected class loader\n        return classLoader;\n    }\n\n    /**\n     * Check cached factories (keyed by contextClassLoader)\n     *\n     * @param contextClassLoader is the context classloader associated\n     * with the current thread. This allows separate LogFactory objects\n     * per component within a container, provided each component has\n     * a distinct context classloader set. This parameter may be null\n     * in JDK1.1, and in embedded systems where jcl-using code is\n     * placed in the bootclasspath.\n     *\n     * @return the factory associated with the specified classloader if\n     *  one has previously been created, or null if this is the first time\n     *  we have seen this particular classloader.\n     */\n    private static LogFactory getCachedFactory(final ClassLoader contextClassLoader) {\n        if (contextClassLoader == null) {\n            // We have to handle this specially, as factories is a Hashtable\n            // and those don't accept null as a key value.\n            //\n            // nb: nullClassLoaderFactory might be null. That's ok.\n            return nullClassLoaderFactory;\n        }\n        return factories.get(contextClassLoader);\n    }\n\n    \n    /**\n     * Safely get access to the classloader for the specified class.\n     * <p>\n     * Theoretically, calling getClassLoader can throw a security exception,\n     * and so should be done under an AccessController in order to provide\n     * maximum flexibility. However in practice people don't appear to use\n     * security policies that forbid getClassLoader calls. So for the moment\n     * all code is written to call this method rather than Class.getClassLoader,\n     * so that we could put AccessController stuff in this method without any\n     * disruption later if we need to.\n     * <\/p>\n     * <p>\n     * Even when using an AccessController, however, this method can still\n     * throw SecurityException. Commons Logging basically relies on the\n     * ability to access classloaders. A policy that forbids all\n     * classloader access will also prevent commons-logging from working:\n     * currently this method will throw an exception preventing the entire app\n     * from starting up. Maybe it would be good to detect this situation and\n     * just disable all commons-logging? Not high priority though - as stated\n     * above, security policies that prevent classloader access aren't common.\n     * <\/p>\n     * <p>\n     * Note that returning an object fetched via an AccessController would\n     * technically be a security flaw anyway; untrusted code that has access\n     * to a trusted JCL library could use it to fetch the classloader for\n     * a class even when forbidden to do so directly.\n     * <\/p>\n     *\n     * @param clazz Class.\n     * @return a ClassLoader.\n     *\n     * @since 1.1\n     */\n    protected static ClassLoader getClassLoader(final Class<?> clazz) {\n        try {\n            return clazz.getClassLoader();\n        } catch (final SecurityException ex) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"Unable to get classloader for class '\" + clazz + \"' due to security restrictions - \" + ex.getMessage());\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Locate a user-provided configuration file.\n     * <p>\n     * The classpath of the specified classLoader (usually the context classloader)\n     * is searched for properties files of the specified name. If none is found,\n     * null is returned. If more than one is found, then the file with the greatest\n     * value for its PRIORITY property is returned. If multiple files have the\n     * same PRIORITY value then the first in the classpath is returned.\n     * <p>\n     * This differs from the 1.0.x releases; those always use the first one found.\n     * However as the priority is a new field, this change is backwards compatible.\n     * <p>\n     * The purpose of the priority field is to allow a webserver administrator to\n     * override logging settings in all webapps by placing a commons-logging.properties\n     * file in a shared classpath location with a priority > 0; this overrides any\n     * commons-logging.properties files without priorities which are in the\n     * webapps. Webapps can also use explicit priorities to override a configuration\n     * file in the shared classpath if needed.\n     */\n    private static Properties getConfigurationFile(final ClassLoader classLoader, final String fileName) {\n        Properties props = null;\n        double priority = 0.0;\n        URL propsUrl = null;\n        try {\n            final Enumeration<URL> urls = getResources(classLoader, fileName);\n\n            if (urls == null) {\n                return null;\n            }\n\n            while (urls.hasMoreElements()) {\n                final URL url = urls.nextElement();\n\n                final Properties newProps = getProperties(url);\n                if (newProps != null) {\n                    if (props == null) {\n                        propsUrl = url;\n                        props = newProps;\n                        final String priorityStr = props.getProperty(PRIORITY_KEY);\n                        priority = 0.0;\n                        if (priorityStr != null) {\n                            priority = Double.parseDouble(priorityStr);\n                        }\n\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"[LOOKUP] Properties file found at '\" + url + \"'\" + \" with priority \" + priority);\n                        }\n                    } else {\n                        final String newPriorityStr = newProps.getProperty(PRIORITY_KEY);\n                        double newPriority = 0.0;\n                        if (newPriorityStr != null) {\n                            newPriority = Double.parseDouble(newPriorityStr);\n                        }\n\n                        if (newPriority > priority) {\n                            if (isDiagnosticsEnabled()) {\n                                logDiagnostic(\"[LOOKUP] Properties file at '\" + url + \"'\" + \" with priority \" + newPriority + \" overrides file at '\" + propsUrl\n                                        + \"'\" + \" with priority \" + priority);\n                            }\n\n                            propsUrl = url;\n                            props = newProps;\n                            priority = newPriority;\n                        } else if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"[LOOKUP] Properties file at '\" + url + \"'\" + \" with priority \" + newPriority + \" does not override file at '\"\n                                    + propsUrl + \"'\" + \" with priority \" + priority);\n                        }\n                    }\n\n                }\n            }\n        } catch (final SecurityException e) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"SecurityException thrown while trying to find/read config files.\");\n            }\n        }\n\n        if (isDiagnosticsEnabled()) {\n            if (props == null) {\n                logDiagnostic(\"[LOOKUP] No properties file of name '\" + fileName + \"' found.\");\n            } else {\n                logDiagnostic(\"[LOOKUP] Properties file of name '\" + fileName + \"' found at '\" + propsUrl + '\"');\n            }\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the current context classloader.\n     * <p>\n     * In versions prior to 1.1, this method did not use an AccessController.\n     * In version 1.1, an AccessController wrapper was incorrectly added to\n     * this method, causing a minor security flaw.\n     * <p>\n     * In version 1.1.1 this change was reverted; this method no longer uses\n     * an AccessController. User code wishing to obtain the context classloader\n     * must invoke this method via AccessController.doPrivileged if it needs\n     * support for that.\n     *\n     * @return the context classloader associated with the current thread,\n     *  or null if security doesn't allow it.\n     * @throws LogConfigurationException if there was some weird error while\n     *  attempting to get the context classloader.\n     */\n    protected static ClassLoader getContextClassLoader() throws LogConfigurationException {\n        return directGetContextClassLoader();\n    }\n\n    \n    /**\n     * Calls LogFactory.directGetContextClassLoader under the control of an\n     * AccessController class. This means that java code running under a\n     * security manager that forbids access to ClassLoaders will still work\n     * if this class is given appropriate privileges, even when the caller\n     * doesn't have such privileges. Without using an AccessController, the\n     * the entire call stack must have the privilege before the call is\n     * allowed.\n     *\n     * @return the context classloader associated with the current thread,\n     *  or null if security doesn't allow it.\n     * @throws LogConfigurationException if there was some weird error while\n     *  attempting to get the context classloader.\n     */\n    private static ClassLoader getContextClassLoaderInternal() throws LogConfigurationException {\n        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) LogFactory::directGetContextClassLoader);\n    }\n\n    /**\n     * Constructs (if necessary) and return a {@code LogFactory} instance, using the following ordered lookup procedure to determine the name of the\n     * implementation class to be loaded.\n     * <ul>\n     * <li>The {@code org.apache.commons.logging.LogFactory} system property.<\/li>\n     * <li>The JDK 1.3 Service Discovery mechanism<\/li>\n     * <li>Use the properties file {@code commons-logging.properties} file, if found in the class path of this class. The configuration file is in standard\n     * {@code java.util.Properties} format and contains the fully qualified name of the implementation class with the key being the system property defined\n     * above.<\/li>\n     * <li>Fall back to a default implementation class ({@code org.apache.commons.logging.impl.LogFactoryImpl}).<\/li>\n     * <\/ul>\n     * <p>\n     * <em>NOTE<\/em> - If the properties file method of identifying the {@code LogFactory} implementation class is utilized, all of the properties defined in\n     * this file will be set as configuration attributes on the corresponding {@code LogFactory} instance.\n     * <\/p>\n     * <p>\n     * <em>NOTE<\/em> - In a multi-threaded environment it is possible that two different instances will be returned for the same classloader environment.\n     * <\/p>\n     *\n     * @return a {@code LogFactory}.\n     * @throws LogConfigurationException if the implementation class is not available or cannot be instantiated.\n     */\n    public static LogFactory getFactory() throws LogConfigurationException {\n        // Identify the class loader we will be using\n        final ClassLoader contextClassLoader = getContextClassLoaderInternal();\n\n\n        // This is an odd enough situation to report about. This\n        // output will be a nuisance on JDK1.1, as the system\n        // class loader is null in that environment.\n        if (contextClassLoader == null && isDiagnosticsEnabled()) {\n            logDiagnostic(\"Context classloader is null.\");\n        }\n\n        // Return any previously registered factory for this class loader\n        LogFactory factory = getCachedFactory(contextClassLoader);\n        if (factory != null) {\n            return factory;\n        }\n\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\n                    \"[LOOKUP] LogFactory implementation requested for the first time for context classloader \" +\n                    objectId(contextClassLoader));\n            logHierarchy(\"[LOOKUP] \", contextClassLoader);\n        }\n\n        // Load properties file.\n        //\n        // If the properties file exists, then its contents are used as\n        // \"attributes\" on the LogFactory implementation class. One particular\n        // property may also control which LogFactory concrete subclass is\n        // used, but only if other discovery mechanisms fail..\n        //\n        // As the properties file (if it exists) will be used one way or\n        // another in the end we may as well look for it first.\n\n        final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);\n\n        // Determine whether we will be using the thread context class loader to\n        // load logging classes or not by checking the loaded properties file (if any).\n        ClassLoader baseClassLoader = contextClassLoader;\n        if (props != null) {\n            final String useTCCLStr = props.getProperty(TCCL_KEY);\n            // The Boolean.valueOf(useTCCLStr).booleanValue() formulation\n            // is required for Java 1.2 compatibility.\n            if (useTCCLStr != null && !Boolean.parseBoolean(useTCCLStr)) {\n                // Don't use current context class loader when locating any\n                // LogFactory or Log classes, just use the class that loaded\n                // this abstract class. When this class is deployed in a shared\n                // classpath of a container, it means webapps cannot deploy their\n                // own logging implementations. It also means that it is up to the\n                // implementation whether to load library-specific config files\n                // from the TCCL or not.\n                baseClassLoader = thisClassLoaderRef.get();\n            }\n        }\n\n        // Determine which concrete LogFactory subclass to use.\n        // First, try a global system property\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"[LOOKUP] Looking for system property [\" + FACTORY_PROPERTY +\n                          \"] to define the LogFactory subclass to use...\");\n        }\n\n        try {\n            final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null);\n            if (factoryClass != null) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\"[LOOKUP] Creating an instance of LogFactory class '\" + factoryClass +\n                                  \"' as specified by system property \" + FACTORY_PROPERTY);\n                }\n                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);\n            } else if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] No system property [\" + FACTORY_PROPERTY + \"] defined.\");\n            }\n        } catch (final SecurityException e) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] A security exception occurred while trying to create an\" +\n                              \" instance of the custom factory class\" + \": [\" + trim(e.getMessage()) +\n                              \"]. Trying alternative implementations...\");\n            }\n            // ignore\n        } catch (final RuntimeException e) {\n            // This is not consistent with the behavior when a bad LogFactory class is\n            // specified in a services file.\n            //\n            // One possible exception that can occur here is a ClassCastException when\n            // the specified class wasn't castable to this LogFactory type.\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] An exception occurred while trying to create an\" +\n                              \" instance of the custom factory class\" + \": [\" +\n                              trim(e.getMessage()) +\n                              \"] as specified by a system property.\");\n            }\n            throw e;\n        }\n\n        // Second, try to find a service by using the JDK1.3 class\n        // discovery mechanism, which involves putting a file with the name\n        // of an interface class in the META-INF/services directory, where the\n        // contents of the file is a single line specifying a concrete class\n        // that implements the desired interface.\n\n        if (factory == null) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] Using ServiceLoader  to define the LogFactory subclass to use...\");\n            }\n            try {\n                final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class);\n                final Iterator<LogFactory> iterator = serviceLoader.iterator();\n\n                int i = MAX_BROKEN_SERVICES;\n                while (factory == null && i-- > 0) {\n                    try {\n                        if (iterator.hasNext()) {\n                            factory = iterator.next();\n                        }\n                    } catch (final ServiceConfigurationError | LinkageError ex) {\n                        if (isDiagnosticsEnabled()) {\n                            logDiagnostic(\"[LOOKUP] An exception occurred while trying to find an\" +\n                                    \" instance of LogFactory\" +\n                                    \": [\" + trim(ex.getMessage()) +\n                                    \"]. Trying alternative implementations...\");\n                        }\n                    }\n                }\n            } catch (final Exception ex) {\n                // note: if the specified LogFactory class wasn't compatible with LogFactory\n                // for some reason, a ClassCastException will be caught here, and attempts will\n                // continue to find a compatible class.\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\n                        \"[LOOKUP] A security exception occurred while trying to create an\" +\n                        \" instance of the custom factory class\" +\n                        \": [\" + trim(ex.getMessage()) +\n                        \"]. Trying alternative implementations...\");\n                }\n                // ignore\n            }\n        }\n\n        // Third try looking into the properties file read earlier (if found)\n\n        if (factory == null) {\n            if (props != null) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\n                        \"[LOOKUP] Looking in properties file for entry with key '\" + FACTORY_PROPERTY +\n                        \"' to define the LogFactory subclass to use...\");\n                }\n                final String factoryClass = props.getProperty(FACTORY_PROPERTY);\n                if (factoryClass != null) {\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\n                            \"[LOOKUP] Properties file specifies LogFactory subclass '\" + factoryClass + \"'\");\n                    }\n                    factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);\n\n                    // TODO: think about whether we need to handle exceptions from newFactory\n                } else {\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\"[LOOKUP] Properties file has no entry specifying LogFactory subclass.\");\n                    }\n                }\n            } else if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"[LOOKUP] No properties file available to determine\" + \" LogFactory subclass from..\");\n            }\n        }\n\n        // Fourth, try one of the 3 provided factories\n\n        try {\n            // We prefer Log4j API, since it does not stringify objects.\n            if (factory == null && isClassAvailable(LOG4J_API_LOGGER, baseClassLoader)) {\n                // If the Log4j API is redirected to SLF4J, we use SLF4J directly.\n                if (isClassAvailable(LOG4J_TO_SLF4J_BRIDGE, baseClassLoader)) {\n                    logDiagnostic(\n                            \"[LOOKUP] Log4j API to SLF4J redirection detected. Loading the SLF4J LogFactory implementation '\" + FACTORY_SLF4J + \"'.\");\n                    factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader);\n                } else {\n                    logDiagnostic(\"[LOOKUP] Log4j API detected. Loading the Log4j API LogFactory implementation '\" + FACTORY_LOG4J_API + \"'.\");\n                    factory = newFactory(FACTORY_LOG4J_API, baseClassLoader, contextClassLoader);\n                }\n            }\n\n            if (factory == null && isClassAvailable(SLF4J_API_LOGGER, baseClassLoader)) {\n                logDiagnostic(\"[LOOKUP] SLF4J detected. Loading the SLF4J LogFactory implementation '\" + FACTORY_SLF4J + \"'.\");\n                factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader);\n            }\n        } catch (final Exception e) {\n            logDiagnostic(\"[LOOKUP] An exception occurred while creating LogFactory: \" + e.getMessage());\n        }\n\n        if (factory == null) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\n                    \"[LOOKUP] Loading the default LogFactory implementation '\" + FACTORY_DEFAULT +\n                    \"' via the same classloader that loaded this LogFactory\" +\n                    \" class (ie not looking in the context classloader).\");\n            }\n\n            // Note: unlike the above code which can try to load custom LogFactory\n            // implementations via the TCCL, we don't try to load the default LogFactory\n            // implementation via the context classloader because:\n            // * that can cause problems (see comments in newFactory method)\n            // * no-one should be customising the code of the default class\n            // Yes, we do give up the ability for the child to ship a newer\n            // version of the LogFactoryImpl class and have it used dynamically\n            // by an old LogFactory class in the parent, but that isn't\n            // necessarily a good idea anyway.\n            factory = newFactory(FACTORY_DEFAULT, thisClassLoaderRef.get(), contextClassLoader);\n        }\n\n        if (factory != null) {\n            /**\n             * Always cache using context class loader.\n             */\n            cacheFactory(contextClassLoader, factory);\n\n            if (props != null) {\n                final Enumeration<?> names = props.propertyNames();\n                while (names.hasMoreElements()) {\n                    final String name = Objects.toString(names.nextElement(), null);\n                    final String value = props.getProperty(name);\n                    factory.setAttribute(name, value);\n                }\n            }\n        }\n\n        return factory;\n    }\n\n    /**\n     * Convenience method to return a named logger, without the application having to care about factories.\n     *\n     * @param clazz Class from which a log name will be derived\n     * @return a named logger.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public static Log getLog(final Class<?> clazz) throws LogConfigurationException {\n        return getFactory().getInstance(clazz);\n    }\n\n    /**\n     * Convenience method to return a named logger, without the application having to care about factories.\n     *\n     * @param name Logical name of the {@code Log} instance to be returned (the meaning of this name is only known to the underlying logging implementation that\n     *             is being wrapped)\n     * @return a named logger.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public static Log getLog(final String name) throws LogConfigurationException {\n        return getFactory().getInstance(name);\n    }\n\n    /**\n     * Given a URL that refers to a .properties file, load that file.\n     * This is done under an AccessController so that this method will\n     * succeed when this jarfile is privileged but the caller is not.\n     * This method must therefore remain private to avoid security issues.\n     * <p>\n     * {@code Null} is returned if the URL cannot be opened.\n     */\n    private static Properties getProperties(final URL url) {\n        return AccessController.doPrivileged((PrivilegedAction<Properties>) () -> {\n            // We must ensure that useCaches is set to false, as the\n            // default behavior of java is to cache file handles, and\n            // this \"locks\" files, preventing hot-redeploy on windows.\n            try {\n                final URLConnection connection = url.openConnection();\n                connection.setUseCaches(false);\n                try (InputStream stream = connection.getInputStream()) {\n                    if (stream != null) {\n                        final Properties props = new Properties();\n                        props.load(stream);\n                        return props;\n                    }\n                } catch (final IOException e) {\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic(\"Unable to close stream for URL \" + url);\n                    }\n                }\n            } catch (final IOException e) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\"Unable to read URL \" + url);\n                }\n            }\n\n            return null;\n        });\n    }\n\n    /**\n     * Given a file name, return an enumeration of URLs pointing to\n     * all the occurrences of that file name in the classpath.\n     * <p>\n     * This is just like ClassLoader.getResources except that the\n     * operation is done under an AccessController so that this method will\n     * succeed when this jarfile is privileged but the caller is not.\n     * This method must therefore remain private to avoid security issues.\n     * <p>\n     * If no instances are found, an Enumeration is returned whose\n     * hasMoreElements method returns false (ie an \"empty\" enumeration).\n     * If resources could not be listed for some reason, null is returned.\n     */\n    private static Enumeration<URL> getResources(final ClassLoader loader, final String name) {\n        return AccessController.doPrivileged((PrivilegedAction<Enumeration<URL>>) () -> {\n            try {\n                if (loader != null) {\n                    return loader.getResources(name);\n                }\n                return ClassLoader.getSystemResources(name);\n            } catch (final IOException e) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\"Exception while trying to find configuration file \" + name + \":\" + e.getMessage());\n                }\n                return null;\n            } catch (final NoSuchMethodError e) {\n                // we must be running on a 1.1 JVM which doesn't support\n                // ClassLoader.getSystemResources; just return null in\n                // this case.\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Read the specified system property, using an AccessController so that\n     * the property can be read if JCL has been granted the appropriate\n     * security rights even if the calling code has not.\n     * <p>\n     * Take care not to expose the value returned by this method to the\n     * calling application in any way; otherwise the calling app can use that\n     * info to access data that should not be available to it.\n     */\n    private static String getSystemProperty(final String key, final String def)\n            throws SecurityException {\n        return AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(key, def));\n    }\n\n    \n    /**\n     * Checks whether the supplied Throwable is one that needs to be\n     * re-thrown and ignores all others.\n     *\n     * The following errors are re-thrown:\n     * <ul>\n     *   <li>ThreadDeath<\/li>\n     *   <li>VirtualMachineError<\/li>\n     * <\/ul>\n     *\n     * @param t the Throwable to check\n     */\n    protected static void handleThrowable(final Throwable t) {\n        if (t instanceof ThreadDeath) {\n            throw (ThreadDeath) t;\n        }\n        if (t instanceof VirtualMachineError) {\n            throw (VirtualMachineError) t;\n        }\n        // All other instances of Throwable will be silently ignored\n    }\n\n    /**\n     * Determines whether the given class actually implements {@code LogFactory}.\n     * Diagnostic information is also logged.\n     * <p>\n     * <strong>Usage:<\/strong> to diagnose whether a classloader conflict is the cause\n     * of incompatibility. The test used is whether the class is assignable from\n     * the {@code LogFactory} class loaded by the class's classloader.\n     * @param logFactoryClass {@code Class} which may implement {@code LogFactory}\n     * @return true if the {@code logFactoryClass} does extend\n     * {@code LogFactory} when that class is loaded via the same\n     * classloader that loaded the {@code logFactoryClass}.\n     */\n    private static boolean implementsLogFactory(final Class logFactoryClass) {\n        boolean implementsLogFactory = false;\n        if (logFactoryClass != null) {\n            try {\n                final ClassLoader logFactoryClassLoader = logFactoryClass.getClassLoader();\n                if (logFactoryClassLoader == null) {\n                    logDiagnostic(\"[CUSTOM LOG FACTORY] was loaded by the boot classloader\");\n                } else {\n                    logHierarchy(\"[CUSTOM LOG FACTORY] \", logFactoryClassLoader);\n                    final Class factoryFromCustomLoader = Class.forName(\"org.apache.commons.logging.LogFactory\", false, logFactoryClassLoader);\n                    implementsLogFactory = factoryFromCustomLoader.isAssignableFrom(logFactoryClass);\n                    final String logFactoryClassName = logFactoryClass.getName();\n                    if (implementsLogFactory) {\n                        logDiagnostic(\"[CUSTOM LOG FACTORY] \" + logFactoryClassName + \" implements LogFactory but was loaded by an incompatible classloader.\");\n                    } else {\n                        logDiagnostic(\"[CUSTOM LOG FACTORY] \" + logFactoryClassName + \" does not implement LogFactory.\");\n                    }\n                }\n            } catch (final SecurityException e) {\n                //\n                // The application is running within a hostile security environment.\n                // This will make it very hard to diagnose issues with JCL.\n                // Consider running less securely whilst debugging this issue.\n                //\n                logDiagnostic(\"[CUSTOM LOG FACTORY] SecurityException caught trying to determine whether \"\n                        + \"the compatibility was caused by a class loader conflict: \" + e.getMessage());\n            } catch (final LinkageError e) {\n                //\n                // This should be an unusual circumstance.\n                // LinkageError's usually indicate that a dependent class has incompatibly changed.\n                // Another possibility may be an exception thrown by an initializer.\n                // Time for a clean rebuild?\n                //\n                logDiagnostic(\"[CUSTOM LOG FACTORY] LinkageError caught trying to determine whether \"\n                        + \"the compatibility was caused by a class loader conflict: \" + e.getMessage());\n            } catch (final ClassNotFoundException e) {\n                //\n                // LogFactory cannot be loaded by the classloader which loaded the custom factory implementation.\n                // The custom implementation is not viable until this is corrected.\n                // Ensure that the JCL jar and the custom class are available from the same classloader.\n                // Running with diagnostics on should give information about the classloaders used\n                // to load the custom factory.\n                //\n                logDiagnostic(\"[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by the class loader which loaded \"\n                        + \"the custom LogFactory implementation. Is the custom factory in the right class loader?\");\n            }\n        }\n        return implementsLogFactory;\n    }\n\n    /**\n     * Determines whether the user wants internal diagnostic output. If so,\n     * returns an appropriate writer object. Users can enable diagnostic\n     * output by setting the system property named {@link #DIAGNOSTICS_DEST_PROPERTY} to\n     * a file name, or the special values STDOUT or STDERR.\n     */\n    private static PrintStream initDiagnostics() {\n        String dest;\n        try {\n            dest = getSystemProperty(DIAGNOSTICS_DEST_PROPERTY, null);\n            if (dest == null) {\n                return null;\n            }\n        } catch (final SecurityException ex) {\n            // We must be running in some very secure environment.\n            // We just have to assume output is not wanted..\n            return null;\n        }\n\n        if (dest.equals(\"STDOUT\")) {\n            return System.out;\n        }\n        if (dest.equals(\"STDERR\")) {\n            return System.err;\n        }\n        try {\n            // open the file in append mode\n            final FileOutputStream fos = new FileOutputStream(dest, true);\n            return new PrintStream(fos);\n        } catch (final IOException ex) {\n            // We should report this to the user - but how?\n            return null;\n        }\n    }\n\n    private static boolean isClassAvailable(final String className, final ClassLoader classLoader) {\n        final ClassLoader loader = LogFactory.class.getClassLoader();\n        logDiagnostic(\"Checking if class '\" + className + \"' is available in class loader \" + objectId(loader));\n        try {\n            Class.forName(className, true, classLoader);\n            return true;\n        } catch (final ClassNotFoundException | LinkageError e) {\n            logDiagnostic(\"Failed to load class '\" + className + \"' from class loader \" + objectId(loader) + \": \" + e.getMessage());\n        }\n        return false;\n    }\n\n    /**\n     * Indicates true if the user has enabled internal logging.\n     * <p>\n     * By the way, sorry for the incorrect grammar, but calling this method\n     * areDiagnosticsEnabled just isn't java beans style.\n     *\n     * @return true if calls to logDiagnostic will have any effect.\n     * @since 1.1\n     */\n    protected static boolean isDiagnosticsEnabled() {\n        return DIAGNOSTICS_STREAM != null;\n    }\n\n    /**\n     * Generate useful diagnostics regarding the classloader tree for\n     * the specified class.\n     * <p>\n     * As an example, if the specified class was loaded via a webapp's\n     * classloader, then you may get the following output:\n     * <pre>\n     * Class com.acme.Foo was loaded via classloader 11111\n     * ClassLoader tree: 11111 -> 22222 (SYSTEM) -> 33333 -> BOOT\n     * <\/pre>\n     * <p>\n     * This method returns immediately if isDiagnosticsEnabled()\n     * returns false.\n     *\n     * @param clazz is the class whose classloader + tree are to be\n     * output.\n     */\n    private static void logClassLoaderEnvironment(final Class<?> clazz) {\n        if (!isDiagnosticsEnabled()) {\n            return;\n        }\n\n        try {\n            // Deliberately use System.getProperty here instead of getSystemProperty; if\n            // the overall security policy for the calling application forbids access to\n            // these variables then we do not want to output them to the diagnostic stream.\n            logDiagnostic(\"[ENV] Extension directories (java.ext.dir): \" + System.getProperty(\"java.ext.dir\"));\n            logDiagnostic(\"[ENV] Application classpath (java.class.path): \" + System.getProperty(\"java.class.path\"));\n        } catch (final SecurityException ex) {\n            logDiagnostic(\"[ENV] Security setting prevent interrogation of system classpaths.\");\n        }\n\n        final String className = clazz.getName();\n        ClassLoader classLoader;\n\n        try {\n            classLoader = getClassLoader(clazz);\n        } catch (final SecurityException ex) {\n            // not much useful diagnostics we can print here!\n            logDiagnostic(\"[ENV] Security forbids determining the classloader for \" + className);\n            return;\n        }\n\n        logDiagnostic(\"[ENV] Class \" + className + \" was loaded via classloader \" + objectId(classLoader));\n        logHierarchy(\"[ENV] Ancestry of classloader which loaded \" + className + \" is \", classLoader);\n    }\n\n    /**\n     * Write the specified message to the internal logging destination.\n     * <p>\n     * Note that this method is private; concrete subclasses of this class\n     * should not call it because the diagnosticPrefix string this\n     * method puts in front of all its messages is LogFactory@....,\n     * while subclasses should put SomeSubClass@...\n     * <p>\n     * Subclasses should instead compute their own prefix, then call\n     * logRawDiagnostic. Note that calling isDiagnosticsEnabled is\n     * fine for subclasses.\n     * <p>\n     * Note that it is safe to call this method before initDiagnostics\n     * is called; any output will just be ignored (as isDiagnosticsEnabled\n     * will return false).\n     *\n     * @param msg is the diagnostic message to be output.\n     */\n    private static void logDiagnostic(final String msg) {\n        if (DIAGNOSTICS_STREAM != null) {\n            DIAGNOSTICS_STREAM.print(diagnosticPrefix);\n            DIAGNOSTICS_STREAM.println(msg);\n            DIAGNOSTICS_STREAM.flush();\n        }\n    }\n\n    /**\n     * Logs diagnostic messages about the given classloader\n     * and it's hierarchy. The prefix is prepended to the message\n     * and is intended to make it easier to understand the logs.\n     * @param prefix\n     * @param classLoader\n     */\n    private static void logHierarchy(final String prefix, ClassLoader classLoader) {\n        if (!isDiagnosticsEnabled()) {\n            return;\n        }\n        ClassLoader systemClassLoader;\n        if (classLoader != null) {\n            final String classLoaderString = classLoader.toString();\n            logDiagnostic(prefix + objectId(classLoader) + \" == '\" + classLoaderString + \"'\");\n        }\n\n        try {\n            systemClassLoader = ClassLoader.getSystemClassLoader();\n        } catch (final SecurityException ex) {\n            logDiagnostic(prefix + \"Security forbids determining the system classloader.\");\n            return;\n        }\n        if (classLoader != null) {\n            final StringBuilder buf = new StringBuilder(prefix + \"ClassLoader tree:\");\n            for(;;) {\n                buf.append(objectId(classLoader));\n                if (classLoader == systemClassLoader) {\n                    buf.append(\" (SYSTEM) \");\n                }\n\n                try {\n                    classLoader = classLoader.getParent();\n                } catch (final SecurityException ex) {\n                    buf.append(\" --> SECRET\");\n                    break;\n                }\n\n                buf.append(\" --> \");\n                if (classLoader == null) {\n                    buf.append(\"BOOT\");\n                    break;\n                }\n            }\n            logDiagnostic(buf.toString());\n        }\n    }\n\n    /**\n     * Write the specified message to the internal logging destination.\n     *\n     * @param msg is the diagnostic message to be output.\n     * @since 1.1\n     */\n    protected static final void logRawDiagnostic(final String msg) {\n        if (DIAGNOSTICS_STREAM != null) {\n            DIAGNOSTICS_STREAM.println(msg);\n            DIAGNOSTICS_STREAM.flush();\n        }\n    }\n\n    /**\n     * Method provided for backwards compatibility; see newFactory version that\n     * takes 3 parameters.\n     * <p>\n     * This method would only ever be called in some rather odd situation.\n     * Note that this method is static, so overriding in a subclass doesn't\n     * have any effect unless this method is called from a method in that\n     * subclass. However this method only makes sense to use from the\n     * getFactory method, and as that is almost always invoked via\n     * LogFactory.getFactory, any custom definition in a subclass would be\n     * pointless. Only a class with a custom getFactory method, then invoked\n     * directly via CustomFactoryImpl.getFactory or similar would ever call\n     * this. Anyway, it's here just in case, though the \"managed class loader\"\n     * value output to the diagnostics will not report the correct value.\n     * <\/p>\n     *\n     * @param factoryClass factory class.\n     * @param classLoader class loader.\n     * @return a LogFactory.\n     */\n    protected static LogFactory newFactory(final String factoryClass,\n                                           final ClassLoader classLoader) {\n        return newFactory(factoryClass, classLoader, null);\n    }\n\n    /**\n     * Return a new instance of the specified {@code LogFactory} implementation class, loaded by the specified class loader. If that fails, try the class loader\n     * used to load this (abstract) LogFactory.\n     * <p>\n     * <b>ClassLoader conflicts<\/b>\n     * <\/p>\n     * <p>\n     * Note that there can be problems if the specified ClassLoader is not the same as the classloader that loaded this class, that is, when loading a concrete\n     * LogFactory subclass via a context classloader.\n     * <\/p>\n     * <p>\n     * The problem is the same one that can occur when loading a concrete Log subclass via a context classloader.\n     * <\/p>\n     * <p>\n     * The problem occurs when code running in the context classloader calls class X which was loaded via a parent classloader, and class X then calls\n     * LogFactory.getFactory (either directly or via LogFactory.getLog). Because class X was loaded via the parent, it binds to LogFactory loaded via the\n     * parent. When the code in this method finds some LogFactoryYYYY class in the child (context) classloader, and there also happens to be a LogFactory class\n     * defined in the child classloader, then LogFactoryYYYY will be bound to LogFactory@childloader. It cannot be cast to LogFactory@parentloader, that is,\n     * this method cannot return the object as the desired type. Note that it doesn't matter if the LogFactory class in the child classloader is identical to\n     * the LogFactory class in the parent classloader, they are not compatible.\n     * <\/p>\n     * <p>\n     * The solution taken here is to simply print out an error message when this occurs then throw an exception. The deployer of the application must ensure\n     * they remove all occurrences of the LogFactory class from the child classloader in order to resolve the issue. Note that they do not have to move the\n     * custom LogFactory subclass; that is ok as long as the only LogFactory class it can find to bind to is in the parent classloader.\n     * <\/p>\n     *\n     * @param factoryClass       Fully qualified name of the {@code LogFactory} implementation class\n     * @param classLoader        ClassLoader from which to load this class\n     * @param contextClassLoader is the context that this new factory will manage logging for.\n     * @return a new instance of the specified {@code LogFactory}.\n     * @throws LogConfigurationException if a suitable instance cannot be created\n     * @since 1.1\n     */\n    protected static LogFactory newFactory(final String factoryClass,\n                                           final ClassLoader classLoader,\n                                           final ClassLoader contextClassLoader)\n        throws LogConfigurationException {\n        // Note that any unchecked exceptions thrown by the createFactory\n        // method will propagate out of this method; in particular a\n        // ClassCastException can be thrown.\n        final Object result = AccessController.doPrivileged(\n            (PrivilegedAction) () -> createFactory(factoryClass, classLoader));\n\n        if (result instanceof LogConfigurationException) {\n            final LogConfigurationException ex = (LogConfigurationException) result;\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\"An error occurred while loading the factory class:\" + ex.getMessage());\n            }\n            throw ex;\n        }\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"Created object \" + objectId(result) + \" to manage classloader \" +\n                          objectId(contextClassLoader));\n        }\n        return (LogFactory) result;\n    }\n\n    /**\n     * Returns a string that uniquely identifies the specified object, including\n     * its class.\n     * <p>\n     * The returned string is of form \"className@hashCode\", that is, is the same as\n     * the return value of the Object.toString() method, but works even when\n     * the specified object's class has overridden the toString method.\n     * <\/p>\n     *\n     * @param o may be null.\n     * @return a string of form className@hashCode, or \"null\" if param o is null.\n     * @since 1.1\n     */\n    public static String objectId(final Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.getClass().getName() + \"@\" + System.identityHashCode(o);\n    }\n\n    /**\n     * Release any internal references to previously created {@link LogFactory}\n     * instances that have been associated with the specified class loader\n     * (if any), after calling the instance method {@code release()} on\n     * each of them.\n     *\n     * @param classLoader ClassLoader for which to release the LogFactory\n     */\n    public static void release(final ClassLoader classLoader) {\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"Releasing factory for classloader \" + objectId(classLoader));\n        }\n        // factories is not final and could be replaced in this block.\n        final Hashtable<ClassLoader, LogFactory> factories = LogFactory.factories;\n        synchronized (factories) {\n            if (classLoader == null) {\n                if (nullClassLoaderFactory != null) {\n                    nullClassLoaderFactory.release();\n                    nullClassLoaderFactory = null;\n                }\n            } else {\n                final LogFactory factory = factories.get(classLoader);\n                if (factory != null) {\n                    factory.release();\n                    factories.remove(classLoader);\n                }\n            }\n        }\n    }\n\n    /**\n     * Release any internal references to previously created {@link LogFactory}\n     * instances, after calling the instance method {@code release()} on\n     * each of them.  This is useful in environments like servlet containers,\n     * which implement application reloading by throwing away a ClassLoader.\n     * Dangling references to objects in that class loader would prevent\n     * garbage collection.\n     */\n    public static void releaseAll() {\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"Releasing factory for all classloaders.\");\n        }\n        // factories is not final and could be replaced in this block.\n        final Hashtable<ClassLoader, LogFactory> factories = LogFactory.factories;\n        synchronized (factories) {\n            final Enumeration<LogFactory> elements = factories.elements();\n            while (elements.hasMoreElements()) {\n                final LogFactory element = elements.nextElement();\n                element.release();\n            }\n            factories.clear();\n\n            if (nullClassLoaderFactory != null) {\n                nullClassLoaderFactory.release();\n                nullClassLoaderFactory = null;\n            }\n        }\n    }\n\n    /** Utility method to safely trim a string. */\n    private static String trim(final String src) {\n        if (src == null) {\n            return null;\n        }\n        return src.trim();\n    }\n\n    /**\n     * Protected constructor that is not available for public use.\n     */\n    protected LogFactory() {\n    }\n\n    /**\n     * Return the configuration attribute with the specified name (if any),\n     * or {@code null} if there is no such attribute.\n     *\n     * @param name Name of the attribute to return\n     * @return the configuration attribute with the specified name.\n     */\n    public abstract Object getAttribute(String name);\n\n    /**\n     * Gets an array containing the names of all currently defined configuration attributes. If there are no such attributes, a zero length array is returned.\n     *\n     * @return an array containing the names of all currently defined configuration attributes\n     */\n    public abstract String[] getAttributeNames();\n\n    /**\n     * Convenience method to derive a name from the specified class and call {@code getInstance(String)} with it.\n     *\n     * @param clazz Class for which a suitable Log name will be derived\n     * @return a name from the specified class.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public abstract Log getInstance(Class<?> clazz) throws LogConfigurationException;\n\n    /**\n     * Constructs (if necessary) and return a {@code Log} instance, using the factory's current set of configuration attributes.\n     * <p>\n     * <strong>NOTE<\/strong> - Depending upon the implementation of the {@code LogFactory} you are using, the {@code Log} instance you are returned may or may\n     * not be local to the current application, and may or may not be returned again on a subsequent call with the same name argument.\n     * <\/p>\n     *\n     * @param name Logical name of the {@code Log} instance to be returned (the meaning of this name is only known to the underlying logging implementation that\n     *             is being wrapped)\n     * @return a {@code Log} instance.\n     * @throws LogConfigurationException if a suitable {@code Log} instance cannot be returned\n     */\n    public abstract Log getInstance(String name)\n        throws LogConfigurationException;\n\n    /**\n     * Release any internal references to previously created {@link Log}\n     * instances returned by this factory.  This is useful in environments\n     * like servlet containers, which implement application reloading by\n     * throwing away a ClassLoader.  Dangling references to objects in that\n     * class loader would prevent garbage collection.\n     */\n    public abstract void release();\n\n    /**\n     * Remove any configuration attribute associated with the specified name.\n     * If there is no such attribute, no action is taken.\n     *\n     * @param name Name of the attribute to remove\n     */\n    public abstract void removeAttribute(String name);\n    \n    /**\n     * Sets the configuration attribute with the specified name.  Calling\n     * this with a {@code null} value is equivalent to calling\n     * {@code removeAttribute(name)}.\n     *\n     * @param name Name of the attribute to set\n     * @param value Value of the attribute to set, or {@code null}\n     *  to remove any setting for this attribute\n     */\n    public abstract void setAttribute(String name, Object value);\n\n    //\n    // We can't do this in the class constructor, as there are many\n    // static methods on this class that can be called before any\n    // LogFactory instances are created, and they depend upon this\n    // stuff having been set up.\n    //\n    // Note that this block must come after any variable declarations used\n    // by any methods called from this block, as we want any static initializer\n    // associated with the variable to run first. If static initializers for\n    // variables run after this code, then (a) their value might be needed\n    // by methods called from here, and (b) they might *override* any value\n    // computed here!\n    //\n    // So the wisest thing to do is just to place this code at the very end\n    // of the class file.\n\n    static {\n        // note: it's safe to call methods before initDiagnostics (though\n        // diagnostic output gets discarded).\n        final ClassLoader thisClassLoader = getClassLoader(LogFactory.class);\n        thisClassLoaderRef = new WeakReference<>(thisClassLoader);\n        // In order to avoid confusion where multiple instances of JCL are\n        // being used via different classloaders within the same app, we\n        // ensure each logged message has a prefix of form\n        // [LogFactory from classloader OID]\n        //\n        // Note that this prefix should be kept consistent with that\n        // in LogFactoryImpl. However here we don't need to output info\n        // about the actual *instance* of LogFactory, as all methods that\n        // output diagnostics from this class are static.\n        String classLoaderName;\n        try {\n            if (thisClassLoader == null) {\n                classLoaderName = \"BOOTLOADER\";\n            } else {\n                classLoaderName = objectId(thisClassLoader);\n            }\n        } catch (final SecurityException e) {\n            classLoaderName = \"UNKNOWN\";\n        }\n        diagnosticPrefix = \"[LogFactory from \" + classLoaderName + \"] \";\n        DIAGNOSTICS_STREAM = initDiagnostics();\n        logClassLoaderEnvironment(LogFactory.class);\n        factories = createFactoryStore();\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\"BOOTSTRAP COMPLETED\");\n        }\n    }\n\n}\n","lineNo":1105}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.logging;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ClassLoader which sees only specified classes, and which can be\n * set to do parent-first or child-first path lookup.\n * <p>\n * Note that this classloader is not \"industrial strength\"; users\n * looking for such a class may wish to look at the Tomcat sourcecode\n * instead. In particular, this class may not be threadsafe.\n * <p>\n * Note that the ClassLoader.getResources method isn't overloaded here.\n * It would be nice to ensure that when child-first lookup is set the\n * resources from the child are returned earlier in the list than the\n * resources from the parent. However overriding this method isn't possible\n * as the java 1.4 version of ClassLoader declares this method final\n * (though the java 1.5 version has removed the final qualifier). As the\n * ClassLoader javadoc doesn't specify the order in which resources\n * are returned, it's valid to return the resources in any order (just\n * untidy) so the inherited implementation is technically ok.\n */\n\npublic class PathableClassLoader extends URLClassLoader {\n\n    private static final URL[] NO_URLS = {};\n\n    /**\n     * A map of package-prefix to ClassLoader. Any class which is in\n     * this map is looked up via the specified classloader instead of\n     * the classpath associated with this classloader or its parents.\n     * <p>\n     * This is necessary in order for the rest of the world to communicate\n     * with classes loaded via a custom classloader. As an example, junit\n     * tests which are loaded via a custom classloader needs to see\n     * the same junit classes as the code invoking the test, otherwise\n     * they can't pass result objects back.\n     * <p>\n     * Normally, only a classloader created with a null parent needs to\n     * have any lookasides defined.\n     */\n    private HashMap lookasides;\n\n    /**\n     * See setParentFirst.\n     */\n    private boolean parentFirst = true;\n\n    /**\n     * Constructor.\n     * <p>\n     * Often, null is passed as the parent, that is, the parent of the new\n     * instance is the bootloader. This ensures that the classpath is\n     * totally clean; nothing but the standard java library will be\n     * present.\n     * <p>\n     * When using a null parent classloader with a junit test, it *is*\n     * necessary for the junit library to also be visible. In this case, it\n     * is recommended that the following code be used:\n     * <pre>\n     * pathableLoader.useExplicitLoader(\n     *   \"junit.\",\n     *   junit.framework.Test.class.getClassLoader());\n     * <\/pre>\n     * Note that this works regardless of whether junit is on the system\n     * classpath, or whether it has been loaded by some test framework that\n     * creates its own classloader to run unit tests in (eg maven2's\n     * Surefire plugin).\n     */\n    public PathableClassLoader(final ClassLoader parent) {\n        super(NO_URLS, parent);\n    }\n\n    /**\n     * Specify a logical library to be included in the classpath used to\n     * locate classes.\n     * <p>\n     * The specified lib name is used as a key into the system properties;\n     * there is expected to be a system property defined with that name\n     * whose value is a url that indicates where that logical library can\n     * be found. Typically this is the name of a jar file, or a directory\n     * containing class files.\n     * <p>\n     * If there is no system property, but the classloader that loaded\n     * this class is a URLClassLoader then the set of URLs that the\n     * classloader uses for its classpath is scanned; any jar in the\n     * URL set whose name starts with the specified string is added to\n     * the classpath managed by this instance.\n     * <p>\n     * Using logical library names allows the calling code to specify its\n     * desired classpath without knowing the exact location of the necessary\n     * classes.\n     */\n    public void addLogicalLib(final String logicalLib) {\n        // first, check the system properties\n        final String fileName = System.getProperty(logicalLib);\n        if (fileName != null) {\n            try {\n                final URL libUrl = new File(fileName).toURL();\n                addURL(libUrl);\n                return;\n            } catch (final java.net.MalformedURLException e) {\n                throw new UnknownError(\n                    \"Invalid file [\" + fileName + \"] for logical lib [\" + logicalLib + \"]\");\n            }\n        }\n\n        // now check the classpath for a similar-named lib\n        final URL libUrl = libFromClasspath(logicalLib);\n        if (libUrl != null) {\n            addURL(libUrl);\n            return;\n        }\n\n        // lib not found\n        throw new UnknownError(\n            \"Logical lib [\" + logicalLib + \"] is not defined\"\n            + \" as a System property.\");\n    }\n\n    /**\n     * Specify a collection of logical libraries. See addLogicalLib.\n     */\n    public void addLogicalLib(final String[] logicalLibs) {\n        for (final String logicalLib : logicalLibs) {\n            addLogicalLib(logicalLib);\n        }\n    }\n\n    /**\n     * Allow caller to explicitly add paths. Generally this not a good idea;\n     * use addLogicalLib instead, then define the location for that logical\n     * library in the build.xml file.\n     */\n    @Override\n    public void addURL(final URL url) {\n        super.addURL(url);\n    }\n\n    /**\n     * Same as parent class method except that when parentFirst is false\n     * the resource is looked for in the local classpath before the parent\n     * loader is consulted.\n     */\n    @Override\n    public URL getResource(final String name) {\n        if (parentFirst) {\n            return super.getResource(name);\n        }\n        final URL local = super.findResource(name);\n        if (local != null) {\n            return local;\n        }\n        return super.getResource(name);\n    }\n\n    /**\n     * Same as parent class method except that when parentFirst is false\n     * the resource is looked for in the local classpath before the parent\n     * loader is consulted.\n     */\n    @Override\n    public InputStream getResourceAsStream(final String name) {\n        if (parentFirst) {\n            return super.getResourceAsStream(name);\n        }\n        final URL local = super.findResource(name);\n        if (local != null) {\n            try {\n                return local.openStream();\n            } catch (final IOException e) {\n                // TODO: check if this is right or whether we should\n                // fall back to trying parent. The javadoc doesn't say...\n                return null;\n            }\n        }\n        return super.getResourceAsStream(name);\n    }\n\n    /**\n     * Emulate a proper implementation of getResources which respects the\n     * setting for parentFirst.\n     * <p>\n     * Note that it's not possible to override the inherited getResources, as\n     * it's declared final in java1.4 (thought that's been removed for 1.5).\n     * The inherited implementation always behaves as if parentFirst=true.\n     */\n    public Enumeration getResourcesInOrder(final String name) throws IOException {\n        if (parentFirst) {\n            return super.getResources(name);\n        }\n        final Enumeration localUrls = super.findResources(name);\n\n        final ClassLoader parent = getParent();\n        if (parent == null) {\n            // Alas, there is no method to get matching resources\n            // from a null (BOOT) parent classloader. Calling\n            // ClassLoader.getSystemClassLoader isn't right. Maybe\n            // calling Class.class.getResources(name) would do?\n            //\n            // However for the purposes of unit tests, we can\n            // simply assume that no relevant resources are\n            // loadable from the parent; unit tests will never be\n            // putting any of their resources in a \"boot\" classloader\n            // path!\n            return localUrls;\n        }\n        final Enumeration parentUrls = parent.getResources(name);\n\n        final ArrayList localItems = toList(localUrls);\n        final ArrayList parentItems = toList(parentUrls);\n        localItems.addAll(parentItems);\n        return Collections.enumeration(localItems);\n    }\n\n    /**\n     * If the classloader that loaded this class has this logical lib in its\n     * path, then return the matching URL otherwise return null.\n     * <p>\n     * This only works when the classloader loading this class is an instance\n     * of URLClassLoader and thus has a getURLs method that returns the classpath\n     * it uses when loading classes. However in practice, the vast majority of the\n     * time this type is the classloader used.\n     * <p>\n     * The classpath of the classloader for this instance is scanned, and any\n     * jarfile in the path whose name starts with the logicalLib string is\n     * considered a match. For example, passing \"foo\" will match a url\n     * of {@code file:///some/where/foo-2.7.jar}.\n     * <p>\n     * When multiple classpath entries match the specified logicalLib string,\n     * the one with the shortest file name component is returned. This means that\n     * if \"foo-1.1.jar\" and \"foobar-1.1.jar\" are in the path, then a logicalLib\n     * name of \"foo\" will match the first entry above.\n     */\n    private URL libFromClasspath(final String logicalLib) {\n        final ClassLoader cl = this.getClass().getClassLoader();\n        if (!(cl instanceof URLClassLoader)) {\n            return null;\n        }\n\n        final URLClassLoader ucl = (URLClassLoader) cl;\n        final URL[] path = ucl.getURLs();\n        URL shortestMatch = null;\n        int shortestMatchLen = Integer.MAX_VALUE;\n        for (final URL u : path) {\n            // extract the file name bit on the end of the URL\n            String fileName = u.toString();\n            if (!fileName.endsWith(\".jar\")) {\n                // not a jarfile, ignore it\n                continue;\n            }\n\n            final int lastSlash = fileName.lastIndexOf('/');\n            if (lastSlash >= 0) {\n                fileName = fileName.substring(lastSlash+1);\n            }\n\n            // ok, this is a candidate\n            if (fileName.startsWith(logicalLib) && fileName.length() < shortestMatchLen) {\n                shortestMatch = u;\n                shortestMatchLen = fileName.length();\n            }\n        }\n\n        return shortestMatch;\n    }\n\n    /**\n     * Override ClassLoader method.\n     * <p>\n     * For each explicitly mapped package prefix, if the name matches the\n     * prefix associated with that entry then attempt to load the class via\n     * that entries' classloader.\n     */\n    @Override\n    protected Class loadClass(final String name, final boolean resolve)\n    throws ClassNotFoundException {\n        // just for performance, check java and javax\n        if (name.startsWith(\"java.\") || name.startsWith(\"javax.\")) {\n            return super.loadClass(name, resolve);\n        }\n\n        if (lookasides != null) {\n            for (final Object element : lookasides.entrySet()) {\n                final Map.Entry entry = (Map.Entry) element;\n                final String prefix = (String) entry.getKey();\n                if (name.startsWith(prefix)) {\n                    final ClassLoader loader = (ClassLoader) entry.getValue();\n                    final Class clazz = Class.forName(name, resolve, loader);\n                    return clazz;\n                }\n            }\n        }\n\n        if (parentFirst) {\n            return super.loadClass(name, resolve);\n        }\n        try {\n            Class clazz = findLoadedClass(name);\n            if (clazz == null) {\n                clazz = super.findClass(name);\n            }\n            if (resolve) {\n                resolveClass(clazz);\n            }\n            return clazz;\n        } catch (final ClassNotFoundException e) {\n            return super.loadClass(name, resolve);\n        }\n    }\n\n    /**\n     * Specify whether this classloader should ask the parent classloader\n     * to resolve a class first, before trying to resolve it via its own\n     * classpath.\n     * <p>\n     * Checking with the parent first is the normal approach for java, but\n     * components within containers such as servlet engines can use\n     * child-first lookup instead, to allow the components to override libs\n     * which are visible in shared classloaders provided by the container.\n     * <p>\n     * Note that the method getResources always behaves as if parentFirst=true,\n     * because of limitations in java 1.4; see the javadoc for method\n     * getResourcesInOrder for details.\n     * <p>\n     * This value defaults to true.\n     */\n    public void setParentFirst(final boolean state) {\n        parentFirst = state;\n    }\n\n    /**\n     *\n     * Clean implementation of list function of\n     * {@link java.util.Collection} added in JDK 1.4\n     * @param en {@code Enumeration}, possibly null\n     * @return {@code ArrayList} containing the enumerated\n     * elements in the enumerated order, not null\n     */\n    private ArrayList toList(final Enumeration en) {\n        final ArrayList results = new ArrayList();\n        if (en != null) {\n            while (en.hasMoreElements()){\n                final Object element = en.nextElement();\n                results.add(element);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Specify a classloader to use for specific java packages.\n     * <p>\n     * The specified classloader is normally a loader that is NOT\n     * an ancestor of this classloader. In particular, this loader\n     * may have the bootloader as its parent, but be configured to\n     * see specific other classes (eg the junit library loaded\n     * via the system classloader).\n     * <p>\n     * The differences between using this method, and using\n     * addLogicalLib are:\n     * <ul>\n     * <li>If code calls getClassLoader on a class loaded via\n     * \"lookaside\", then traces up its inheritance chain, it\n     * will see the \"real\" classloaders. When the class is remapped\n     * into this classloader via addLogicalLib, the classloader\n     * chain seen is this object plus ancestors.\n     * <li>If two different jars contain classes in the same\n     * package, then it is not possible to load both jars into\n     * the same \"lookaside\" classloader (eg the system classloader)\n     * then map one of those subsets from here. Of course they could\n     * be loaded into two different \"lookaside\" classloaders and\n     * then a prefix used to map from here to one of those classloaders.\n     * <\/ul>\n     */\n    public void useExplicitLoader(final String prefix, final ClassLoader loader) {\n        if (lookasides == null) {\n            lookasides = new HashMap();\n        }\n        lookasides.put(prefix, loader);\n    }\n\n    /**\n     * For classes with the specified prefix, get them from the system\n     * classpath <i>which is active at the point this method is called<\/i>.\n     * <p>\n     * This method is just a shortcut for\n     * <pre>\n     * useExplicitLoader(prefix, ClassLoader.getSystemClassLoader());\n     * <\/pre>\n     * <p>\n     * Of course, this assumes that the classes of interest are already\n     * in the classpath of the system classloader.\n     */\n    public void useSystemLoader(final String prefix) {\n        useExplicitLoader(prefix, ClassLoader.getSystemClassLoader());\n\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.logging;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport junit.framework.Assert;\n\n/**\n * A ClassLoader which sees only specified classes, and which can be\n * set to do parent-first or child-first path lookup.\n * <p>\n * Note that this classloader is not \"industrial strength\"; users\n * looking for such a class may wish to look at the Tomcat sourcecode\n * instead. In particular, this class may not be threadsafe.\n * <p>\n * Note that the ClassLoader.getResources method isn't overloaded here.\n * It would be nice to ensure that when child-first lookup is set the\n * resources from the child are returned earlier in the list than the\n * resources from the parent. However overriding this method isn't possible\n * as the java 1.4 version of ClassLoader declares this method final\n * (though the java 1.5 version has removed the final qualifier). As the\n * ClassLoader javadoc doesn't specify the order in which resources\n * are returned, it's valid to return the resources in any order (just\n * untidy) so the inherited implementation is technically ok.\n */\n\npublic class PathableClassLoader extends URLClassLoader {\n\n    private static final URL[] NO_URLS = {};\n\n    /**\n     * A map of package-prefix to ClassLoader. Any class which is in\n     * this map is looked up via the specified classloader instead of\n     * the classpath associated with this classloader or its parents.\n     * <p>\n     * This is necessary in order for the rest of the world to communicate\n     * with classes loaded via a custom classloader. As an example, junit\n     * tests which are loaded via a custom classloader needs to see\n     * the same junit classes as the code invoking the test, otherwise\n     * they can't pass result objects back.\n     * <p>\n     * Normally, only a classloader created with a null parent needs to\n     * have any lookasides defined.\n     */\n    private HashMap lookasides;\n\n    /**\n     * See setParentFirst.\n     */\n    private boolean parentFirst = true;\n\n    /**\n     * Constructor.\n     * <p>\n     * Often, null is passed as the parent, that is, the parent of the new\n     * instance is the bootloader. This ensures that the classpath is\n     * totally clean; nothing but the standard java library will be\n     * present.\n     * <p>\n     * When using a null parent classloader with a junit test, it *is*\n     * necessary for the junit library to also be visible. In this case, it\n     * is recommended that the following code be used:\n     * <pre>\n     * pathableLoader.useExplicitLoader(\n     *   \"junit.\",\n     *   junit.framework.Test.class.getClassLoader());\n     * <\/pre>\n     * Note that this works regardless of whether junit is on the system\n     * classpath, or whether it has been loaded by some test framework that\n     * creates its own classloader to run unit tests in (eg maven2's\n     * Surefire plugin).\n     */\n    public PathableClassLoader(final ClassLoader parent) {\n        super(NO_URLS, parent);\n    }\n\n    /**\n     * Specify a logical library to be included in the classpath used to\n     * locate classes.\n     * <p>\n     * The specified lib name is used as a key into the system properties;\n     * there is expected to be a system property defined with that name\n     * whose value is a url that indicates where that logical library can\n     * be found. Typically this is the name of a jar file, or a directory\n     * containing class files.\n     * <p>\n     * If there is no system property, but the classloader that loaded\n     * this class is a URLClassLoader then the set of URLs that the\n     * classloader uses for its classpath is scanned; any jar in the\n     * URL set whose name starts with the specified string is added to\n     * the classpath managed by this instance.\n     * <p>\n     * Using logical library names allows the calling code to specify its\n     * desired classpath without knowing the exact location of the necessary\n     * classes.\n     */\n    public void addLogicalLib(final String logicalLib) {\n        // first, check the system properties\n        final String fileName = System.getProperty(logicalLib);\n        if (fileName != null) {\n            try {\n                final File file = new File(fileName);\n                if (!file.exists()) {\n                    Assert.fail(\"Unable to add logical library \" + fileName);\n                }\n                final URL libUrl = file.toURL();\n                addURL(libUrl);\n                return;\n            } catch (final java.net.MalformedURLException e) {\n                throw new UnknownError(\n                    \"Invalid file [\" + fileName + \"] for logical lib [\" + logicalLib + \"]\");\n            }\n        }\n\n        // now check the classpath for a similar-named lib\n        final URL libUrl = libFromClasspath(logicalLib);\n        if (libUrl != null) {\n            addURL(libUrl);\n            return;\n        }\n\n        // lib not found\n        throw new UnknownError(\n            \"Logical lib [\" + logicalLib + \"] is not defined\"\n            + \" as a System property.\");\n    }\n\n    /**\n     * Specify a collection of logical libraries. See addLogicalLib.\n     */\n    public void addLogicalLib(final String[] logicalLibs) {\n        for (final String logicalLib : logicalLibs) {\n            addLogicalLib(logicalLib);\n        }\n    }\n\n    /**\n     * Allow caller to explicitly add paths. Generally this not a good idea;\n     * use addLogicalLib instead, then define the location for that logical\n     * library in the build.xml file.\n     */\n    @Override\n    public void addURL(final URL url) {\n        super.addURL(url);\n    }\n\n    /**\n     * Same as parent class method except that when parentFirst is false\n     * the resource is looked for in the local classpath before the parent\n     * loader is consulted.\n     */\n    @Override\n    public URL getResource(final String name) {\n        if (parentFirst) {\n            return super.getResource(name);\n        }\n        final URL local = super.findResource(name);\n        if (local != null) {\n            return local;\n        }\n        return super.getResource(name);\n    }\n\n    /**\n     * Same as parent class method except that when parentFirst is false\n     * the resource is looked for in the local classpath before the parent\n     * loader is consulted.\n     */\n    @Override\n    public InputStream getResourceAsStream(final String name) {\n        if (parentFirst) {\n            return super.getResourceAsStream(name);\n        }\n        final URL local = super.findResource(name);\n        if (local != null) {\n            try {\n                return local.openStream();\n            } catch (final IOException e) {\n                // TODO: check if this is right or whether we should\n                // fall back to trying parent. The javadoc doesn't say...\n                return null;\n            }\n        }\n        return super.getResourceAsStream(name);\n    }\n\n    /**\n     * Emulate a proper implementation of getResources which respects the\n     * setting for parentFirst.\n     * <p>\n     * Note that it's not possible to override the inherited getResources, as\n     * it's declared final in java1.4 (thought that's been removed for 1.5).\n     * The inherited implementation always behaves as if parentFirst=true.\n     */\n    public Enumeration getResourcesInOrder(final String name) throws IOException {\n        if (parentFirst) {\n            return super.getResources(name);\n        }\n        final Enumeration localUrls = super.findResources(name);\n\n        final ClassLoader parent = getParent();\n        if (parent == null) {\n            // Alas, there is no method to get matching resources\n            // from a null (BOOT) parent classloader. Calling\n            // ClassLoader.getSystemClassLoader isn't right. Maybe\n            // calling Class.class.getResources(name) would do?\n            //\n            // However for the purposes of unit tests, we can\n            // simply assume that no relevant resources are\n            // loadable from the parent; unit tests will never be\n            // putting any of their resources in a \"boot\" classloader\n            // path!\n            return localUrls;\n        }\n        final Enumeration parentUrls = parent.getResources(name);\n\n        final ArrayList localItems = toList(localUrls);\n        final ArrayList parentItems = toList(parentUrls);\n        localItems.addAll(parentItems);\n        return Collections.enumeration(localItems);\n    }\n\n    /**\n     * If the classloader that loaded this class has this logical lib in its\n     * path, then return the matching URL otherwise return null.\n     * <p>\n     * This only works when the classloader loading this class is an instance\n     * of URLClassLoader and thus has a getURLs method that returns the classpath\n     * it uses when loading classes. However in practice, the vast majority of the\n     * time this type is the classloader used.\n     * <p>\n     * The classpath of the classloader for this instance is scanned, and any\n     * jarfile in the path whose name starts with the logicalLib string is\n     * considered a match. For example, passing \"foo\" will match a url\n     * of {@code file:///some/where/foo-2.7.jar}.\n     * <p>\n     * When multiple classpath entries match the specified logicalLib string,\n     * the one with the shortest file name component is returned. This means that\n     * if \"foo-1.1.jar\" and \"foobar-1.1.jar\" are in the path, then a logicalLib\n     * name of \"foo\" will match the first entry above.\n     */\n    private URL libFromClasspath(final String logicalLib) {\n        final ClassLoader cl = this.getClass().getClassLoader();\n        if (!(cl instanceof URLClassLoader)) {\n            return null;\n        }\n\n        final URLClassLoader ucl = (URLClassLoader) cl;\n        final URL[] path = ucl.getURLs();\n        URL shortestMatch = null;\n        int shortestMatchLen = Integer.MAX_VALUE;\n        for (final URL u : path) {\n            // extract the file name bit on the end of the URL\n            String fileName = u.toString();\n            if (!fileName.endsWith(\".jar\")) {\n                // not a jarfile, ignore it\n                continue;\n            }\n\n            final int lastSlash = fileName.lastIndexOf('/');\n            if (lastSlash >= 0) {\n                fileName = fileName.substring(lastSlash+1);\n            }\n\n            // ok, this is a candidate\n            if (fileName.startsWith(logicalLib) && fileName.length() < shortestMatchLen) {\n                shortestMatch = u;\n                shortestMatchLen = fileName.length();\n            }\n        }\n\n        return shortestMatch;\n    }\n\n    /**\n     * Override ClassLoader method.\n     * <p>\n     * For each explicitly mapped package prefix, if the name matches the\n     * prefix associated with that entry then attempt to load the class via\n     * that entries' classloader.\n     */\n    @Override\n    protected Class loadClass(final String name, final boolean resolve)\n    throws ClassNotFoundException {\n        // just for performance, check java and javax\n        if (name.startsWith(\"java.\") || name.startsWith(\"javax.\")) {\n            return super.loadClass(name, resolve);\n        }\n\n        if (lookasides != null) {\n            for (final Object element : lookasides.entrySet()) {\n                final Map.Entry entry = (Map.Entry) element;\n                final String prefix = (String) entry.getKey();\n                if (name.startsWith(prefix)) {\n                    final ClassLoader loader = (ClassLoader) entry.getValue();\n                    final Class clazz = Class.forName(name, resolve, loader);\n                    return clazz;\n                }\n            }\n        }\n\n        if (parentFirst) {\n            return super.loadClass(name, resolve);\n        }\n        try {\n            Class clazz = findLoadedClass(name);\n            if (clazz == null) {\n                clazz = super.findClass(name);\n            }\n            if (resolve) {\n                resolveClass(clazz);\n            }\n            return clazz;\n        } catch (final ClassNotFoundException e) {\n            return super.loadClass(name, resolve);\n        }\n    }\n\n    /**\n     * Specify whether this classloader should ask the parent classloader\n     * to resolve a class first, before trying to resolve it via its own\n     * classpath.\n     * <p>\n     * Checking with the parent first is the normal approach for java, but\n     * components within containers such as servlet engines can use\n     * child-first lookup instead, to allow the components to override libs\n     * which are visible in shared classloaders provided by the container.\n     * <p>\n     * Note that the method getResources always behaves as if parentFirst=true,\n     * because of limitations in java 1.4; see the javadoc for method\n     * getResourcesInOrder for details.\n     * <p>\n     * This value defaults to true.\n     */\n    public void setParentFirst(final boolean state) {\n        parentFirst = state;\n    }\n\n    /**\n     *\n     * Clean implementation of list function of\n     * {@link java.util.Collection} added in JDK 1.4\n     * @param en {@code Enumeration}, possibly null\n     * @return {@code ArrayList} containing the enumerated\n     * elements in the enumerated order, not null\n     */\n    private ArrayList toList(final Enumeration en) {\n        final ArrayList results = new ArrayList();\n        if (en != null) {\n            while (en.hasMoreElements()){\n                final Object element = en.nextElement();\n                results.add(element);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Specify a classloader to use for specific java packages.\n     * <p>\n     * The specified classloader is normally a loader that is NOT\n     * an ancestor of this classloader. In particular, this loader\n     * may have the bootloader as its parent, but be configured to\n     * see specific other classes (eg the junit library loaded\n     * via the system classloader).\n     * <p>\n     * The differences between using this method, and using\n     * addLogicalLib are:\n     * <ul>\n     * <li>If code calls getClassLoader on a class loaded via\n     * \"lookaside\", then traces up its inheritance chain, it\n     * will see the \"real\" classloaders. When the class is remapped\n     * into this classloader via addLogicalLib, the classloader\n     * chain seen is this object plus ancestors.\n     * <li>If two different jars contain classes in the same\n     * package, then it is not possible to load both jars into\n     * the same \"lookaside\" classloader (eg the system classloader)\n     * then map one of those subsets from here. Of course they could\n     * be loaded into two different \"lookaside\" classloaders and\n     * then a prefix used to map from here to one of those classloaders.\n     * <\/ul>\n     */\n    public void useExplicitLoader(final String prefix, final ClassLoader loader) {\n        if (lookasides == null) {\n            lookasides = new HashMap();\n        }\n        lookasides.put(prefix, loader);\n    }\n\n    /**\n     * For classes with the specified prefix, get them from the system\n     * classpath <i>which is active at the point this method is called<\/i>.\n     * <p>\n     * This method is just a shortcut for\n     * <pre>\n     * useExplicitLoader(prefix, ClassLoader.getSystemClassLoader());\n     * <\/pre>\n     * <p>\n     * Of course, this assumes that the classes of interest are already\n     * in the classpath of the system classloader.\n     */\n    public void useSystemLoader(final String prefix) {\n        useExplicitLoader(prefix, ClassLoader.getSystemClassLoader());\n\n    }\n}\n","lineNo":125}
