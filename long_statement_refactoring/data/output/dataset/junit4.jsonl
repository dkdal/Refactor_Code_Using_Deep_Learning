{"Smelly Sample":"package org.junit.runners.model;\n\nimport java.lang.reflect.Modifier;\nimport java.util.List;\n\n/**\n * Parent class for {@link FrameworkField} and {@link FrameworkMethod}\n *\n * @since 4.7\n */\npublic abstract class FrameworkMember<T extends FrameworkMember<T>> implements\n        Annotatable {\n    abstract boolean isShadowedBy(T otherMember);\n\n    @SuppressWarnings(\"unchecked\")\n    T handlePossibleBridgeMethod(List<T> members) {\n        for (int i = members.size() - 1; i >=0; i--) {\n            T otherMember = members.get(i);\n            if (isShadowedBy(otherMember)) {\n                if (otherMember.isBridgeMethod()) {\n                    /*\n                     *  We need to return the previously-encountered bridge method\n                     *  because JUnit won't be able to call the parent method,\n                     *  because the parent class isn't public.\n                     */\n                    members.remove(i);\n                    return otherMember;\n                }\n                // We found a shadowed member that isn't a bridge method. Ignore it.\n                return null;\n            }\n        }\n        // No shadow or bridge method found. The caller should add *this* member.\n        return (T) this;\n    }\n\n    abstract boolean isBridgeMethod();\n\n    protected abstract int getModifiers();\n\n    /**\n     * Returns true if this member is static, false if not.\n     */\n    public boolean isStatic() {\n        return Modifier.isStatic(getModifiers());\n    }\n\n    /**\n     * Returns true if this member is public, false if not.\n     */\n    public boolean isPublic() {\n        return Modifier.isPublic(getModifiers());\n    }\n\n    public abstract String getName();\n\n    public abstract Class<?> getType();\n\n    public abstract Class<?> getDeclaringClass();\n}\n","Method after Refactoring":"package org.junit.runners.model;\n\nimport java.lang.reflect.Modifier;\nimport java.util.List;\n\n/**\n * Parent class for {@link FrameworkField} and {@link FrameworkMethod}\n *\n * @since 4.7\n */\npublic abstract class FrameworkMember<T extends FrameworkMember<T>> implements\n        Annotatable {\n    abstract boolean isShadowedBy(T otherMember);\n\n    T handlePossibleBridgeMethod(List<T> members) {\n        for (int i = members.size() - 1; i >=0; i--) {\n            T otherMember = members.get(i);\n            if (isShadowedBy(otherMember)) {\n                if (otherMember.isBridgeMethod()) {\n                    /*\n                     *  We need to return the previously-encountered bridge method\n                     *  because JUnit won't be able to call the parent method,\n                     *  because the parent class isn't public.\n                     */\n                    members.remove(i);\n                    return otherMember;\n                }\n                // We found a shadowed member that isn't a bridge method. Ignore it.\n                return null;\n            }\n        }\n        // No shadow or bridge method found. The caller should add *this* member.\n        FrameworkMember<? extends T> thisMember = this;\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) thisMember;\n\n        return result;\n    }\n\n    abstract boolean isBridgeMethod();\n\n    protected abstract int getModifiers();\n\n    /**\n     * Returns true if this member is static, false if not.\n     */\n    public boolean isStatic() {\n        return Modifier.isStatic(getModifiers());\n    }\n\n    /**\n     * Returns true if this member is public, false if not.\n     */\n    public boolean isPublic() {\n        return Modifier.isPublic(getModifiers());\n    }\n\n    public abstract String getName();\n\n    public abstract Class<?> getType();\n\n    public abstract Class<?> getDeclaringClass();\n}\n","lineNo":33}
{"Smelly Sample":"package org.junit.runners;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.runner.Runner;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InvalidTestClassError;\nimport org.junit.runners.model.TestClass;\nimport org.junit.runners.parameterized.BlockJUnit4ClassRunnerWithParametersFactory;\nimport org.junit.runners.parameterized.ParametersRunnerFactory;\nimport org.junit.runners.parameterized.TestWithParameters;\n\n/**\n * The custom runner <code>Parameterized<\/code> implements parameterized tests.\n * When running a parameterized test class, instances are created for the\n * cross-product of the test methods and the test data elements.\n * <p>\n * For example, to test the <code>+<\/code> operator, write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class AdditionTest {\n *     &#064;Parameters(name = &quot;{index}: {0} + {1} = {2}&quot;)\n *     public static Iterable&lt;Object[]&gt; data() {\n *         return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 },\n *                 { 3, 2, 5 }, { 4, 3, 7 } });\n *     }\n *\n *     private int firstSummand;\n *\n *     private int secondSummand;\n *\n *     private int sum;\n *\n *     public AdditionTest(int firstSummand, int secondSummand, int sum) {\n *         this.firstSummand = firstSummand;\n *         this.secondSummand = secondSummand;\n *         this.sum = sum;\n *     }\n *\n *     &#064;Test\n *     public void test() {\n *         assertEquals(sum, firstSummand + secondSummand);\n *     }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>AdditionTest<\/code> will be constructed using the\n * three-argument constructor and the data values in the\n * <code>&#064;Parameters<\/code> method.\n * <p>\n * In order that you can easily identify the individual tests, you may provide a\n * name for the <code>&#064;Parameters<\/code> annotation. This name is allowed\n * to contain placeholders, which are replaced at runtime. The placeholders are\n * <dl>\n * <dt>{index}<\/dt>\n * <dd>the current parameter index<\/dd>\n * <dt>{0}<\/dt>\n * <dd>the first parameter value<\/dd>\n * <dt>{1}<\/dt>\n * <dd>the second parameter value<\/dd>\n * <dt>...<\/dt>\n * <dd>...<\/dd>\n * <\/dl>\n * <p>\n * In the example given above, the <code>Parameterized<\/code> runner creates\n * names like <code>[2: 3 + 2 = 5]<\/code>. If you don't use the name parameter,\n * then the current parameter index is used as name.\n * <p>\n * You can also write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class AdditionTest {\n *     &#064;Parameters(name = &quot;{index}: {0} + {1} = {2}&quot;)\n *     public static Iterable&lt;Object[]&gt; data() {\n *         return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 },\n *                 { 3, 2, 5 }, { 4, 3, 7 } });\n *     }\n *\n *     &#064;Parameter(0)\n *     public int firstSummand;\n *\n *     &#064;Parameter(1)\n *     public int secondSummand;\n *\n *     &#064;Parameter(2)\n *     public int sum;\n *\n *     &#064;Test\n *     public void test() {\n *         assertEquals(sum, firstSummand + secondSummand);\n *     }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>AdditionTest<\/code> will be constructed with the default constructor\n * and fields annotated by <code>&#064;Parameter<\/code>  will be initialized\n * with the data values in the <code>&#064;Parameters<\/code> method.\n *\n * <p>\n * The parameters can be provided as an array, too:\n * \n * <pre>\n * &#064;Parameters\n * public static Object[][] data() {\n * \treturn new Object[][] { { 0, 0, 0 }, { 1, 1, 2 }, { 3, 2, 5 }, { 4, 3, 7 } } };\n * }\n * <\/pre>\n * \n * <h3>Tests with single parameter<\/h3>\n * <p>\n * If your test needs a single parameter only, you don't have to wrap it with an\n * array. Instead you can provide an <code>Iterable<\/code> or an array of\n * objects.\n * <pre>\n * &#064;Parameters\n * public static Iterable&lt;? extends Object&gt; data() {\n * \treturn Arrays.asList(&quot;first test&quot;, &quot;second test&quot;);\n * }\n * <\/pre>\n * <p>\n * or\n * <pre>\n * &#064;Parameters\n * public static Object[] data() {\n * \treturn new Object[] { &quot;first test&quot;, &quot;second test&quot; };\n * }\n * <\/pre>\n *\n * <h3>Executing code before/after executing tests for specific parameters<\/h3>\n * <p>\n * If your test needs to perform some preparation or cleanup based on the\n * parameters, this can be done by adding public static methods annotated with\n * {@code @BeforeParam}/{@code @AfterParam}. Such methods should either have no\n * parameters or the same parameters as the test.\n * <pre>\n * &#064;BeforeParam\n * public static void beforeTestsForParameter(String onlyParameter) {\n *     System.out.println(\"Testing \" + onlyParameter);\n * }\n * <\/pre>\n *\n * <h3>Create different runners<\/h3>\n * <p>\n * By default the {@code Parameterized} runner creates a slightly modified\n * {@link BlockJUnit4ClassRunner} for each set of parameters. You can build an\n * own {@code Parameterized} runner that creates another runner for each set of\n * parameters. Therefore you have to build a {@link ParametersRunnerFactory}\n * that creates a runner for each {@link TestWithParameters}. (\n * {@code TestWithParameters} are bundling the parameters and the test name.)\n * The factory must have a public zero-arg constructor.\n *\n * <pre>\n * public class YourRunnerFactory implements ParametersRunnerFactory {\n *     public Runner createRunnerForTestWithParameters(TestWithParameters test)\n *             throws InitializationError {\n *         return YourRunner(test);\n *     }\n * }\n * <\/pre>\n * <p>\n * Use the {@link UseParametersRunnerFactory} to tell the {@code Parameterized}\n * runner that it should use your factory.\n *\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * &#064;UseParametersRunnerFactory(YourRunnerFactory.class)\n * public class YourTest {\n *     ...\n * }\n * <\/pre>\n *\n * @since 4.0\n */\npublic class Parameterized extends Suite {\n    /**\n     * Annotation for a method which provides parameters to be injected into the\n     * test class constructor by <code>Parameterized<\/code>. The method has to\n     * be public and static.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public @interface Parameters {\n        /**\n         * Optional pattern to derive the test's name from the parameters. Use\n         * numbers in braces to refer to the parameters or the additional data\n         * as follows:\n         * <pre>\n         * {index} - the current parameter index\n         * {0} - the first parameter value\n         * {1} - the second parameter value\n         * etc...\n         * <\/pre>\n         * <p>\n         * Default value is \"{index}\" for compatibility with previous JUnit\n         * versions.\n         *\n         * @return {@link MessageFormat} pattern string, except the index\n         *         placeholder.\n         * @see MessageFormat\n         */\n        String name() default \"{index}\";\n    }\n\n    /**\n     * Annotation for fields of the test class which will be initialized by the\n     * method annotated by <code>Parameters<\/code>.\n     * By using directly this annotation, the test class constructor isn't needed.\n     * Index range must start at 0.\n     * Default value is 0.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.FIELD)\n    public @interface Parameter {\n        /**\n         * Method that returns the index of the parameter in the array\n         * returned by the method annotated by <code>Parameters<\/code>.\n         * Index range must start at 0.\n         * Default value is 0.\n         *\n         * @return the index of the parameter.\n         */\n        int value() default 0;\n    }\n\n    /**\n     * Add this annotation to your test class if you want to generate a special\n     * runner. You have to specify a {@link ParametersRunnerFactory} class that\n     * creates such runners. The factory must have a public zero-arg\n     * constructor.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Inherited\n    @Target(ElementType.TYPE)\n    public @interface UseParametersRunnerFactory {\n        /**\n         * @return a {@link ParametersRunnerFactory} class (must have a default\n         *         constructor)\n         */\n        Class<? extends ParametersRunnerFactory> value() default BlockJUnit4ClassRunnerWithParametersFactory.class;\n    }\n\n    /**\n     * Annotation for {@code public static void} methods which should be executed before\n     * evaluating tests with particular parameters.\n     *\n     * @see org.junit.BeforeClass\n     * @see org.junit.Before\n     * @since 4.13\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public @interface BeforeParam {\n    }\n\n    /**\n     * Annotation for {@code public static void} methods which should be executed after\n     * evaluating tests with particular parameters.\n     *\n     * @see org.junit.AfterClass\n     * @see org.junit.After\n     * @since 4.13\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public @interface AfterParam {\n    }\n\n    /**\n     * Only called reflectively. Do not use programmatically.\n     */\n    public Parameterized(Class<?> klass) throws Throwable {\n        this(klass, new RunnersFactory(klass));\n    }\n\n    private Parameterized(Class<?> klass, RunnersFactory runnersFactory) throws Exception {\n        super(klass, runnersFactory.createRunners());\n        validateBeforeParamAndAfterParamMethods(runnersFactory.parameterCount);\n    }\n\n    private void validateBeforeParamAndAfterParamMethods(Integer parameterCount)\n            throws InvalidTestClassError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        validatePublicStaticVoidMethods(Parameterized.BeforeParam.class, parameterCount, errors);\n        validatePublicStaticVoidMethods(Parameterized.AfterParam.class, parameterCount, errors);\n        if (!errors.isEmpty()) {\n            throw new InvalidTestClassError(getTestClass().getJavaClass(), errors);\n        }\n    }\n\n    private void validatePublicStaticVoidMethods(\n            Class<? extends Annotation> annotation, Integer parameterCount,\n            List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n        for (FrameworkMethod fm : methods) {\n            fm.validatePublicVoid(true, errors);\n            if (parameterCount != null) {\n                int methodParameterCount = fm.getMethod().getParameterTypes().length;\n                if (methodParameterCount != 0 && methodParameterCount != parameterCount) {\n                    errors.add(new Exception(\"Method \" + fm.getName()\n                            + \"() should have 0 or \" + parameterCount + \" parameter(s)\"));\n                }\n            }\n        }\n    }\n\n    private static class RunnersFactory {\n        private static final ParametersRunnerFactory DEFAULT_FACTORY = new BlockJUnit4ClassRunnerWithParametersFactory();\n\n        private final TestClass testClass;\n        private final FrameworkMethod parametersMethod;\n        private final List<Object> allParameters;\n        private final int parameterCount;\n\n\n        private RunnersFactory(Class<?> klass) throws Throwable {\n            testClass = new TestClass(klass);\n            parametersMethod = getParametersMethod(testClass);\n            allParameters = allParameters(testClass, parametersMethod);\n            parameterCount =\n                    allParameters.isEmpty() ? 0 : normalizeParameters(allParameters.get(0)).length;\n        }\n\n        private List<Runner> createRunners() throws Exception {\n            Parameters parameters = parametersMethod.getAnnotation(Parameters.class);\n            return Collections.unmodifiableList(createRunnersForParameters(\n                    allParameters, parameters.name(),\n                    getParametersRunnerFactory()));\n        }\n\n        private ParametersRunnerFactory getParametersRunnerFactory()\n                throws InstantiationException, IllegalAccessException {\n            UseParametersRunnerFactory annotation = testClass\n                    .getAnnotation(UseParametersRunnerFactory.class);\n            if (annotation == null) {\n                return DEFAULT_FACTORY;\n            } else {\n                Class<? extends ParametersRunnerFactory> factoryClass = annotation\n                        .value();\n                return factoryClass.newInstance();\n            }\n        }\n\n        private TestWithParameters createTestWithNotNormalizedParameters(\n                String pattern, int index, Object parametersOrSingleParameter) {\n            Object[] parameters = normalizeParameters(parametersOrSingleParameter);\n            return createTestWithParameters(testClass, pattern, index, parameters);\n        }\n\n        private static Object[] normalizeParameters(Object parametersOrSingleParameter) {\n            return (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter\n                    : new Object[] { parametersOrSingleParameter };\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private static List<Object> allParameters(\n                TestClass testClass, FrameworkMethod parametersMethod) throws Throwable {\n            Object parameters = parametersMethod.invokeExplosively(null);\n            if (parameters instanceof List) {\n                return (List<Object>) parameters;\n            } else if (parameters instanceof Collection) {\n                return new ArrayList<Object>((Collection<Object>) parameters);\n            } else if (parameters instanceof Iterable) {\n                List<Object> result = new ArrayList<Object>();\n                for (Object entry : ((Iterable<Object>) parameters)) {\n                    result.add(entry);\n                }\n                return result;\n            } else if (parameters instanceof Object[]) {\n                return Arrays.asList((Object[]) parameters);\n            } else {\n                throw parametersMethodReturnedWrongType(testClass, parametersMethod);\n            }\n        }\n\n        private static FrameworkMethod getParametersMethod(TestClass testClass) throws Exception {\n            List<FrameworkMethod> methods = testClass\n                    .getAnnotatedMethods(Parameters.class);\n            for (FrameworkMethod each : methods) {\n                if (each.isStatic() && each.isPublic()) {\n                    return each;\n                }\n            }\n\n            throw new Exception(\"No public static parameters method on class \"\n                    + testClass.getName());\n        }\n\n        private List<Runner> createRunnersForParameters(\n                Iterable<Object> allParameters, String namePattern,\n                ParametersRunnerFactory runnerFactory) throws Exception {\n            try {\n                List<TestWithParameters> tests = createTestsForParameters(\n                        allParameters, namePattern);\n                List<Runner> runners = new ArrayList<Runner>();\n                for (TestWithParameters test : tests) {\n                    runners.add(runnerFactory\n                            .createRunnerForTestWithParameters(test));\n                }\n                return runners;\n            } catch (ClassCastException e) {\n                throw parametersMethodReturnedWrongType(testClass, parametersMethod);\n            }\n        }\n\n        private List<TestWithParameters> createTestsForParameters(\n                Iterable<Object> allParameters, String namePattern)\n                throws Exception {\n            int i = 0;\n            List<TestWithParameters> children = new ArrayList<TestWithParameters>();\n            for (Object parametersOfSingleTest : allParameters) {\n                children.add(createTestWithNotNormalizedParameters(namePattern,\n                        i++, parametersOfSingleTest));\n            }\n            return children;\n        }\n\n        private static Exception parametersMethodReturnedWrongType(\n                TestClass testClass, FrameworkMethod parametersMethod) throws Exception {\n            String className = testClass.getName();\n            String methodName = parametersMethod.getName();\n            String message = MessageFormat.format(\n                    \"{0}.{1}() must return an Iterable of arrays.\", className,\n                    methodName);\n            return new Exception(message);\n        }\n\n        private TestWithParameters createTestWithParameters(\n                TestClass testClass, String pattern, int index,\n                Object[] parameters) {\n            String finalPattern = pattern.replaceAll(\"\\\\{index\\\\}\",\n                    Integer.toString(index));\n            String name = MessageFormat.format(finalPattern, parameters);\n            return new TestWithParameters(\"[\" + name + \"]\", testClass,\n                    Arrays.asList(parameters));\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InvalidTestClassError;\nimport org.junit.runners.model.TestClass;\nimport org.junit.runners.parameterized.BlockJUnit4ClassRunnerWithParametersFactory;\nimport org.junit.runners.parameterized.ParametersRunnerFactory;\nimport org.junit.runners.parameterized.TestWithParameters;\n\n/**\n * The custom runner <code>Parameterized<\/code> implements parameterized tests.\n * When running a parameterized test class, instances are created for the\n * cross-product of the test methods and the test data elements.\n * <p>\n * For example, to test the <code>+<\/code> operator, write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class AdditionTest {\n *     &#064;Parameters(name = &quot;{index}: {0} + {1} = {2}&quot;)\n *     public static Iterable&lt;Object[]&gt; data() {\n *         return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 },\n *                 { 3, 2, 5 }, { 4, 3, 7 } });\n *     }\n *\n *     private int firstSummand;\n *\n *     private int secondSummand;\n *\n *     private int sum;\n *\n *     public AdditionTest(int firstSummand, int secondSummand, int sum) {\n *         this.firstSummand = firstSummand;\n *         this.secondSummand = secondSummand;\n *         this.sum = sum;\n *     }\n *\n *     &#064;Test\n *     public void test() {\n *         assertEquals(sum, firstSummand + secondSummand);\n *     }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>AdditionTest<\/code> will be constructed using the\n * three-argument constructor and the data values in the\n * <code>&#064;Parameters<\/code> method.\n * <p>\n * In order that you can easily identify the individual tests, you may provide a\n * name for the <code>&#064;Parameters<\/code> annotation. This name is allowed\n * to contain placeholders, which are replaced at runtime. The placeholders are\n * <dl>\n * <dt>{index}<\/dt>\n * <dd>the current parameter index<\/dd>\n * <dt>{0}<\/dt>\n * <dd>the first parameter value<\/dd>\n * <dt>{1}<\/dt>\n * <dd>the second parameter value<\/dd>\n * <dt>...<\/dt>\n * <dd>...<\/dd>\n * <\/dl>\n * <p>\n * In the example given above, the <code>Parameterized<\/code> runner creates\n * names like <code>[2: 3 + 2 = 5]<\/code>. If you don't use the name parameter,\n * then the current parameter index is used as name.\n * <p>\n * You can also write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class AdditionTest {\n *     &#064;Parameters(name = &quot;{index}: {0} + {1} = {2}&quot;)\n *     public static Iterable&lt;Object[]&gt; data() {\n *         return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 },\n *                 { 3, 2, 5 }, { 4, 3, 7 } });\n *     }\n *\n *     &#064;Parameter(0)\n *     public int firstSummand;\n *\n *     &#064;Parameter(1)\n *     public int secondSummand;\n *\n *     &#064;Parameter(2)\n *     public int sum;\n *\n *     &#064;Test\n *     public void test() {\n *         assertEquals(sum, firstSummand + secondSummand);\n *     }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>AdditionTest<\/code> will be constructed with the default constructor\n * and fields annotated by <code>&#064;Parameter<\/code>  will be initialized\n * with the data values in the <code>&#064;Parameters<\/code> method.\n *\n * <p>\n * The parameters can be provided as an array, too:\n * \n * <pre>\n * &#064;Parameters\n * public static Object[][] data() {\n * \treturn new Object[][] { { 0, 0, 0 }, { 1, 1, 2 }, { 3, 2, 5 }, { 4, 3, 7 } } };\n * }\n * <\/pre>\n * \n * <h3>Tests with single parameter<\/h3>\n * <p>\n * If your test needs a single parameter only, you don't have to wrap it with an\n * array. Instead you can provide an <code>Iterable<\/code> or an array of\n * objects.\n * <pre>\n * &#064;Parameters\n * public static Iterable&lt;? extends Object&gt; data() {\n * \treturn Arrays.asList(&quot;first test&quot;, &quot;second test&quot;);\n * }\n * <\/pre>\n * <p>\n * or\n * <pre>\n * &#064;Parameters\n * public static Object[] data() {\n * \treturn new Object[] { &quot;first test&quot;, &quot;second test&quot; };\n * }\n * <\/pre>\n *\n * <h3>Executing code before/after executing tests for specific parameters<\/h3>\n * <p>\n * If your test needs to perform some preparation or cleanup based on the\n * parameters, this can be done by adding public static methods annotated with\n * {@code @BeforeParam}/{@code @AfterParam}. Such methods should either have no\n * parameters or the same parameters as the test.\n * <pre>\n * &#064;BeforeParam\n * public static void beforeTestsForParameter(String onlyParameter) {\n *     System.out.println(\"Testing \" + onlyParameter);\n * }\n * <\/pre>\n *\n * <h3>Create different runners<\/h3>\n * <p>\n * By default the {@code Parameterized} runner creates a slightly modified\n * {@link BlockJUnit4ClassRunner} for each set of parameters. You can build an\n * own {@code Parameterized} runner that creates another runner for each set of\n * parameters. Therefore you have to build a {@link ParametersRunnerFactory}\n * that creates a runner for each {@link TestWithParameters}. (\n * {@code TestWithParameters} are bundling the parameters and the test name.)\n * The factory must have a public zero-arg constructor.\n *\n * <pre>\n * public class YourRunnerFactory implements ParametersRunnerFactory {\n *     public Runner createRunnerForTestWithParameters(TestWithParameters test)\n *             throws InitializationError {\n *         return YourRunner(test);\n *     }\n * }\n * <\/pre>\n * <p>\n * Use the {@link UseParametersRunnerFactory} to tell the {@code Parameterized}\n * runner that it should use your factory.\n *\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * &#064;UseParametersRunnerFactory(YourRunnerFactory.class)\n * public class YourTest {\n *     ...\n * }\n * <\/pre>\n *\n * @since 4.0\n */\npublic class Parameterized extends Suite {\n    /**\n     * Annotation for a method which provides parameters to be injected into the\n     * test class constructor by <code>Parameterized<\/code>. The method has to\n     * be public and static.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public @interface Parameters {\n        /**\n         * Optional pattern to derive the test's name from the parameters. Use\n         * numbers in braces to refer to the parameters or the additional data\n         * as follows:\n         * <pre>\n         * {index} - the current parameter index\n         * {0} - the first parameter value\n         * {1} - the second parameter value\n         * etc...\n         * <\/pre>\n         * <p>\n         * Default value is \"{index}\" for compatibility with previous JUnit\n         * versions.\n         *\n         * @return {@link MessageFormat} pattern string, except the index\n         *         placeholder.\n         * @see MessageFormat\n         */\n        String name() default \"{index}\";\n    }\n\n    /**\n     * Annotation for fields of the test class which will be initialized by the\n     * method annotated by <code>Parameters<\/code>.\n     * By using directly this annotation, the test class constructor isn't needed.\n     * Index range must start at 0.\n     * Default value is 0.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.FIELD)\n    public @interface Parameter {\n        /**\n         * Method that returns the index of the parameter in the array\n         * returned by the method annotated by <code>Parameters<\/code>.\n         * Index range must start at 0.\n         * Default value is 0.\n         *\n         * @return the index of the parameter.\n         */\n        int value() default 0;\n    }\n\n    /**\n     * Add this annotation to your test class if you want to generate a special\n     * runner. You have to specify a {@link ParametersRunnerFactory} class that\n     * creates such runners. The factory must have a public zero-arg\n     * constructor.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Inherited\n    @Target(ElementType.TYPE)\n    public @interface UseParametersRunnerFactory {\n        /**\n         * @return a {@link ParametersRunnerFactory} class (must have a default\n         *         constructor)\n         */\n        Class<? extends ParametersRunnerFactory> value() default BlockJUnit4ClassRunnerWithParametersFactory.class;\n    }\n\n    /**\n     * Annotation for {@code public static void} methods which should be executed before\n     * evaluating tests with particular parameters.\n     *\n     * @see org.junit.BeforeClass\n     * @see org.junit.Before\n     * @since 4.13\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public @interface BeforeParam {\n    }\n\n    /**\n     * Annotation for {@code public static void} methods which should be executed after\n     * evaluating tests with particular parameters.\n     *\n     * @see org.junit.AfterClass\n     * @see org.junit.After\n     * @since 4.13\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public @interface AfterParam {\n    }\n\n    /**\n     * Only called reflectively. Do not use programmatically.\n     */\n    public Parameterized(Class<?> klass) throws Throwable {\n        this(klass, new RunnersFactory(klass));\n    }\n\n    private Parameterized(Class<?> klass, RunnersFactory runnersFactory) throws Exception {\n        super(klass, runnersFactory.createRunners());\n        validateBeforeParamAndAfterParamMethods(runnersFactory.parameterCount);\n    }\n\n    private void validateBeforeParamAndAfterParamMethods(Integer parameterCount)\n            throws InvalidTestClassError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        validatePublicStaticVoidMethods(Parameterized.BeforeParam.class, parameterCount, errors);\n        validatePublicStaticVoidMethods(Parameterized.AfterParam.class, parameterCount, errors);\n        if (!errors.isEmpty()) {\n            throw new InvalidTestClassError(getTestClass().getJavaClass(), errors);\n        }\n    }\n\n    private void validatePublicStaticVoidMethods(\n            Class<? extends Annotation> annotation, Integer parameterCount,\n            List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n        for (FrameworkMethod fm : methods) {\n            fm.validatePublicVoid(true, errors);\n            if (parameterCount != null) {\n                int methodParameterCount = fm.getMethod().getParameterTypes().length;\n                if (methodParameterCount != 0 && methodParameterCount != parameterCount) {\n                    errors.add(new Exception(\"Method \" + fm.getName()\n                            + \"() should have 0 or \" + parameterCount + \" parameter(s)\"));\n                }\n            }\n        }\n    }\n\n    private static class AssumptionViolationRunner extends Runner {\n        private final Description description;\n        private final AssumptionViolatedException exception;\n\n        AssumptionViolationRunner(TestClass testClass, String methodName,\n                AssumptionViolatedException exception) {\n            this.description = Description\n                    .createTestDescription(testClass.getJavaClass(),\n                            methodName + \"() assumption violation\");\n            this.exception = exception;\n        }\n\n        @Override\n        public Description getDescription() {\n            return description;\n        }\n\n        @Override\n        public void run(RunNotifier notifier) {\n            notifier.fireTestAssumptionFailed(new Failure(description, exception));\n        }\n    }\n\n    private static class RunnersFactory {\n        private static final ParametersRunnerFactory DEFAULT_FACTORY = new BlockJUnit4ClassRunnerWithParametersFactory();\n\n        private final TestClass testClass;\n        private final FrameworkMethod parametersMethod;\n        private final List<Object> allParameters;\n        private final int parameterCount;\n        private final Runner runnerOverride;\n\n        private RunnersFactory(Class<?> klass) throws Throwable {\n            testClass = new TestClass(klass);\n            parametersMethod = getParametersMethod(testClass);\n            List<Object> allParametersResult;\n            AssumptionViolationRunner assumptionViolationRunner = null;\n            try {\n                allParametersResult = allParameters(testClass, parametersMethod);\n            } catch (AssumptionViolatedException e) {\n                allParametersResult = Collections.emptyList();\n                assumptionViolationRunner = new AssumptionViolationRunner(testClass,\n                        parametersMethod.getName(), e);\n            }\n            allParameters = allParametersResult;\n            runnerOverride = assumptionViolationRunner;\n            parameterCount =\n                    allParameters.isEmpty() ? 0 : normalizeParameters(allParameters.get(0)).length;\n        }\n\n        private List<Runner> createRunners() throws Exception {\n            if (runnerOverride != null) {\n                return Collections.singletonList(runnerOverride);\n            }\n            Parameters parameters = parametersMethod.getAnnotation(Parameters.class);\n            return Collections.unmodifiableList(createRunnersForParameters(\n                    allParameters, parameters.name(),\n                    getParametersRunnerFactory()));\n        }\n\n        private ParametersRunnerFactory getParametersRunnerFactory()\n                throws InstantiationException, IllegalAccessException {\n            UseParametersRunnerFactory annotation = testClass\n                    .getAnnotation(UseParametersRunnerFactory.class);\n            if (annotation == null) {\n                return DEFAULT_FACTORY;\n            } else {\n                Class<? extends ParametersRunnerFactory> factoryClass = annotation\n                        .value();\n                return factoryClass.newInstance();\n            }\n        }\n\n        private TestWithParameters createTestWithNotNormalizedParameters(\n                String pattern, int index, Object parametersOrSingleParameter) {\n            Object[] parameters = normalizeParameters(parametersOrSingleParameter);\n            return createTestWithParameters(testClass, pattern, index, parameters);\n        }\n\n        private static Object[] normalizeParameters(Object parametersOrSingleParameter) {\n            return (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter\n                    : new Object[] { parametersOrSingleParameter };\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private static List<Object> allParameters(\n                TestClass testClass, FrameworkMethod parametersMethod) throws Throwable {\n            Object parameters = parametersMethod.invokeExplosively(null);\n            if (parameters instanceof List) {\n                return (List<Object>) parameters;\n            } else if (parameters instanceof Collection) {\n                return new ArrayList<Object>((Collection<Object>) parameters);\n            } else if (parameters instanceof Iterable) {\n                List<Object> result = new ArrayList<Object>();\n                for (Object entry : ((Iterable<Object>) parameters)) {\n                    result.add(entry);\n                }\n                return result;\n            } else if (parameters instanceof Object[]) {\n                return Arrays.asList((Object[]) parameters);\n            } else {\n                throw parametersMethodReturnedWrongType(testClass, parametersMethod);\n            }\n        }\n\n        private static FrameworkMethod getParametersMethod(TestClass testClass) throws Exception {\n            List<FrameworkMethod> methods = testClass\n                    .getAnnotatedMethods(Parameters.class);\n            for (FrameworkMethod each : methods) {\n                if (each.isStatic() && each.isPublic()) {\n                    return each;\n                }\n            }\n\n            throw new Exception(\"No public static parameters method on class \"\n                    + testClass.getName());\n        }\n\n        private List<Runner> createRunnersForParameters(\n                Iterable<Object> allParameters, String namePattern,\n                ParametersRunnerFactory runnerFactory) throws Exception {\n            try {\n                List<TestWithParameters> tests = createTestsForParameters(\n                        allParameters, namePattern);\n                List<Runner> runners = new ArrayList<Runner>();\n                for (TestWithParameters test : tests) {\n                    runners.add(runnerFactory\n                            .createRunnerForTestWithParameters(test));\n                }\n                return runners;\n            } catch (ClassCastException e) {\n                throw parametersMethodReturnedWrongType(testClass, parametersMethod);\n            }\n        }\n\n        private List<TestWithParameters> createTestsForParameters(\n                Iterable<Object> allParameters, String namePattern)\n                throws Exception {\n            int i = 0;\n            List<TestWithParameters> children = new ArrayList<TestWithParameters>();\n            for (Object parametersOfSingleTest : allParameters) {\n                children.add(createTestWithNotNormalizedParameters(namePattern,\n                        i++, parametersOfSingleTest));\n            }\n            return children;\n        }\n\n        private static Exception parametersMethodReturnedWrongType(\n                TestClass testClass, FrameworkMethod parametersMethod) throws Exception {\n            String className = testClass.getName();\n            String methodName = parametersMethod.getName();\n            String message = MessageFormat.format(\n                    \"{0}.{1}() must return an Iterable of arrays.\", className,\n                    methodName);\n            return new Exception(message);\n        }\n\n        private TestWithParameters createTestWithParameters(\n                TestClass testClass, String pattern, int index,\n                Object[] parameters) {\n            String finalPattern = pattern.replaceAll(\"\\\\{index\\\\}\",\n                    Integer.toString(index));\n            String name = MessageFormat.format(finalPattern, parameters);\n            return new TestWithParameters(\"[\" + name + \"]\", testClass,\n                    Arrays.asList(parameters));\n        }\n    }\n}\n","lineNo":356}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_VALIDATOR;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.MethodRule;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\nimport org.junit.validator.PublicClassValidator;\nimport org.junit.validator.TestClassValidator;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * <p>\n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n *\n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n *\n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n * <p>\n * In turn, in 2009 we introduced {@link Rule}s.  In many cases where extending\n * BlockJUnit4ClassRunner was necessary to add new behavior, {@link Rule}s can\n * be used, which makes the extension more reusable and composable.\n *\n * @since 4.5\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n    private static TestClassValidator PUBLIC_CLASS_VALIDATOR = new PublicClassValidator();\n\n    private final ConcurrentMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();\n\n    /**\n     * Creates a BlockJUnit4ClassRunner to run {@code testClass}\n     *\n     * @throws InitializationError if the test class is malformed.\n     */\n    public BlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {\n        super(testClass);\n    }\n\n    //\n    // Implementation of ParentRunner\n    //\n\n    @Override\n    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement;\n            try {\n                statement = methodBlock(method);\n            }\n            catch (Throwable ex) {\n                statement = new Fail(ex);\n            }\n            runLeaf(statement, description, notifier);\n        }\n    }\n\n    /**\n     * Evaluates whether {@link FrameworkMethod}s are ignored based on the\n     * {@link Ignore} annotation.\n     */\n    @Override\n    protected boolean isIgnored(FrameworkMethod child) {\n        return child.getAnnotation(Ignore.class) != null;\n    }\n\n    @Override\n    protected Description describeChild(FrameworkMethod method) {\n        Description description = methodDescriptions.get(method);\n\n        if (description == null) {\n            description = Description.createTestDescription(getTestClass().getJavaClass(),\n                    testName(method), method.getAnnotations());\n            methodDescriptions.putIfAbsent(method, description);\n        }\n\n        return description;\n    }\n\n    @Override\n    protected List<FrameworkMethod> getChildren() {\n        return computeTestMethods();\n    }\n\n    //\n    // Override in subclasses\n    //\n\n    /**\n     * Returns the methods that run tests. Default implementation returns all\n     * methods annotated with {@code @Test} on this class and superclasses that\n     * are not overridden.\n     */\n    protected List<FrameworkMethod> computeTestMethods() {\n        return getTestClass().getAnnotatedMethods(Test.class);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n\n        validatePublicConstructor(errors);\n        validateNoNonStaticInnerClass(errors);\n        validateConstructor(errors);\n        validateInstanceMethods(errors);\n        validateFields(errors);\n        validateMethods(errors);\n    }\n\n    private void validatePublicConstructor(List<Throwable> errors) {\n        if (getTestClass().getJavaClass() != null) {\n            errors.addAll(PUBLIC_CLASS_VALIDATOR.validateTestClass(getTestClass()));\n        }\n    }\n\n    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n        if (getTestClass().isANonStaticInnerClass()) {\n            String gripe = \"The inner class \" + getTestClass().getName()\n                    + \" is not static.\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor,\n     * or if the constructor takes parameters. Override if a subclass requires\n     * different validation rules.\n     */\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor\n     * (do not override)\n     */\n    protected void validateOnlyOneConstructor(List<Throwable> errors) {\n        if (!hasOneConstructor()) {\n            String gripe = \"Test class should have exactly one public constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class's single constructor takes\n     * parameters (do not override)\n     */\n    protected void validateZeroArgConstructor(List<Throwable> errors) {\n        if (!getTestClass().isANonStaticInnerClass()\n                && hasOneConstructor()\n                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n            String gripe = \"Test class should have exactly one public zero-argument constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    private boolean hasOneConstructor() {\n        return getTestClass().getJavaClass().getConstructors().length == 1;\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test},\n     * {@code @Before}, or {@code @After} that is not a public, void instance\n     * method with no arguments.\n     * @deprecated\n     */\n    @Deprecated\n    protected void validateInstanceMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(After.class, false, errors);\n        validatePublicVoidNoArgMethods(Before.class, false, errors);\n        validateTestMethods(errors);\n\n        if (computeTestMethods().isEmpty()) {\n            errors.add(new Exception(\"No runnable methods\"));\n        }\n    }\n\n    protected void validateFields(List<Throwable> errors) {\n        RULE_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    private void validateMethods(List<Throwable> errors) {\n        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test}that\n     * is not a public, void instance method with no arguments.\n     */\n    protected void validateTestMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(Test.class, false, errors);\n    }\n\n    /**\n     * Returns a new fixture for running a test. Default implementation executes\n     * the test class's no-argument constructor (validation should have ensured\n     * one exists).\n     */\n    protected Object createTest() throws Exception {\n        return getTestClass().getOnlyConstructor().newInstance();\n    }\n\n    /**\n     * Returns a new fixture to run a particular test {@code method} against.\n     * Default implementation executes the no-argument {@link #createTest()} method.\n     *\n     * @since 4.13\n     */\n    protected Object createTest(FrameworkMethod method) throws Exception {\n        return createTest();\n    }\n\n    /**\n     * Returns the name that describes {@code method} for {@link Description}s.\n     * Default implementation is the method's name\n     */\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n\n    /**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@link Test#expected()}\n     * attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * <\/ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest(method);\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }\n\n    //\n    // Statement builders\n    //\n\n    /**\n     * Returns a {@link Statement} that invokes {@code method} on {@code test}\n     */\n    protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@link Test#expected()} attribute, return normally only if {@code next}\n     * throws an exception of the correct type, and throw an exception\n     * otherwise.\n     */\n    protected Statement possiblyExpectingExceptions(FrameworkMethod method,\n            Object test, Statement next) {\n        Test annotation = method.getAnnotation(Test.class);\n        return expectsException(annotation) ? new ExpectException(next,\n                getExpectedException(annotation)) : next;\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code timeout} attribute, throw an exception if {@code next}\n     * takes more than the specified number of milliseconds.\n     * @deprecated\n     */\n    @Deprecated\n    protected Statement withPotentialTimeout(FrameworkMethod method,\n            Object test, Statement next) {\n        long timeout = getTimeout(method.getAnnotation(Test.class));\n        if (timeout <= 0) {\n            return next;\n        }\n        return FailOnTimeout.builder()\n               .withTimeout(timeout, TimeUnit.MILLISECONDS)\n               .build(next);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @Before}\n     * methods on this class and superclasses before running {@code next}; if\n     * any throws an Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBefores(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(\n                Before.class);\n        return befores.isEmpty() ? statement : new RunBefores(statement,\n                befores, target);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @After}\n     * methods on this class and superclasses before running {@code next}; all\n     * After methods are always executed: exceptions thrown by previous steps\n     * are combined, if necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfters(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(\n                After.class);\n        return afters.isEmpty() ? statement : new RunAfters(statement, afters,\n                target);\n    }\n\n    private Statement withRules(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<TestRule> testRules = getTestRules(target);\n        Statement result = statement;\n        result = withMethodRules(method, testRules, target, result);\n        result = withTestRules(method, testRules, result);\n\n        return result;\n    }\n\n    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,\n            Object target, Statement result) {\n        Statement withMethodRules = result;\n        for (org.junit.rules.MethodRule each : getMethodRules(target)) {\n            if (!(each instanceof TestRule && testRules.contains(each))) {\n                withMethodRules = each.apply(withMethodRules, method, target);\n            }\n        }\n        return withMethodRules;\n    }\n\n    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n        return rules(target);\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of MethodRules that should be applied when executing this\n     *         test\n     */\n    protected List<MethodRule> rules(Object target) {\n        List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, \n                Rule.class, MethodRule.class);\n\n        rules.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, MethodRule.class));\n\n        return rules;\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all non-static fields\n     * annotated with {@link Rule}.\n     *\n     * @param statement The base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,\n            Statement statement) {\n        return testRules.isEmpty() ? statement :\n                new RunRules(statement, testRules, describeChild(method));\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of TestRules that should be applied when executing this\n     *         test\n     */\n    protected List<TestRule> getTestRules(Object target) {\n        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,\n                Rule.class, TestRule.class);\n\n        result.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, TestRule.class));\n\n        return result;\n    }\n\n    private Class<? extends Throwable> getExpectedException(Test annotation) {\n        if (annotation == null || annotation.expected() == None.class) {\n            return null;\n        } else {\n            return annotation.expected();\n        }\n    }\n\n    private boolean expectsException(Test annotation) {\n        return getExpectedException(annotation) != null;\n    }\n\n    private long getTimeout(Test annotation) {\n        if (annotation == null) {\n            return 0;\n        }\n        return annotation.timeout();\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_VALIDATOR;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.MethodRule;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\nimport org.junit.validator.PublicClassValidator;\nimport org.junit.validator.TestClassValidator;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * <p>\n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n *\n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n *\n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n * <p>\n * In turn, in 2009 we introduced {@link Rule}s.  In many cases where extending\n * BlockJUnit4ClassRunner was necessary to add new behavior, {@link Rule}s can\n * be used, which makes the extension more reusable and composable.\n *\n * @since 4.5\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n    private static TestClassValidator PUBLIC_CLASS_VALIDATOR = new PublicClassValidator();\n\n    private final ConcurrentMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();\n\n    /**\n     * Creates a BlockJUnit4ClassRunner to run {@code testClass}\n     *\n     * @throws InitializationError if the test class is malformed.\n     */\n    public BlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {\n        super(testClass);\n    }\n\n    //\n    // Implementation of ParentRunner\n    //\n\n    @Override\n    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement;\n            try {\n                statement = methodBlock(method);\n            }\n            catch (Throwable ex) {\n                statement = new Fail(ex);\n            }\n            runLeaf(statement, description, notifier);\n        }\n    }\n\n    /**\n     * Evaluates whether {@link FrameworkMethod}s are ignored based on the\n     * {@link Ignore} annotation.\n     */\n    @Override\n    protected boolean isIgnored(FrameworkMethod child) {\n        return child.getAnnotation(Ignore.class) != null;\n    }\n\n    @Override\n    protected Description describeChild(FrameworkMethod method) {\n        Description description = methodDescriptions.get(method);\n\n        if (description == null) {\n            description = Description.createTestDescription(getTestClass().getJavaClass(),\n                    testName(method), method.getAnnotations());\n            methodDescriptions.putIfAbsent(method, description);\n        }\n\n        return description;\n    }\n\n    @Override\n    protected List<FrameworkMethod> getChildren() {\n        return computeTestMethods();\n    }\n\n    //\n    // Override in subclasses\n    //\n\n    /**\n     * Returns the methods that run tests. Default implementation returns all\n     * methods annotated with {@code @Test} on this class and superclasses that\n     * are not overridden.\n     */\n    protected List<FrameworkMethod> computeTestMethods() {\n        return getTestClass().getAnnotatedMethods(Test.class);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n\n        validatePublicConstructor(errors);\n        validateNoNonStaticInnerClass(errors);\n        validateConstructor(errors);\n        validateInstanceMethods(errors);\n        validateFields(errors);\n        validateMethods(errors);\n    }\n\n    private void validatePublicConstructor(List<Throwable> errors) {\n        if (getTestClass().getJavaClass() != null) {\n            errors.addAll(PUBLIC_CLASS_VALIDATOR.validateTestClass(getTestClass()));\n        }\n    }\n\n    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n        if (getTestClass().isANonStaticInnerClass()) {\n            String gripe = \"The inner class \" + getTestClass().getName()\n                    + \" is not static.\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor,\n     * or if the constructor takes parameters. Override if a subclass requires\n     * different validation rules.\n     */\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor\n     * (do not override)\n     */\n    protected void validateOnlyOneConstructor(List<Throwable> errors) {\n        if (!hasOneConstructor()) {\n            String gripe = \"Test class should have exactly one public constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class's single constructor takes\n     * parameters (do not override)\n     */\n    protected void validateZeroArgConstructor(List<Throwable> errors) {\n        if (!getTestClass().isANonStaticInnerClass()\n                && hasOneConstructor()\n                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n            String gripe = \"Test class should have exactly one public zero-argument constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    private boolean hasOneConstructor() {\n        return getTestClass().getJavaClass().getConstructors().length == 1;\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test},\n     * {@code @Before}, or {@code @After} that is not a public, void instance\n     * method with no arguments.\n     * @deprecated\n     */\n    @Deprecated\n    protected void validateInstanceMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(After.class, false, errors);\n        validatePublicVoidNoArgMethods(Before.class, false, errors);\n        validateTestMethods(errors);\n\n        if (computeTestMethods().isEmpty()) {\n            errors.add(new Exception(\"No runnable methods\"));\n        }\n    }\n\n    protected void validateFields(List<Throwable> errors) {\n        RULE_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    private void validateMethods(List<Throwable> errors) {\n        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test}that\n     * is not a public, void instance method with no arguments.\n     */\n    protected void validateTestMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(Test.class, false, errors);\n    }\n\n    /**\n     * Returns a new fixture for running a test. Default implementation executes\n     * the test class's no-argument constructor (validation should have ensured\n     * one exists).\n     */\n    protected Object createTest() throws Exception {\n        return getTestClass().getOnlyConstructor().newInstance();\n    }\n\n    /**\n     * Returns a new fixture to run a particular test {@code method} against.\n     * Default implementation executes the no-argument {@link #createTest()} method.\n     *\n     * @since 4.13\n     */\n    protected Object createTest(FrameworkMethod method) throws Exception {\n        return createTest();\n    }\n\n    /**\n     * Returns the name that describes {@code method} for {@link Description}s.\n     * Default implementation is the method's name\n     */\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n\n    /**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@link Test#expected()}\n     * attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * <\/ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest(method);\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }\n\n    //\n    // Statement builders\n    //\n\n    /**\n     * Returns a {@link Statement} that invokes {@code method} on {@code test}\n     */\n    protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@link Test#expected()} attribute, return normally only if {@code next}\n     * throws an exception of the correct type, and throw an exception\n     * otherwise.\n     */\n    protected Statement possiblyExpectingExceptions(FrameworkMethod method,\n            Object test, Statement next) {\n        Test annotation = method.getAnnotation(Test.class);\n        Class<? extends Throwable> expectedExceptionClass = getExpectedException(annotation);\n        return expectedExceptionClass != null ? new ExpectException(next, expectedExceptionClass) : next;\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code timeout} attribute, throw an exception if {@code next}\n     * takes more than the specified number of milliseconds.\n     * @deprecated\n     */\n    @Deprecated\n    protected Statement withPotentialTimeout(FrameworkMethod method,\n            Object test, Statement next) {\n        long timeout = getTimeout(method.getAnnotation(Test.class));\n        if (timeout <= 0) {\n            return next;\n        }\n        return FailOnTimeout.builder()\n               .withTimeout(timeout, TimeUnit.MILLISECONDS)\n               .build(next);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @Before}\n     * methods on this class and superclasses before running {@code next}; if\n     * any throws an Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBefores(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(\n                Before.class);\n        return befores.isEmpty() ? statement : new RunBefores(statement,\n                befores, target);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @After}\n     * methods on this class and superclasses before running {@code next}; all\n     * After methods are always executed: exceptions thrown by previous steps\n     * are combined, if necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfters(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(\n                After.class);\n        return afters.isEmpty() ? statement : new RunAfters(statement, afters,\n                target);\n    }\n\n    private Statement withRules(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<TestRule> testRules = getTestRules(target);\n        Statement result = statement;\n        result = withMethodRules(method, testRules, target, result);\n        result = withTestRules(method, testRules, result);\n\n        return result;\n    }\n\n    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,\n            Object target, Statement result) {\n        Statement withMethodRules = result;\n        for (org.junit.rules.MethodRule each : getMethodRules(target)) {\n            if (!(each instanceof TestRule && testRules.contains(each))) {\n                withMethodRules = each.apply(withMethodRules, method, target);\n            }\n        }\n        return withMethodRules;\n    }\n\n    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n        return rules(target);\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of MethodRules that should be applied when executing this\n     *         test\n     */\n    protected List<MethodRule> rules(Object target) {\n        List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, \n                Rule.class, MethodRule.class);\n\n        rules.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, MethodRule.class));\n\n        return rules;\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all non-static fields\n     * annotated with {@link Rule}.\n     *\n     * @param statement The base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,\n            Statement statement) {\n        return testRules.isEmpty() ? statement :\n                new RunRules(statement, testRules, describeChild(method));\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of TestRules that should be applied when executing this\n     *         test\n     */\n    protected List<TestRule> getTestRules(Object target) {\n        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,\n                Rule.class, TestRule.class);\n\n        result.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, TestRule.class));\n\n        return result;\n    }\n\n    private Class<? extends Throwable> getExpectedException(Test annotation) {\n        if (annotation == null || annotation.expected() == None.class) {\n            return null;\n        } else {\n            return annotation.expected();\n        }\n    }\n\n    private long getTimeout(Test annotation) {\n        if (annotation == null) {\n            return 0;\n        }\n        return annotation.timeout();\n    }\n}\n","lineNo":333}
{"Smelly Sample":"package org.junit.runners.model;\n\nimport static java.lang.reflect.Modifier.isStatic;\nimport static org.junit.internal.MethodSorter.NAME_ASCENDING;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.internal.MethodSorter;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n *\n * @since 4.5\n */\npublic class TestClass implements Annotatable {\n    private static final FieldComparator FIELD_COMPARATOR = new FieldComparator();\n    private static final MethodComparator METHOD_COMPARATOR = new MethodComparator();\n\n    private final Class<?> clazz;\n    private final Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations;\n    private final Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations;\n\n    /**\n     * Creates a {@code TestClass} wrapping {@code clazz}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> clazz) {\n        this.clazz = clazz;\n        if (clazz != null && clazz.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);\n\n        this.methodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);\n        this.fieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);\n    }\n\n    protected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {\n        for (Class<?> eachClass : getSuperClasses(clazz)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            // ensuring fields are sorted to make sure that entries are inserted\n            // and read from fieldForAnnotations in a deterministic order\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n    }\n\n    private static Field[] getSortedDeclaredFields(Class<?> clazz) {\n        Field[] declaredFields = clazz.getDeclaredFields();\n        Arrays.sort(declaredFields, FIELD_COMPARATOR);\n        return declaredFields;\n    }\n\n    protected static <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n            Map<Class<? extends Annotation>, List<T>> map) {\n        for (Annotation each : member.getAnnotations()) {\n            Class<? extends Annotation> type = each.annotationType();\n            List<T> members = getAnnotatedMembers(map, type, true);\n            if (member.isShadowedBy(members)) {\n                return;\n            }\n            if (runsTopToBottom(type)) {\n                members.add(0, member);\n            } else {\n                members.add(member);\n            }\n        }\n    }\n\n    private static <T extends FrameworkMember<T>> Map<Class<? extends Annotation>, List<T>>\n            makeDeeplyUnmodifiable(Map<Class<? extends Annotation>, List<T>> source) {\n        Map<Class<? extends Annotation>, List<T>> copy =\n                new LinkedHashMap<Class<? extends Annotation>, List<T>>();\n        for (Map.Entry<Class<? extends Annotation>, List<T>> entry : source.entrySet()) {\n            copy.put(entry.getKey(), Collections.unmodifiableList(entry.getValue()));\n        }\n        return Collections.unmodifiableMap(copy);\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated}.\n     * \n     * @since 4.12\n     */\n    public List<FrameworkMethod> getAnnotatedMethods() {\n        List<FrameworkMethod> methods = collectValues(methodsForAnnotations);\n        Collections.sort(methods, METHOD_COMPARATOR);\n        return methods;\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkMethod> getAnnotatedMethods(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(methodsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated.\n     * \n     * @since 4.12\n     */\n    public List<FrameworkField> getAnnotatedFields() {\n        return collectValues(fieldsForAnnotations);\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkField> getAnnotatedFields(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fieldsForAnnotations, annotationClass, false));\n    }\n\n    private <T> List<T> collectValues(Map<?, List<T>> map) {\n        Set<T> values = new LinkedHashSet<T>();\n        for (List<T> additionalValues : map.values()) {\n            values.addAll(additionalValues);\n        }\n        return new ArrayList<T>(values);\n    }\n\n    private static <T> List<T> getAnnotatedMembers(Map<Class<? extends Annotation>, List<T>> map,\n            Class<? extends Annotation> type, boolean fillIfAbsent) {\n        if (!map.containsKey(type) && fillIfAbsent) {\n            map.put(type, new ArrayList<T>());\n        }\n        List<T> members = map.get(type);\n        return members == null ? Collections.<T>emptyList() : members;\n    }\n\n    private static boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n        return annotation.equals(Before.class)\n                || annotation.equals(BeforeClass.class);\n    }\n\n    private static List<Class<?>> getSuperClasses(Class<?> testClass) {\n        List<Class<?>> results = new ArrayList<Class<?>>();\n        Class<?> current = testClass;\n        while (current != null) {\n            results.add(current);\n            current = current.getSuperclass();\n        }\n        return results;\n    }\n\n    /**\n     * Returns the underlying Java class.\n     */\n    public Class<?> getJavaClass() {\n        return clazz;\n    }\n\n    /**\n     * Returns the class's name.\n     */\n    public String getName() {\n        if (clazz == null) {\n            return \"null\";\n        }\n        return clazz.getName();\n    }\n\n    /**\n     * Returns the only public constructor in the class, or throws an {@code\n     * AssertionError} if there are more or less than one.\n     */\n\n    public Constructor<?> getOnlyConstructor() {\n        Constructor<?>[] constructors = clazz.getConstructors();\n        Assert.assertEquals(1, constructors.length);\n        return constructors[0];\n    }\n\n    /**\n     * Returns the annotations on this class\n     */\n    public Annotation[] getAnnotations() {\n        if (clazz == null) {\n            return new Annotation[0];\n        }\n        return clazz.getAnnotations();\n    }\n\n    public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        if (clazz == null) {\n            return null;\n        }\n        return clazz.getAnnotation(annotationType);\n    }\n\n    public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n        return results;\n    }\n\n    public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                /*\n                 * A method annotated with @Rule may return a @TestRule or a @MethodRule,\n                 * we cannot call the method to check whether the return type matches our\n                 * expectation i.e. subclass of valueClass. If we do that then the method \n                 * will be invoked twice and we do not want to do that. So we first check\n                 * whether return type matches our expectation and only then call the method\n                 * to fetch the MethodRule\n                 */\n                if (valueClass.isAssignableFrom(each.getReturnType())) {\n                    Object fieldValue = each.invokeExplosively(test);\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n        return results;\n    }\n\n    public boolean isPublic() {\n        return Modifier.isPublic(clazz.getModifiers());\n    }\n\n    public boolean isANonStaticInnerClass() {\n        return clazz.isMemberClass() && !isStatic(clazz.getModifiers());\n    }\n\n    @Override\n    public int hashCode() {\n        return (clazz == null) ? 0 : clazz.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        TestClass other = (TestClass) obj;\n        return clazz == other.clazz;\n    }\n\n    /**\n     * Compares two fields by its name.\n     */\n    private static class FieldComparator implements Comparator<Field> {\n        public int compare(Field left, Field right) {\n            return left.getName().compareTo(right.getName());\n        }\n    }\n\n    /**\n     * Compares two methods by its name.\n     */\n    private static class MethodComparator implements\n            Comparator<FrameworkMethod> {\n        public int compare(FrameworkMethod left, FrameworkMethod right) {\n            return NAME_ASCENDING.compare(left.getMethod(), right.getMethod());\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.runners.model;\n\nimport static java.lang.reflect.Modifier.isStatic;\nimport static org.junit.internal.MethodSorter.NAME_ASCENDING;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.internal.MethodSorter;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n *\n * @since 4.5\n */\npublic class TestClass implements Annotatable {\n    private static final FieldComparator FIELD_COMPARATOR = new FieldComparator();\n    private static final MethodComparator METHOD_COMPARATOR = new MethodComparator();\n\n    private final Class<?> clazz;\n    private final Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations;\n    private final Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations;\n\n    /**\n     * Creates a {@code TestClass} wrapping {@code clazz}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> clazz) {\n        this.clazz = clazz;\n        if (clazz != null && clazz.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);\n\n        this.methodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);\n        this.fieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);\n    }\n\n    protected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {\n        for (Class<?> eachClass : getSuperClasses(clazz)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            // ensuring fields are sorted to make sure that entries are inserted\n            // and read from fieldForAnnotations in a deterministic order\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n    }\n\n    private static Field[] getSortedDeclaredFields(Class<?> clazz) {\n        Field[] declaredFields = clazz.getDeclaredFields();\n        Arrays.sort(declaredFields, FIELD_COMPARATOR);\n        return declaredFields;\n    }\n\n    protected static <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n            Map<Class<? extends Annotation>, List<T>> map) {\n        for (Annotation each : member.getAnnotations()) {\n            Class<? extends Annotation> type = each.annotationType();\n            List<T> members = getAnnotatedMembers(map, type, true);\n            T memberToAdd = member.handlePossibleBridgeMethod(members);\n            if (memberToAdd == null) {\n                return;\n            }\n            if (runsTopToBottom(type)) {\n                members.add(0, memberToAdd);\n            } else {\n                members.add(memberToAdd);\n            }\n        }\n    }\n\n    private static <T extends FrameworkMember<T>> Map<Class<? extends Annotation>, List<T>>\n            makeDeeplyUnmodifiable(Map<Class<? extends Annotation>, List<T>> source) {\n        Map<Class<? extends Annotation>, List<T>> copy =\n                new LinkedHashMap<Class<? extends Annotation>, List<T>>();\n        for (Map.Entry<Class<? extends Annotation>, List<T>> entry : source.entrySet()) {\n            copy.put(entry.getKey(), Collections.unmodifiableList(entry.getValue()));\n        }\n        return Collections.unmodifiableMap(copy);\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated}.\n     * \n     * @since 4.12\n     */\n    public List<FrameworkMethod> getAnnotatedMethods() {\n        List<FrameworkMethod> methods = collectValues(methodsForAnnotations);\n        Collections.sort(methods, METHOD_COMPARATOR);\n        return methods;\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkMethod> getAnnotatedMethods(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(methodsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated.\n     * \n     * @since 4.12\n     */\n    public List<FrameworkField> getAnnotatedFields() {\n        return collectValues(fieldsForAnnotations);\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkField> getAnnotatedFields(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fieldsForAnnotations, annotationClass, false));\n    }\n\n    private <T> List<T> collectValues(Map<?, List<T>> map) {\n        Set<T> values = new LinkedHashSet<T>();\n        for (List<T> additionalValues : map.values()) {\n            values.addAll(additionalValues);\n        }\n        return new ArrayList<T>(values);\n    }\n\n    private static <T> List<T> getAnnotatedMembers(Map<Class<? extends Annotation>, List<T>> map,\n            Class<? extends Annotation> type, boolean fillIfAbsent) {\n        if (!map.containsKey(type) && fillIfAbsent) {\n            map.put(type, new ArrayList<T>());\n        }\n        List<T> members = map.get(type);\n        return members == null ? Collections.<T>emptyList() : members;\n    }\n\n    private static boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n        return annotation.equals(Before.class)\n                || annotation.equals(BeforeClass.class);\n    }\n\n    private static List<Class<?>> getSuperClasses(Class<?> testClass) {\n        List<Class<?>> results = new ArrayList<Class<?>>();\n        Class<?> current = testClass;\n        while (current != null) {\n            results.add(current);\n            current = current.getSuperclass();\n        }\n        return results;\n    }\n\n    /**\n     * Returns the underlying Java class.\n     */\n    public Class<?> getJavaClass() {\n        return clazz;\n    }\n\n    /**\n     * Returns the class's name.\n     */\n    public String getName() {\n        if (clazz == null) {\n            return \"null\";\n        }\n        return clazz.getName();\n    }\n\n    /**\n     * Returns the only public constructor in the class, or throws an {@code\n     * AssertionError} if there are more or less than one.\n     */\n\n    public Constructor<?> getOnlyConstructor() {\n        Constructor<?>[] constructors = clazz.getConstructors();\n        Assert.assertEquals(1, constructors.length);\n        return constructors[0];\n    }\n\n    /**\n     * Returns the annotations on this class\n     */\n    public Annotation[] getAnnotations() {\n        if (clazz == null) {\n            return new Annotation[0];\n        }\n        return clazz.getAnnotations();\n    }\n\n    public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        if (clazz == null) {\n            return null;\n        }\n        return clazz.getAnnotation(annotationType);\n    }\n\n    public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n        return results;\n    }\n\n    public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                /*\n                 * A method annotated with @Rule may return a @TestRule or a @MethodRule,\n                 * we cannot call the method to check whether the return type matches our\n                 * expectation i.e. subclass of valueClass. If we do that then the method \n                 * will be invoked twice and we do not want to do that. So we first check\n                 * whether return type matches our expectation and only then call the method\n                 * to fetch the MethodRule\n                 */\n                if (valueClass.isAssignableFrom(each.getReturnType())) {\n                    Object fieldValue = each.invokeExplosively(test);\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n        return results;\n    }\n\n    public boolean isPublic() {\n        return Modifier.isPublic(clazz.getModifiers());\n    }\n\n    public boolean isANonStaticInnerClass() {\n        return clazz.isMemberClass() && !isStatic(clazz.getModifiers());\n    }\n\n    @Override\n    public int hashCode() {\n        return (clazz == null) ? 0 : clazz.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        TestClass other = (TestClass) obj;\n        return clazz == other.clazz;\n    }\n\n    /**\n     * Compares two fields by its name.\n     */\n    private static class FieldComparator implements Comparator<Field> {\n        public int compare(Field left, Field right) {\n            return left.getName().compareTo(right.getName());\n        }\n    }\n\n    /**\n     * Compares two methods by its name.\n     */\n    private static class MethodComparator implements\n            Comparator<FrameworkMethod> {\n        public int compare(FrameworkMethod left, FrameworkMethod right) {\n            return NAME_ASCENDING.compare(left.getMethod(), right.getMethod());\n        }\n    }\n}\n","lineNo":87}
{"Smelly Sample":"package org.junit.rules;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\n/**\n * <tt>TemporaryFolderUsageTest<\/tt> provides tests for API usage correctness\n * and ensure implementation symmetry of public methods against a root folder.\n */\npublic class TemporaryFolderUsageTest {\n\n    private TemporaryFolder tempFolder;\n\n    @Rule\n    public final ExpectedException thrown = ExpectedException.none();\n\n    @Before\n    public void setUp() {\n        tempFolder = new TemporaryFolder();\n    }\n\n    @After\n    public void tearDown() {\n        tempFolder.delete();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void getRootShouldThrowIllegalStateExceptionIfCreateWasNotInvoked() {\n        new TemporaryFolder().getRoot();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFileThrowsIllegalStateExceptionIfCreateWasNotInvoked()\n            throws IOException {\n        new TemporaryFolder().newFile();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFileWithGivenNameThrowsIllegalStateExceptionIfCreateWasNotInvoked()\n            throws IOException {\n        new TemporaryFolder().newFile(\"MyFile.txt\");\n    }\n\n    @Test\n    public void newFileWithGivenFilenameThrowsIllegalArgumentExceptionIfFileExists() throws IOException {\n        tempFolder.create();\n        tempFolder.newFile(\"MyFile.txt\");\n\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"a file with the name 'MyFile.txt' already exists in the test folder\");\n        tempFolder.newFile(\"MyFile.txt\");\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFolderThrowsIllegalStateExceptionIfCreateWasNotInvoked()\n            throws IOException {\n        new TemporaryFolder().newFolder();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFolderWithGivenPathThrowsIllegalStateExceptionIfCreateWasNotInvoked() throws IOException {\n        new TemporaryFolder().newFolder(\"level1\", \"level2\", \"level3\");\n    }\n\n    @Test\n    public void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists() throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"level1\");\n\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"a folder with the name 'level1' already exists\");\n        tempFolder.newFolder(\"level1\");\n    }\n    \n    @Test\n    public void newFolderWithPathStartingWithFileSeparatorThrowsIOException()\n            throws IOException {\n        tempFolder.create();\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"folder name must be a relative path\");\n        tempFolder.newFolder(File.separator + \"temp1\");\n    }\n    \n    @Test\n    public void newFolderWithPathContainingFileSeparaterCreatesDirectories()\n            throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"temp1\" + File.separator + \"temp2\");\n        File temp1 = new File(tempFolder.getRoot(), \"temp1\");\n        assertFileIsDirectory(temp1);\n        assertFileIsDirectory(new File(temp1, \"temp2\"));\n    }\n \n    @Test\n    public void newFolderWithPathContainingForwardSlashCreatesDirectories()\n            throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"temp1/temp2\");\n        File temp1 = new File(tempFolder.getRoot(), \"temp1\");\n        assertFileIsDirectory(temp1);\n        assertFileIsDirectory(new File(temp1, \"temp2\"));\n    }\n    \n    @Test\n    public void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"a folder with the name 'level3' already exists\");\n        tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n    }\n\n    @Test\n    public void newFolderWithGivenPathThrowsIOExceptionIfFolderNamesConsistOfMultiplePathComponents()\n            throws IOException {\n        tempFolder.create();\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"name cannot consist of multiple path components\");\n        tempFolder.newFolder(\"temp1\", \"temp2\", \"temp3/temp4\");\n    }\n    \n    @Test\n    public void createInitializesRootFolder() throws IOException {\n        tempFolder.create();\n        assertFileIsDirectory(tempFolder.getRoot());\n    }\n\n    @Test\n    public void deleteShouldDoNothingIfRootFolderWasNotInitialized() {\n        tempFolder.delete();\n    }\n\n    @Test\n    public void deleteRemovesRootFolder() throws IOException {\n        tempFolder.create();\n        tempFolder.delete();\n        assertFileDoesNotExist(tempFolder.getRoot());\n    }\n\n    @Test\n    public void newRandomFileIsCreatedUnderRootFolder() throws IOException {\n        tempFolder.create();\n\n        File f = tempFolder.newFile();\n        assertFileExists(f);\n        assertFileCreatedUnderRootFolder(\"Random file\", f);\n    }\n\n    @Test\n    public void newNamedFileIsCreatedUnderRootFolder() throws IOException {\n        final String fileName = \"SampleFile.txt\";\n        tempFolder.create();\n\n        File f = tempFolder.newFile(fileName);\n\n        assertFileExists(f);\n        assertFileCreatedUnderRootFolder(\"Named file\", f);\n        assertThat(\"file name\", f.getName(), equalTo(fileName));\n    }\n\n    @Test\n    public void newRandomFolderIsCreatedUnderRootFolder() throws IOException {\n        tempFolder.create();\n\n        File f = tempFolder.newFolder();\n        assertFileIsDirectory(f);\n        assertFileCreatedUnderRootFolder(\"Random folder\", f);\n    }\n\n    @Test\n    public void newNestedFoldersCreatedUnderRootFolder() throws IOException {\n        tempFolder.create();\n\n        File f = tempFolder.newFolder(\"top\", \"middle\", \"bottom\");\n        assertFileIsDirectory(f);\n        assertParentFolderForFileIs(f, new File(tempFolder.getRoot(),\n                \"top/middle\"));\n        assertParentFolderForFileIs(f.getParentFile(),\n                new File(tempFolder.getRoot(), \"top\"));\n        assertFileCreatedUnderRootFolder(\"top\", f.getParentFile()\n                .getParentFile());\n    }\n\n    @Test\n    public void canSetTheBaseFileForATemporaryFolder() throws IOException {\n        File tempDir = createTemporaryFolder();\n\n        TemporaryFolder folder = new TemporaryFolder(tempDir);\n        folder.create();\n\n        assertThat(tempDir, is(folder.getRoot().getParentFile()));\n    }\n\n    private File createTemporaryFolder() throws IOException {\n        File tempDir = File.createTempFile(\"junit\", \"tempFolder\");\n        assertTrue(\"Unable to delete temporary file\", tempDir.delete());\n        assertTrue(\"Unable to create temp directory\", tempDir.mkdir());\n        return tempDir;\n    }\n\n    private void assertFileDoesNotExist(File file) {\n        checkFileExists(\"exists\", file, false);\n    }\n\n    private void checkFileExists(String msg, File file, boolean exists) {\n        assertThat(\"File is null\", file, is(notNullValue()));\n        assertThat(\"File '\" + file.getAbsolutePath() + \"' \" + msg,\n                file.exists(), is(exists));\n    }\n\n    private void checkFileIsDirectory(String msg, File file, boolean isDirectory) {\n        assertThat(\"File is null\", file, is(notNullValue()));\n        assertThat(\"File '\" + file.getAbsolutePath() + \"' \" + msg,\n                file.isDirectory(), is(isDirectory));\n    }\n\n    private void assertFileExists(File file) {\n        checkFileExists(\"does not exist\", file, true);\n        checkFileIsDirectory(\"is a directory\", file, false);\n    }\n\n    private void assertFileIsDirectory(File file) {\n        checkFileExists(\"does not exist\", file, true);\n        checkFileIsDirectory(\"is not a directory\", file, true);\n    }\n\n    private void assertFileCreatedUnderRootFolder(String msg, File f) {\n        assertParentFolderForFileIs(f, tempFolder.getRoot());\n    }\n\n    private void assertParentFolderForFileIs(File f, File parentFolder) {\n        assertThat(\"'\" + f.getAbsolutePath() + \"': not under root\",\n                f.getParentFile(), is(parentFolder));\n    }\n}\n","Method after Refactoring":"package org.junit.rules;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.notNullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\n/**\n * <tt>TemporaryFolderUsageTest<\/tt> provides tests for API usage correctness\n * and ensure implementation symmetry of public methods against a root folder.\n */\npublic class TemporaryFolderUsageTest {\n\n    private TemporaryFolder tempFolder;\n\n    @Rule\n    public final ExpectedException thrown = ExpectedException.none();\n\n    @Before\n    public void setUp() {\n        tempFolder = new TemporaryFolder();\n    }\n\n    @After\n    public void tearDown() {\n        tempFolder.delete();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void getRootShouldThrowIllegalStateExceptionIfCreateWasNotInvoked() {\n        new TemporaryFolder().getRoot();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFileThrowsIllegalStateExceptionIfCreateWasNotInvoked()\n            throws IOException {\n        new TemporaryFolder().newFile();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFileWithGivenNameThrowsIllegalStateExceptionIfCreateWasNotInvoked()\n            throws IOException {\n        new TemporaryFolder().newFile(\"MyFile.txt\");\n    }\n\n    @Test\n    public void newFileWithGivenFilenameThrowsIllegalArgumentExceptionIfFileExists() throws IOException {\n        tempFolder.create();\n        tempFolder.newFile(\"MyFile.txt\");\n\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"a file with the name 'MyFile.txt' already exists in the test folder\");\n        tempFolder.newFile(\"MyFile.txt\");\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFolderThrowsIllegalStateExceptionIfCreateWasNotInvoked()\n            throws IOException {\n        new TemporaryFolder().newFolder();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void newFolderWithGivenPathThrowsIllegalStateExceptionIfCreateWasNotInvoked() throws IOException {\n        new TemporaryFolder().newFolder(\"level1\", \"level2\", \"level3\");\n    }\n\n    @Test\n    public void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists() throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"level1\");\n\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"a folder with the name 'level1' already exists\");\n        tempFolder.newFolder(\"level1\");\n    }\n    \n    @Test\n    public void newFolderWithPathStartingWithFileSeparatorThrowsIOException()\n            throws IOException {\n        String fileAtRoot;\n        File[] roots = File.listRoots();\n        if (roots != null && roots.length > 0) {\n            fileAtRoot = roots[0].getAbsolutePath() + \"temp1\";\n        } else {\n            fileAtRoot = File.separator + \"temp1\";\n        }\n        tempFolder.create();\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"folder name must be a relative path\");\n        tempFolder.newFolder(fileAtRoot);\n    }\n    \n    @Test\n    public void newFolderWithPathContainingFileSeparaterCreatesDirectories()\n            throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"temp1\" + File.separator + \"temp2\");\n        File temp1 = new File(tempFolder.getRoot(), \"temp1\");\n        assertFileIsDirectory(temp1);\n        assertFileIsDirectory(new File(temp1, \"temp2\"));\n    }\n \n    @Test\n    public void newFolderWithPathContainingForwardSlashCreatesDirectories()\n            throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"temp1/temp2\");\n        File temp1 = new File(tempFolder.getRoot(), \"temp1\");\n        assertFileIsDirectory(temp1);\n        assertFileIsDirectory(new File(temp1, \"temp2\"));\n    }\n    \n    @Test\n    public void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() throws IOException {\n        tempFolder.create();\n        tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"a folder with the name 'level3' already exists\");\n        tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n    }\n\n    @Test\n    public void newFolderWithGivenPathThrowsIOExceptionIfFolderNamesConsistOfMultiplePathComponents()\n            throws IOException {\n        tempFolder.create();\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"name cannot consist of multiple path components\");\n        tempFolder.newFolder(\"temp1\", \"temp2\", \"temp3/temp4\");\n    }\n    \n    @Test\n    public void createInitializesRootFolder() throws IOException {\n        tempFolder.create();\n        assertFileIsDirectory(tempFolder.getRoot());\n    }\n\n    @Test\n    public void deleteShouldDoNothingIfRootFolderWasNotInitialized() {\n        tempFolder.delete();\n    }\n\n    @Test\n    public void deleteRemovesRootFolder() throws IOException {\n        tempFolder.create();\n        tempFolder.delete();\n        assertFileDoesNotExist(tempFolder.getRoot());\n    }\n\n    @Test\n    public void newRandomFileIsCreatedUnderRootFolder() throws IOException {\n        tempFolder.create();\n\n        File f = tempFolder.newFile();\n        assertFileExists(f);\n        assertFileCreatedUnderRootFolder(\"Random file\", f);\n    }\n\n    @Test\n    public void newNamedFileIsCreatedUnderRootFolder() throws IOException {\n        final String fileName = \"SampleFile.txt\";\n        tempFolder.create();\n\n        File f = tempFolder.newFile(fileName);\n\n        assertFileExists(f);\n        assertFileCreatedUnderRootFolder(\"Named file\", f);\n        assertThat(\"file name\", f.getName(), equalTo(fileName));\n    }\n\n    @Test\n    public void newRandomFolderIsCreatedUnderRootFolder() throws IOException {\n        tempFolder.create();\n\n        File f = tempFolder.newFolder();\n        assertFileIsDirectory(f);\n        assertFileCreatedUnderRootFolder(\"Random folder\", f);\n    }\n\n    @Test\n    public void newNestedFoldersCreatedUnderRootFolder() throws IOException {\n        tempFolder.create();\n\n        File f = tempFolder.newFolder(\"top\", \"middle\", \"bottom\");\n        assertFileIsDirectory(f);\n        assertParentFolderForFileIs(f, new File(tempFolder.getRoot(),\n                \"top/middle\"));\n        assertParentFolderForFileIs(f.getParentFile(),\n                new File(tempFolder.getRoot(), \"top\"));\n        assertFileCreatedUnderRootFolder(\"top\", f.getParentFile()\n                .getParentFile());\n    }\n\n    @Test\n    public void canSetTheBaseFileForATemporaryFolder() throws IOException {\n        File tempDir = createTemporaryFolder();\n\n        TemporaryFolder folder = new TemporaryFolder(tempDir);\n        folder.create();\n\n        assertThat(tempDir, is(folder.getRoot().getParentFile()));\n    }\n\n    private File createTemporaryFolder() throws IOException {\n        File tempDir = File.createTempFile(\"junit\", \"tempFolder\");\n        assertTrue(\"Unable to delete temporary file\", tempDir.delete());\n        assertTrue(\"Unable to create temp directory\", tempDir.mkdir());\n        return tempDir;\n    }\n\n    private void assertFileDoesNotExist(File file) {\n        checkFileExists(\"exists\", file, false);\n    }\n\n    private void checkFileExists(String msg, File file, boolean exists) {\n        assertThat(\"File is null\", file, is(notNullValue()));\n        assertThat(\"File '\" + file.getAbsolutePath() + \"' \" + msg,\n                file.exists(), is(exists));\n    }\n\n    private void checkFileIsDirectory(String msg, File file, boolean isDirectory) {\n        assertThat(\"File is null\", file, is(notNullValue()));\n        assertThat(\"File '\" + file.getAbsolutePath() + \"' \" + msg,\n                file.isDirectory(), is(isDirectory));\n    }\n\n    private void assertFileExists(File file) {\n        checkFileExists(\"does not exist\", file, true);\n        checkFileIsDirectory(\"is a directory\", file, false);\n    }\n\n    private void assertFileIsDirectory(File file) {\n        checkFileExists(\"does not exist\", file, true);\n        checkFileIsDirectory(\"is not a directory\", file, true);\n    }\n\n    private void assertFileCreatedUnderRootFolder(String msg, File f) {\n        assertParentFolderForFileIs(f, tempFolder.getRoot());\n    }\n\n    private void assertParentFolderForFileIs(File f, File parentFolder) {\n        assertThat(\"'\" + f.getAbsolutePath() + \"': not under root\",\n                f.getParentFile(), is(parentFolder));\n    }\n}\n","lineNo":89}
{"Smelly Sample":"package org.junit;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.internal.ArrayComparisonFailure;\nimport org.junit.internal.ExactComparisonCriteria;\nimport org.junit.internal.InexactComparisonCriteria;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions\n * are recorded. These methods can be used directly:\n * <code>Assert.assertEquals(...)<\/code>, however, they read better if they\n * are referenced through static import:\n *\n * <pre>\n * import static org.junit.Assert.*;\n *    ...\n *    assertEquals(...);\n * <\/pre>\n *\n * @see AssertionError\n * @since 4.0\n */\npublic class Assert {\n    /**\n     * Protect constructor since it is a static only class\n     */\n    protected Assert() {\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }\n\n    /**\n     * Fails a test with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @see AssertionError\n     */\n    public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionError();\n        }\n        throw new AssertionError(message);\n    }\n\n    /**\n     * Fails a test with no message.\n     */\n    public static void fail() {\n        fail(null);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual actual value\n     */\n    public static void assertEquals(String message, Object expected,\n            Object actual) {\n        if (equalsRegardingNull(expected, actual)) {\n            return;\n        }\n        if (expected instanceof String && actual instanceof String) {\n            String cleanMessage = message == null ? \"\" : message;\n            throw new ComparisonFailure(cleanMessage, (String) expected,\n                    (String) actual);\n        } else {\n            failNotEquals(message, expected, actual);\n        }\n    }\n\n    private static boolean equalsRegardingNull(Object expected, Object actual) {\n        if (expected == null) {\n            return actual == null;\n        }\n\n        return isEquals(expected, actual);\n    }\n\n    private static boolean isEquals(Object expected, Object actual) {\n        return expected.equals(actual);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     */\n    public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, Object unexpected,\n            Object actual) {\n        if (equalsRegardingNull(unexpected, actual)) {\n            failEquals(message, actual);\n        }\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(Object unexpected, Object actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    private static void failEquals(String message, Object actual) {\n        String formatted = \"Values should be different. \";\n        if (message != null) {\n            formatted = message + \". \";\n        }\n\n        formatted += \"Actual: \" + actual;\n        fail(formatted);\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, long unexpected, long actual) {\n        if (unexpected == actual) {\n            failEquals(message, Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(long unexpected, long actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, double unexpected,\n            double actual, double delta) {\n        if (!doubleIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(double unexpected, double actual, double delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(float unexpected, float actual, float delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(String message, Object[] expecteds,\n            Object[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(String message, boolean[] expecteds,\n            boolean[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(String message, byte[] expecteds,\n            byte[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(String message, char[] expecteds,\n            char[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(char[] expecteds, char[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(String message, short[] expecteds,\n            short[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(short[] expecteds, short[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(String message, int[] expecteds,\n            int[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(int[] expecteds, int[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(String message, long[] expecteds,\n            long[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(long[] expecteds, long[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, double[] expecteds,\n            double[] actuals, double delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, float[] expecteds,\n            float[] actuals, float delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    private static void internalArrayEquals(String message, Object expecteds,\n            Object actuals) throws ArrayComparisonFailure {\n        new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, double expected,\n            double actual, double delta) {\n        if (doubleIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, float unexpected,\n            float actual, float delta) {\n        if (!floatIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, actual);\n        }\n    }\n\n    private static boolean doubleIsDifferent(double d1, double d2, double delta) {\n        if (Double.compare(d1, d2) == 0) {\n            return false;\n        }\n        if ((Math.abs(d1 - d2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expected expected long value.\n     * @param actual actual long value\n     */\n    public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected long expected value.\n     * @param actual long actual value\n     */\n    public static void assertEquals(String message, long expected, long actual) {\n        if (expected != actual) {\n            failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(double expected, double actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(String message, double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(String message, double expected,\n            double actual) {\n        fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored. NaNs are considered\n     * equal: <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it is not, an {@link AssertionError}\n     * is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(String message, Object object) {\n        if (object == null) {\n            return;\n        }\n        failNotNull(message, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it isn't an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(Object object) {\n        assertNull(null, object);\n    }\n\n    private static void failNotNull(String message, Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected null, but was:<\" + actual + \">\");\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not the\n     * same, an {@link AssertionError} without a message is thrown.\n     *\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} is thrown with the\n     * given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(String message, Object unexpected,\n            Object actual) {\n        if (unexpected == actual) {\n            failSame(message);\n        }\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} without a message is\n     * thrown.\n     *\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(Object unexpected, Object actual) {\n        assertNotSame(null, unexpected, actual);\n    }\n\n    private static void failSame(String message) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected not same\");\n    }\n\n    private static void failNotSame(String message, Object expected,\n            Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual\n                + \">\");\n    }\n\n    private static void failNotEquals(String message, Object expected,\n            Object actual) {\n        fail(format(message, expected, actual));\n    }\n\n    static String format(String message, Object expected, Object actual) {\n        String formatted = \"\";\n        if (message != null && !\"\".equals(message)) {\n            formatted = message + \" \";\n        }\n        String expectedString = String.valueOf(expected);\n        String actualString = String.valueOf(actual);\n        if (expectedString.equals(actualString)) {\n            return formatted + \"expected: \"\n                    + formatClassAndValue(expected, expectedString)\n                    + \" but was: \" + formatClassAndValue(actual, actualString);\n        } else {\n            return formatted + \"expected:<\" + expectedString + \"> but was:<\"\n                    + actualString + \">\";\n        }\n    }\n\n    private static String formatClass(Class<?> value) {\n        String className = value.getCanonicalName();\n        return className == null ? value.getName() : className;\n    }\n\n    private static String formatClassAndValue(Object value, String valueString) {\n        String className = value == null ? \"null\" : value.getClass().getName();\n        return className + \"<\" + valueString + \">\";\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(String message, Object[] expecteds,\n            Object[] actuals) {\n        assertArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(expecteds, actuals);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(0, is(1)); // fails:\n     *     // failure message:\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * the reason and information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:\n     *     // failure message:\n     *     // Help! Integers don't work\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param reason additional information about the error\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(String reason, T actual,\n            Matcher<? super T> matcher) {\n        MatcherAssert.assertThat(reason, actual, matcher);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it\n     * throws the wrong type of exception, an {@code AssertionError} is thrown describing the\n     * mismatch; the exception that was actually thrown can be obtained by calling {@link\n     * AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @since 4.13\n     */\n    public static void assertThrows(Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {\n        expectThrows(expectedThrowable, runnable);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does, the exception object is returned. If it does not throw an exception, an\n     * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code\n     * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can\n     * be obtained by calling {@link AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @return the exception thrown by {@code runnable}\n     * @since 4.13\n     */\n    public static <T extends Throwable> T expectThrows(Class<T> expectedThrowable, ThrowingRunnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable actualThrown) {\n            if (expectedThrowable.isInstance(actualThrown)) {\n                @SuppressWarnings(\"unchecked\") T retVal = (T) actualThrown;\n                return retVal;\n            } else {\n                String mismatchMessage = format(\"unexpected exception type thrown;\",\n                    formatClass(expectedThrowable), formatClass(actualThrown));\n\n                // The AssertionError(String, Throwable) ctor is only available on JDK7.\n                AssertionError assertionError = new AssertionError(mismatchMessage);\n                assertionError.initCause(actualThrown);\n                throw assertionError;\n            }\n        }\n        String message = String.format(\"expected %s to be thrown, but nothing was thrown\",\n                formatClass(expectedThrowable));\n        throw new AssertionError(message);\n    }\n}\n","Method after Refactoring":"package org.junit;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.internal.ArrayComparisonFailure;\nimport org.junit.internal.ExactComparisonCriteria;\nimport org.junit.internal.InexactComparisonCriteria;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions\n * are recorded. These methods can be used directly:\n * <code>Assert.assertEquals(...)<\/code>, however, they read better if they\n * are referenced through static import:\n *\n * <pre>\n * import static org.junit.Assert.*;\n *    ...\n *    assertEquals(...);\n * <\/pre>\n *\n * @see AssertionError\n * @since 4.0\n */\npublic class Assert {\n    /**\n     * Protect constructor since it is a static only class\n     */\n    protected Assert() {\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }\n\n    /**\n     * Fails a test with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @see AssertionError\n     */\n    public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionError();\n        }\n        throw new AssertionError(message);\n    }\n\n    /**\n     * Fails a test with no message.\n     */\n    public static void fail() {\n        fail(null);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual actual value\n     */\n    public static void assertEquals(String message, Object expected,\n            Object actual) {\n        if (equalsRegardingNull(expected, actual)) {\n            return;\n        }\n        if (expected instanceof String && actual instanceof String) {\n            String cleanMessage = message == null ? \"\" : message;\n            throw new ComparisonFailure(cleanMessage, (String) expected,\n                    (String) actual);\n        } else {\n            failNotEquals(message, expected, actual);\n        }\n    }\n\n    private static boolean equalsRegardingNull(Object expected, Object actual) {\n        if (expected == null) {\n            return actual == null;\n        }\n\n        return isEquals(expected, actual);\n    }\n\n    private static boolean isEquals(Object expected, Object actual) {\n        return expected.equals(actual);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     */\n    public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, Object unexpected,\n            Object actual) {\n        if (equalsRegardingNull(unexpected, actual)) {\n            failEquals(message, actual);\n        }\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(Object unexpected, Object actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    private static void failEquals(String message, Object actual) {\n        String formatted = \"Values should be different. \";\n        if (message != null) {\n            formatted = message + \". \";\n        }\n\n        formatted += \"Actual: \" + actual;\n        fail(formatted);\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, long unexpected, long actual) {\n        if (unexpected == actual) {\n            failEquals(message, Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(long unexpected, long actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, double unexpected,\n            double actual, double delta) {\n        if (!doubleIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(double unexpected, double actual, double delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(float unexpected, float actual, float delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(String message, Object[] expecteds,\n            Object[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(String message, boolean[] expecteds,\n            boolean[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(String message, byte[] expecteds,\n            byte[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(String message, char[] expecteds,\n            char[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(char[] expecteds, char[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(String message, short[] expecteds,\n            short[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(short[] expecteds, short[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(String message, int[] expecteds,\n            int[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(int[] expecteds, int[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(String message, long[] expecteds,\n            long[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(long[] expecteds, long[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, double[] expecteds,\n            double[] actuals, double delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, float[] expecteds,\n            float[] actuals, float delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    private static void internalArrayEquals(String message, Object expecteds,\n            Object actuals) throws ArrayComparisonFailure {\n        new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, double expected,\n            double actual, double delta) {\n        if (doubleIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, float unexpected,\n            float actual, float delta) {\n        if (!floatIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, actual);\n        }\n    }\n\n    private static boolean doubleIsDifferent(double d1, double d2, double delta) {\n        if (Double.compare(d1, d2) == 0) {\n            return false;\n        }\n        if ((Math.abs(d1 - d2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expected expected long value.\n     * @param actual actual long value\n     */\n    public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected long expected value.\n     * @param actual long actual value\n     */\n    public static void assertEquals(String message, long expected, long actual) {\n        if (expected != actual) {\n            failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(double expected, double actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(String message, double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(String message, double expected,\n            double actual) {\n        fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored. NaNs are considered\n     * equal: <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it is not, an {@link AssertionError}\n     * is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(String message, Object object) {\n        if (object == null) {\n            return;\n        }\n        failNotNull(message, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it isn't an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(Object object) {\n        assertNull(null, object);\n    }\n\n    private static void failNotNull(String message, Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected null, but was:<\" + actual + \">\");\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not the\n     * same, an {@link AssertionError} without a message is thrown.\n     *\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} is thrown with the\n     * given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(String message, Object unexpected,\n            Object actual) {\n        if (unexpected == actual) {\n            failSame(message);\n        }\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} without a message is\n     * thrown.\n     *\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(Object unexpected, Object actual) {\n        assertNotSame(null, unexpected, actual);\n    }\n\n    private static void failSame(String message) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected not same\");\n    }\n\n    private static void failNotSame(String message, Object expected,\n            Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual\n                + \">\");\n    }\n\n    private static void failNotEquals(String message, Object expected,\n            Object actual) {\n        fail(format(message, expected, actual));\n    }\n\n    static String format(String message, Object expected, Object actual) {\n        String formatted = \"\";\n        if (message != null && !\"\".equals(message)) {\n            formatted = message + \" \";\n        }\n        String expectedString = String.valueOf(expected);\n        String actualString = String.valueOf(actual);\n        if (expectedString.equals(actualString)) {\n            return formatted + \"expected: \"\n                    + formatClassAndValue(expected, expectedString)\n                    + \" but was: \" + formatClassAndValue(actual, actualString);\n        } else {\n            return formatted + \"expected:<\" + expectedString + \"> but was:<\"\n                    + actualString + \">\";\n        }\n    }\n\n    private static String formatClass(Class<?> value) {\n        String className = value.getCanonicalName();\n        return className == null ? value.getName() : className;\n    }\n\n    private static String formatClassAndValue(Object value, String valueString) {\n        String className = value == null ? \"null\" : value.getClass().getName();\n        return className + \"<\" + valueString + \">\";\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(String message, Object[] expecteds,\n            Object[] actuals) {\n        assertArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(expecteds, actuals);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(0, is(1)); // fails:\n     *     // failure message:\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * the reason and information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:\n     *     // failure message:\n     *     // Help! Integers don't work\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param reason additional information about the error\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(String reason, T actual,\n            Matcher<? super T> matcher) {\n        MatcherAssert.assertThat(reason, actual, matcher);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it\n     * throws the wrong type of exception, an {@code AssertionError} is thrown describing the\n     * mismatch; the exception that was actually thrown can be obtained by calling {@link\n     * AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @since 4.13\n     */\n    public static void assertThrows(Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {\n        expectThrows(expectedThrowable, runnable);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does, the exception object is returned. If it does not throw an exception, an\n     * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code\n     * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can\n     * be obtained by calling {@link AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @return the exception thrown by {@code runnable}\n     * @since 4.13\n     */\n    public static <T extends Throwable> T expectThrows(Class<T> expectedThrowable, ThrowingRunnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable actualThrown) {\n            if (expectedThrowable.isInstance(actualThrown)) {\n                @SuppressWarnings(\"unchecked\") T retVal = (T) actualThrown;\n                return retVal;\n            } else {\n                String expected = formatClass(expectedThrowable);\n                Class<? extends Throwable> actualThrowable = actualThrown.getClass();\n                String actual = formatClass(actualThrowable);\n                if (expected.equals(actual)) {\n                    // There must be multiple class loaders. Add the identity hash code so the message\n                    // doesn't say \"expected: java.lang.String<my.package.MyException> ...\"\n                    expected += \"@\" + Integer.toHexString(System.identityHashCode(expectedThrowable));\n                    actual += \"@\" + Integer.toHexString(System.identityHashCode(actualThrowable));\n                }\n                String mismatchMessage = format(\"unexpected exception type thrown;\", expected, actual);\n\n                // The AssertionError(String, Throwable) ctor is only available on JDK7.\n                AssertionError assertionError = new AssertionError(mismatchMessage);\n                assertionError.initCause(actualThrown);\n                throw assertionError;\n            }\n        }\n        String message = String.format(\"expected %s to be thrown, but nothing was thrown\",\n                formatClass(expectedThrowable));\n        throw new AssertionError(message);\n    }\n}\n","lineNo":1004}
{"Smelly Sample":"package org.junit;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.internal.ArrayComparisonFailure;\nimport org.junit.internal.ExactComparisonCriteria;\nimport org.junit.internal.InexactComparisonCriteria;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions\n * are recorded. These methods can be used directly:\n * <code>Assert.assertEquals(...)<\/code>, however, they read better if they\n * are referenced through static import:\n *\n * <pre>\n * import static org.junit.Assert.*;\n *    ...\n *    assertEquals(...);\n * <\/pre>\n *\n * @see AssertionError\n * @since 4.0\n */\npublic class Assert {\n    /**\n     * Protect constructor since it is a static only class\n     */\n    protected Assert() {\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }\n\n    /**\n     * Fails a test with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @see AssertionError\n     */\n    public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionError();\n        }\n        throw new AssertionError(message);\n    }\n\n    /**\n     * Fails a test with no message.\n     */\n    public static void fail() {\n        fail(null);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual actual value\n     */\n    public static void assertEquals(String message, Object expected,\n            Object actual) {\n        if (equalsRegardingNull(expected, actual)) {\n            return;\n        }\n        if (expected instanceof String && actual instanceof String) {\n            String cleanMessage = message == null ? \"\" : message;\n            throw new ComparisonFailure(cleanMessage, (String) expected,\n                    (String) actual);\n        } else {\n            failNotEquals(message, expected, actual);\n        }\n    }\n\n    private static boolean equalsRegardingNull(Object expected, Object actual) {\n        if (expected == null) {\n            return actual == null;\n        }\n\n        return isEquals(expected, actual);\n    }\n\n    private static boolean isEquals(Object expected, Object actual) {\n        return expected.equals(actual);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     */\n    public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, Object unexpected,\n            Object actual) {\n        if (equalsRegardingNull(unexpected, actual)) {\n            failEquals(message, actual);\n        }\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(Object unexpected, Object actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    private static void failEquals(String message, Object actual) {\n        String formatted = \"Values should be different. \";\n        if (message != null) {\n            formatted = message + \". \";\n        }\n\n        formatted += \"Actual: \" + actual;\n        fail(formatted);\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, long unexpected, long actual) {\n        if (unexpected == actual) {\n            failEquals(message, Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(long unexpected, long actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, double unexpected,\n            double actual, double delta) {\n        if (!doubleIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(double unexpected, double actual, double delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(float unexpected, float actual, float delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(String message, Object[] expecteds,\n            Object[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(String message, boolean[] expecteds,\n            boolean[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(String message, byte[] expecteds,\n            byte[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(String message, char[] expecteds,\n            char[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(char[] expecteds, char[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(String message, short[] expecteds,\n            short[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(short[] expecteds, short[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(String message, int[] expecteds,\n            int[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(int[] expecteds, int[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(String message, long[] expecteds,\n            long[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(long[] expecteds, long[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, double[] expecteds,\n            double[] actuals, double delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, float[] expecteds,\n            float[] actuals, float delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    private static void internalArrayEquals(String message, Object expecteds,\n            Object actuals) throws ArrayComparisonFailure {\n        new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, double expected,\n            double actual, double delta) {\n        if (doubleIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, float unexpected,\n            float actual, float delta) {\n        if (!floatIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, actual);\n        }\n    }\n\n    private static boolean doubleIsDifferent(double d1, double d2, double delta) {\n        if (Double.compare(d1, d2) == 0) {\n            return false;\n        }\n        if ((Math.abs(d1 - d2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expected expected long value.\n     * @param actual actual long value\n     */\n    public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected long expected value.\n     * @param actual long actual value\n     */\n    public static void assertEquals(String message, long expected, long actual) {\n        if (expected != actual) {\n            failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(double expected, double actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(String message, double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(String message, double expected,\n            double actual) {\n        fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored. NaNs are considered\n     * equal: <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it is not, an {@link AssertionError}\n     * is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(String message, Object object) {\n        if (object == null) {\n            return;\n        }\n        failNotNull(message, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it isn't an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(Object object) {\n        assertNull(null, object);\n    }\n\n    private static void failNotNull(String message, Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected null, but was:<\" + actual + \">\");\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not the\n     * same, an {@link AssertionError} without a message is thrown.\n     *\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} is thrown with the\n     * given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(String message, Object unexpected,\n            Object actual) {\n        if (unexpected == actual) {\n            failSame(message);\n        }\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} without a message is\n     * thrown.\n     *\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(Object unexpected, Object actual) {\n        assertNotSame(null, unexpected, actual);\n    }\n\n    private static void failSame(String message) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected not same\");\n    }\n\n    private static void failNotSame(String message, Object expected,\n            Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual\n                + \">\");\n    }\n\n    private static void failNotEquals(String message, Object expected,\n            Object actual) {\n        fail(format(message, expected, actual));\n    }\n\n    static String format(String message, Object expected, Object actual) {\n        String formatted = \"\";\n        if (message != null && !\"\".equals(message)) {\n            formatted = message + \" \";\n        }\n        String expectedString = String.valueOf(expected);\n        String actualString = String.valueOf(actual);\n        if (expectedString.equals(actualString)) {\n            return formatted + \"expected: \"\n                    + formatClassAndValue(expected, expectedString)\n                    + \" but was: \" + formatClassAndValue(actual, actualString);\n        } else {\n            return formatted + \"expected:<\" + expectedString + \"> but was:<\"\n                    + actualString + \">\";\n        }\n    }\n\n    private static String formatClass(Class<?> value) {\n        String className = value.getCanonicalName();\n        return className == null ? value.getName() : className;\n    }\n\n    private static String formatClassAndValue(Object value, String valueString) {\n        String className = value == null ? \"null\" : value.getClass().getName();\n        return className + \"<\" + valueString + \">\";\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(String message, Object[] expecteds,\n            Object[] actuals) {\n        assertArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(expecteds, actuals);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(0, is(1)); // fails:\n     *     // failure message:\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * the reason and information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:\n     *     // failure message:\n     *     // Help! Integers don't work\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param reason additional information about the error\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(String reason, T actual,\n            Matcher<? super T> matcher) {\n        MatcherAssert.assertThat(reason, actual, matcher);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it\n     * throws the wrong type of exception, an {@code AssertionError} is thrown describing the\n     * mismatch; the exception that was actually thrown can be obtained by calling {@link\n     * AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @since 4.13\n     */\n    public static void assertThrows(Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {\n        expectThrows(expectedThrowable, runnable);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does, the exception object is returned. If it does not throw an exception, an\n     * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code\n     * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can\n     * be obtained by calling {@link AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @return the exception thrown by {@code runnable}\n     * @since 4.13\n     */\n    public static <T extends Throwable> T expectThrows(Class<T> expectedThrowable, ThrowingRunnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable actualThrown) {\n            if (expectedThrowable.isInstance(actualThrown)) {\n                @SuppressWarnings(\"unchecked\") T retVal = (T) actualThrown;\n                return retVal;\n            } else {\n                String mismatchMessage = format(\"unexpected exception type thrown;\",\n                    formatClass(expectedThrowable), formatClass(actualThrown));\n\n                // The AssertionError(String, Throwable) ctor is only available on JDK7.\n                AssertionError assertionError = new AssertionError(mismatchMessage);\n                assertionError.initCause(actualThrown);\n                throw assertionError;\n            }\n        }\n        String message = String.format(\"expected %s to be thrown, but nothing was thrown\",\n                formatClass(expectedThrowable));\n        throw new AssertionError(message);\n    }\n}\n","Method after Refactoring":"package org.junit;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.internal.ArrayComparisonFailure;\nimport org.junit.internal.ExactComparisonCriteria;\nimport org.junit.internal.InexactComparisonCriteria;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions\n * are recorded. These methods can be used directly:\n * <code>Assert.assertEquals(...)<\/code>, however, they read better if they\n * are referenced through static import:\n *\n * <pre>\n * import static org.junit.Assert.*;\n *    ...\n *    assertEquals(...);\n * <\/pre>\n *\n * @see AssertionError\n * @since 4.0\n */\npublic class Assert {\n    /**\n     * Protect constructor since it is a static only class\n     */\n    protected Assert() {\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }\n\n    /**\n     * Fails a test with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @see AssertionError\n     */\n    public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionError();\n        }\n        throw new AssertionError(message);\n    }\n\n    /**\n     * Fails a test with no message.\n     */\n    public static void fail() {\n        fail(null);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual actual value\n     */\n    public static void assertEquals(String message, Object expected,\n            Object actual) {\n        if (equalsRegardingNull(expected, actual)) {\n            return;\n        }\n        if (expected instanceof String && actual instanceof String) {\n            String cleanMessage = message == null ? \"\" : message;\n            throw new ComparisonFailure(cleanMessage, (String) expected,\n                    (String) actual);\n        } else {\n            failNotEquals(message, expected, actual);\n        }\n    }\n\n    private static boolean equalsRegardingNull(Object expected, Object actual) {\n        if (expected == null) {\n            return actual == null;\n        }\n\n        return isEquals(expected, actual);\n    }\n\n    private static boolean isEquals(Object expected, Object actual) {\n        return expected.equals(actual);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     */\n    public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, Object unexpected,\n            Object actual) {\n        if (equalsRegardingNull(unexpected, actual)) {\n            failEquals(message, actual);\n        }\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(Object unexpected, Object actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    private static void failEquals(String message, Object actual) {\n        String formatted = \"Values should be different. \";\n        if (message != null) {\n            formatted = message + \". \";\n        }\n\n        formatted += \"Actual: \" + actual;\n        fail(formatted);\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, long unexpected, long actual) {\n        if (unexpected == actual) {\n            failEquals(message, Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(long unexpected, long actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, double unexpected,\n            double actual, double delta) {\n        if (!doubleIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(double unexpected, double actual, double delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(float unexpected, float actual, float delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(String message, Object[] expecteds,\n            Object[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(String message, boolean[] expecteds,\n            boolean[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(String message, byte[] expecteds,\n            byte[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(String message, char[] expecteds,\n            char[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(char[] expecteds, char[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(String message, short[] expecteds,\n            short[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(short[] expecteds, short[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(String message, int[] expecteds,\n            int[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(int[] expecteds, int[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(String message, long[] expecteds,\n            long[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(long[] expecteds, long[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, double[] expecteds,\n            double[] actuals, double delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, float[] expecteds,\n            float[] actuals, float delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    private static void internalArrayEquals(String message, Object expecteds,\n            Object actuals) throws ArrayComparisonFailure {\n        new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, double expected,\n            double actual, double delta) {\n        if (doubleIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, float unexpected,\n            float actual, float delta) {\n        if (!floatIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, actual);\n        }\n    }\n\n    private static boolean doubleIsDifferent(double d1, double d2, double delta) {\n        if (Double.compare(d1, d2) == 0) {\n            return false;\n        }\n        if ((Math.abs(d1 - d2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expected expected long value.\n     * @param actual actual long value\n     */\n    public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected long expected value.\n     * @param actual long actual value\n     */\n    public static void assertEquals(String message, long expected, long actual) {\n        if (expected != actual) {\n            failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(double expected, double actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(String message, double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(String message, double expected,\n            double actual) {\n        fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored. NaNs are considered\n     * equal: <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it is not, an {@link AssertionError}\n     * is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(String message, Object object) {\n        if (object == null) {\n            return;\n        }\n        failNotNull(message, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it isn't an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(Object object) {\n        assertNull(null, object);\n    }\n\n    private static void failNotNull(String message, Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected null, but was:<\" + actual + \">\");\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not the\n     * same, an {@link AssertionError} without a message is thrown.\n     *\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} is thrown with the\n     * given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(String message, Object unexpected,\n            Object actual) {\n        if (unexpected == actual) {\n            failSame(message);\n        }\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} without a message is\n     * thrown.\n     *\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(Object unexpected, Object actual) {\n        assertNotSame(null, unexpected, actual);\n    }\n\n    private static void failSame(String message) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected not same\");\n    }\n\n    private static void failNotSame(String message, Object expected,\n            Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual\n                + \">\");\n    }\n\n    private static void failNotEquals(String message, Object expected,\n            Object actual) {\n        fail(format(message, expected, actual));\n    }\n\n    static String format(String message, Object expected, Object actual) {\n        String formatted = \"\";\n        if (message != null && !\"\".equals(message)) {\n            formatted = message + \" \";\n        }\n        String expectedString = String.valueOf(expected);\n        String actualString = String.valueOf(actual);\n        if (expectedString.equals(actualString)) {\n            return formatted + \"expected: \"\n                    + formatClassAndValue(expected, expectedString)\n                    + \" but was: \" + formatClassAndValue(actual, actualString);\n        } else {\n            return formatted + \"expected:<\" + expectedString + \"> but was:<\"\n                    + actualString + \">\";\n        }\n    }\n\n    private static String formatClass(Class<?> value) {\n        String className = value.getCanonicalName();\n        return className == null ? value.getName() : className;\n    }\n\n    private static String formatClassAndValue(Object value, String valueString) {\n        String className = value == null ? \"null\" : value.getClass().getName();\n        return className + \"<\" + valueString + \">\";\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(String message, Object[] expecteds,\n            Object[] actuals) {\n        assertArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(expecteds, actuals);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(0, is(1)); // fails:\n     *     // failure message:\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * the reason and information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:\n     *     // failure message:\n     *     // Help! Integers don't work\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param reason additional information about the error\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(String reason, T actual,\n            Matcher<? super T> matcher) {\n        MatcherAssert.assertThat(reason, actual, matcher);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it\n     * throws the wrong type of exception, an {@code AssertionError} is thrown describing the\n     * mismatch; the exception that was actually thrown can be obtained by calling {@link\n     * AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @since 4.13\n     */\n    public static void assertThrows(Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {\n        expectThrows(expectedThrowable, runnable);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does, the exception object is returned. If it does not throw an exception, an\n     * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code\n     * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can\n     * be obtained by calling {@link AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @return the exception thrown by {@code runnable}\n     * @since 4.13\n     */\n    public static <T extends Throwable> T expectThrows(Class<T> expectedThrowable, ThrowingRunnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable actualThrown) {\n            if (expectedThrowable.isInstance(actualThrown)) {\n                @SuppressWarnings(\"unchecked\") T retVal = (T) actualThrown;\n                return retVal;\n            } else {\n                String expected = formatClass(expectedThrowable);\n                Class<? extends Throwable> actualThrowable = actualThrown.getClass();\n                String actual = formatClass(actualThrowable);\n                if (expected.equals(actual)) {\n                    // There must be multiple class loaders. Add the identity hash code so the message\n                    // doesn't say \"expected: java.lang.String<my.package.MyException> ...\"\n                    expected += \"@\" + Integer.toHexString(System.identityHashCode(expectedThrowable));\n                    actual += \"@\" + Integer.toHexString(System.identityHashCode(actualThrowable));\n                }\n                String mismatchMessage = format(\"unexpected exception type thrown;\", expected, actual);\n\n                // The AssertionError(String, Throwable) ctor is only available on JDK7.\n                AssertionError assertionError = new AssertionError(mismatchMessage);\n                assertionError.initCause(actualThrown);\n                throw assertionError;\n            }\n        }\n        String message = String.format(\"expected %s to be thrown, but nothing was thrown\",\n                formatClass(expectedThrowable));\n        throw new AssertionError(message);\n    }\n}\n","lineNo":1006}
{"Smelly Sample":"package org.junit;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.internal.ArrayComparisonFailure;\nimport org.junit.internal.ExactComparisonCriteria;\nimport org.junit.internal.InexactComparisonCriteria;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions\n * are recorded. These methods can be used directly:\n * <code>Assert.assertEquals(...)<\/code>, however, they read better if they\n * are referenced through static import:\n *\n * <pre>\n * import static org.junit.Assert.*;\n *    ...\n *    assertEquals(...);\n * <\/pre>\n *\n * @see AssertionError\n * @since 4.0\n */\npublic class Assert {\n    /**\n     * Protect constructor since it is a static only class\n     */\n    protected Assert() {\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }\n\n    /**\n     * Fails a test with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @see AssertionError\n     */\n    public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionError();\n        }\n        throw new AssertionError(message);\n    }\n\n    /**\n     * Fails a test with no message.\n     */\n    public static void fail() {\n        fail(null);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual actual value\n     */\n    public static void assertEquals(String message, Object expected,\n            Object actual) {\n        if (equalsRegardingNull(expected, actual)) {\n            return;\n        }\n        if (expected instanceof String && actual instanceof String) {\n            String cleanMessage = message == null ? \"\" : message;\n            throw new ComparisonFailure(cleanMessage, (String) expected,\n                    (String) actual);\n        } else {\n            failNotEquals(message, expected, actual);\n        }\n    }\n\n    private static boolean equalsRegardingNull(Object expected, Object actual) {\n        if (expected == null) {\n            return actual == null;\n        }\n\n        return isEquals(expected, actual);\n    }\n\n    private static boolean isEquals(Object expected, Object actual) {\n        return expected.equals(actual);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     */\n    public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, Object unexpected,\n            Object actual) {\n        if (equalsRegardingNull(unexpected, actual)) {\n            failEquals(message, actual);\n        }\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(Object unexpected, Object actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    private static void failEquals(String message, Object actual) {\n        String formatted = \"Values should be different. \";\n        if (message != null) {\n            formatted = message + \". \";\n        }\n\n        formatted += \"Actual: \" + actual;\n        fail(formatted);\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, long unexpected, long actual) {\n        if (unexpected == actual) {\n            failEquals(message, Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(long unexpected, long actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, double unexpected,\n            double actual, double delta) {\n        if (!doubleIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(double unexpected, double actual, double delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(float unexpected, float actual, float delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(String message, Object[] expecteds,\n            Object[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(String message, boolean[] expecteds,\n            boolean[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(String message, byte[] expecteds,\n            byte[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(String message, char[] expecteds,\n            char[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(char[] expecteds, char[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(String message, short[] expecteds,\n            short[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(short[] expecteds, short[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(String message, int[] expecteds,\n            int[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(int[] expecteds, int[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(String message, long[] expecteds,\n            long[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(long[] expecteds, long[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, double[] expecteds,\n            double[] actuals, double delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, float[] expecteds,\n            float[] actuals, float delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    private static void internalArrayEquals(String message, Object expecteds,\n            Object actuals) throws ArrayComparisonFailure {\n        new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, double expected,\n            double actual, double delta) {\n        if (doubleIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, float unexpected,\n            float actual, float delta) {\n        if (!floatIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, actual);\n        }\n    }\n\n    private static boolean doubleIsDifferent(double d1, double d2, double delta) {\n        if (Double.compare(d1, d2) == 0) {\n            return false;\n        }\n        if ((Math.abs(d1 - d2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expected expected long value.\n     * @param actual actual long value\n     */\n    public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected long expected value.\n     * @param actual long actual value\n     */\n    public static void assertEquals(String message, long expected, long actual) {\n        if (expected != actual) {\n            failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(double expected, double actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(String message, double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(String message, double expected,\n            double actual) {\n        fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored. NaNs are considered\n     * equal: <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it is not, an {@link AssertionError}\n     * is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(String message, Object object) {\n        if (object == null) {\n            return;\n        }\n        failNotNull(message, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it isn't an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(Object object) {\n        assertNull(null, object);\n    }\n\n    private static void failNotNull(String message, Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected null, but was:<\" + actual + \">\");\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not the\n     * same, an {@link AssertionError} without a message is thrown.\n     *\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} is thrown with the\n     * given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(String message, Object unexpected,\n            Object actual) {\n        if (unexpected == actual) {\n            failSame(message);\n        }\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} without a message is\n     * thrown.\n     *\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(Object unexpected, Object actual) {\n        assertNotSame(null, unexpected, actual);\n    }\n\n    private static void failSame(String message) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected not same\");\n    }\n\n    private static void failNotSame(String message, Object expected,\n            Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual\n                + \">\");\n    }\n\n    private static void failNotEquals(String message, Object expected,\n            Object actual) {\n        fail(format(message, expected, actual));\n    }\n\n    static String format(String message, Object expected, Object actual) {\n        String formatted = \"\";\n        if (message != null && !\"\".equals(message)) {\n            formatted = message + \" \";\n        }\n        String expectedString = String.valueOf(expected);\n        String actualString = String.valueOf(actual);\n        if (expectedString.equals(actualString)) {\n            return formatted + \"expected: \"\n                    + formatClassAndValue(expected, expectedString)\n                    + \" but was: \" + formatClassAndValue(actual, actualString);\n        } else {\n            return formatted + \"expected:<\" + expectedString + \"> but was:<\"\n                    + actualString + \">\";\n        }\n    }\n\n    private static String formatClass(Class<?> value) {\n        String className = value.getCanonicalName();\n        return className == null ? value.getName() : className;\n    }\n\n    private static String formatClassAndValue(Object value, String valueString) {\n        String className = value == null ? \"null\" : value.getClass().getName();\n        return className + \"<\" + valueString + \">\";\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(String message, Object[] expecteds,\n            Object[] actuals) {\n        assertArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(expecteds, actuals);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(0, is(1)); // fails:\n     *     // failure message:\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * the reason and information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:\n     *     // failure message:\n     *     // Help! Integers don't work\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param reason additional information about the error\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(String reason, T actual,\n            Matcher<? super T> matcher) {\n        MatcherAssert.assertThat(reason, actual, matcher);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it\n     * throws the wrong type of exception, an {@code AssertionError} is thrown describing the\n     * mismatch; the exception that was actually thrown can be obtained by calling {@link\n     * AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @since 4.13\n     */\n    public static void assertThrows(Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {\n        expectThrows(expectedThrowable, runnable);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does, the exception object is returned. If it does not throw an exception, an\n     * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code\n     * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can\n     * be obtained by calling {@link AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @return the exception thrown by {@code runnable}\n     * @since 4.13\n     */\n    public static <T extends Throwable> T expectThrows(Class<T> expectedThrowable, ThrowingRunnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable actualThrown) {\n            if (expectedThrowable.isInstance(actualThrown)) {\n                @SuppressWarnings(\"unchecked\") T retVal = (T) actualThrown;\n                return retVal;\n            } else {\n                String mismatchMessage = format(\"unexpected exception type thrown;\",\n                    formatClass(expectedThrowable), formatClass(actualThrown));\n\n                // The AssertionError(String, Throwable) ctor is only available on JDK7.\n                AssertionError assertionError = new AssertionError(mismatchMessage);\n                assertionError.initCause(actualThrown);\n                throw assertionError;\n            }\n        }\n        String message = String.format(\"expected %s to be thrown, but nothing was thrown\",\n                formatClass(expectedThrowable));\n        throw new AssertionError(message);\n    }\n}\n","Method after Refactoring":"package org.junit;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.internal.ArrayComparisonFailure;\nimport org.junit.internal.ExactComparisonCriteria;\nimport org.junit.internal.InexactComparisonCriteria;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions\n * are recorded. These methods can be used directly:\n * <code>Assert.assertEquals(...)<\/code>, however, they read better if they\n * are referenced through static import:\n *\n * <pre>\n * import static org.junit.Assert.*;\n *    ...\n *    assertEquals(...);\n * <\/pre>\n *\n * @see AssertionError\n * @since 4.0\n */\npublic class Assert {\n    /**\n     * Protect constructor since it is a static only class\n     */\n    protected Assert() {\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }\n\n    /**\n     * Asserts that a condition is true. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }\n\n    /**\n     * Asserts that a condition is false. If it isn't it throws an\n     * {@link AssertionError} without a message.\n     *\n     * @param condition condition to be checked\n     */\n    public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }\n\n    /**\n     * Fails a test with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @see AssertionError\n     */\n    public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionError();\n        }\n        throw new AssertionError(message);\n    }\n\n    /**\n     * Fails a test with no message.\n     */\n    public static void fail() {\n        fail(null);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual actual value\n     */\n    public static void assertEquals(String message, Object expected,\n            Object actual) {\n        if (equalsRegardingNull(expected, actual)) {\n            return;\n        }\n        if (expected instanceof String && actual instanceof String) {\n            String cleanMessage = message == null ? \"\" : message;\n            throw new ComparisonFailure(cleanMessage, (String) expected,\n                    (String) actual);\n        } else {\n            failNotEquals(message, expected, actual);\n        }\n    }\n\n    private static boolean equalsRegardingNull(Object expected, Object actual) {\n        if (expected == null) {\n            return actual == null;\n        }\n\n        return isEquals(expected, actual);\n    }\n\n    private static boolean isEquals(Object expected, Object actual) {\n        return expected.equals(actual);\n    }\n\n    /**\n     * Asserts that two objects are equal. If they are not, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>expected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     */\n    public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, Object unexpected,\n            Object actual) {\n        if (equalsRegardingNull(unexpected, actual)) {\n            failEquals(message, actual);\n        }\n    }\n\n    /**\n     * Asserts that two objects are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown. If\n     * <code>unexpected<\/code> and <code>actual<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(Object unexpected, Object actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    private static void failEquals(String message, Object actual) {\n        String formatted = \"Values should be different. \";\n        if (message != null) {\n            formatted = message + \". \";\n        }\n\n        formatted += \"Actual: \" + actual;\n        fail(formatted);\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(String message, long unexpected, long actual) {\n        if (unexpected == actual) {\n            failEquals(message, Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two longs are <b>not<\/b> equals. If they are, an\n     * {@link AssertionError} without a message is thrown.\n     *\n     * @param unexpected unexpected value to check\n     * @param actual the value to check against <code>unexpected<\/code>\n     */\n    public static void assertNotEquals(long unexpected, long actual) {\n        assertNotEquals(null, unexpected, actual);\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, double unexpected,\n            double actual, double delta) {\n        if (!doubleIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two doubles are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Double.NaN, Double.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(double unexpected, double actual, double delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown. If the unexpected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(float unexpected, float actual, float delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(String message, Object[] expecteds,\n            Object[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(String message, boolean[] expecteds,\n            boolean[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two boolean arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds boolean array with expected values.\n     * @param actuals boolean array with expected values.\n     */\n    public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(String message, byte[] expecteds,\n            byte[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two byte arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds byte array with expected values.\n     * @param actuals byte array with actual values\n     */\n    public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(String message, char[] expecteds,\n            char[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two char arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds char array with expected values.\n     * @param actuals char array with actual values\n     */\n    public static void assertArrayEquals(char[] expecteds, char[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(String message, short[] expecteds,\n            short[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two short arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds short array with expected values.\n     * @param actuals short array with actual values\n     */\n    public static void assertArrayEquals(short[] expecteds, short[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(String message, int[] expecteds,\n            int[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two int arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds int array with expected values.\n     * @param actuals int array with actual values\n     */\n    public static void assertArrayEquals(int[] expecteds, int[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(String message, long[] expecteds,\n            long[] actuals) throws ArrayComparisonFailure {\n        internalArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two long arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds long array with expected values.\n     * @param actuals long array with actual values\n     */\n    public static void assertArrayEquals(long[] expecteds, long[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, double[] expecteds,\n            double[] actuals, double delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two double arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds double array with expected values.\n     * @param actuals double array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(String message, float[] expecteds,\n            float[] actuals, float delta) throws ArrayComparisonFailure {\n        new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two float arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expecteds float array with expected values.\n     * @param actuals float array with actual values\n     * @param delta the maximum delta between <code>expecteds[i]<\/code> and\n     * <code>actuals[i]<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    private static void internalArrayEquals(String message, Object expecteds,\n            Object actuals) throws ArrayComparisonFailure {\n        new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, double expected,\n            double actual, double delta) {\n        if (doubleIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));\n        }\n    }\n\n    /**\n     * Asserts that two floats are <b>not<\/b> equal to within a positive delta.\n     * If they are, an {@link AssertionError} is thrown with the given\n     * message. If the unexpected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertNotEquals(Float.NaN, Float.NaN, *)<\/code> fails\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected unexpected value\n     * @param actual the value to check against <code>unexpected<\/code>\n     * @param delta the maximum delta between <code>unexpected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertNotEquals(String message, float unexpected,\n            float actual, float delta) {\n        if (!floatIsDifferent(unexpected, actual, delta)) {\n            failEquals(message, actual);\n        }\n    }\n\n    private static boolean doubleIsDifferent(double d1, double d2, double delta) {\n        if (Double.compare(d1, d2) == 0) {\n            return false;\n        }\n        if ((Math.abs(d1 - d2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown.\n     *\n     * @param expected expected long value.\n     * @param actual actual long value\n     */\n    public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two longs are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected long expected value.\n     * @param actual long actual value\n     */\n    public static void assertEquals(String message, long expected, long actual) {\n        if (expected != actual) {\n            failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n        }\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(double expected, double actual) {\n        assertEquals(null, expected, actual);\n    }\n\n    /**\n     * @deprecated Use\n     *             <code>assertEquals(String message, double expected, double actual, double delta)<\/code>\n     *             instead\n     */\n    @Deprecated\n    public static void assertEquals(String message, double expected,\n            double actual) {\n        fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n    }\n\n    /**\n     * Asserts that two doubles are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored.NaNs are considered\n     * equal: <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown. If the expected\n     * value is infinity then the delta value is ignored. NaNs are considered\n     * equal: <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n     *\n     * @param expected expected value\n     * @param actual the value to check against <code>expected<\/code>\n     * @param delta the maximum delta between <code>expected<\/code> and\n     * <code>actual<\/code> for which both numbers are still\n     * considered equal.\n     */\n    public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }\n\n    /**\n     * Asserts that an object isn't null. If it is an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it is not, an {@link AssertionError}\n     * is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(String message, Object object) {\n        if (object == null) {\n            return;\n        }\n        failNotNull(message, object);\n    }\n\n    /**\n     * Asserts that an object is null. If it isn't an {@link AssertionError} is\n     * thrown.\n     *\n     * @param object Object to check or <code>null<\/code>\n     */\n    public static void assertNull(Object object) {\n        assertNull(null, object);\n    }\n\n    private static void failNotNull(String message, Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected null, but was:<\" + actual + \">\");\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not, an\n     * {@link AssertionError} is thrown with the given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects refer to the same object. If they are not the\n     * same, an {@link AssertionError} without a message is thrown.\n     *\n     * @param expected the expected object\n     * @param actual the object to compare to <code>expected<\/code>\n     */\n    public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} is thrown with the\n     * given message.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(String message, Object unexpected,\n            Object actual) {\n        if (unexpected == actual) {\n            failSame(message);\n        }\n    }\n\n    /**\n     * Asserts that two objects do not refer to the same object. If they do\n     * refer to the same object, an {@link AssertionError} without a message is\n     * thrown.\n     *\n     * @param unexpected the object you don't expect\n     * @param actual the object to compare to <code>unexpected<\/code>\n     */\n    public static void assertNotSame(Object unexpected, Object actual) {\n        assertNotSame(null, unexpected, actual);\n    }\n\n    private static void failSame(String message) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected not same\");\n    }\n\n    private static void failNotSame(String message, Object expected,\n            Object actual) {\n        String formatted = \"\";\n        if (message != null) {\n            formatted = message + \" \";\n        }\n        fail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual\n                + \">\");\n    }\n\n    private static void failNotEquals(String message, Object expected,\n            Object actual) {\n        fail(format(message, expected, actual));\n    }\n\n    static String format(String message, Object expected, Object actual) {\n        String formatted = \"\";\n        if (message != null && !\"\".equals(message)) {\n            formatted = message + \" \";\n        }\n        String expectedString = String.valueOf(expected);\n        String actualString = String.valueOf(actual);\n        if (expectedString.equals(actualString)) {\n            return formatted + \"expected: \"\n                    + formatClassAndValue(expected, expectedString)\n                    + \" but was: \" + formatClassAndValue(actual, actualString);\n        } else {\n            return formatted + \"expected:<\" + expectedString + \"> but was:<\"\n                    + actualString + \">\";\n        }\n    }\n\n    private static String formatClass(Class<?> value) {\n        String className = value.getCanonicalName();\n        return className == null ? value.getName() : className;\n    }\n\n    private static String formatClassAndValue(Object value, String valueString) {\n        String className = value == null ? \"null\" : value.getClass().getName();\n        return className + \"<\" + valueString + \">\";\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown with the given message. If\n     * <code>expecteds<\/code> and <code>actuals<\/code> are <code>null<\/code>,\n     * they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null<\/code>\n     * okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(String message, Object[] expecteds,\n            Object[] actuals) {\n        assertArrayEquals(message, expecteds, actuals);\n    }\n\n    /**\n     * Asserts that two object arrays are equal. If they are not, an\n     * {@link AssertionError} is thrown. If <code>expected<\/code> and\n     * <code>actual<\/code> are <code>null<\/code>, they are considered\n     * equal.\n     *\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     * @deprecated use assertArrayEquals\n     */\n    @Deprecated\n    public static void assertEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(expecteds, actuals);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(0, is(1)); // fails:\n     *     // failure message:\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }\n\n    /**\n     * Asserts that <code>actual<\/code> satisfies the condition specified by\n     * <code>matcher<\/code>. If not, an {@link AssertionError} is thrown with\n     * the reason and information about the matcher and failing value. Example:\n     *\n     * <pre>\n     *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:\n     *     // failure message:\n     *     // Help! Integers don't work\n     *     // expected: is &lt;1&gt;\n     *     // got value: &lt;0&gt;\n     *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes\n     * <\/pre>\n     *\n     * <code>org.hamcrest.Matcher<\/code> does not currently document the meaning\n     * of its type parameter <code>T<\/code>.  This method assumes that a matcher\n     * typed as <code>Matcher&lt;T&gt;<\/code> can be meaningfully applied only\n     * to values that could be assigned to a variable of type <code>T<\/code>.\n     *\n     * @param reason additional information about the error\n     * @param <T> the static type accepted by the matcher (this can flag obvious\n     * compile-time problems such as {@code assertThat(1, is(\"a\"))}\n     * @param actual the computed value being compared\n     * @param matcher an expression, built of {@link Matcher}s, specifying allowed\n     * values\n     * @see org.hamcrest.CoreMatchers\n     * @see org.hamcrest.MatcherAssert\n     * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}\n     */\n    @Deprecated\n    public static <T> void assertThat(String reason, T actual,\n            Matcher<? super T> matcher) {\n        MatcherAssert.assertThat(reason, actual, matcher);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it\n     * throws the wrong type of exception, an {@code AssertionError} is thrown describing the\n     * mismatch; the exception that was actually thrown can be obtained by calling {@link\n     * AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @since 4.13\n     */\n    public static void assertThrows(Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {\n        expectThrows(expectedThrowable, runnable);\n    }\n\n    /**\n     * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when\n     * executed. If it does, the exception object is returned. If it does not throw an exception, an\n     * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code\n     * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can\n     * be obtained by calling {@link AssertionError#getCause}.\n     *\n     * @param expectedThrowable the expected type of the exception\n     * @param runnable       a function that is expected to throw an exception when executed\n     * @return the exception thrown by {@code runnable}\n     * @since 4.13\n     */\n    public static <T extends Throwable> T expectThrows(Class<T> expectedThrowable, ThrowingRunnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable actualThrown) {\n            if (expectedThrowable.isInstance(actualThrown)) {\n                @SuppressWarnings(\"unchecked\") T retVal = (T) actualThrown;\n                return retVal;\n            } else {\n                String expected = formatClass(expectedThrowable);\n                Class<? extends Throwable> actualThrowable = actualThrown.getClass();\n                String actual = formatClass(actualThrowable);\n                if (expected.equals(actual)) {\n                    // There must be multiple class loaders. Add the identity hash code so the message\n                    // doesn't say \"expected: java.lang.String<my.package.MyException> ...\"\n                    expected += \"@\" + Integer.toHexString(System.identityHashCode(expectedThrowable));\n                    actual += \"@\" + Integer.toHexString(System.identityHashCode(actualThrowable));\n                }\n                String mismatchMessage = format(\"unexpected exception type thrown;\", expected, actual);\n\n                // The AssertionError(String, Throwable) ctor is only available on JDK7.\n                AssertionError assertionError = new AssertionError(mismatchMessage);\n                assertionError.initCause(actualThrown);\n                throw assertionError;\n            }\n        }\n        String message = String.format(\"expected %s to be thrown, but nothing was thrown\",\n                formatClass(expectedThrowable));\n        throw new AssertionError(message);\n    }\n}\n","lineNo":1005}
{"Smelly Sample":"package org.junit.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\nimport org.junit.Assert;\n\n/**\n * Defines criteria for finding two items \"equal enough\". Concrete subclasses\n * may demand exact equality, or, for example, equality within a given delta.\n */\npublic abstract class ComparisonCriteria {\n    /**\n     * Asserts that two arrays are equal, according to the criteria defined by\n     * the concrete subclass. If they are not, an {@link AssertionError} is\n     * thrown with the given message. If <code>expecteds<\/code> and\n     * <code>actuals<\/code> are <code>null<\/code>, they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (\n     * <code>null<\/code> okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public void arrayEquals(String message, Object expecteds, Object actuals)\n            throws ArrayComparisonFailure {\n        arrayEquals(message, expecteds, actuals, true);\n    }\n\n    private void arrayEquals(String message, Object expecteds, Object actuals, boolean outer)\n            throws ArrayComparisonFailure {\n        if (expecteds == actuals\n            || Arrays.deepEquals(new Object[] {expecteds}, new Object[] {actuals})) {\n            // The reflection-based loop below is potentially very slow, especially for primitive\n            // arrays. The deepEquals check allows us to circumvent it in the usual case where\n            // the arrays are exactly equal.\n            return;\n        }\n        String header = message == null ? \"\" : message + \": \";\n\n        // Only include the user-provided message in the outer exception.\n        String exceptionMessage = outer ? header : \"\";\n        int expectedsLength = assertArraysAreSameLength(expecteds, actuals, exceptionMessage);\n\n        for (int i = 0; i < expectedsLength; i++) {\n            Object expected = Array.get(expecteds, i);\n            Object actual = Array.get(actuals, i);\n\n            if (isArray(expected) && isArray(actual)) {\n                try {\n                    arrayEquals(message, expected, actual, false);\n                } catch (ArrayComparisonFailure e) {\n                    e.addDimension(i);\n                    throw e;\n                } catch (AssertionError e) {\n                    // Array lengths differed.\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            } else {\n                try {\n                    assertElementsEqual(expected, actual);\n                } catch (AssertionError e) {\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            }\n        }\n    }\n\n    private boolean isArray(Object expected) {\n        return expected != null && expected.getClass().isArray();\n    }\n\n    private int assertArraysAreSameLength(Object expecteds,\n            Object actuals, String header) {\n        if (expecteds == null) {\n            Assert.fail(header + \"expected array was null\");\n        }\n        if (actuals == null) {\n            Assert.fail(header + \"actual array was null\");\n        }\n        int actualsLength = Array.getLength(actuals);\n        int expectedsLength = Array.getLength(expecteds);\n        if (actualsLength != expectedsLength) {\n            Assert.fail(header + \"array lengths differed, expected.length=\"\n                    + expectedsLength + \" actual.length=\" + actualsLength);\n        }\n        return expectedsLength;\n    }\n\n    protected abstract void assertElementsEqual(Object expected, Object actual);\n}\n","Method after Refactoring":"package org.junit.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\nimport org.junit.Assert;\n\n/**\n * Defines criteria for finding two items \"equal enough\". Concrete subclasses\n * may demand exact equality, or, for example, equality within a given delta.\n */\npublic abstract class ComparisonCriteria {\n    /**\n     * Asserts that two arrays are equal, according to the criteria defined by\n     * the concrete subclass. If they are not, an {@link AssertionError} is\n     * thrown with the given message. If <code>expecteds<\/code> and\n     * <code>actuals<\/code> are <code>null<\/code>, they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (\n     * <code>null<\/code> okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public void arrayEquals(String message, Object expecteds, Object actuals)\n            throws ArrayComparisonFailure {\n        arrayEquals(message, expecteds, actuals, true);\n    }\n\n    private void arrayEquals(String message, Object expecteds, Object actuals, boolean outer)\n            throws ArrayComparisonFailure {\n        if (expecteds == actuals\n            || Arrays.deepEquals(new Object[] {expecteds}, new Object[] {actuals})) {\n            // The reflection-based loop below is potentially very slow, especially for primitive\n            // arrays. The deepEquals check allows us to circumvent it in the usual case where\n            // the arrays are exactly equal.\n            return;\n        }\n        String header = message == null ? \"\" : message + \": \";\n\n        // Only include the user-provided message in the outer exception.\n        String exceptionMessage = outer ? header : \"\";\n\n        if (expecteds == null) {\n            Assert.fail(exceptionMessage + \"expected array was null\");\n        }\n        if (actuals == null) {\n            Assert.fail(exceptionMessage + \"actual array was null\");\n        }\n\n        int actualsLength = Array.getLength(actuals);\n        int expectedsLength = Array.getLength(expecteds);\n        if (actualsLength != expectedsLength) {\n            header += \"array lengths differed, expected.length=\"\n                    + expectedsLength + \" actual.length=\" + actualsLength + \"; \";\n        }\n        int prefixLength = Math.min(actualsLength, expectedsLength);\n\n        for (int i = 0; i < prefixLength; i++) {\n            Object expected = Array.get(expecteds, i);\n            Object actual = Array.get(actuals, i);\n\n            if (isArray(expected) && isArray(actual)) {\n                try {\n                    arrayEquals(message, expected, actual, false);\n                } catch (ArrayComparisonFailure e) {\n                    e.addDimension(i);\n                    throw e;\n                } catch (AssertionError e) {\n                    // Array lengths differed.\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            } else {\n                try {\n                    assertElementsEqual(expected, actual);\n                } catch (AssertionError e) {\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            }\n        }\n\n        if (actualsLength != expectedsLength) {\n            Object expected = getArrayElementOrSentinel(expecteds, expectedsLength, prefixLength);\n            Object actual = getArrayElementOrSentinel(actuals, actualsLength, prefixLength);\n            try {\n                Assert.assertEquals(expected, actual);\n            } catch (AssertionError e) {\n                throw new ArrayComparisonFailure(header, e, prefixLength);\n            }\n        }\n    }\n\n    private static final Object END_OF_ARRAY_SENTINEL = new Object() {\n        @Override\n        public String toString() {\n            return \"end of array\";\n        }\n    };\n\n    private Object getArrayElementOrSentinel(Object array, int length, int index) {\n        return index < length ? Array.get(array, index) : END_OF_ARRAY_SENTINEL;\n    }\n\n    private boolean isArray(Object expected) {\n        return expected != null && expected.getClass().isArray();\n    }\n\n    protected abstract void assertElementsEqual(Object expected, Object actual);\n}\n","lineNo":58}
{"Smelly Sample":"package junit.tests.runner;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.List;\n\nimport junit.framework.TestCase;\nimport junit.tests.framework.Success;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.tests.running.methods.AnnotationTest;\n\npublic class ResultTest extends TestCase {\n\n    public void testRunFailureResultCanBeSerialised() throws Exception {\n        JUnitCore runner = new JUnitCore();\n        Result result = runner.run(AnnotationTest.FailureTest.class);\n        assertResultSerializable(result);\n    }\n\n    public void testRunSuccessResultCanBeSerialised() throws Exception {\n        JUnitCore runner = new JUnitCore();\n        Result result = runner.run(Success.class);\n        assertResultSerializable(result);\n    }\n\n    private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        new ObjectOutputStream(byteArrayOutputStream).writeObject(result);\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Result fromStream = (Result) objectInputStream.readObject();\n        assertSerializedCorrectly(result, fromStream);\n\n        InputStream resource = getClass().getResourceAsStream(getName());\n        assertNotNull(\"Could not read resource \" + getName(), resource);\n        objectInputStream = new ObjectInputStream(resource);\n        fromStream = (Result) objectInputStream.readObject();\n        \n        assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream);\n    }\n\n    /**\n     * A version of {@code Result} that returns a hard-coded runtime.\n     * This makes values returned by the methods deterministic.\n     */\n    private static class ResultWithFixedRunTime extends Result {\n\n        private static final long serialVersionUID = 1L;\n\n        private final Result delegate;\n\n        public ResultWithFixedRunTime(Result delegate) {\n            this.delegate = delegate;\n        }\n\n        @Override\n        public int getRunCount() {\n            return delegate.getRunCount();\n        }\n\n        @Override\n        public int getFailureCount() {\n            return delegate.getFailureCount();\n        }\n\n        @Override\n        public long getRunTime() {\n            return 2;\n        }\n\n        @Override\n        public List<Failure> getFailures() {\n            return delegate.getFailures();\n        }\n\n        @Override\n        public int getIgnoreCount() {\n            return delegate.getIgnoreCount();\n        }\n    }\n\n    private void assertSerializedCorrectly(Result result, Result fromStream) {\n        assertNotNull(fromStream);\n\n        // Exceptions don't implement equals() so we need to compare field by field\n        assertEquals(\"failureCount\", result.getFailureCount(), fromStream.getFailureCount());\n        assertEquals(\"ignoreCount\", result.getIgnoreCount(), fromStream.getIgnoreCount());\n        assertEquals(\"runTime\", result.getRunTime(), fromStream.getRunTime());\n        assertEquals(\"failures\", result.getFailures().size(), fromStream.getFailures().size());\n        int index = 0;\n        for (Failure failure : result.getFailures()) {\n            Failure failureFromStream = fromStream.getFailures().get(index);\n            String messagePrefix = String.format(\"failures[%d]\", index++);\n            assertEquals(messagePrefix + \".description\",\n                    failure.getDescription(), failureFromStream.getDescription());\n            Throwable exception = failure.getException();\n            Throwable exceptionFromStream = failureFromStream.getException();\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getClass(), exceptionFromStream.getClass());\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getMessage(), exceptionFromStream.getMessage());\n        }\n    }\n}\n","Method after Refactoring":"package junit.tests.runner;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.List;\n\nimport junit.framework.TestCase;\nimport junit.tests.framework.Success;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.tests.running.methods.AnnotationTest;\n\npublic class ResultTest extends TestCase {\n\n    public void testRunFailureResultCanBeSerialised() throws Exception {\n        JUnitCore runner = new JUnitCore();\n        Result result = runner.run(AnnotationTest.FailureTest.class);\n        assertResultSerializable(result);\n    }\n\n    public void testRunSuccessResultCanBeSerialised() throws Exception {\n        JUnitCore runner = new JUnitCore();\n        Result result = runner.run(Success.class);\n        assertResultSerializable(result);\n    }\n\n    private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n        objectOutputStream.writeObject(result);\n        objectOutputStream.flush();\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Result fromStream = (Result) objectInputStream.readObject();\n        assertSerializedCorrectly(result, fromStream);\n\n        InputStream resource = getClass().getResourceAsStream(getName());\n        assertNotNull(\"Could not read resource \" + getName(), resource);\n        objectInputStream = new ObjectInputStream(resource);\n        fromStream = (Result) objectInputStream.readObject();\n        \n        assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream);\n    }\n\n    /**\n     * A version of {@code Result} that returns a hard-coded runtime.\n     * This makes values returned by the methods deterministic.\n     */\n    private static class ResultWithFixedRunTime extends Result {\n\n        private static final long serialVersionUID = 1L;\n\n        private final Result delegate;\n\n        public ResultWithFixedRunTime(Result delegate) {\n            this.delegate = delegate;\n        }\n\n        @Override\n        public int getRunCount() {\n            return delegate.getRunCount();\n        }\n\n        @Override\n        public int getFailureCount() {\n            return delegate.getFailureCount();\n        }\n\n        @Override\n        public long getRunTime() {\n            return 2;\n        }\n\n        @Override\n        public List<Failure> getFailures() {\n            return delegate.getFailures();\n        }\n\n        @Override\n        public int getIgnoreCount() {\n            return delegate.getIgnoreCount();\n        }\n    }\n\n    private void assertSerializedCorrectly(Result result, Result fromStream) {\n        assertNotNull(fromStream);\n\n        // Exceptions don't implement equals() so we need to compare field by field\n        assertEquals(\"failureCount\", result.getFailureCount(), fromStream.getFailureCount());\n        assertEquals(\"ignoreCount\", result.getIgnoreCount(), fromStream.getIgnoreCount());\n        assertEquals(\"runTime\", result.getRunTime(), fromStream.getRunTime());\n        assertEquals(\"failures\", result.getFailures().size(), fromStream.getFailures().size());\n        int index = 0;\n        for (Failure failure : result.getFailures()) {\n            Failure failureFromStream = fromStream.getFailures().get(index);\n            String messagePrefix = String.format(\"failures[%d]\", index++);\n            assertEquals(messagePrefix + \".description\",\n                    failure.getDescription(), failureFromStream.getDescription());\n            Throwable exception = failure.getException();\n            Throwable exceptionFromStream = failureFromStream.getException();\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getClass(), exceptionFromStream.getClass());\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getMessage(), exceptionFromStream.getMessage());\n        }\n    }\n}\n","lineNo":34}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_VALIDATOR;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.MethodRule;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * <p>\n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n *\n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n *\n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n * <p>\n * In turn, in 2009 we introduced {@link Rule}s.  In many cases where extending\n * BlockJUnit4ClassRunner was necessary to add new behavior, {@link Rule}s can\n * be used, which makes the extension more reusable and composable.\n *\n * @since 4.5\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n\n    private final ConcurrentHashMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();\n\n    /**\n     * Creates a BlockJUnit4ClassRunner to run {@code testClass}\n     *\n     * @throws InitializationError if the test class is malformed.\n     */\n    public BlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {\n        super(testClass);\n    }\n\n    //\n    // Implementation of ParentRunner\n    //\n\n    @Override\n    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement;\n            try {\n                statement = methodBlock(method);\n            }\n            catch (Throwable ex) {\n                statement = new Fail(ex);\n            }\n            runLeaf(statement, description, notifier);\n        }\n    }\n\n    /**\n     * Evaluates whether {@link FrameworkMethod}s are ignored based on the\n     * {@link Ignore} annotation.\n     */\n    @Override\n    protected boolean isIgnored(FrameworkMethod child) {\n        return child.getAnnotation(Ignore.class) != null;\n    }\n\n    @Override\n    protected Description describeChild(FrameworkMethod method) {\n        Description description = methodDescriptions.get(method);\n\n        if (description == null) {\n            description = Description.createTestDescription(getTestClass().getJavaClass(),\n                    testName(method), method.getAnnotations());\n            methodDescriptions.putIfAbsent(method, description);\n        }\n\n        return description;\n    }\n\n    @Override\n    protected List<FrameworkMethod> getChildren() {\n        return computeTestMethods();\n    }\n\n    //\n    // Override in subclasses\n    //\n\n    /**\n     * Returns the methods that run tests. Default implementation returns all\n     * methods annotated with {@code @Test} on this class and superclasses that\n     * are not overridden.\n     */\n    protected List<FrameworkMethod> computeTestMethods() {\n        return getTestClass().getAnnotatedMethods(Test.class);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n\n        validateNoNonStaticInnerClass(errors);\n        validateConstructor(errors);\n        validateInstanceMethods(errors);\n        validateFields(errors);\n        validateMethods(errors);\n    }\n\n    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n        if (getTestClass().isANonStaticInnerClass()) {\n            String gripe = \"The inner class \" + getTestClass().getName()\n                    + \" is not static.\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor,\n     * or if the constructor takes parameters. Override if a subclass requires\n     * different validation rules.\n     */\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor\n     * (do not override)\n     */\n    protected void validateOnlyOneConstructor(List<Throwable> errors) {\n        if (!hasOneConstructor()) {\n            String gripe = \"Test class should have exactly one public constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class's single constructor takes\n     * parameters (do not override)\n     */\n    protected void validateZeroArgConstructor(List<Throwable> errors) {\n        if (!getTestClass().isANonStaticInnerClass()\n                && hasOneConstructor()\n                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n            String gripe = \"Test class should have exactly one public zero-argument constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    private boolean hasOneConstructor() {\n        return getTestClass().getJavaClass().getConstructors().length == 1;\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test},\n     * {@code @Before}, or {@code @After} that is not a public, void instance\n     * method with no arguments.\n     */\n    @Deprecated\n    protected void validateInstanceMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(After.class, false, errors);\n        validatePublicVoidNoArgMethods(Before.class, false, errors);\n        validateTestMethods(errors);\n\n        if (computeTestMethods().size() == 0) {\n            errors.add(new Exception(\"No runnable methods\"));\n        }\n    }\n\n    protected void validateFields(List<Throwable> errors) {\n        RULE_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    private void validateMethods(List<Throwable> errors) {\n        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test}that\n     * is not a public, void instance method with no arguments.\n     */\n    protected void validateTestMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(Test.class, false, errors);\n    }\n\n    /**\n     * Returns a new fixture for running a test. Default implementation executes\n     * the test class's no-argument constructor (validation should have ensured\n     * one exists).\n     */\n    protected Object createTest() throws Exception {\n        return getTestClass().getOnlyConstructor().newInstance();\n    }\n\n    /**\n     * Returns a new fixture to run a particular test {@code method} against.\n     * Default implementation executes the no-argument {@link #createTest()} method.\n     *\n     * @since 4.13\n     */\n    protected Object createTest(FrameworkMethod method) throws Exception {\n        return createTest();\n    }\n\n    /**\n     * Returns the name that describes {@code method} for {@link Description}s.\n     * Default implementation is the method's name\n     */\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n\n    /**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * expecting} attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * <\/ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest(method);\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }\n\n    //\n    // Statement builders\n    //\n\n    /**\n     * Returns a {@link Statement} that invokes {@code method} on {@code test}\n     */\n    protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code expecting} attribute, return normally only if {@code next}\n     * throws an exception of the correct type, and throw an exception\n     * otherwise.\n     */\n    protected Statement possiblyExpectingExceptions(FrameworkMethod method,\n            Object test, Statement next) {\n        Test annotation = method.getAnnotation(Test.class);\n        return expectsException(annotation) ? new ExpectException(next,\n                getExpectedException(annotation)) : next;\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code timeout} attribute, throw an exception if {@code next}\n     * takes more than the specified number of milliseconds.\n     */\n    @Deprecated\n    protected Statement withPotentialTimeout(FrameworkMethod method,\n            Object test, Statement next) {\n        long timeout = getTimeout(method.getAnnotation(Test.class));\n        if (timeout <= 0) {\n            return next;\n        }\n        return FailOnTimeout.builder()\n               .withTimeout(timeout, TimeUnit.MILLISECONDS)\n               .build(next);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @Before}\n     * methods on this class and superclasses before running {@code next}; if\n     * any throws an Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBefores(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(\n                Before.class);\n        return befores.isEmpty() ? statement : new RunBefores(statement,\n                befores, target);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @After}\n     * methods on this class and superclasses before running {@code next}; all\n     * After methods are always executed: exceptions thrown by previous steps\n     * are combined, if necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfters(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(\n                After.class);\n        return afters.isEmpty() ? statement : new RunAfters(statement, afters,\n                target);\n    }\n\n    private Statement withRules(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<TestRule> testRules = getTestRules(target);\n        Statement result = statement;\n        result = withMethodRules(method, testRules, target, result);\n        result = withTestRules(method, testRules, result);\n\n        return result;\n    }\n\n    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,\n            Object target, Statement result) {\n        for (org.junit.rules.MethodRule each : getMethodRules(target)) {\n            if (!testRules.contains(each)) {\n                result = each.apply(result, method, target);\n            }\n        }\n        return result;\n    }\n\n    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n        return rules(target);\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of MethodRules that should be applied when executing this\n     *         test\n     */\n    protected List<MethodRule> rules(Object target) {\n        List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, \n                Rule.class, MethodRule.class);\n\n        rules.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, MethodRule.class));\n\n        return rules;\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all non-static fields\n     * annotated with {@link Rule}.\n     *\n     * @param statement The base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,\n            Statement statement) {\n        return testRules.isEmpty() ? statement :\n                new RunRules(statement, testRules, describeChild(method));\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of TestRules that should be applied when executing this\n     *         test\n     */\n    protected List<TestRule> getTestRules(Object target) {\n        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,\n                Rule.class, TestRule.class);\n\n        result.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, TestRule.class));\n\n        return result;\n    }\n\n    private Class<? extends Throwable> getExpectedException(Test annotation) {\n        if (annotation == null || annotation.expected() == None.class) {\n            return null;\n        } else {\n            return annotation.expected();\n        }\n    }\n\n    private boolean expectsException(Test annotation) {\n        return getExpectedException(annotation) != null;\n    }\n\n    private long getTimeout(Test annotation) {\n        if (annotation == null) {\n            return 0;\n        }\n        return annotation.timeout();\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_VALIDATOR;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.MethodRule;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * <p>\n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n *\n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n *\n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n * <p>\n * In turn, in 2009 we introduced {@link Rule}s.  In many cases where extending\n * BlockJUnit4ClassRunner was necessary to add new behavior, {@link Rule}s can\n * be used, which makes the extension more reusable and composable.\n *\n * @since 4.5\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n\n    private final ConcurrentMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();\n\n    /**\n     * Creates a BlockJUnit4ClassRunner to run {@code testClass}\n     *\n     * @throws InitializationError if the test class is malformed.\n     */\n    public BlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {\n        super(testClass);\n    }\n\n    //\n    // Implementation of ParentRunner\n    //\n\n    @Override\n    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement;\n            try {\n                statement = methodBlock(method);\n            }\n            catch (Throwable ex) {\n                statement = new Fail(ex);\n            }\n            runLeaf(statement, description, notifier);\n        }\n    }\n\n    /**\n     * Evaluates whether {@link FrameworkMethod}s are ignored based on the\n     * {@link Ignore} annotation.\n     */\n    @Override\n    protected boolean isIgnored(FrameworkMethod child) {\n        return child.getAnnotation(Ignore.class) != null;\n    }\n\n    @Override\n    protected Description describeChild(FrameworkMethod method) {\n        Description description = methodDescriptions.get(method);\n\n        if (description == null) {\n            description = Description.createTestDescription(getTestClass().getJavaClass(),\n                    testName(method), method.getAnnotations());\n            methodDescriptions.putIfAbsent(method, description);\n        }\n\n        return description;\n    }\n\n    @Override\n    protected List<FrameworkMethod> getChildren() {\n        return computeTestMethods();\n    }\n\n    //\n    // Override in subclasses\n    //\n\n    /**\n     * Returns the methods that run tests. Default implementation returns all\n     * methods annotated with {@code @Test} on this class and superclasses that\n     * are not overridden.\n     */\n    protected List<FrameworkMethod> computeTestMethods() {\n        return getTestClass().getAnnotatedMethods(Test.class);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n\n        validateNoNonStaticInnerClass(errors);\n        validateConstructor(errors);\n        validateInstanceMethods(errors);\n        validateFields(errors);\n        validateMethods(errors);\n    }\n\n    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n        if (getTestClass().isANonStaticInnerClass()) {\n            String gripe = \"The inner class \" + getTestClass().getName()\n                    + \" is not static.\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor,\n     * or if the constructor takes parameters. Override if a subclass requires\n     * different validation rules.\n     */\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor\n     * (do not override)\n     */\n    protected void validateOnlyOneConstructor(List<Throwable> errors) {\n        if (!hasOneConstructor()) {\n            String gripe = \"Test class should have exactly one public constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class's single constructor takes\n     * parameters (do not override)\n     */\n    protected void validateZeroArgConstructor(List<Throwable> errors) {\n        if (!getTestClass().isANonStaticInnerClass()\n                && hasOneConstructor()\n                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n            String gripe = \"Test class should have exactly one public zero-argument constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    private boolean hasOneConstructor() {\n        return getTestClass().getJavaClass().getConstructors().length == 1;\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test},\n     * {@code @Before}, or {@code @After} that is not a public, void instance\n     * method with no arguments.\n     * @deprecated\n     */\n    @Deprecated\n    protected void validateInstanceMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(After.class, false, errors);\n        validatePublicVoidNoArgMethods(Before.class, false, errors);\n        validateTestMethods(errors);\n\n        if (computeTestMethods().isEmpty()) {\n            errors.add(new Exception(\"No runnable methods\"));\n        }\n    }\n\n    protected void validateFields(List<Throwable> errors) {\n        RULE_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    private void validateMethods(List<Throwable> errors) {\n        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test}that\n     * is not a public, void instance method with no arguments.\n     */\n    protected void validateTestMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(Test.class, false, errors);\n    }\n\n    /**\n     * Returns a new fixture for running a test. Default implementation executes\n     * the test class's no-argument constructor (validation should have ensured\n     * one exists).\n     */\n    protected Object createTest() throws Exception {\n        return getTestClass().getOnlyConstructor().newInstance();\n    }\n\n    /**\n     * Returns a new fixture to run a particular test {@code method} against.\n     * Default implementation executes the no-argument {@link #createTest()} method.\n     *\n     * @since 4.13\n     */\n    protected Object createTest(FrameworkMethod method) throws Exception {\n        return createTest();\n    }\n\n    /**\n     * Returns the name that describes {@code method} for {@link Description}s.\n     * Default implementation is the method's name\n     */\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n\n    /**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * expecting} attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * <\/ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest(method);\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }\n\n    //\n    // Statement builders\n    //\n\n    /**\n     * Returns a {@link Statement} that invokes {@code method} on {@code test}\n     */\n    protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code expecting} attribute, return normally only if {@code next}\n     * throws an exception of the correct type, and throw an exception\n     * otherwise.\n     */\n    protected Statement possiblyExpectingExceptions(FrameworkMethod method,\n            Object test, Statement next) {\n        Test annotation = method.getAnnotation(Test.class);\n        return expectsException(annotation) ? new ExpectException(next,\n                getExpectedException(annotation)) : next;\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code timeout} attribute, throw an exception if {@code next}\n     * takes more than the specified number of milliseconds.\n     * @deprecated\n     */\n    @Deprecated\n    protected Statement withPotentialTimeout(FrameworkMethod method,\n            Object test, Statement next) {\n        long timeout = getTimeout(method.getAnnotation(Test.class));\n        if (timeout <= 0) {\n            return next;\n        }\n        return FailOnTimeout.builder()\n               .withTimeout(timeout, TimeUnit.MILLISECONDS)\n               .build(next);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @Before}\n     * methods on this class and superclasses before running {@code next}; if\n     * any throws an Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBefores(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(\n                Before.class);\n        return befores.isEmpty() ? statement : new RunBefores(statement,\n                befores, target);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @After}\n     * methods on this class and superclasses before running {@code next}; all\n     * After methods are always executed: exceptions thrown by previous steps\n     * are combined, if necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfters(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(\n                After.class);\n        return afters.isEmpty() ? statement : new RunAfters(statement, afters,\n                target);\n    }\n\n    private Statement withRules(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<TestRule> testRules = getTestRules(target);\n        Statement result = statement;\n        result = withMethodRules(method, testRules, target, result);\n        result = withTestRules(method, testRules, result);\n\n        return result;\n    }\n\n    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,\n            Object target, Statement result) {\n        Statement withMethodRules = result;\n        for (org.junit.rules.MethodRule each : getMethodRules(target)) {\n            if (!(each instanceof TestRule && testRules.contains(each))) {\n                withMethodRules = each.apply(withMethodRules, method, target);\n            }\n        }\n        return withMethodRules;\n    }\n\n    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n        return rules(target);\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of MethodRules that should be applied when executing this\n     *         test\n     */\n    protected List<MethodRule> rules(Object target) {\n        List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, \n                Rule.class, MethodRule.class);\n\n        rules.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, MethodRule.class));\n\n        return rules;\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all non-static fields\n     * annotated with {@link Rule}.\n     *\n     * @param statement The base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,\n            Statement statement) {\n        return testRules.isEmpty() ? statement :\n                new RunRules(statement, testRules, describeChild(method));\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of TestRules that should be applied when executing this\n     *         test\n     */\n    protected List<TestRule> getTestRules(Object target) {\n        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,\n                Rule.class, TestRule.class);\n\n        result.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, TestRule.class));\n\n        return result;\n    }\n\n    private Class<? extends Throwable> getExpectedException(Test annotation) {\n        if (annotation == null || annotation.expected() == None.class) {\n            return null;\n        } else {\n            return annotation.expected();\n        }\n    }\n\n    private boolean expectsException(Test annotation) {\n        return getExpectedException(annotation) != null;\n    }\n\n    private long getTimeout(Test annotation) {\n        if (annotation == null) {\n            return 0;\n        }\n        return annotation.timeout();\n    }\n}\n","lineNo":385}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_VALIDATOR;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.MethodRule;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * <p>\n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n *\n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n *\n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n * <p>\n * In turn, in 2009 we introduced {@link Rule}s.  In many cases where extending\n * BlockJUnit4ClassRunner was necessary to add new behavior, {@link Rule}s can\n * be used, which makes the extension more reusable and composable.\n *\n * @since 4.5\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n    private final ConcurrentHashMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();\n    /**\n     * Creates a BlockJUnit4ClassRunner to run {@code testClass}\n     *\n     * @throws InitializationError if the test class is malformed.\n     */\n    public BlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {\n        super(testClass);\n    }\n\n    //\n    // Implementation of ParentRunner\n    //\n\n    @Override\n    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            runLeaf(methodBlock(method), description, notifier);\n        }\n    }\n    \n    /**\n     * Evaluates whether {@link FrameworkMethod}s are ignored based on the\n     * {@link Ignore} annotation.\n     */\n    @Override\n    protected boolean isIgnored(FrameworkMethod child) {\n        return child.getAnnotation(Ignore.class) != null;\n    }\n\n    @Override\n    protected Description describeChild(FrameworkMethod method) {\n        Description description = methodDescriptions.get(method);\n\n        if (description == null) {\n            description = Description.createTestDescription(getTestClass().getJavaClass(),\n                    testName(method), method.getAnnotations());\n            methodDescriptions.putIfAbsent(method, description);\n        }\n\n        return description;\n    }\n\n    @Override\n    protected List<FrameworkMethod> getChildren() {\n        return computeTestMethods();\n    }\n\n    //\n    // Override in subclasses\n    //\n\n    /**\n     * Returns the methods that run tests. Default implementation returns all\n     * methods annotated with {@code @Test} on this class and superclasses that\n     * are not overridden.\n     */\n    protected List<FrameworkMethod> computeTestMethods() {\n        return getTestClass().getAnnotatedMethods(Test.class);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n\n        validateNoNonStaticInnerClass(errors);\n        validateConstructor(errors);\n        validateInstanceMethods(errors);\n        validateFields(errors);\n        validateMethods(errors);\n    }\n\n    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n        if (getTestClass().isANonStaticInnerClass()) {\n            String gripe = \"The inner class \" + getTestClass().getName()\n                    + \" is not static.\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor,\n     * or if the constructor takes parameters. Override if a subclass requires\n     * different validation rules.\n     */\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor\n     * (do not override)\n     */\n    protected void validateOnlyOneConstructor(List<Throwable> errors) {\n        if (!hasOneConstructor()) {\n            String gripe = \"Test class should have exactly one public constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class's single constructor takes\n     * parameters (do not override)\n     */\n    protected void validateZeroArgConstructor(List<Throwable> errors) {\n        if (!getTestClass().isANonStaticInnerClass()\n                && hasOneConstructor()\n                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n            String gripe = \"Test class should have exactly one public zero-argument constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    private boolean hasOneConstructor() {\n        return getTestClass().getJavaClass().getConstructors().length == 1;\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test},\n     * {@code @Before}, or {@code @After} that is not a public, void instance\n     * method with no arguments.\n     */\n    @Deprecated\n    protected void validateInstanceMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(After.class, false, errors);\n        validatePublicVoidNoArgMethods(Before.class, false, errors);\n        validateTestMethods(errors);\n\n        if (computeTestMethods().size() == 0) {\n            errors.add(new Exception(\"No runnable methods\"));\n        }\n    }\n\n    protected void validateFields(List<Throwable> errors) {\n        RULE_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    private void validateMethods(List<Throwable> errors) {\n        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test}that\n     * is not a public, void instance method with no arguments.\n     */\n    protected void validateTestMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(Test.class, false, errors);\n    }\n\n    /**\n     * Returns a new fixture for running a test. Default implementation executes\n     * the test class's no-argument constructor (validation should have ensured\n     * one exists).\n     */\n    protected Object createTest() throws Exception {\n        return getTestClass().getOnlyConstructor().newInstance();\n    }\n\n    /**\n     * Returns a new fixture to run a particular test {@code method} against.\n     * Default implementation executes the no-argument {@link #createTest()} method.\n     *\n     * @since 4.13\n     */\n    protected Object createTest(FrameworkMethod method) throws Exception {\n        return createTest();\n    }\n\n    /**\n     * Returns the name that describes {@code method} for {@link Description}s.\n     * Default implementation is the method's name\n     */\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n\n    /**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * expecting} attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * <\/ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest(method);\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }\n\n    //\n    // Statement builders\n    //\n\n    /**\n     * Returns a {@link Statement} that invokes {@code method} on {@code test}\n     */\n    protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code expecting} attribute, return normally only if {@code next}\n     * throws an exception of the correct type, and throw an exception\n     * otherwise.\n     */\n    protected Statement possiblyExpectingExceptions(FrameworkMethod method,\n            Object test, Statement next) {\n        Test annotation = method.getAnnotation(Test.class);\n        return expectsException(annotation) ? new ExpectException(next,\n                getExpectedException(annotation)) : next;\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code timeout} attribute, throw an exception if {@code next}\n     * takes more than the specified number of milliseconds.\n     */\n    @Deprecated\n    protected Statement withPotentialTimeout(FrameworkMethod method,\n            Object test, Statement next) {\n        long timeout = getTimeout(method.getAnnotation(Test.class));\n        if (timeout <= 0) {\n            return next;\n        }\n        return FailOnTimeout.builder()\n               .withTimeout(timeout, TimeUnit.MILLISECONDS)\n               .build(next);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @Before}\n     * methods on this class and superclasses before running {@code next}; if\n     * any throws an Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBefores(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(\n                Before.class);\n        return befores.isEmpty() ? statement : new RunBefores(statement,\n                befores, target);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @After}\n     * methods on this class and superclasses before running {@code next}; all\n     * After methods are always executed: exceptions thrown by previous steps\n     * are combined, if necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfters(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(\n                After.class);\n        return afters.isEmpty() ? statement : new RunAfters(statement, afters,\n                target);\n    }\n\n    private Statement withRules(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<TestRule> testRules = getTestRules(target);\n        Statement result = statement;\n        result = withMethodRules(method, testRules, target, result);\n        result = withTestRules(method, testRules, result);\n\n        return result;\n    }\n\n    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,\n            Object target, Statement result) {\n        for (org.junit.rules.MethodRule each : getMethodRules(target)) {\n            if (!testRules.contains(each)) {\n                result = each.apply(result, method, target);\n            }\n        }\n        return result;\n    }\n\n    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n        return rules(target);\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of MethodRules that should be applied when executing this\n     *         test\n     */\n    protected List<MethodRule> rules(Object target) {\n        List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, \n                Rule.class, MethodRule.class);\n        \n        rules.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, MethodRule.class));\n        \n        return rules;\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all non-static fields\n     * annotated with {@link Rule}.\n     *\n     * @param statement The base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,\n            Statement statement) {\n        return testRules.isEmpty() ? statement :\n                new RunRules(statement, testRules, describeChild(method));\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of TestRules that should be applied when executing this\n     *         test\n     */\n    protected List<TestRule> getTestRules(Object target) {\n        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,\n                Rule.class, TestRule.class);\n\n        result.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, TestRule.class));\n\n        return result;\n    }\n\n    private Class<? extends Throwable> getExpectedException(Test annotation) {\n        if (annotation == null || annotation.expected() == None.class) {\n            return null;\n        } else {\n            return annotation.expected();\n        }\n    }\n\n    private boolean expectsException(Test annotation) {\n        return getExpectedException(annotation) != null;\n    }\n\n    private long getTimeout(Test annotation) {\n        if (annotation == null) {\n            return 0;\n        }\n        return annotation.timeout();\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleMemberValidator.RULE_VALIDATOR;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.MethodRule;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * <p>\n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n *\n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n *\n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n * <p>\n * In turn, in 2009 we introduced {@link Rule}s.  In many cases where extending\n * BlockJUnit4ClassRunner was necessary to add new behavior, {@link Rule}s can\n * be used, which makes the extension more reusable and composable.\n *\n * @since 4.5\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n\n    private final ConcurrentHashMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();\n\n    /**\n     * Creates a BlockJUnit4ClassRunner to run {@code testClass}\n     *\n     * @throws InitializationError if the test class is malformed.\n     */\n    public BlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {\n        super(testClass);\n    }\n\n    //\n    // Implementation of ParentRunner\n    //\n\n    @Override\n    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement;\n            try {\n                statement = methodBlock(method);\n            }\n            catch (Throwable ex) {\n                statement = new Fail(ex);\n            }\n            runLeaf(statement, description, notifier);\n        }\n    }\n\n    /**\n     * Evaluates whether {@link FrameworkMethod}s are ignored based on the\n     * {@link Ignore} annotation.\n     */\n    @Override\n    protected boolean isIgnored(FrameworkMethod child) {\n        return child.getAnnotation(Ignore.class) != null;\n    }\n\n    @Override\n    protected Description describeChild(FrameworkMethod method) {\n        Description description = methodDescriptions.get(method);\n\n        if (description == null) {\n            description = Description.createTestDescription(getTestClass().getJavaClass(),\n                    testName(method), method.getAnnotations());\n            methodDescriptions.putIfAbsent(method, description);\n        }\n\n        return description;\n    }\n\n    @Override\n    protected List<FrameworkMethod> getChildren() {\n        return computeTestMethods();\n    }\n\n    //\n    // Override in subclasses\n    //\n\n    /**\n     * Returns the methods that run tests. Default implementation returns all\n     * methods annotated with {@code @Test} on this class and superclasses that\n     * are not overridden.\n     */\n    protected List<FrameworkMethod> computeTestMethods() {\n        return getTestClass().getAnnotatedMethods(Test.class);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n\n        validateNoNonStaticInnerClass(errors);\n        validateConstructor(errors);\n        validateInstanceMethods(errors);\n        validateFields(errors);\n        validateMethods(errors);\n    }\n\n    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n        if (getTestClass().isANonStaticInnerClass()) {\n            String gripe = \"The inner class \" + getTestClass().getName()\n                    + \" is not static.\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor,\n     * or if the constructor takes parameters. Override if a subclass requires\n     * different validation rules.\n     */\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if the test class has more than one constructor\n     * (do not override)\n     */\n    protected void validateOnlyOneConstructor(List<Throwable> errors) {\n        if (!hasOneConstructor()) {\n            String gripe = \"Test class should have exactly one public constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if the test class's single constructor takes\n     * parameters (do not override)\n     */\n    protected void validateZeroArgConstructor(List<Throwable> errors) {\n        if (!getTestClass().isANonStaticInnerClass()\n                && hasOneConstructor()\n                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n            String gripe = \"Test class should have exactly one public zero-argument constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }\n\n    private boolean hasOneConstructor() {\n        return getTestClass().getJavaClass().getConstructors().length == 1;\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test},\n     * {@code @Before}, or {@code @After} that is not a public, void instance\n     * method with no arguments.\n     */\n    @Deprecated\n    protected void validateInstanceMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(After.class, false, errors);\n        validatePublicVoidNoArgMethods(Before.class, false, errors);\n        validateTestMethods(errors);\n\n        if (computeTestMethods().size() == 0) {\n            errors.add(new Exception(\"No runnable methods\"));\n        }\n    }\n\n    protected void validateFields(List<Throwable> errors) {\n        RULE_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    private void validateMethods(List<Throwable> errors) {\n        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Adds to {@code errors} for each method annotated with {@code @Test}that\n     * is not a public, void instance method with no arguments.\n     */\n    protected void validateTestMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(Test.class, false, errors);\n    }\n\n    /**\n     * Returns a new fixture for running a test. Default implementation executes\n     * the test class's no-argument constructor (validation should have ensured\n     * one exists).\n     */\n    protected Object createTest() throws Exception {\n        return getTestClass().getOnlyConstructor().newInstance();\n    }\n\n    /**\n     * Returns a new fixture to run a particular test {@code method} against.\n     * Default implementation executes the no-argument {@link #createTest()} method.\n     *\n     * @since 4.13\n     */\n    protected Object createTest(FrameworkMethod method) throws Exception {\n        return createTest();\n    }\n\n    /**\n     * Returns the name that describes {@code method} for {@link Description}s.\n     * Default implementation is the method's name\n     */\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n\n    /**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * expecting} attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * <\/ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest(method);\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }\n\n    //\n    // Statement builders\n    //\n\n    /**\n     * Returns a {@link Statement} that invokes {@code method} on {@code test}\n     */\n    protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code expecting} attribute, return normally only if {@code next}\n     * throws an exception of the correct type, and throw an exception\n     * otherwise.\n     */\n    protected Statement possiblyExpectingExceptions(FrameworkMethod method,\n            Object test, Statement next) {\n        Test annotation = method.getAnnotation(Test.class);\n        return expectsException(annotation) ? new ExpectException(next,\n                getExpectedException(annotation)) : next;\n    }\n\n    /**\n     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n     * has the {@code timeout} attribute, throw an exception if {@code next}\n     * takes more than the specified number of milliseconds.\n     */\n    @Deprecated\n    protected Statement withPotentialTimeout(FrameworkMethod method,\n            Object test, Statement next) {\n        long timeout = getTimeout(method.getAnnotation(Test.class));\n        if (timeout <= 0) {\n            return next;\n        }\n        return FailOnTimeout.builder()\n               .withTimeout(timeout, TimeUnit.MILLISECONDS)\n               .build(next);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @Before}\n     * methods on this class and superclasses before running {@code next}; if\n     * any throws an Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBefores(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(\n                Before.class);\n        return befores.isEmpty() ? statement : new RunBefores(statement,\n                befores, target);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @After}\n     * methods on this class and superclasses before running {@code next}; all\n     * After methods are always executed: exceptions thrown by previous steps\n     * are combined, if necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfters(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(\n                After.class);\n        return afters.isEmpty() ? statement : new RunAfters(statement, afters,\n                target);\n    }\n\n    private Statement withRules(FrameworkMethod method, Object target,\n            Statement statement) {\n        List<TestRule> testRules = getTestRules(target);\n        Statement result = statement;\n        result = withMethodRules(method, testRules, target, result);\n        result = withTestRules(method, testRules, result);\n\n        return result;\n    }\n\n    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,\n            Object target, Statement result) {\n        for (org.junit.rules.MethodRule each : getMethodRules(target)) {\n            if (!testRules.contains(each)) {\n                result = each.apply(result, method, target);\n            }\n        }\n        return result;\n    }\n\n    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n        return rules(target);\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of MethodRules that should be applied when executing this\n     *         test\n     */\n    protected List<MethodRule> rules(Object target) {\n        List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, \n                Rule.class, MethodRule.class);\n\n        rules.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, MethodRule.class));\n\n        return rules;\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all non-static fields\n     * annotated with {@link Rule}.\n     *\n     * @param statement The base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,\n            Statement statement) {\n        return testRules.isEmpty() ? statement :\n                new RunRules(statement, testRules, describeChild(method));\n    }\n\n    /**\n     * @param target the test case instance\n     * @return a list of TestRules that should be applied when executing this\n     *         test\n     */\n    protected List<TestRule> getTestRules(Object target) {\n        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,\n                Rule.class, TestRule.class);\n\n        result.addAll(getTestClass().getAnnotatedFieldValues(target,\n                Rule.class, TestRule.class));\n\n        return result;\n    }\n\n    private Class<? extends Throwable> getExpectedException(Test annotation) {\n        if (annotation == null || annotation.expected() == None.class) {\n            return null;\n        } else {\n            return annotation.expected();\n        }\n    }\n\n    private boolean expectsException(Test annotation) {\n        return getExpectedException(annotation) != null;\n    }\n\n    private long getTimeout(Test annotation) {\n        if (annotation == null) {\n            return 0;\n        }\n        return annotation.timeout();\n    }\n}\n","lineNo":80}
{"Smelly Sample":"package org.junit.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\nimport org.junit.Assert;\n\n/**\n * Defines criteria for finding two items \"equal enough\". Concrete subclasses\n * may demand exact equality, or, for example, equality within a given delta.\n */\npublic abstract class ComparisonCriteria {\n    /**\n     * Asserts that two arrays are equal, according to the criteria defined by\n     * the concrete subclass. If they are not, an {@link AssertionError} is\n     * thrown with the given message. If <code>expecteds<\/code> and\n     * <code>actuals<\/code> are <code>null<\/code>, they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (\n     * <code>null<\/code> okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public void arrayEquals(String message, Object expecteds, Object actuals)\n            throws ArrayComparisonFailure {\n        if (expecteds == actuals\n            || Arrays.deepEquals(new Object[] {expecteds}, new Object[] {actuals})) {\n            // The reflection-based loop below is potentially very slow, especially for primitive\n            // arrays. The deepEquals check allows us to circumvent it in the usual case where\n            // the arrays are exactly equal.\n            return;\n        }\n        String header = message == null ? \"\" : message + \": \";\n\n        int expectedsLength = assertArraysAreSameLength(expecteds,\n                actuals, header);\n\n        for (int i = 0; i < expectedsLength; i++) {\n            Object expected = Array.get(expecteds, i);\n            Object actual = Array.get(actuals, i);\n\n            if (isArray(expected) && isArray(actual)) {\n                try {\n                    arrayEquals(message, expected, actual);\n                } catch (ArrayComparisonFailure e) {\n                    e.addDimension(i);\n                    throw e;\n                }\n            } else {\n                try {\n                    assertElementsEqual(expected, actual);\n                } catch (AssertionError e) {\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            }\n        }\n    }\n\n    private boolean isArray(Object expected) {\n        return expected != null && expected.getClass().isArray();\n    }\n\n    private int assertArraysAreSameLength(Object expecteds,\n            Object actuals, String header) {\n        if (expecteds == null) {\n            Assert.fail(header + \"expected array was null\");\n        }\n        if (actuals == null) {\n            Assert.fail(header + \"actual array was null\");\n        }\n        int actualsLength = Array.getLength(actuals);\n        int expectedsLength = Array.getLength(expecteds);\n        if (actualsLength != expectedsLength) {\n            Assert.fail(header + \"array lengths differed, expected.length=\"\n                    + expectedsLength + \" actual.length=\" + actualsLength);\n        }\n        return expectedsLength;\n    }\n\n    protected abstract void assertElementsEqual(Object expected, Object actual);\n}\n","Method after Refactoring":"package org.junit.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\nimport org.junit.Assert;\n\n/**\n * Defines criteria for finding two items \"equal enough\". Concrete subclasses\n * may demand exact equality, or, for example, equality within a given delta.\n */\npublic abstract class ComparisonCriteria {\n    /**\n     * Asserts that two arrays are equal, according to the criteria defined by\n     * the concrete subclass. If they are not, an {@link AssertionError} is\n     * thrown with the given message. If <code>expecteds<\/code> and\n     * <code>actuals<\/code> are <code>null<\/code>, they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (\n     * <code>null<\/code> okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public void arrayEquals(String message, Object expecteds, Object actuals)\n            throws ArrayComparisonFailure {\n        arrayEquals(message, expecteds, actuals, true);\n    }\n\n    private void arrayEquals(String message, Object expecteds, Object actuals, boolean outer)\n            throws ArrayComparisonFailure {\n        if (expecteds == actuals\n            || Arrays.deepEquals(new Object[] {expecteds}, new Object[] {actuals})) {\n            // The reflection-based loop below is potentially very slow, especially for primitive\n            // arrays. The deepEquals check allows us to circumvent it in the usual case where\n            // the arrays are exactly equal.\n            return;\n        }\n        String header = message == null ? \"\" : message + \": \";\n\n        // Only include the user-provided message in the outer exception.\n        String exceptionMessage = outer ? header : \"\";\n        int expectedsLength = assertArraysAreSameLength(expecteds, actuals, exceptionMessage);\n\n        for (int i = 0; i < expectedsLength; i++) {\n            Object expected = Array.get(expecteds, i);\n            Object actual = Array.get(actuals, i);\n\n            if (isArray(expected) && isArray(actual)) {\n                try {\n                    arrayEquals(message, expected, actual, false);\n                } catch (ArrayComparisonFailure e) {\n                    e.addDimension(i);\n                    throw e;\n                } catch (AssertionError e) {\n                    // Array lengths differed.\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            } else {\n                try {\n                    assertElementsEqual(expected, actual);\n                } catch (AssertionError e) {\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            }\n        }\n    }\n\n    private boolean isArray(Object expected) {\n        return expected != null && expected.getClass().isArray();\n    }\n\n    private int assertArraysAreSameLength(Object expecteds,\n            Object actuals, String header) {\n        if (expecteds == null) {\n            Assert.fail(header + \"expected array was null\");\n        }\n        if (actuals == null) {\n            Assert.fail(header + \"actual array was null\");\n        }\n        int actualsLength = Array.getLength(actuals);\n        int expectedsLength = Array.getLength(expecteds);\n        if (actualsLength != expectedsLength) {\n            Assert.fail(header + \"array lengths differed, expected.length=\"\n                    + expectedsLength + \" actual.length=\" + actualsLength);\n        }\n        return expectedsLength;\n    }\n\n    protected abstract void assertElementsEqual(Object expected, Object actual);\n}\n","lineNo":43}
{"Smelly Sample":"package org.junit.internal.runners.statements;\n\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestTimedOutException;\n\npublic class FailOnTimeout extends Statement {\n    private final Statement originalStatement;\n    private final TimeUnit timeUnit;\n    private final long timeout;\n    private final boolean lookForStuckThread;\n    private volatile ThreadGroup threadGroup = null;\n\n    public FailOnTimeout(Statement originalStatement, long millis) {\n        this(originalStatement, millis, TimeUnit.MILLISECONDS);\n    }\n\n    public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        this(originalStatement, timeout, unit, false);\n    }\n\n    public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit, boolean lookForStuckThread) {\n        this.originalStatement = originalStatement;\n        this.timeout = timeout;\n        timeUnit = unit;\n        this.lookForStuckThread = lookForStuckThread;\n    }\n\n    @Override\n    public void evaluate() throws Throwable {\n        FutureTask<Throwable> task = new FutureTask<Throwable>(new CallableStatement());\n        threadGroup = new ThreadGroup(\"FailOnTimeoutGroup\");\n        Thread thread = new Thread(threadGroup, task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n            throw throwable;\n        }\n    }\n\n    /**\n     * Wait for the test task, returning the exception thrown by the test if the\n     * test failed, an exception indicating a timeout if the test timed out, or\n     * {@code null} if the test passed.\n     */\n    private Throwable getResult(FutureTask<Throwable> task, Thread thread) {\n        try {\n            if (timeout > 0) {\n                return task.get(timeout, timeUnit);\n            } else {\n                return task.get();\n            }\n        } catch (InterruptedException e) {\n            return e; // caller will re-throw; no need to call Thread.interrupt()\n        } catch (ExecutionException e) {\n            // test failed; have caller re-throw the exception thrown by the test\n            return e.getCause();\n        } catch (TimeoutException e) {\n            return createTimeoutException(thread);\n        }\n    }\n\n    private Exception createTimeoutException(Thread thread) {\n        StackTraceElement[] stackTrace = thread.getStackTrace();\n        final Thread stuckThread = lookForStuckThread ? getStuckThread(thread) : null;\n        Exception currThreadException = new TestTimedOutException(timeout, timeUnit);\n        if (stackTrace != null) {\n            currThreadException.setStackTrace(stackTrace);\n            thread.interrupt();\n        }\n        if (stuckThread != null) {\n            Exception stuckThreadException = \n                new Exception (\"Appears to be stuck in thread \" +\n                               stuckThread.getName());\n            stuckThreadException.setStackTrace(getStackTrace(stuckThread));\n            return new MultipleFailureException    \n                (Arrays.<Throwable>asList(currThreadException, stuckThreadException));\n        } else {\n            return currThreadException;\n        }\n    }\n\n    /**\n     * Retrieves the stack trace for a given thread.\n     * @param thread The thread whose stack is to be retrieved.\n     * @return The stack trace; returns a zero-length array if the thread has \n     * terminated or the stack cannot be retrieved for some other reason.\n     */\n    private StackTraceElement[] getStackTrace(Thread thread) {\n        try {\n            return thread.getStackTrace();\n        } catch (SecurityException e) {\n            return new StackTraceElement[0];\n        }\n    }\n\n    /**\n     * Determines whether the test appears to be stuck in some thread other than\n     * the \"main thread\" (the one created to run the test).  This feature is experimental.\n     * Behavior may change after the 4.12 release in response to feedback.\n     * @param mainThread The main thread created by {@code evaluate()}\n     * @return The thread which appears to be causing the problem, if different from\n     * {@code mainThread}, or {@code null} if the main thread appears to be the\n     * problem or if the thread cannot be determined.  The return value is never equal \n     * to {@code mainThread}.\n     */\n    private Thread getStuckThread (Thread mainThread) {\n        if (threadGroup == null){\n            return null;\n        }\n        Thread[] threadsInGroup = getThreadArray(threadGroup);\n        if (threadsInGroup == null){\n            return null;\n        }\n\n        // Now that we have all the threads in the test's thread group: Assume that\n        // any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n        // If just one, we return that (unless it equals threadMain).  If there's more\n        // than one, pick the one that's using the most CPU time, if this feature is\n        // supported.\n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }\n\n    /**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) \n                return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return copyThreads(threads, enumCount);\n    }\n\n    /**\n     * Returns an array of the first {@code count} Threads in {@code threads}. \n     * (Use instead of Arrays.copyOf to maintain compatibility with Java 1.5.)\n     * @param threads The source array.\n     * @param count The maximum length of the result array.\n     * @return The first {@count} (at most) elements of {@code threads}.\n     */\n    private Thread[] copyThreads(Thread[] threads, int count) {\n        int length = Math.min(count, threads.length);\n        Thread[] result = new Thread[length];\n        for (int i = 0; i < length; i++)\n            result[i] = threads[i];\n        return result;\n    }\n\n    /**\n     * Returns the CPU time used by a thread, if possible.\n     * @param thr The thread to query.\n     * @return The CPU time used by {@code thr}, or 0 if it cannot be determined.\n     */\n    private long cpuTime (Thread thr) {\n        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }\n\n    private class CallableStatement implements Callable<Throwable> {\n        public Throwable call() throws Exception {\n            try {\n                originalStatement.evaluate();\n            } catch (Exception e) {\n                throw e;\n            } catch (Throwable e) {\n                return e;\n            }\n            return null;\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.internal.runners.statements;\n\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestTimedOutException;\n\npublic class FailOnTimeout extends Statement {\n    private final Statement originalStatement;\n    private final TimeUnit timeUnit;\n    private final long timeout;\n    private final boolean lookForStuckThread;\n    private volatile ThreadGroup threadGroup = null;\n\n    public FailOnTimeout(Statement originalStatement, long millis) {\n        this(originalStatement, millis, TimeUnit.MILLISECONDS);\n    }\n\n    public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        this(originalStatement, timeout, unit, false);\n    }\n\n    public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit, boolean lookForStuckThread) {\n        this.originalStatement = originalStatement;\n        this.timeout = timeout;\n        timeUnit = unit;\n        this.lookForStuckThread = lookForStuckThread;\n    }\n\n    @Override\n    public void evaluate() throws Throwable {\n        CallableStatement callable = new CallableStatement();\n        FutureTask<Throwable> task = new FutureTask<Throwable>(callable);\n        threadGroup = new ThreadGroup(\"FailOnTimeoutGroup\");\n        Thread thread = new Thread(threadGroup, task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        callable.awaitStarted();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n            throw throwable;\n        }\n    }\n\n    /**\n     * Wait for the test task, returning the exception thrown by the test if the\n     * test failed, an exception indicating a timeout if the test timed out, or\n     * {@code null} if the test passed.\n     */\n    private Throwable getResult(FutureTask<Throwable> task, Thread thread) {\n        try {\n            if (timeout > 0) {\n                return task.get(timeout, timeUnit);\n            } else {\n                return task.get();\n            }\n        } catch (InterruptedException e) {\n            return e; // caller will re-throw; no need to call Thread.interrupt()\n        } catch (ExecutionException e) {\n            // test failed; have caller re-throw the exception thrown by the test\n            return e.getCause();\n        } catch (TimeoutException e) {\n            return createTimeoutException(thread);\n        }\n    }\n\n    private Exception createTimeoutException(Thread thread) {\n        StackTraceElement[] stackTrace = thread.getStackTrace();\n        final Thread stuckThread = lookForStuckThread ? getStuckThread(thread) : null;\n        Exception currThreadException = new TestTimedOutException(timeout, timeUnit);\n        if (stackTrace != null) {\n            currThreadException.setStackTrace(stackTrace);\n            thread.interrupt();\n        }\n        if (stuckThread != null) {\n            Exception stuckThreadException = \n                new Exception (\"Appears to be stuck in thread \" +\n                               stuckThread.getName());\n            stuckThreadException.setStackTrace(getStackTrace(stuckThread));\n            return new MultipleFailureException    \n                (Arrays.<Throwable>asList(currThreadException, stuckThreadException));\n        } else {\n            return currThreadException;\n        }\n    }\n\n    /**\n     * Retrieves the stack trace for a given thread.\n     * @param thread The thread whose stack is to be retrieved.\n     * @return The stack trace; returns a zero-length array if the thread has \n     * terminated or the stack cannot be retrieved for some other reason.\n     */\n    private StackTraceElement[] getStackTrace(Thread thread) {\n        try {\n            return thread.getStackTrace();\n        } catch (SecurityException e) {\n            return new StackTraceElement[0];\n        }\n    }\n\n    /**\n     * Determines whether the test appears to be stuck in some thread other than\n     * the \"main thread\" (the one created to run the test).  This feature is experimental.\n     * Behavior may change after the 4.12 release in response to feedback.\n     * @param mainThread The main thread created by {@code evaluate()}\n     * @return The thread which appears to be causing the problem, if different from\n     * {@code mainThread}, or {@code null} if the main thread appears to be the\n     * problem or if the thread cannot be determined.  The return value is never equal \n     * to {@code mainThread}.\n     */\n    private Thread getStuckThread (Thread mainThread) {\n        if (threadGroup == null){\n            return null;\n        }\n        Thread[] threadsInGroup = getThreadArray(threadGroup);\n        if (threadsInGroup == null){\n            return null;\n        }\n\n        // Now that we have all the threads in the test's thread group: Assume that\n        // any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n        // If just one, we return that (unless it equals threadMain).  If there's more\n        // than one, pick the one that's using the most CPU time, if this feature is\n        // supported.\n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }\n\n    /**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) \n                return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return copyThreads(threads, enumCount);\n    }\n\n    /**\n     * Returns an array of the first {@code count} Threads in {@code threads}. \n     * (Use instead of Arrays.copyOf to maintain compatibility with Java 1.5.)\n     * @param threads The source array.\n     * @param count The maximum length of the result array.\n     * @return The first {@count} (at most) elements of {@code threads}.\n     */\n    private Thread[] copyThreads(Thread[] threads, int count) {\n        int length = Math.min(count, threads.length);\n        Thread[] result = new Thread[length];\n        for (int i = 0; i < length; i++)\n            result[i] = threads[i];\n        return result;\n    }\n\n    /**\n     * Returns the CPU time used by a thread, if possible.\n     * @param thr The thread to query.\n     * @return The CPU time used by {@code thr}, or 0 if it cannot be determined.\n     */\n    private long cpuTime (Thread thr) {\n        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }\n\n    private class CallableStatement implements Callable<Throwable> {\n        private final CountDownLatch startLatch = new CountDownLatch(1);\n\n        public Throwable call() throws Exception {\n            try {\n                startLatch.countDown();\n                originalStatement.evaluate();\n            } catch (Exception e) {\n                throw e;\n            } catch (Throwable e) {\n                return e;\n            }\n            return null;\n        }\n\n        public void awaitStarted() throws InterruptedException {\n            startLatch.await();\n        }\n    }\n}\n","lineNo":41}
{"Smelly Sample":"package org.junit.rules;\n\nimport org.junit.AssumptionViolatedException;\nimport org.junit.runner.Description;\nimport org.junit.runners.model.Statement;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The Stopwatch Rule notifies one of its own protected methods of the time spent by a test.\n *\n * <p>Override them to get the time in nanoseconds. For example, this class will keep logging the\n * time spent by each passed, failed, skipped, and finished test:\n *\n * <pre>\n * public static class StopwatchTest {\n *     private static final Logger logger = Logger.getLogger(&quot;&quot;);\n *\n *     private static void logInfo(Description description, String status, long nanos) {\n *         String testName = description.getMethodName();\n *         logger.info(String.format(&quot;Test %s %s, spent %d microseconds&quot;,\n *                                   testName, status, TimeUnit.NANOSECONDS.toMicros(nanos)));\n *     }\n *\n *     &#064;Rule\n *     public Stopwatch stopwatch = new Stopwatch() {\n *         &#064;Override\n *         protected void succeeded(long nanos, Description description) {\n *             logInfo(description, &quot;succeeded&quot;, nanos);\n *         }\n *\n *         &#064;Override\n *         protected void failed(long nanos, Throwable e, Description description) {\n *             logInfo(description, &quot;failed&quot;, nanos);\n *         }\n *\n *         &#064;Override\n *         protected void skipped(long nanos, AssumptionViolatedException e, Description description) {\n *             logInfo(description, &quot;skipped&quot;, nanos);\n *         }\n *\n *         &#064;Override\n *         protected void finished(long nanos, Description description) {\n *             logInfo(description, &quot;finished&quot;, nanos);\n *         }\n *     };\n *\n *     &#064;Test\n *     public void succeeds() {\n *     }\n *\n *     &#064;Test\n *     public void fails() {\n *         fail();\n *     }\n *\n *     &#064;Test\n *     public void skips() {\n *         assumeTrue(false);\n *     }\n * }\n * <\/pre>\n *\n * An example to assert runtime:\n * <pre>\n * &#064;Test\n * public void performanceTest() throws InterruptedException {\n *     long delta = 30;\n *     Thread.sleep(300L);\n *     assertEquals(300d, stopwatch.runtime(MILLISECONDS), delta);\n *     Thread.sleep(500L);\n *     assertEquals(800d, stopwatch.runtime(MILLISECONDS), delta);\n * }\n * <\/pre>\n *\n * @author tibor17\n * @since 4.12\n */\npublic abstract class Stopwatch implements TestRule {\n    private final Clock clock;\n    private volatile long startNanos;\n    private volatile long endNanos;\n\n    public Stopwatch() {\n        this(new Clock());\n    }\n\n    Stopwatch(Clock clock) {\n        this.clock = clock;\n    }\n\n    /**\n     * Gets the runtime for the test.\n     *\n     * @param unit time unit for returned runtime\n     * @return runtime measured during the test\n     */\n    public long runtime(TimeUnit unit) {\n        return unit.convert(clock.nanoTime() - startNanos, TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Invoked when a test succeeds\n     */\n    protected void succeeded(long nanos, Description description) {\n    }\n\n    /**\n     * Invoked when a test fails\n     */\n    protected void failed(long nanos, Throwable e, Description description) {\n    }\n\n    /**\n     * Invoked when a test is skipped due to a failed assumption.\n     */\n    protected void skipped(long nanos, AssumptionViolatedException e, Description description) {\n    }\n\n    /**\n     * Invoked when a test method finishes (whether passing or failing)\n     */\n    protected void finished(long nanos, Description description) {\n    }\n\n    private long getNanos() {\n        return endNanos - startNanos;\n    }\n\n    private void starting() {\n        startNanos = clock.nanoTime();\n        endNanos = 0;\n    }\n\n    private void stopping() {\n        endNanos = clock.nanoTime();\n    }\n\n    public final Statement apply(Statement base, Description description) {\n        return new InternalWatcher().apply(base, description);\n    }\n\n    private class InternalWatcher extends TestWatcher {\n\n        @Override protected void starting(Description description) {\n            Stopwatch.this.starting();\n        }\n\n        @Override protected void finished(Description description) {\n            Stopwatch.this.finished(getNanos(), description);\n        }\n\n        @Override protected void succeeded(Description description) {\n            Stopwatch.this.stopping();\n            Stopwatch.this.succeeded(getNanos(), description);\n        }\n\n        @Override protected void failed(Throwable e, Description description) {\n            Stopwatch.this.stopping();\n            Stopwatch.this.failed(getNanos(), e, description);\n        }\n\n        @Override protected void skipped(AssumptionViolatedException e, Description description) {\n            Stopwatch.this.stopping();\n            Stopwatch.this.skipped(getNanos(), e, description);\n        }\n    }\n\n    static class Clock {\n\n        public long nanoTime() {\n            return System.nanoTime();\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.rules;\n\nimport org.junit.AssumptionViolatedException;\nimport org.junit.runner.Description;\nimport org.junit.runners.model.Statement;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The Stopwatch Rule notifies one of its own protected methods of the time spent by a test.\n *\n * <p>Override them to get the time in nanoseconds. For example, this class will keep logging the\n * time spent by each passed, failed, skipped, and finished test:\n *\n * <pre>\n * public static class StopwatchTest {\n *     private static final Logger logger = Logger.getLogger(&quot;&quot;);\n *\n *     private static void logInfo(Description description, String status, long nanos) {\n *         String testName = description.getMethodName();\n *         logger.info(String.format(&quot;Test %s %s, spent %d microseconds&quot;,\n *                                   testName, status, TimeUnit.NANOSECONDS.toMicros(nanos)));\n *     }\n *\n *     &#064;Rule\n *     public Stopwatch stopwatch = new Stopwatch() {\n *         &#064;Override\n *         protected void succeeded(long nanos, Description description) {\n *             logInfo(description, &quot;succeeded&quot;, nanos);\n *         }\n *\n *         &#064;Override\n *         protected void failed(long nanos, Throwable e, Description description) {\n *             logInfo(description, &quot;failed&quot;, nanos);\n *         }\n *\n *         &#064;Override\n *         protected void skipped(long nanos, AssumptionViolatedException e, Description description) {\n *             logInfo(description, &quot;skipped&quot;, nanos);\n *         }\n *\n *         &#064;Override\n *         protected void finished(long nanos, Description description) {\n *             logInfo(description, &quot;finished&quot;, nanos);\n *         }\n *     };\n *\n *     &#064;Test\n *     public void succeeds() {\n *     }\n *\n *     &#064;Test\n *     public void fails() {\n *         fail();\n *     }\n *\n *     &#064;Test\n *     public void skips() {\n *         assumeTrue(false);\n *     }\n * }\n * <\/pre>\n *\n * An example to assert runtime:\n * <pre>\n * &#064;Test\n * public void performanceTest() throws InterruptedException {\n *     long delta = 30;\n *     Thread.sleep(300L);\n *     assertEquals(300d, stopwatch.runtime(MILLISECONDS), delta);\n *     Thread.sleep(500L);\n *     assertEquals(800d, stopwatch.runtime(MILLISECONDS), delta);\n * }\n * <\/pre>\n *\n * @author tibor17\n * @since 4.12\n */\npublic abstract class Stopwatch implements TestRule {\n    private final Clock clock;\n    private volatile long startNanos;\n    private volatile long endNanos;\n\n    public Stopwatch() {\n        this(new Clock());\n    }\n\n    Stopwatch(Clock clock) {\n        this.clock = clock;\n    }\n\n    /**\n     * Gets the runtime for the test.\n     *\n     * @param unit time unit for returned runtime\n     * @return runtime measured during the test\n     */\n    public long runtime(TimeUnit unit) {\n        return unit.convert(getNanos(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Invoked when a test succeeds\n     */\n    protected void succeeded(long nanos, Description description) {\n    }\n\n    /**\n     * Invoked when a test fails\n     */\n    protected void failed(long nanos, Throwable e, Description description) {\n    }\n\n    /**\n     * Invoked when a test is skipped due to a failed assumption.\n     */\n    protected void skipped(long nanos, AssumptionViolatedException e, Description description) {\n    }\n\n    /**\n     * Invoked when a test method finishes (whether passing or failing)\n     */\n    protected void finished(long nanos, Description description) {\n    }\n\n    private long getNanos() {\n        if (startNanos == 0) {\n            throw new IllegalStateException(\"Test has not started\");\n        }\n        long currentEndNanos = endNanos; // volatile read happens here\n        if (currentEndNanos == 0) {\n          currentEndNanos = clock.nanoTime();\n        }\n\n        return currentEndNanos - startNanos;\n    }\n\n    private void starting() {\n        startNanos = clock.nanoTime();\n        endNanos = 0;\n    }\n\n    private void stopping() {\n        endNanos = clock.nanoTime();\n    }\n\n    public final Statement apply(Statement base, Description description) {\n        return new InternalWatcher().apply(base, description);\n    }\n\n    private class InternalWatcher extends TestWatcher {\n\n        @Override protected void starting(Description description) {\n            Stopwatch.this.starting();\n        }\n\n        @Override protected void finished(Description description) {\n            Stopwatch.this.finished(getNanos(), description);\n        }\n\n        @Override protected void succeeded(Description description) {\n            Stopwatch.this.stopping();\n            Stopwatch.this.succeeded(getNanos(), description);\n        }\n\n        @Override protected void failed(Throwable e, Description description) {\n            Stopwatch.this.stopping();\n            Stopwatch.this.failed(getNanos(), e, description);\n        }\n\n        @Override protected void skipped(AssumptionViolatedException e, Description description) {\n            Stopwatch.this.stopping();\n            Stopwatch.this.skipped(getNanos(), e, description);\n        }\n    }\n\n    static class Clock {\n\n        public long nanoTime() {\n            return System.nanoTime();\n        }\n    }\n}\n","lineNo":130}
{"Smelly Sample":"package org.junit.runners;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Field;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\n\n/**\n * The custom runner <code>Parameterized<\/code> implements parameterized tests.\n * When running a parameterized test class, instances are created for the\n * cross-product of the test methods and the test data elements.\n * <p>\n * For example, to test a Fibonacci function, write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class FibonacciTest {\n *     &#064;Parameters(name= &quot;{index}: fib[{0}]={1}&quot;)\n *     public static Iterable&lt;Object[]&gt; data() {\n *         return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },\n *                 { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });\n *     }\n *\n *     private int fInput;\n *\n *     private int fExpected;\n *\n *     public FibonacciTest(int input, int expected) {\n *         fInput= input;\n *         fExpected= expected;\n *     }\n *\n *     &#064;Test\n *     public void test() {\n *         assertEquals(fExpected, Fibonacci.compute(fInput));\n *     }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>FibonacciTest<\/code> will be constructed using the\n * two-argument constructor and the data values in the\n * <code>&#064;Parameters<\/code> method.\n * <p>\n * In order that you can easily identify the individual tests, you may provide a\n * name for the <code>&#064;Parameters<\/code> annotation. This name is allowed\n * to contain placeholders, which are replaced at runtime. The placeholders are\n * <dl>\n * <dt>{index}<\/dt>\n * <dd>the current parameter index<\/dd>\n * <dt>{0}<\/dt>\n * <dd>the first parameter value<\/dd>\n * <dt>{1}<\/dt>\n * <dd>the second parameter value<\/dd>\n * <dt>...<\/dt>\n * <dd><\/dd>\n * <\/dl>\n * <p>\n * In the example given above, the <code>Parameterized<\/code> runner creates\n * names like <code>[1: fib(3)=2]<\/code>. If you don't use the name parameter,\n * then the current parameter index is used as name.\n * <p>\n * You can also write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class FibonacciTest {\n *  &#064;Parameters\n *  public static Iterable&lt;Object[]&gt; data() {\n *      return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },\n *                 { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });\n *  }\n *  \n *  &#064;Parameter(0)\n *  public int fInput;\n *\n *  &#064;Parameter(1)\n *  public int fExpected;\n *\n *  &#064;Test\n *  public void test() {\n *      assertEquals(fExpected, Fibonacci.compute(fInput));\n *  }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>FibonacciTest<\/code> will be constructed with the default constructor\n * and fields annotated by <code>&#064;Parameter<\/code>  will be initialized\n * with the data values in the <code>&#064;Parameters<\/code> method.\n *\n * <p>\n * The parameters can be provided as an array, too:\n * \n * <pre>\n * &#064;Parameters\n * public static Object[][] data() {\n * \treturn new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 }, { 3, 2 }, { 4, 3 },\n * \t\t\t{ 5, 5 }, { 6, 8 } };\n * }\n * <\/pre>\n * \n * <h3>Tests with single parameter<\/h3>\n * <p>\n * If your test needs a single parameter only, you don't have to wrap it with an\n * array. Instead you can provide an <code>Iterable<\/code> or an array of\n * objects.\n * <pre>\n * &#064;Parameters\n * public static Iterable&lt;? extends Object&gt; data() {\n * \treturn Arrays.asList(&quot;first test&quot;, &quot;second test&quot;);\n * }\n * <\/pre>\n * <p>\n * or\n * <pre>\n * &#064;Parameters\n * public static Object[] data() {\n * \treturn new Object[] { &quot;first test&quot;, &quot;second test&quot; };\n * }\n * <\/pre>\n *\n * @since 4.0\n */\npublic class Parameterized extends Suite {\n    /**\n     * Annotation for a method which provides parameters to be injected into the\n     * test class constructor by <code>Parameterized<\/code>. The method has to\n     * be public and static.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public static @interface Parameters {\n        /**\n         * Optional pattern to derive the test's name from the parameters. Use\n         * numbers in braces to refer to the parameters or the additional data\n         * as follows:\n         * <pre>\n         * {index} - the current parameter index\n         * {0} - the first parameter value\n         * {1} - the second parameter value\n         * etc...\n         * <\/pre>\n         * <p>\n         * Default value is \"{index}\" for compatibility with previous JUnit\n         * versions.\n         *\n         * @return {@link MessageFormat} pattern string, except the index\n         *         placeholder.\n         * @see MessageFormat\n         */\n        String name() default \"{index}\";\n    }\n\n    /**\n     * Annotation for fields of the test class which will be initialized by the\n     * method annotated by <code>Parameters<\/code><br/>\n     * By using directly this annotation, the test class constructor isn't needed.<br/>\n     * Index range must start at 0.\n     * Default value is 0.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.FIELD)\n    public static @interface Parameter {\n        /**\n         * Method that returns the index of the parameter in the array\n         * returned by the method annotated by <code>Parameters<\/code>.<br/>\n         * Index range must start at 0.\n         * Default value is 0.\n         *\n         * @return the index of the parameter.\n         */\n        int value() default 0;\n    }\n\n    protected class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {\n        private final Object[] fParameters;\n\n        private final String fName;\n\n        protected TestClassRunnerForParameters(Class<?> type, String pattern, int index, Object[] parameters) throws InitializationError {\n            super(type);\n\n            fParameters = parameters;\n            fName = nameFor(pattern, index, parameters);\n        }\n\n        @Override\n        public Object createTest() throws Exception {\n            if (fieldsAreAnnotated()) {\n                return createTestUsingFieldInjection();\n            } else {\n                return createTestUsingConstructorInjection();\n            }\n        }\n\n        private Object createTestUsingConstructorInjection() throws Exception {\n            return getTestClass().getOnlyConstructor().newInstance(fParameters);\n        }\n\n        private Object createTestUsingFieldInjection() throws Exception {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n            if (annotatedFieldsByParameter.size() != fParameters.length) {\n                throw new Exception(\"Wrong number of parameters and @Parameter fields.\" +\n                        \" @Parameter fields counted: \" + annotatedFieldsByParameter.size() + \", available parameters: \" + fParameters.length + \".\");\n            }\n            Object testClassInstance = getTestClass().getJavaClass().newInstance();\n            for (FrameworkField each : annotatedFieldsByParameter) {\n                Field field = each.getField();\n                Parameter annotation = field.getAnnotation(Parameter.class);\n                int index = annotation.value();\n                try {\n                    field.set(testClassInstance, fParameters[index]);\n                } catch (IllegalArgumentException iare) {\n                    throw new Exception(getTestClass().getName() + \": Trying to set \" + field.getName() +\n                            \" with the value \" + fParameters[index] +\n                            \" that is not the right type (\" + fParameters[index].getClass().getSimpleName() + \" instead of \" +\n                            field.getType().getSimpleName() + \").\", iare);\n                }\n            }\n            return testClassInstance;\n        }\n\n        protected String nameFor(String pattern, int index, Object[] parameters) {\n            String finalPattern = pattern.replaceAll(\"\\\\{index\\\\}\", Integer.toString(index));\n            String name = MessageFormat.format(finalPattern, parameters);\n            return \"[\" + name + \"]\";\n        }\n\n        @Override\n        protected String getName() {\n            return fName;\n        }\n\n        @Override\n        protected String testName(FrameworkMethod method) {\n            return method.getName() + getName();\n        }\n\n        @Override\n        protected void validateConstructor(List<Throwable> errors) {\n            validateOnlyOneConstructor(errors);\n            if (fieldsAreAnnotated()) {\n                validateZeroArgConstructor(errors);\n            }\n        }\n\n        @Override\n        protected void validateFields(List<Throwable> errors) {\n            super.validateFields(errors);\n            if (fieldsAreAnnotated()) {\n                List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n                int[] usedIndices = new int[annotatedFieldsByParameter.size()];\n                for (FrameworkField each : annotatedFieldsByParameter) {\n                    int index = each.getField().getAnnotation(Parameter.class).value();\n                    if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {\n                        errors.add(\n                                new Exception(\"Invalid @Parameter value: \" + index + \". @Parameter fields counted: \" +\n                                        annotatedFieldsByParameter.size() + \". Please use an index between 0 and \" +\n                                        (annotatedFieldsByParameter.size() - 1) + \".\")\n                        );\n                    } else {\n                        usedIndices[index]++;\n                    }\n                }\n                for (int index = 0; index < usedIndices.length; index++) {\n                    int numberOfUse = usedIndices[index];\n                    if (numberOfUse == 0) {\n                        errors.add(new Exception(\"@Parameter(\" + index + \") is never used.\"));\n                    } else if (numberOfUse > 1) {\n                        errors.add(new Exception(\"@Parameter(\" + index + \") is used more than once (\" + numberOfUse + \").\"));\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected Statement classBlock(RunNotifier notifier) {\n            return childrenInvoker(notifier);\n        }\n\n        @Override\n        protected Annotation[] getRunnerAnnotations() {\n            return new Annotation[0];\n        }\n    }\n\n    private static final List<Runner> NO_RUNNERS = Collections.<Runner>emptyList();\n\n    private final List<Runner> fRunners;\n\n    /**\n     * Only called reflectively. Do not use programmatically.\n     */\n    public Parameterized(Class<?> klass) throws Throwable {\n        super(klass, NO_RUNNERS);\n        Parameters parameters = getParametersMethod().getAnnotation(\n                Parameters.class);\n        fRunners = Collections.unmodifiableList(createRunnersForParameters(allParameters(), parameters.name()));\n    }\n\n    @Override\n    protected List<Runner> getChildren() {\n        return fRunners;\n    }\n\n    private Runner createRunnerWithNotNormalizedParameters(String pattern,\n            int index, Object parametersOrSingleParameter)\n            throws InitializationError {\n        Object[] parameters= (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter\n            : new Object[] { parametersOrSingleParameter };\n        return createRunner(pattern, index, parameters);\n    }\n\n    protected Runner createRunner(String pattern, int index, Object[] parameters) throws InitializationError {\n        return new TestClassRunnerForParameters(getTestClass().getJavaClass(), pattern, index, parameters);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Iterable<Object> allParameters() throws Throwable {\n        Object parameters = getParametersMethod().invokeExplosively(null);\n        if (parameters instanceof Iterable) {\n            return (Iterable<Object>) parameters;\n        } else if (parameters instanceof Object[]) {\n            return Arrays.asList((Object[]) parameters);\n        } else {\n            throw parametersMethodReturnedWrongType();\n        }\n    }\n\n    private FrameworkMethod getParametersMethod() throws Exception {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(\n                Parameters.class);\n        for (FrameworkMethod each : methods) {\n            if (each.isStatic() && each.isPublic()) {\n                return each;\n            }\n        }\n\n        throw new Exception(\"No public static parameters method on class \"\n                + getTestClass().getName());\n    }\n\n    private List<Runner> createRunnersForParameters(Iterable<Object> allParameters, String namePattern) throws Exception {\n        try {\n            int i = 0;\n            List<Runner> children = new ArrayList<Runner>();\n            for (Object parametersOfSingleTest : allParameters) {\n                children.add(createRunnerWithNotNormalizedParameters(\n                    namePattern, i++, parametersOfSingleTest));\n            }\n            return children;\n        } catch (ClassCastException e) {\n            throw parametersMethodReturnedWrongType();\n        }\n    }\n\n    private Exception parametersMethodReturnedWrongType() throws Exception {\n        String className = getTestClass().getName();\n        String methodName = getParametersMethod().getName();\n        String message = MessageFormat.format(\n                \"{0}.{1}() must return an Iterable of arrays.\",\n                className, methodName);\n        return new Exception(message);\n    }\n\n    private List<FrameworkField> getAnnotatedFieldsByParameter() {\n        return getTestClass().getAnnotatedFields(Parameter.class);\n    }\n\n    private boolean fieldsAreAnnotated() {\n        return !getAnnotatedFieldsByParameter().isEmpty();\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Field;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\nimport org.junit.runners.parameterized.TestWithParameters;\n\n/**\n * The custom runner <code>Parameterized<\/code> implements parameterized tests.\n * When running a parameterized test class, instances are created for the\n * cross-product of the test methods and the test data elements.\n * <p>\n * For example, to test a Fibonacci function, write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class FibonacciTest {\n *     &#064;Parameters(name= &quot;{index}: fib[{0}]={1}&quot;)\n *     public static Iterable&lt;Object[]&gt; data() {\n *         return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },\n *                 { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });\n *     }\n *\n *     private int fInput;\n *\n *     private int fExpected;\n *\n *     public FibonacciTest(int input, int expected) {\n *         fInput= input;\n *         fExpected= expected;\n *     }\n *\n *     &#064;Test\n *     public void test() {\n *         assertEquals(fExpected, Fibonacci.compute(fInput));\n *     }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>FibonacciTest<\/code> will be constructed using the\n * two-argument constructor and the data values in the\n * <code>&#064;Parameters<\/code> method.\n * <p>\n * In order that you can easily identify the individual tests, you may provide a\n * name for the <code>&#064;Parameters<\/code> annotation. This name is allowed\n * to contain placeholders, which are replaced at runtime. The placeholders are\n * <dl>\n * <dt>{index}<\/dt>\n * <dd>the current parameter index<\/dd>\n * <dt>{0}<\/dt>\n * <dd>the first parameter value<\/dd>\n * <dt>{1}<\/dt>\n * <dd>the second parameter value<\/dd>\n * <dt>...<\/dt>\n * <dd><\/dd>\n * <\/dl>\n * <p>\n * In the example given above, the <code>Parameterized<\/code> runner creates\n * names like <code>[1: fib(3)=2]<\/code>. If you don't use the name parameter,\n * then the current parameter index is used as name.\n * <p>\n * You can also write:\n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class FibonacciTest {\n *  &#064;Parameters\n *  public static Iterable&lt;Object[]&gt; data() {\n *      return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },\n *                 { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });\n *  }\n *  \n *  &#064;Parameter(0)\n *  public int fInput;\n *\n *  &#064;Parameter(1)\n *  public int fExpected;\n *\n *  &#064;Test\n *  public void test() {\n *      assertEquals(fExpected, Fibonacci.compute(fInput));\n *  }\n * }\n * <\/pre>\n * <p>\n * Each instance of <code>FibonacciTest<\/code> will be constructed with the default constructor\n * and fields annotated by <code>&#064;Parameter<\/code>  will be initialized\n * with the data values in the <code>&#064;Parameters<\/code> method.\n *\n * <p>\n * The parameters can be provided as an array, too:\n * \n * <pre>\n * &#064;Parameters\n * public static Object[][] data() {\n * \treturn new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 }, { 3, 2 }, { 4, 3 },\n * \t\t\t{ 5, 5 }, { 6, 8 } };\n * }\n * <\/pre>\n * \n * <h3>Tests with single parameter<\/h3>\n * <p>\n * If your test needs a single parameter only, you don't have to wrap it with an\n * array. Instead you can provide an <code>Iterable<\/code> or an array of\n * objects.\n * <pre>\n * &#064;Parameters\n * public static Iterable&lt;? extends Object&gt; data() {\n * \treturn Arrays.asList(&quot;first test&quot;, &quot;second test&quot;);\n * }\n * <\/pre>\n * <p>\n * or\n * <pre>\n * &#064;Parameters\n * public static Object[] data() {\n * \treturn new Object[] { &quot;first test&quot;, &quot;second test&quot; };\n * }\n * <\/pre>\n *\n * @since 4.0\n */\npublic class Parameterized extends Suite {\n    /**\n     * Annotation for a method which provides parameters to be injected into the\n     * test class constructor by <code>Parameterized<\/code>. The method has to\n     * be public and static.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public static @interface Parameters {\n        /**\n         * Optional pattern to derive the test's name from the parameters. Use\n         * numbers in braces to refer to the parameters or the additional data\n         * as follows:\n         * <pre>\n         * {index} - the current parameter index\n         * {0} - the first parameter value\n         * {1} - the second parameter value\n         * etc...\n         * <\/pre>\n         * <p>\n         * Default value is \"{index}\" for compatibility with previous JUnit\n         * versions.\n         *\n         * @return {@link MessageFormat} pattern string, except the index\n         *         placeholder.\n         * @see MessageFormat\n         */\n        String name() default \"{index}\";\n    }\n\n    /**\n     * Annotation for fields of the test class which will be initialized by the\n     * method annotated by <code>Parameters<\/code><br/>\n     * By using directly this annotation, the test class constructor isn't needed.<br/>\n     * Index range must start at 0.\n     * Default value is 0.\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.FIELD)\n    public static @interface Parameter {\n        /**\n         * Method that returns the index of the parameter in the array\n         * returned by the method annotated by <code>Parameters<\/code>.<br/>\n         * Index range must start at 0.\n         * Default value is 0.\n         *\n         * @return the index of the parameter.\n         */\n        int value() default 0;\n    }\n\n    protected class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {\n        private final Object[] fParameters;\n\n        private final String fName;\n\n        /**\n         * @deprecated please use\n         *             {@code TestClassRunnerForParameters(TestWithParameters)}\n         */\n        @Deprecated\n        protected TestClassRunnerForParameters(Class<?> type, String pattern, int index, Object[] parameters) throws InitializationError {\n            this(createTestWithParameters(new TestClass(type), pattern, index,\n                    parameters));\n        }\n\n        protected TestClassRunnerForParameters(TestWithParameters test)\n                throws InitializationError {\n            super(test.getTestClass().getJavaClass());\n            fParameters = test.getParameters().toArray();\n            fName = test.getName();\n        }\n\n        @Override\n        public Object createTest() throws Exception {\n            if (fieldsAreAnnotated()) {\n                return createTestUsingFieldInjection();\n            } else {\n                return createTestUsingConstructorInjection();\n            }\n        }\n\n        private Object createTestUsingConstructorInjection() throws Exception {\n            return getTestClass().getOnlyConstructor().newInstance(fParameters);\n        }\n\n        private Object createTestUsingFieldInjection() throws Exception {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n            if (annotatedFieldsByParameter.size() != fParameters.length) {\n                throw new Exception(\"Wrong number of parameters and @Parameter fields.\" +\n                        \" @Parameter fields counted: \" + annotatedFieldsByParameter.size() + \", available parameters: \" + fParameters.length + \".\");\n            }\n            Object testClassInstance = getTestClass().getJavaClass().newInstance();\n            for (FrameworkField each : annotatedFieldsByParameter) {\n                Field field = each.getField();\n                Parameter annotation = field.getAnnotation(Parameter.class);\n                int index = annotation.value();\n                try {\n                    field.set(testClassInstance, fParameters[index]);\n                } catch (IllegalArgumentException iare) {\n                    throw new Exception(getTestClass().getName() + \": Trying to set \" + field.getName() +\n                            \" with the value \" + fParameters[index] +\n                            \" that is not the right type (\" + fParameters[index].getClass().getSimpleName() + \" instead of \" +\n                            field.getType().getSimpleName() + \").\", iare);\n                }\n            }\n            return testClassInstance;\n        }\n\n        @Override\n        protected String getName() {\n            return fName;\n        }\n\n        @Override\n        protected String testName(FrameworkMethod method) {\n            return method.getName() + getName();\n        }\n\n        @Override\n        protected void validateConstructor(List<Throwable> errors) {\n            validateOnlyOneConstructor(errors);\n            if (fieldsAreAnnotated()) {\n                validateZeroArgConstructor(errors);\n            }\n        }\n\n        @Override\n        protected void validateFields(List<Throwable> errors) {\n            super.validateFields(errors);\n            if (fieldsAreAnnotated()) {\n                List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n                int[] usedIndices = new int[annotatedFieldsByParameter.size()];\n                for (FrameworkField each : annotatedFieldsByParameter) {\n                    int index = each.getField().getAnnotation(Parameter.class).value();\n                    if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {\n                        errors.add(\n                                new Exception(\"Invalid @Parameter value: \" + index + \". @Parameter fields counted: \" +\n                                        annotatedFieldsByParameter.size() + \". Please use an index between 0 and \" +\n                                        (annotatedFieldsByParameter.size() - 1) + \".\")\n                        );\n                    } else {\n                        usedIndices[index]++;\n                    }\n                }\n                for (int index = 0; index < usedIndices.length; index++) {\n                    int numberOfUse = usedIndices[index];\n                    if (numberOfUse == 0) {\n                        errors.add(new Exception(\"@Parameter(\" + index + \") is never used.\"));\n                    } else if (numberOfUse > 1) {\n                        errors.add(new Exception(\"@Parameter(\" + index + \") is used more than once (\" + numberOfUse + \").\"));\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected Statement classBlock(RunNotifier notifier) {\n            return childrenInvoker(notifier);\n        }\n\n        @Override\n        protected Annotation[] getRunnerAnnotations() {\n            return new Annotation[0];\n        }\n    }\n\n    private static final List<Runner> NO_RUNNERS = Collections.<Runner>emptyList();\n\n    private final List<Runner> fRunners;\n\n    /**\n     * Only called reflectively. Do not use programmatically.\n     */\n    public Parameterized(Class<?> klass) throws Throwable {\n        super(klass, NO_RUNNERS);\n        Parameters parameters = getParametersMethod().getAnnotation(\n                Parameters.class);\n        fRunners = Collections.unmodifiableList(createRunnersForParameters(allParameters(), parameters.name()));\n    }\n\n    @Override\n    protected List<Runner> getChildren() {\n        return fRunners;\n    }\n\n    private Runner createRunnerWithNotNormalizedParameters(String pattern,\n            int index, Object parametersOrSingleParameter)\n            throws InitializationError {\n        Object[] parameters= (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter\n            : new Object[] { parametersOrSingleParameter };\n        TestWithParameters test = createTestWithParameters(getTestClass(),\n                pattern, index, parameters);\n        return createRunnerForTest(test);\n    }\n\n    protected Runner createRunnerForTest(TestWithParameters test)\n            throws InitializationError {\n        return new TestClassRunnerForParameters(test);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Iterable<Object> allParameters() throws Throwable {\n        Object parameters = getParametersMethod().invokeExplosively(null);\n        if (parameters instanceof Iterable) {\n            return (Iterable<Object>) parameters;\n        } else if (parameters instanceof Object[]) {\n            return Arrays.asList((Object[]) parameters);\n        } else {\n            throw parametersMethodReturnedWrongType();\n        }\n    }\n\n    private FrameworkMethod getParametersMethod() throws Exception {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(\n                Parameters.class);\n        for (FrameworkMethod each : methods) {\n            if (each.isStatic() && each.isPublic()) {\n                return each;\n            }\n        }\n\n        throw new Exception(\"No public static parameters method on class \"\n                + getTestClass().getName());\n    }\n\n    private List<Runner> createRunnersForParameters(Iterable<Object> allParameters, String namePattern) throws Exception {\n        try {\n            int i = 0;\n            List<Runner> children = new ArrayList<Runner>();\n            for (Object parametersOfSingleTest : allParameters) {\n                children.add(createRunnerWithNotNormalizedParameters(\n                    namePattern, i++, parametersOfSingleTest));\n            }\n            return children;\n        } catch (ClassCastException e) {\n            throw parametersMethodReturnedWrongType();\n        }\n    }\n\n    private Exception parametersMethodReturnedWrongType() throws Exception {\n        String className = getTestClass().getName();\n        String methodName = getParametersMethod().getName();\n        String message = MessageFormat.format(\n                \"{0}.{1}() must return an Iterable of arrays.\",\n                className, methodName);\n        return new Exception(message);\n    }\n\n    private List<FrameworkField> getAnnotatedFieldsByParameter() {\n        return getTestClass().getAnnotatedFields(Parameter.class);\n    }\n\n    private boolean fieldsAreAnnotated() {\n        return !getAnnotatedFieldsByParameter().isEmpty();\n    }\n\n    private static TestWithParameters createTestWithParameters(\n            TestClass testClass, String pattern, int index, Object[] parameters) {\n        String finalPattern = pattern.replaceAll(\"\\\\{index\\\\}\",\n                Integer.toString(index));\n        String name = MessageFormat.format(finalPattern, parameters);\n        return new TestWithParameters(\"[\" + name + \"]\", testClass,\n                Arrays.asList(parameters));\n    }\n}\n","lineNo":328}
{"Smelly Sample":"package org.junit.runners.model;\n\nimport static java.lang.reflect.Modifier.isStatic;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.internal.MethodSorter;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n *\n * @since 4.5\n */\npublic class TestClass {\n    private final Class<?> fClass;\n    private final Map<Class<? extends Annotation>, List<FrameworkMethod>> fMethodsForAnnotations;\n    private final Map<Class<? extends Annotation>, List<FrameworkField>> fFieldsForAnnotations;\n\n    /**\n     * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> klass) {\n        fClass = klass;\n        if (klass != null && klass.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);\n\n        fMethodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);\n        fFieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);\n    }\n\n    protected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {\n        for (Class<?> eachClass : getSuperClasses(fClass)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            // ensuring fields are sorted to make sure that entries are inserted\n            // and read from fieldForAnnotations in a deterministic order\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n    }\n\n    private static Field[] getSortedDeclaredFields(Class<?> clazz) {\n        Field[] declaredFields = clazz.getDeclaredFields();\n        Arrays.sort(declaredFields, new Comparator<Field>() {\n            public int compare(Field field1, Field field2) {\n                return field1.getName().compareTo(field2.getName());\n            }\n        });\n        return declaredFields;\n    }\n\n    protected static <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n            Map<Class<? extends Annotation>, List<T>> map) {\n        for (Annotation each : member.getAnnotations()) {\n            Class<? extends Annotation> type = each.annotationType();\n            List<T> members = getAnnotatedMembers(map, type, true);\n            if (member.isShadowedBy(members)) {\n                return;\n            }\n            if (runsTopToBottom(type)) {\n                members.add(0, member);\n            } else {\n                members.add(member);\n            }\n        }\n    }\n\n    private static <T extends FrameworkMember<T>> Map<Class<? extends Annotation>, List<T>>\n            makeDeeplyUnmodifiable(Map<Class<? extends Annotation>, List<T>> source) {\n        LinkedHashMap<Class<? extends Annotation>, List<T>> copy =\n                new LinkedHashMap<Class<? extends Annotation>, List<T>>();\n        for (Map.Entry<Class<? extends Annotation>, List<T>> entry : source.entrySet()) {\n            copy.put(entry.getKey(), Collections.unmodifiableList(entry.getValue()));\n        }\n        return Collections.unmodifiableMap(copy);\n    }\n\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkMethod> getAnnotatedMethods(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fMethodsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkField> getAnnotatedFields(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fFieldsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Gets a {@code Map} between annotations and methods that have\n     * the annotation in this class or its superclasses.\n     *\n     * @since 4.12\n     */\n    public Map<Class<? extends Annotation>, List<FrameworkMethod>> getAnnotationToMethods() {\n        return fMethodsForAnnotations;\n    }\n\n    /**\n     * Gets a {@code Map} between annotations and fields that have\n     * the annotation in this class or its superclasses.\n     *\n     * @since 4.12\n     */\n    public Map<Class<? extends Annotation>, List<FrameworkField>> getAnnotationToFields() {\n        return fFieldsForAnnotations;\n    }\n\n    private static <T> List<T> getAnnotatedMembers(Map<Class<? extends Annotation>, List<T>> map,\n            Class<? extends Annotation> type, boolean fillIfAbsent) {\n        if (!map.containsKey(type) && fillIfAbsent) {\n            map.put(type, new ArrayList<T>());\n        }\n        List<T> members = map.get(type);\n        return members == null ? Collections.<T>emptyList() : members;\n    }\n\n    private static boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n        return annotation.equals(Before.class)\n                || annotation.equals(BeforeClass.class);\n    }\n\n    private static List<Class<?>> getSuperClasses(Class<?> testClass) {\n        ArrayList<Class<?>> results = new ArrayList<Class<?>>();\n        Class<?> current = testClass;\n        while (current != null) {\n            results.add(current);\n            current = current.getSuperclass();\n        }\n        return results;\n    }\n\n    /**\n     * Returns the underlying Java class.\n     */\n    public Class<?> getJavaClass() {\n        return fClass;\n    }\n\n    /**\n     * Returns the class's name.\n     */\n    public String getName() {\n        if (fClass == null) {\n            return \"null\";\n        }\n        return fClass.getName();\n    }\n\n    /**\n     * Returns the only public constructor in the class, or throws an {@code\n     * AssertionError} if there are more or less than one.\n     */\n\n    public Constructor<?> getOnlyConstructor() {\n        Constructor<?>[] constructors = fClass.getConstructors();\n        Assert.assertEquals(1, constructors.length);\n        return constructors[0];\n    }\n\n    /**\n     * Returns the annotations on this class\n     */\n    public Annotation[] getAnnotations() {\n        if (fClass == null) {\n            return new Annotation[0];\n        }\n        return fClass.getAnnotations();\n    }\n\n    public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n        return results;\n    }\n\n    public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                Object fieldValue = each.invokeExplosively(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n        return results;\n    }\n\n    public boolean isANonStaticInnerClass() {\n        return fClass.isMemberClass() && !isStatic(fClass.getModifiers());\n    }\n}\n","Method after Refactoring":"package org.junit.runners.model;\n\nimport static java.lang.reflect.Modifier.isStatic;\nimport static org.junit.internal.MethodSorter.NAME_ASCENDING;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.internal.MethodSorter;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n *\n * @since 4.5\n */\npublic class TestClass implements Annotatable {\n    private static final FieldComparator FIELD_COMPARATOR = new FieldComparator();\n    private static final MethodComparator METHOD_COMPARATOR = new MethodComparator();\n\n    private final Class<?> fClass;\n    private final Map<Class<? extends Annotation>, List<FrameworkMethod>> fMethodsForAnnotations;\n    private final Map<Class<? extends Annotation>, List<FrameworkField>> fFieldsForAnnotations;\n\n    /**\n     * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> klass) {\n        fClass = klass;\n        if (klass != null && klass.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);\n\n        fMethodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);\n        fFieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);\n    }\n\n    protected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {\n        for (Class<?> eachClass : getSuperClasses(fClass)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            // ensuring fields are sorted to make sure that entries are inserted\n            // and read from fieldForAnnotations in a deterministic order\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n    }\n\n    private static Field[] getSortedDeclaredFields(Class<?> clazz) {\n        Field[] declaredFields = clazz.getDeclaredFields();\n        Arrays.sort(declaredFields, FIELD_COMPARATOR);\n        return declaredFields;\n    }\n\n    protected static <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n            Map<Class<? extends Annotation>, List<T>> map) {\n        for (Annotation each : member.getAnnotations()) {\n            Class<? extends Annotation> type = each.annotationType();\n            List<T> members = getAnnotatedMembers(map, type, true);\n            if (member.isShadowedBy(members)) {\n                return;\n            }\n            if (runsTopToBottom(type)) {\n                members.add(0, member);\n            } else {\n                members.add(member);\n            }\n        }\n    }\n\n    private static <T extends FrameworkMember<T>> Map<Class<? extends Annotation>, List<T>>\n            makeDeeplyUnmodifiable(Map<Class<? extends Annotation>, List<T>> source) {\n        LinkedHashMap<Class<? extends Annotation>, List<T>> copy =\n                new LinkedHashMap<Class<? extends Annotation>, List<T>>();\n        for (Map.Entry<Class<? extends Annotation>, List<T>> entry : source.entrySet()) {\n            copy.put(entry.getKey(), Collections.unmodifiableList(entry.getValue()));\n        }\n        return Collections.unmodifiableMap(copy);\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated}.\n     * \n     * @since 4.12\n     */\n    public List<FrameworkMethod> getAnnotatedMethods() {\n        List<FrameworkMethod> methods = collectValues(fMethodsForAnnotations);\n        Collections.sort(methods, METHOD_COMPARATOR);\n        return methods;\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkMethod> getAnnotatedMethods(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fMethodsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated.\n     * \n     * @since 4.12\n     */\n    public List<FrameworkField> getAnnotatedFields() {\n        return collectValues(fFieldsForAnnotations);\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkField> getAnnotatedFields(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fFieldsForAnnotations, annotationClass, false));\n    }\n\n    private <T> List<T> collectValues(Map<?, List<T>> map) {\n        Set<T> values = new LinkedHashSet<T>();\n        for (List<T> additionalValues : map.values()) {\n            values.addAll(additionalValues);\n        }\n        return new ArrayList<T>(values);\n    }\n\n    private static <T> List<T> getAnnotatedMembers(Map<Class<? extends Annotation>, List<T>> map,\n            Class<? extends Annotation> type, boolean fillIfAbsent) {\n        if (!map.containsKey(type) && fillIfAbsent) {\n            map.put(type, new ArrayList<T>());\n        }\n        List<T> members = map.get(type);\n        return members == null ? Collections.<T>emptyList() : members;\n    }\n\n    private static boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n        return annotation.equals(Before.class)\n                || annotation.equals(BeforeClass.class);\n    }\n\n    private static List<Class<?>> getSuperClasses(Class<?> testClass) {\n        ArrayList<Class<?>> results = new ArrayList<Class<?>>();\n        Class<?> current = testClass;\n        while (current != null) {\n            results.add(current);\n            current = current.getSuperclass();\n        }\n        return results;\n    }\n\n    /**\n     * Returns the underlying Java class.\n     */\n    public Class<?> getJavaClass() {\n        return fClass;\n    }\n\n    /**\n     * Returns the class's name.\n     */\n    public String getName() {\n        if (fClass == null) {\n            return \"null\";\n        }\n        return fClass.getName();\n    }\n\n    /**\n     * Returns the only public constructor in the class, or throws an {@code\n     * AssertionError} if there are more or less than one.\n     */\n\n    public Constructor<?> getOnlyConstructor() {\n        Constructor<?>[] constructors = fClass.getConstructors();\n        Assert.assertEquals(1, constructors.length);\n        return constructors[0];\n    }\n\n    /**\n     * Returns the annotations on this class\n     */\n    public Annotation[] getAnnotations() {\n        if (fClass == null) {\n            return new Annotation[0];\n        }\n        return fClass.getAnnotations();\n    }\n\n    public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n        return results;\n    }\n\n    public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                Object fieldValue = each.invokeExplosively(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n        return results;\n    }\n\n    public boolean isANonStaticInnerClass() {\n        return fClass.isMemberClass() && !isStatic(fClass.getModifiers());\n    }\n\n    /**\n     * Compares two fields by its name.\n     */\n    private static class FieldComparator implements Comparator<Field> {\n        public int compare(Field left, Field right) {\n            return left.getName().compareTo(right.getName());\n        }\n    }\n\n    /**\n     * Compares two methods by its name.\n     */\n    private static class MethodComparator implements\n            Comparator<FrameworkMethod> {\n        public int compare(FrameworkMethod left, FrameworkMethod right) {\n            return NAME_ASCENDING.compare(left.getMethod(), right.getMethod());\n        }\n    }\n}\n","lineNo":114}
{"Smelly Sample":"package org.junit.tests.experimental.rules;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.junit.rules.TestRule;\nimport org.junit.rules.Timeout;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\npublic class TimeoutRuleTest {\n    private static final ReentrantLock run1Lock = new ReentrantLock();\n\n    private static volatile boolean run4done = false;\n\n    public abstract static class AbstractTimeoutTest {\n        public static final StringBuffer logger = new StringBuffer();\n\n        @Rule\n        public final TemporaryFolder tmpFile = new TemporaryFolder();\n\n        @Test\n        public void run1() throws InterruptedException {\n            logger.append(\"run1\");\n            TimeoutRuleTest.run1Lock.lockInterruptibly();\n            TimeoutRuleTest.run1Lock.unlock();\n        }\n\n        @Test\n        public void run2() throws InterruptedException {\n            logger.append(\"run2\");\n            Thread.currentThread().join();\n        }\n\n        @Test\n        public synchronized void run3() throws InterruptedException {\n            logger.append(\"run3\");\n            wait();\n        }\n\n        @Test\n        public void run4() {\n            logger.append(\"run4\");\n            while (!run4done) {\n            }\n        }\n\n        @Test\n        public void run5() throws IOException {\n            logger.append(\"run5\");\n            Random rnd = new Random();\n            byte[] data = new byte[1024];\n            File tmp = tmpFile.newFile();\n            while (true) {\n                FileChannel channel = new RandomAccessFile(tmp, \"rw\").getChannel();\n                rnd.nextBytes(data);\n                ByteBuffer buffer = ByteBuffer.wrap(data);\n                // Interrupted thread closes channel and throws ClosedByInterruptException.\n                channel.write(buffer);\n                channel.close();\n                tmp.delete();\n            }\n        }\n\n        @Test\n        public void run6() throws InterruptedIOException {\n            logger.append(\"run6\");\n            // Java IO throws InterruptedIOException only on SUN machines.\n            throw new InterruptedIOException();\n        }\n    }\n\n    public static class HasGlobalLongTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = Timeout.millis(200);\n    }\n\n    public static class HasGlobalTimeUnitTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = new Timeout(200, TimeUnit.MILLISECONDS);\n    }\n\n    @Before\n    public void before() {\n        run4done = false;\n        run1Lock.lock();\n    }\n\n    @After\n    public void after() {\n        // set run4done to make sure that the thread won't continue at run4()\n        run4done = true;\n        run1Lock.unlock();\n    }\n\n    @Test\n    public void timeUnitTimeout() throws InterruptedException {\n        HasGlobalTimeUnitTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalTimeUnitTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run6\"));\n    }\n\n    @Test\n    public void longTimeout() throws InterruptedException {\n        HasGlobalLongTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalLongTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run6\"));\n    }\n}\n","Method after Refactoring":"package org.junit.tests.experimental.rules;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.junit.rules.TestRule;\nimport org.junit.rules.Timeout;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\n\npublic class TimeoutRuleTest {\n    private static final ReentrantLock run1Lock = new ReentrantLock();\n\n    private static volatile boolean run4done = false;\n\n    public abstract static class AbstractTimeoutTest {\n        public static final StringBuffer logger = new StringBuffer();\n\n        @Rule\n        public final TemporaryFolder tmpFile = new TemporaryFolder();\n\n        @Test\n        public void run1() throws InterruptedException {\n            logger.append(\"run1\");\n            TimeoutRuleTest.run1Lock.lockInterruptibly();\n            TimeoutRuleTest.run1Lock.unlock();\n        }\n\n        @Test\n        public void run2() throws InterruptedException {\n            logger.append(\"run2\");\n            Thread.currentThread().join();\n        }\n\n        @Test\n        public synchronized void run3() throws InterruptedException {\n            logger.append(\"run3\");\n            wait();\n        }\n\n        @Test\n        public void run4() {\n            logger.append(\"run4\");\n            while (!run4done) {\n            }\n        }\n\n        @Test\n        public void run5() throws IOException {\n            logger.append(\"run5\");\n            Random rnd = new Random();\n            byte[] data = new byte[1024];\n            File tmp = tmpFile.newFile();\n            while (true) {\n                RandomAccessFile randomAccessFile = new RandomAccessFile(tmp, \"rw\");\n                try {\n                    FileChannel channel = randomAccessFile.getChannel();\n                    rnd.nextBytes(data);\n                    ByteBuffer buffer = ByteBuffer.wrap(data);\n                    // Interrupted thread closes channel and throws ClosedByInterruptException.\n                    channel.write(buffer);\n                } finally {\n                    randomAccessFile.close();\n                }\n                tmp.delete();\n            }\n        }\n\n        @Test\n        public void run6() throws InterruptedIOException {\n            logger.append(\"run6\");\n            // Java IO throws InterruptedIOException only on SUN machines.\n            throw new InterruptedIOException();\n        }\n    }\n\n    public static class HasGlobalLongTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = Timeout.millis(200);\n    }\n\n    public static class HasGlobalTimeUnitTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = new Timeout(200, TimeUnit.MILLISECONDS);\n    }\n\n    @Before\n    public void before() {\n        run4done = false;\n        run1Lock.lock();\n    }\n\n    @After\n    public void after() {\n        // set run4done to make sure that the thread won't continue at run4()\n        run4done = true;\n        run1Lock.unlock();\n    }\n\n    @Test\n    public void timeUnitTimeout() {\n        HasGlobalTimeUnitTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalTimeUnitTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run6\"));\n    }\n\n    @Test\n    public void longTimeout() {\n        HasGlobalLongTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalLongTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run6\"));\n    }\n}\n","lineNo":71}
{"Smelly Sample":"package org.junit.runners.model;\n\nimport static java.lang.reflect.Modifier.isStatic;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.internal.MethodSorter;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n *\n * @since 4.5\n */\npublic class TestClass {\n    private final Class<?> fClass;\n    private final Map<Class<? extends Annotation>, List<FrameworkMethod>> fMethodsForAnnotations;\n    private final Map<Class<? extends Annotation>, List<FrameworkField>> fFieldsForAnnotations;\n\n    /**\n     * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> klass) {\n        fClass = klass;\n        if (klass != null && klass.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations = new HashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations = new HashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        for (Class<?> eachClass : getSuperClasses(fClass)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            for (Field eachField : eachClass.getDeclaredFields()) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n\n        convertListValuesToBeUnmodifiable(methodsForAnnotations);\n        convertListValuesToBeUnmodifiable(fieldsForAnnotations);\n\n        fMethodsForAnnotations = Collections.unmodifiableMap(methodsForAnnotations);\n        fFieldsForAnnotations = Collections.unmodifiableMap(fieldsForAnnotations);\n    }\n\n    private static <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n            Map<Class<? extends Annotation>, List<T>> map) {\n        for (Annotation each : member.getAnnotations()) {\n            Class<? extends Annotation> type = each.annotationType();\n            List<T> members = getAnnotatedMembers(map, type, true);\n            if (member.isShadowedBy(members)) {\n                return;\n            }\n            if (runsTopToBottom(type)) {\n                members.add(0, member);\n            } else {\n                members.add(member);\n            }\n        }\n    }\n\n    private static <T extends FrameworkMember<T>>  void convertListValuesToBeUnmodifiable(\n            Map<Class<? extends Annotation>, List<T>> methodsForAnnotations) {\n        for (Class<? extends Annotation> clazz : methodsForAnnotations.keySet()) {\n            methodsForAnnotations.put(clazz, Collections.unmodifiableList(methodsForAnnotations.get(clazz)));\n        }\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkMethod> getAnnotatedMethods(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fMethodsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkField> getAnnotatedFields(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fFieldsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Gets a {@code Map} between annotations and methods that have\n     * the annotation in this class or its superclasses.\n     */\n    public Map<Class<? extends Annotation>, List<FrameworkMethod>> getAnnotationToMethods() {\n        return Collections.unmodifiableMap(fMethodsForAnnotations);\n    }\n\n    /**\n     * Gets a {@code Map} between annotations and fields that have\n     * the annotation in this class or its superclasses.\n     */\n    public Map<Class<? extends Annotation>, List<FrameworkField>> getAnnotationToFields() {\n        return Collections.unmodifiableMap(fFieldsForAnnotations);\n    }\n\n    private static <T> List<T> getAnnotatedMembers(Map<Class<? extends Annotation>, List<T>> map,\n            Class<? extends Annotation> type, boolean fillIfAbsent) {\n        if (!map.containsKey(type) && fillIfAbsent) {\n            map.put(type, new ArrayList<T>());\n        }\n        List<T> members = map.get(type);\n        return members == null ? Collections.<T>emptyList() : members;\n    }\n\n    private static boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n        return annotation.equals(Before.class)\n                || annotation.equals(BeforeClass.class);\n    }\n\n    private static List<Class<?>> getSuperClasses(Class<?> testClass) {\n        ArrayList<Class<?>> results = new ArrayList<Class<?>>();\n        Class<?> current = testClass;\n        while (current != null) {\n            results.add(current);\n            current = current.getSuperclass();\n        }\n        return results;\n    }\n\n    /**\n     * Returns the underlying Java class.\n     */\n    public Class<?> getJavaClass() {\n        return fClass;\n    }\n\n    /**\n     * Returns the class's name.\n     */\n    public String getName() {\n        if (fClass == null) {\n            return \"null\";\n        }\n        return fClass.getName();\n    }\n\n    /**\n     * Returns the only public constructor in the class, or throws an {@code\n     * AssertionError} if there are more or less than one.\n     */\n\n    public Constructor<?> getOnlyConstructor() {\n        Constructor<?>[] constructors = fClass.getConstructors();\n        Assert.assertEquals(1, constructors.length);\n        return constructors[0];\n    }\n\n    /**\n     * Returns the annotations on this class\n     */\n    public Annotation[] getAnnotations() {\n        if (fClass == null) {\n            return new Annotation[0];\n        }\n        return fClass.getAnnotations();\n    }\n\n    public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n        return results;\n    }\n\n    public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                Object fieldValue = each.invokeExplosively(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n        return results;\n    }\n\n    public boolean isANonStaticInnerClass() {\n        return fClass.isMemberClass() && !isStatic(fClass.getModifiers());\n    }\n}\n","Method after Refactoring":"package org.junit.runners.model;\n\nimport static java.lang.reflect.Modifier.isStatic;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.internal.MethodSorter;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n *\n * @since 4.5\n */\npublic class TestClass {\n    private final Class<?> fClass;\n    private final Map<Class<? extends Annotation>, List<FrameworkMethod>> fMethodsForAnnotations;\n    private final Map<Class<? extends Annotation>, List<FrameworkField>> fFieldsForAnnotations;\n\n    /**\n     * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> klass) {\n        fClass = klass;\n        if (klass != null && klass.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        for (Class<?> eachClass : getSuperClasses(fClass)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotationsWithUnmodifiableLists =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        convertListValuesToBeUnmodifiable(methodsForAnnotations, methodsForAnnotationsWithUnmodifiableLists);\n\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotationsWithUnmodifiableLists =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n        convertListValuesToBeUnmodifiable(fieldsForAnnotations, fieldsForAnnotationsWithUnmodifiableLists);\n\n        fMethodsForAnnotations = Collections.unmodifiableMap(methodsForAnnotationsWithUnmodifiableLists);\n        fFieldsForAnnotations = Collections.unmodifiableMap(fieldsForAnnotationsWithUnmodifiableLists);\n    }\n\n    private static Field[] getSortedDeclaredFields(Class<?> clazz) {\n        Field[] declaredFields = clazz.getDeclaredFields();\n        Arrays.sort(declaredFields, new Comparator<Field>() {\n            public int compare(Field field1, Field field2) {\n                return field1.getName().compareTo(field2.getName());\n            }\n        });\n        return declaredFields;\n    }\n\n    private static <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n            Map<Class<? extends Annotation>, List<T>> map) {\n        for (Annotation each : member.getAnnotations()) {\n            Class<? extends Annotation> type = each.annotationType();\n            List<T> members = getAnnotatedMembers(map, type, true);\n            if (member.isShadowedBy(members)) {\n                return;\n            }\n            if (runsTopToBottom(type)) {\n                members.add(0, member);\n            } else {\n                members.add(member);\n            }\n        }\n    }\n\n    private static <T extends FrameworkMember<T>> void convertListValuesToBeUnmodifiable(\n            Map<Class<? extends Annotation>, List<T>> source, Map<Class<? extends Annotation>, List<T>> target) {\n        Set<Class<? extends Annotation>> classes = source.keySet();\n        for (Class<? extends Annotation> clazz : classes) {\n            target.put(clazz, Collections.unmodifiableList(source.get(clazz)));\n        }\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden methods in this class and\n     * its superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkMethod> getAnnotatedMethods(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fMethodsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Returns, efficiently, all the non-overridden fields in this class and its\n     * superclasses that are annotated with {@code annotationClass}.\n     */\n    public List<FrameworkField> getAnnotatedFields(\n            Class<? extends Annotation> annotationClass) {\n        return Collections.unmodifiableList(getAnnotatedMembers(fFieldsForAnnotations, annotationClass, false));\n    }\n\n    /**\n     * Gets a {@code Map} between annotations and methods that have\n     * the annotation in this class or its superclasses.\n     */\n    public Map<Class<? extends Annotation>, List<FrameworkMethod>> getAnnotationToMethods() {\n        return fMethodsForAnnotations;\n    }\n\n    /**\n     * Gets a {@code Map} between annotations and fields that have\n     * the annotation in this class or its superclasses.\n     */\n    public Map<Class<? extends Annotation>, List<FrameworkField>> getAnnotationToFields() {\n        return fFieldsForAnnotations;\n    }\n\n    private static <T> List<T> getAnnotatedMembers(Map<Class<? extends Annotation>, List<T>> map,\n            Class<? extends Annotation> type, boolean fillIfAbsent) {\n        if (!map.containsKey(type) && fillIfAbsent) {\n            map.put(type, new ArrayList<T>());\n        }\n        List<T> members = map.get(type);\n        return members == null ? Collections.<T>emptyList() : members;\n    }\n\n    private static boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n        return annotation.equals(Before.class)\n                || annotation.equals(BeforeClass.class);\n    }\n\n    private static List<Class<?>> getSuperClasses(Class<?> testClass) {\n        ArrayList<Class<?>> results = new ArrayList<Class<?>>();\n        Class<?> current = testClass;\n        while (current != null) {\n            results.add(current);\n            current = current.getSuperclass();\n        }\n        return results;\n    }\n\n    /**\n     * Returns the underlying Java class.\n     */\n    public Class<?> getJavaClass() {\n        return fClass;\n    }\n\n    /**\n     * Returns the class's name.\n     */\n    public String getName() {\n        if (fClass == null) {\n            return \"null\";\n        }\n        return fClass.getName();\n    }\n\n    /**\n     * Returns the only public constructor in the class, or throws an {@code\n     * AssertionError} if there are more or less than one.\n     */\n\n    public Constructor<?> getOnlyConstructor() {\n        Constructor<?>[] constructors = fClass.getConstructors();\n        Assert.assertEquals(1, constructors.length);\n        return constructors[0];\n    }\n\n    /**\n     * Returns the annotations on this class\n     */\n    public Annotation[] getAnnotations() {\n        if (fClass == null) {\n            return new Annotation[0];\n        }\n        return fClass.getAnnotations();\n    }\n\n    public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n        return results;\n    }\n\n    public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                Object fieldValue = each.invokeExplosively(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n        return results;\n    }\n\n    public boolean isANonStaticInnerClass() {\n        return fClass.isMemberClass() && !isStatic(fClass.getModifiers());\n    }\n}\n","lineNo":100}
{"Smelly Sample":"package org.junit.experimental.validator;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Creates instances of Annotation Validators.\n */\npublic class AnnotationValidatorFactory {\n\n    private static Map<ValidateWith, AnnotationValidator> fAnnotationTypeToValidatorMap =\n            new ConcurrentHashMap<ValidateWith, AnnotationValidator>();\n\n    /**\n     * Creates the AnnotationValidator specified by the value in\n     * {@link org.junit.experimental.validator.ValidateWith}. Instances are\n     * cached. A null parameter return a default no-args {@link AnnotationValidator}.\n     *\n     * @param validateWithAnnotation\n     * @return An instance of the AnnotationValidator.\n     */\n    public AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator();\n        }\n\n        if (fAnnotationTypeToValidatorMap.containsKey(validateWithAnnotation)) {\n            return fAnnotationTypeToValidatorMap.get(validateWithAnnotation);\n        }\n\n        Class<?> clazz = validateWithAnnotation.value();\n        try {\n            AnnotationValidator annotationValidator = (AnnotationValidator) clazz.newInstance();\n            fAnnotationTypeToValidatorMap.put(validateWithAnnotation, annotationValidator);\n            return annotationValidator;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error when creating AnnotationValidator class \" + clazz.getName(), e);\n        }\n    }\n\n}\n","Method after Refactoring":"package org.junit.experimental.validator;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Creates instances of Annotation Validators.\n */\npublic class AnnotationValidatorFactory {\n\n    private static ConcurrentHashMap<ValidateWith, AnnotationValidator> fAnnotationTypeToValidatorMap =\n            new ConcurrentHashMap<ValidateWith, AnnotationValidator>();\n\n    /**\n     * Creates the AnnotationValidator specified by the value in\n     * {@link org.junit.experimental.validator.ValidateWith}. Instances are\n     * cached. A null parameter return a default no-args {@link AnnotationValidator}.\n     *\n     * @param validateWithAnnotation\n     * @return An instance of the AnnotationValidator.\n     */\n    public AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n\n        AnnotationValidator validator = fAnnotationTypeToValidatorMap.get(validateWithAnnotation);\n        if (validator != null) {\n            return validator;\n        }\n\n        Class<? extends AnnotationValidator> clazz = validateWithAnnotation.value();\n        try {\n            AnnotationValidator annotationValidator = clazz.newInstance();\n            fAnnotationTypeToValidatorMap.putIfAbsent(validateWithAnnotation, annotationValidator);\n            return annotationValidator;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error when creating AnnotationValidator class \" + clazz.getName(), e);\n        }\n    }\n\n}\n","lineNo":27}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.ValidateWith;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private static Map<Class<? extends Annotation>, AnnotationValidator> fAnnotationTypeToValidatorMap =\n            new HashMap<Class<? extends Annotation>, AnnotationValidator>();\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            if (hasValidatorAnnotation(annotation.annotationType())) {\n                AnnotationValidator annotationValidator =\n                        getAnnotationValidator(annotation.annotationType());\n                annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n            if (hasValidatorAnnotation(annotation)) {\n                for (FrameworkMethod frameworkMethod : annotationMap.get(annotation)) {\n                    AnnotationValidator annotationValidator = getAnnotationValidator(annotation);\n                    annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    for (FrameworkField frameworkField : annotationMap.get(annotation)) {\n                        AnnotationValidator annotationValidator = getAnnotationValidator(annotation);\n                        annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n                    }\n                }\n        }\n    }\n\n    private boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        return getAnnotationValidator(annotationType) != null;\n    }\n\n    private AnnotationValidator getAnnotationValidator(Class<? extends Annotation> annotationType) {\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            return fAnnotationTypeToValidatorMap.get(annotationType);\n        }\n        AnnotationValidator annotationValidator = createAnnotationValidator(annotationType);\n        fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n        return annotationValidator;\n    }\n\n    private AnnotationValidator createAnnotationValidator(Class<? extends Annotation> annotationType) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation == null) {\n            return null;\n        }\n        Class<?> clazz = validateWithAnnotation.value();\n        try {\n            AnnotationValidator annotationValidator = (AnnotationValidator) clazz.newInstance();\n            fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n            return annotationValidator;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not create AnnotationValidator class \" + clazz.getName(), e);\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.AnnotationValidatorFactory;\nimport org.junit.experimental.validator.ValidateWith;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private final AnnotationValidatorFactory fAnnotationValidatorFactory =\n            new AnnotationValidatorFactory();\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n            }\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":136}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.ValidateWith;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private static Map<Class<? extends Annotation>, AnnotationValidator> fAnnotationTypeToValidatorMap =\n            new HashMap<Class<? extends Annotation>, AnnotationValidator>();\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            if (hasValidatorAnnotation(annotation.annotationType())) {\n                AnnotationValidator annotationValidator =\n                        getAnnotationValidator(annotation.annotationType());\n                annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n            if (hasValidatorAnnotation(annotation)) {\n                for (FrameworkMethod frameworkMethod : annotationMap.get(annotation)) {\n                    AnnotationValidator annotationValidator = getAnnotationValidator(annotation);\n                    annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    for (FrameworkField frameworkField : annotationMap.get(annotation)) {\n                        AnnotationValidator annotationValidator = getAnnotationValidator(annotation);\n                        annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n                    }\n                }\n        }\n    }\n\n    private boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        return getAnnotationValidator(annotationType) != null;\n    }\n\n    private AnnotationValidator getAnnotationValidator(Class<? extends Annotation> annotationType) {\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            return fAnnotationTypeToValidatorMap.get(annotationType);\n        }\n        AnnotationValidator annotationValidator = createAnnotationValidator(annotationType);\n        fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n        return annotationValidator;\n    }\n\n    private AnnotationValidator createAnnotationValidator(Class<? extends Annotation> annotationType) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation == null) {\n            return null;\n        }\n        Class<?> clazz = validateWithAnnotation.value();\n        try {\n            AnnotationValidator annotationValidator = (AnnotationValidator) clazz.newInstance();\n            fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n            return annotationValidator;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not create AnnotationValidator class \" + clazz.getName(), e);\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.AnnotationValidatorFactory;\nimport org.junit.experimental.validator.ValidateWith;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private final AnnotationValidatorFactory fAnnotationValidatorFactory =\n            new AnnotationValidatorFactory();\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n            }\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":137}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.Validator;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.*;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            if (hasValidatorAnnotation(annotation)) {\n                invokeValidatorsOnClass(annotation, errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnClass(Annotation annotation, List<Throwable> errors) {\n        List<AnnotationValidator> annotationValidators = createAnnotationValidators(annotation);\n        for (AnnotationValidator annotationValidator : annotationValidators) {\n            annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Set<FrameworkMethod> annotatedMethods = getTestClass().getAnnotatedMethods();\n        for (FrameworkMethod frameworkMethod : annotatedMethods) {\n            for (Annotation annotation : frameworkMethod.getAnnotations()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    invokeValidatorsOnMethod(annotation, frameworkMethod, errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnMethod(Annotation annotation,\n                                          FrameworkMethod frameworkMethod,\n                                          List<Throwable> errors) {\n        List<AnnotationValidator> annotationValidators = createAnnotationValidators(annotation);\n        for (AnnotationValidator annotationValidator : annotationValidators) {\n            annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Set<FrameworkField> annotatedFields = getTestClass().getAnnotatedFields();\n        for (FrameworkField frameworkField : annotatedFields) {\n            for (Annotation annotation : frameworkField.getAnnotations()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    invokeValidatorsOnField(annotation, frameworkField, errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnField(Annotation annotation,\n                                         FrameworkField frameworkField,\n                                         List<Throwable> errors) {\n        List<AnnotationValidator> annotationValidators = createAnnotationValidators(annotation);\n        for (AnnotationValidator annotationValidator : annotationValidators) {\n            annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n        }\n    }\n\n    private boolean hasValidatorAnnotation(Annotation annotation) {\n        Annotation[] annotations = annotation.annotationType().getAnnotations();\n        for (Annotation current : annotations) {\n            if (Validator.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private List<AnnotationValidator> createAnnotationValidators(Annotation annotation) {\n        List<AnnotationValidator> validators = new ArrayList<AnnotationValidator>();\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        Validator validatorAnnotation = annotationType.getAnnotation(Validator.class);\n        Class<?>[] classes = validatorAnnotation.value();\n        for (Class clazz : classes) {\n            try {\n                AnnotationValidator annotationValidator = (AnnotationValidator) clazz.newInstance();\n                validators.add(annotationValidator);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Could not create AnnotationValidator class \" + clazz.getName(), e);\n            }\n        }\n        return validators;\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.ValidateWith;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.*;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private static Map<Class<? extends Annotation>, AnnotationValidator> fAnnotationTypeToValidatorMap =\n            new HashMap<Class<? extends Annotation>, AnnotationValidator>();\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            if (hasValidatorAnnotation(annotation)) {\n                AnnotationValidator annotationValidator =\n                        getAnnotationValidator(annotation.annotationType());\n                annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap =\n                getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n            if (hasValidatorAnnotation(annotation)) {\n                for (FrameworkMethod frameworkMethod : annotationMap.get(annotation)) {\n                    AnnotationValidator annotationValidator =\n                            getAnnotationValidator(annotation);\n                    annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap =\n                getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    for (FrameworkField frameworkField : annotationMap.get(annotation)) {\n                        AnnotationValidator annotationValidator =\n                                getAnnotationValidator(annotation);\n                        annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n                    }\n                }\n        }\n    }\n\n    private boolean hasValidatorAnnotation(Annotation annotation) {\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        boolean hasValidatorAnnotation;\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            hasValidatorAnnotation = fAnnotationTypeToValidatorMap.get(annotationType) != null;\n        } else {\n            hasValidatorAnnotation = hasValidatorAnnotation(annotationType);\n            if (!hasValidatorAnnotation) {\n                fAnnotationTypeToValidatorMap.put(annotationType, null);\n            }\n        }\n\n        return hasValidatorAnnotation;\n    }\n\n    private boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        Annotation[] annotations = annotationType.getAnnotations();\n        for (Annotation current : annotations) {\n            if (ValidateWith.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private AnnotationValidator getAnnotationValidator(Class<? extends Annotation> annotationType) {\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            return fAnnotationTypeToValidatorMap.get(annotationType);\n        }\n        AnnotationValidator annotationValidator = createAnnotationValidator(annotationType);\n        fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n        return annotationValidator;\n    }\n\n    private AnnotationValidator createAnnotationValidator(Class<? extends Annotation> annotationType) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        Class<?> clazz = validateWithAnnotation.value();\n        try {\n            AnnotationValidator annotationValidator = (AnnotationValidator) clazz.newInstance();\n            fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n            return annotationValidator;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not create AnnotationValidator class \" + clazz.getName(), e);\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":149}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.Validator;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.*;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            if (hasValidatorAnnotation(annotation)) {\n                invokeValidatorsOnClass(annotation, errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnClass(Annotation annotation, List<Throwable> errors) {\n        List<AnnotationValidator> annotationValidators = createAnnotationValidators(annotation);\n        for (AnnotationValidator annotationValidator : annotationValidators) {\n            annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Set<FrameworkMethod> annotatedMethods = getTestClass().getAnnotatedMethods();\n        for (FrameworkMethod frameworkMethod : annotatedMethods) {\n            for (Annotation annotation : frameworkMethod.getAnnotations()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    invokeValidatorsOnMethod(annotation, frameworkMethod, errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnMethod(Annotation annotation,\n                                          FrameworkMethod frameworkMethod,\n                                          List<Throwable> errors) {\n        List<AnnotationValidator> annotationValidators = createAnnotationValidators(annotation);\n        for (AnnotationValidator annotationValidator : annotationValidators) {\n            annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Set<FrameworkField> annotatedFields = getTestClass().getAnnotatedFields();\n        for (FrameworkField frameworkField : annotatedFields) {\n            for (Annotation annotation : frameworkField.getAnnotations()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    invokeValidatorsOnField(annotation, frameworkField, errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnField(Annotation annotation,\n                                         FrameworkField frameworkField,\n                                         List<Throwable> errors) {\n        List<AnnotationValidator> annotationValidators = createAnnotationValidators(annotation);\n        for (AnnotationValidator annotationValidator : annotationValidators) {\n            annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n        }\n    }\n\n    private boolean hasValidatorAnnotation(Annotation annotation) {\n        Annotation[] annotations = annotation.annotationType().getAnnotations();\n        for (Annotation current : annotations) {\n            if (Validator.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private List<AnnotationValidator> createAnnotationValidators(Annotation annotation) {\n        List<AnnotationValidator> validators = new ArrayList<AnnotationValidator>();\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        Validator validatorAnnotation = annotationType.getAnnotation(Validator.class);\n        Class<?>[] classes = validatorAnnotation.value();\n        for (Class clazz : classes) {\n            try {\n                AnnotationValidator annotationValidator = (AnnotationValidator) clazz.newInstance();\n                validators.add(annotationValidator);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Could not create AnnotationValidator class \" + clazz.getName(), e);\n            }\n        }\n        return validators;\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.experimental.validator.AnnotationValidator;\nimport org.junit.experimental.validator.ValidateWith;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.*;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fChildrenLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fChildrenLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private static Map<Class<? extends Annotation>, AnnotationValidator> fAnnotationTypeToValidatorMap =\n            new HashMap<Class<? extends Annotation>, AnnotationValidator>();\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        invokeValidators(errors);\n    }\n\n    private void invokeValidators(List<Throwable> errors) {\n        invokeValidatorsOnClass(errors);\n        invokeValidatorsOnMethods(errors);\n        invokeValidatorsOnFields(errors);\n    }\n\n    private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            if (hasValidatorAnnotation(annotation)) {\n                AnnotationValidator annotationValidator =\n                        getAnnotationValidator(annotation.annotationType());\n                annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass(), errors);\n            }\n        }\n    }\n\n    private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap =\n                getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n            if (hasValidatorAnnotation(annotation)) {\n                for (FrameworkMethod frameworkMethod : annotationMap.get(annotation)) {\n                    AnnotationValidator annotationValidator =\n                            getAnnotationValidator(annotation);\n                    annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod(), errors);\n                }\n            }\n        }\n    }\n\n    private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap =\n                getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotation : annotationMap.keySet()) {\n                if (hasValidatorAnnotation(annotation)) {\n                    for (FrameworkField frameworkField : annotationMap.get(annotation)) {\n                        AnnotationValidator annotationValidator =\n                                getAnnotationValidator(annotation);\n                        annotationValidator.validateAnnotatedField(frameworkField.getField(), errors);\n                    }\n                }\n        }\n    }\n\n    private boolean hasValidatorAnnotation(Annotation annotation) {\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        boolean hasValidatorAnnotation;\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            hasValidatorAnnotation = fAnnotationTypeToValidatorMap.get(annotationType) != null;\n        } else {\n            hasValidatorAnnotation = hasValidatorAnnotation(annotationType);\n            if (!hasValidatorAnnotation) {\n                fAnnotationTypeToValidatorMap.put(annotationType, null);\n            }\n        }\n\n        return hasValidatorAnnotation;\n    }\n\n    private boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        Annotation[] annotations = annotationType.getAnnotations();\n        for (Annotation current : annotations) {\n            if (ValidateWith.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private AnnotationValidator getAnnotationValidator(Class<? extends Annotation> annotationType) {\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            return fAnnotationTypeToValidatorMap.get(annotationType);\n        }\n        AnnotationValidator annotationValidator = createAnnotationValidator(annotationType);\n        fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n        return annotationValidator;\n    }\n\n    private AnnotationValidator createAnnotationValidator(Class<? extends Annotation> annotationType) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        Class<?> clazz = validateWithAnnotation.value();\n        try {\n            AnnotationValidator annotationValidator = (AnnotationValidator) clazz.newInstance();\n            fAnnotationTypeToValidatorMap.put(annotationType, annotationValidator);\n            return annotationValidator;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not create AnnotationValidator class \" + clazz.getName(), e);\n        }\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fChildrenLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                T each = iter.next();\n                if (shouldRun(filter, each)) {\n                    try {\n                        filter.apply(each);\n                    } catch (NoTestsRemainException e) {\n                        iter.remove();\n                    }\n                } else {\n                    iter.remove();\n                }\n            }\n            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            if (fFilteredChildren.isEmpty()) {\n                throw new NoTestsRemainException();\n            }\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fChildrenLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fChildrenLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":163}
{"Smelly Sample":"package org.junit.internal.runners.statements;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.runners.model.Statement;\n\npublic class FailOnTimeout extends Statement {\n    private final Statement fOriginalStatement;\n    private final TimeUnit fTimeUnit;\n    private final long fTimeout;\n\n    public FailOnTimeout(Statement originalStatement, long millis) {\n        this(originalStatement, millis, TimeUnit.MILLISECONDS);\n    }\n\n    public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n        fTimeUnit = unit;\n    }\n\n    @Override\n    public void evaluate() throws Throwable {\n        FutureTask<Throwable> task = new FutureTask<Throwable>(new CallableStatement());\n        Thread thread = new Thread(task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n        \tthrow throwable;\n        }\n    }\n\n    /**\n     * Wait for the test task, returning the exception thrown by the test if the\n     * test failed, an exception indicating a timeout if the test timed out, or\n     * {@code null} if the test passed.\n     */\n    private Throwable getResult(FutureTask<Throwable> task, Thread thread) {\n        try {\n            return task.get(fTimeout, fTimeUnit);\n        } catch (InterruptedException e) {\n            return e; // caller will re-throw; no need to call Thread.interrupt()\n        } catch (ExecutionException e) {\n            // test failed; have caller re-throw the exception thrown by the test\n            return e.getCause();\n        } catch (TimeoutException e) {\n            return createTimeoutException(thread);\n        }\n    }\n\n    private Exception createTimeoutException(Thread thread) {\n        StackTraceElement[] stackTrace = thread.getStackTrace();\n        Exception exception = new Exception(String.format(\n                \"test timed out after %d %s\", fTimeout, fTimeUnit.name().toLowerCase()));\n        if (stackTrace != null) {\n            exception.setStackTrace(stackTrace);\n            thread.interrupt();\n        }\n        return exception;\n    }\n\n    private class CallableStatement implements Callable<Throwable> {\n\n        public Throwable call() throws Exception {\n            try {\n                fOriginalStatement.evaluate();\n            } catch (Exception e) {\n                throw e;\n            } catch (Throwable e) {\n                return e;\n            }\n            return null;\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.internal.runners.statements;\n\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.internal.runners.ExceptionWithThread;\nimport org.junit.runners.model.Statement;\n\npublic class FailOnTimeout extends Statement {\n    private final Statement fOriginalStatement;\n    private final TimeUnit fTimeUnit;\n    private final long fTimeout;\n\tprivate ThreadGroup fThreadGroup = null;\n\n    public FailOnTimeout(Statement originalStatement, long millis) {\n        this(originalStatement, millis, TimeUnit.MILLISECONDS);\n    }\n\n    public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n        fTimeUnit = unit;\n    }\n\n    @Override\n    public void evaluate() throws Throwable {\n        FutureTask<Throwable> task = new FutureTask<Throwable>(new CallableStatement());\n\t\tfThreadGroup = new ThreadGroup (\"FailOnTimeoutGroup\");\n        Thread thread = new Thread(fThreadGroup, task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n        \tthrow throwable;\n        }\n    }\n\n    /**\n     * Wait for the test task, returning the exception thrown by the test if the\n     * test failed, an exception indicating a timeout if the test timed out, or\n     * {@code null} if the test passed.\n     */\n    private Throwable getResult(FutureTask<Throwable> task, Thread thread) {\n        try {\n            return task.get(fTimeout, fTimeUnit);\n        } catch (InterruptedException e) {\n            return e; // caller will re-throw; no need to call Thread.interrupt()\n        } catch (ExecutionException e) {\n            // test failed; have caller re-throw the exception thrown by the test\n            return e.getCause();\n        } catch (TimeoutException e) {\n            return createTimeoutException(thread);\n        }\n    }\n\n    private Exception createTimeoutException(Thread thread) {\n        StackTraceElement[] stackTrace = thread.getStackTrace();\n        final Thread stuckThread = getStuckThread (thread);\n        String message = String.format(\n                \"test timed out after %d %s\", fTimeout, fTimeUnit.name().toLowerCase());\n        Exception exception = (stuckThread == null) \n        \t? new Exception(message) \n            : new ExceptionWithThread (message, stuckThread,\n            \t\t\"Appears to be stuck in thread {0}\");\n        if (stackTrace != null) {\n            exception.setStackTrace(stackTrace);\n            thread.interrupt();\n        }\n        return exception;\n    }\n\n    /**\n     * Determines whether the test appears to be stuck in some thread other than\n     * the \"main thread\" (the one created to run the test).\n     * @param mainThread The main thread created by {@code evaluate()}\n     * @return The thread which appears to be causing the problem, if different from\n     * {@code mainThread}, or {@code null} if the main thread appears to be the\n     * problem or if the thread cannot be determined.  The return value is never equal \n     * to {@code mainThread}.\n     */\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); // this is just an estimate\n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\t// if there are too many threads to fit into the array, enumerate's result\n    \t\t// is >= the array's length; therefore we can't trust that it returned all\n    \t\t// the threads.  Try again.\n    \t\tif (enumCount < enumSize) break;\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t// threads are proliferating too fast for us.  Bail before we get into \n    \t\t// trouble.\n    \t} \n    \t\n    \t// Now that we have all the threads in the test's thread group: Assume that\n    \t// any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n    \t// If just one, we return that (unless it equals threadMain).  If there's more\n    \t// than one, pick the one that's using the most CPU time, if this feature is\n    \t// supported.\n    \tThread firstRunnable = null;\n    \tThread mostCpu = null;\n    \tlong maxCpuTime = 0;\n    \tint runnableCount = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n    \t\t\trunnableCount++;\n    \t\t\tif (firstRunnable == null) firstRunnable = threads[i];\n    \t\t\tif (mxBean.isThreadCpuTimeSupported()) {\n    \t\t\t\ttry {\n    \t\t\t\t\tlong cpuTime = mxBean.getThreadCpuTime(threads[i].getId());\n    \t\t\t\t\tif (mostCpu == null || cpuTime > maxCpuTime) {\n    \t\t\t\t\t\tmostCpu = threads[i];\n    \t\t\t\t\t\tmaxCpuTime = cpuTime;\n    \t\t\t\t\t}\n    \t\t\t\t} catch (UnsupportedOperationException e) {\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}   \t\t\t\n    \t}\n    \tThread stuckThread =\n    \t\t\t(runnableCount == 1) ? firstRunnable :\n    \t\t\t\t((mostCpu != null) ? mostCpu : firstRunnable);\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\n\tprivate class CallableStatement implements Callable<Throwable> {\n        public Throwable call() throws Exception {\n            try {\n                fOriginalStatement.evaluate();\n            } catch (Exception e) {\n                throw e;\n            } catch (Throwable e) {\n                return e;\n            }\n            return null;\n        }\n    }\n}\n","lineNo":64}
{"Smelly Sample":"package org.junit.runner.notification;\n\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.io.StringWriter;\n\nimport org.junit.runner.Description;\n\n/**\n * A <code>Failure<\/code> holds a description of the failed test and the\n * exception that was thrown while running it. In most cases the {@link org.junit.runner.Description}\n * will be of a single test. However, if problems are encountered while constructing the\n * test (for example, if a {@link org.junit.BeforeClass} method is not static), it may describe\n * something other than a single test.\n *\n * @since 4.0\n */\npublic class Failure implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private final Description fDescription;\n    private final Throwable fThrownException;\n\n    /**\n     * Constructs a <code>Failure<\/code> with the given description and exception.\n     *\n     * @param description a {@link org.junit.runner.Description} of the test that failed\n     * @param thrownException the exception that was thrown while running the test\n     */\n    public Failure(Description description, Throwable thrownException) {\n        fThrownException = thrownException;\n        fDescription = description;\n    }\n\n    /**\n     * @return a user-understandable label for the test\n     */\n    public String getTestHeader() {\n        return fDescription.getDisplayName();\n    }\n\n    /**\n     * @return the raw description of the context of the failure.\n     */\n    public Description getDescription() {\n        return fDescription;\n    }\n\n    /**\n     * @return the exception thrown\n     */\n\n    public Throwable getException() {\n        return fThrownException;\n    }\n\n    @Override\n    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(getTestHeader() + \": \" + fThrownException.getMessage());\n        return buffer.toString();\n    }\n\n    /**\n     * Convenience method\n     *\n     * @return the printed form of the exception\n     */\n    public String getTrace() {\n        StringWriter stringWriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(stringWriter);\n        getException().printStackTrace(writer);\n        StringBuffer buffer = stringWriter.getBuffer();\n        return buffer.toString();\n    }\n\n    /**\n     * Convenience method\n     *\n     * @return the message of the thrown exception\n     */\n    public String getMessage() {\n        return getException().getMessage();\n    }\n}\n","Method after Refactoring":"package org.junit.runner.notification;\n\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.io.StringWriter;\n\nimport org.junit.internal.runners.ExceptionWithThread;\nimport org.junit.runner.Description;\n\n/**\n * A <code>Failure<\/code> holds a description of the failed test and the\n * exception that was thrown while running it. In most cases the {@link org.junit.runner.Description}\n * will be of a single test. However, if problems are encountered while constructing the\n * test (for example, if a {@link org.junit.BeforeClass} method is not static), it may describe\n * something other than a single test.\n *\n * @since 4.0\n */\npublic class Failure implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private final Description fDescription;\n    private final Throwable fThrownException;\n\n    /**\n     * Constructs a <code>Failure<\/code> with the given description and exception.\n     *\n     * @param description a {@link org.junit.runner.Description} of the test that failed\n     * @param thrownException the exception that was thrown while running the test\n     */\n    public Failure(Description description, Throwable thrownException) {\n        fThrownException = thrownException;\n        fDescription = description;\n    }\n\n    /**\n     * @return a user-understandable label for the test\n     */\n    public String getTestHeader() {\n        return fDescription.getDisplayName();\n    }\n\n    /**\n     * @return the raw description of the context of the failure.\n     */\n    public Description getDescription() {\n        return fDescription;\n    }\n\n    /**\n     * @return the exception thrown\n     */\n\n    public Throwable getException() {\n        return fThrownException;\n    }\n\n    @Override\n    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(getTestHeader() + \": \" + fThrownException.getMessage());\n        return buffer.toString();\n    }\n\n    /**\n     * Convenience method\n     *\n     * @return the printed form of the exception\n     */\n    public String getTrace() {\n        StringWriter stringWriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(stringWriter);\n        Throwable exc = getException();\n        exc.printStackTrace(writer);\n        if (exc instanceof ExceptionWithThread) {\n        \tExceptionWithThread ewt = (ExceptionWithThread) exc;\n        \tif (ewt.getDescription() == null)  {\n        \t    writer.println(\"Stack for thread \" + ewt.getThread().getName() + \":\");\n        \t} else {\n        \t\twriter.println(ewt.getDescription() + \":\");\n        \t}\n        \tStackTraceElement[] threadTrace = ewt.getThreadStackTrace();\n        \tfor (StackTraceElement traceElement : threadTrace) {\n        \t\twriter.println(\"\\tat \" + traceElement);\n        \t}\n        }\n        StringBuffer buffer = stringWriter.getBuffer();\n        return buffer.toString();\n    }\n\n    /**\n     * Convenience method\n     *\n     * @return the message of the thrown exception\n     */\n    public String getMessage() {\n        return getException().getMessage();\n    }\n}\n","lineNo":72}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = new ArrayList<TestRule>(fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class));\n\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            try {\n                for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                    T each = iter.next();\n                    if (shouldRun(filter, each)) {\n                        try {\n                            filter.apply(each);\n                        } catch (NoTestsRemainException e) {\n                            iter.remove();\n                        }\n                    } else {\n                        iter.remove();\n                    }\n                }\n            } finally {\n                fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            }\n        }\n\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fLock = new Object();\n    private final TestClass fTestClass;\n\n    // Guarded by fLock\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result = new ArrayList<TestRule>(result);\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fLock) {\n            List<T> filteredChildren = new ArrayList<T>(getFilteredChildren());\n            try {\n                for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {\n                    T each = iter.next();\n                    if (shouldRun(filter, each)) {\n                        try {\n                            filter.apply(each);\n                        } catch (NoTestsRemainException e) {\n                            iter.remove();\n                        }\n                    } else {\n                        iter.remove();\n                    }\n                }\n            } finally {\n                fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n            }\n        }\n\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fLock) {\n            for (T each : getFilteredChildren()) {\n                sorter.apply(each);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fLock) {\n                if (fFilteredChildren == null) {\n                    fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n                }\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":214}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final TestClass fTestClass;\n\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        for (Iterator<T> iter = getFilteredChildren().iterator(); iter.hasNext(); ) {\n            T each = iter.next();\n            if (shouldRun(filter, each)) {\n                try {\n                    filter.apply(each);\n                } catch (NoTestsRemainException e) {\n                    iter.remove();\n                }\n            } else {\n                iter.remove();\n            }\n        }\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        for (T each : getFilteredChildren()) {\n            sortChild(each, sorter);\n        }\n        List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n        Collections.sort(sortedChildren, comparator(sorter));\n        getFilteredChildren().clear();\n        getFilteredChildren().addAll(sortedChildren);\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            fFilteredChildren = new ConcurrentLinkedQueue<T>(getChildren());\n        }\n        return fFilteredChildren;\n    }\n\n    private void sortChild(T child, Sorter sorter) {\n        sorter.apply(child);\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final Object fLock = new Object();\n    private final TestClass fTestClass;\n\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        synchronized (fLock) {\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            try {\n                for (Iterator<T> iter = sortedChildren.iterator(); iter.hasNext(); ) {\n                    T each = iter.next();\n                    if (shouldRun(filter, each)) {\n                        try {\n                            filter.apply(each);\n                        } catch (NoTestsRemainException e) {\n                            iter.remove();\n                        }\n                    } else {\n                        iter.remove();\n                    }\n                }\n            } finally {\n                setFilteredChildren(sortedChildren);\n            }\n        }\n\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        synchronized (fLock) {\n            for (T each : getFilteredChildren()) {\n                sortChild(each, sorter);\n            }\n            List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n            Collections.sort(sortedChildren, comparator(sorter));\n            setFilteredChildren(sortedChildren);\n        }\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private void setFilteredChildren(Collection<T> filteredChildren) {\n        fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            synchronized (fLock) {\n                setFilteredChildren(getChildren());\n            }\n        }\n        return fFilteredChildren;\n    }\n\n    private void sortChild(T child, Sorter sorter) {\n        sorter.apply(child);\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":329}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final TestClass fTestClass;\n\n    private Sorter fSorter = Sorter.NULL;\n\n    private List<T> fFilteredChildren = null;\n\n    private RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        for (final T each : getFilteredChildren()) {\n            fScheduler.schedule(new Runnable() {\n                public void run() {\n                    ParentRunner.this.runChild(each, notifier);\n                }\n            });\n        }\n        fScheduler.finished();\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        for (Iterator<T> iter = getFilteredChildren().iterator(); iter.hasNext(); ) {\n            T each = iter.next();\n            if (shouldRun(filter, each)) {\n                try {\n                    filter.apply(each);\n                } catch (NoTestsRemainException e) {\n                    iter.remove();\n                }\n            } else {\n                iter.remove();\n            }\n        }\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        fSorter = sorter;\n        for (T each : getFilteredChildren()) {\n            sortChild(each);\n        }\n        Collections.sort(getFilteredChildren(), comparator());\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private List<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            fFilteredChildren = new ArrayList<T>(getChildren());\n        }\n        return fFilteredChildren;\n    }\n\n    private void sortChild(T child) {\n        fSorter.apply(child);\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator() {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return fSorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final TestClass fTestClass;\n\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        for (Iterator<T> iter = getFilteredChildren().iterator(); iter.hasNext(); ) {\n            T each = iter.next();\n            if (shouldRun(filter, each)) {\n                try {\n                    filter.apply(each);\n                } catch (NoTestsRemainException e) {\n                    iter.remove();\n                }\n            } else {\n                iter.remove();\n            }\n        }\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        for (T each : getFilteredChildren()) {\n            sortChild(each, sorter);\n        }\n        List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n        Collections.sort(sortedChildren, comparator(sorter));\n        getFilteredChildren().clear();\n        getFilteredChildren().addAll(sortedChildren);\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            fFilteredChildren = new ConcurrentLinkedQueue<T>(getChildren());\n        }\n        return fFilteredChildren;\n    }\n\n    private void sortChild(T child, Sorter sorter) {\n        sorter.apply(child);\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":235}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final TestClass fTestClass;\n\n    private Sorter fSorter = Sorter.NULL;\n\n    private List<T> fFilteredChildren = null;\n\n    private RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        for (final T each : getFilteredChildren()) {\n            fScheduler.schedule(new Runnable() {\n                public void run() {\n                    ParentRunner.this.runChild(each, notifier);\n                }\n            });\n        }\n        fScheduler.finished();\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        for (Iterator<T> iter = getFilteredChildren().iterator(); iter.hasNext(); ) {\n            T each = iter.next();\n            if (shouldRun(filter, each)) {\n                try {\n                    filter.apply(each);\n                } catch (NoTestsRemainException e) {\n                    iter.remove();\n                }\n            } else {\n                iter.remove();\n            }\n        }\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        fSorter = sorter;\n        for (T each : getFilteredChildren()) {\n            sortChild(each);\n        }\n        Collections.sort(getFilteredChildren(), comparator());\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private List<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            fFilteredChildren = new ArrayList<T>(getChildren());\n        }\n        return fFilteredChildren;\n    }\n\n    private void sortChild(T child) {\n        fSorter.apply(child);\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator() {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return fSorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_METHOD_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.CLASS_RULE_VALIDATOR;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.RunnerScheduler;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Provides most of the functionality specific to a Runner that implements a\n * \"parent node\" in the test tree, with children defined by objects of some data\n * type {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n * {@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\n * must implement finding the children of the node, describing each child, and\n * running each child. ParentRunner will filter and sort children, handle\n * {@code @BeforeClass} and {@code @AfterClass} methods,\n * handle annotated {@link ClassRule}s, create a composite\n * {@link Description}, and run children sequentially.\n *\n * @since 4.5\n */\npublic abstract class ParentRunner<T> extends Runner implements Filterable,\n        Sortable {\n    private final TestClass fTestClass;\n\n    private volatile Collection<T> fFilteredChildren = null;\n\n    private volatile RunnerScheduler fScheduler = new RunnerScheduler() {\n        public void schedule(Runnable childStatement) {\n            childStatement.run();\n        }\n\n        public void finished() {\n            // do nothing\n        }\n    };\n\n    /**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }\n\n    //\n    // Must be overridden\n    //\n\n    /**\n     * Returns a list of objects that define the children of this Runner.\n     */\n    protected abstract List<T> getChildren();\n\n    /**\n     * Returns a {@link Description} for {@code child}, which can be assumed to\n     * be an element of the list returned by {@link ParentRunner#getChildren()}\n     */\n    protected abstract Description describeChild(T child);\n\n    /**\n     * Runs the test corresponding to {@code child}, which can be assumed to be\n     * an element of the list returned by {@link ParentRunner#getChildren()}.\n     * Subclasses are responsible for making sure that relevant test events are\n     * reported through {@code notifier}\n     */\n    protected abstract void runChild(T child, RunNotifier notifier);\n\n    //\n    // May be overridden\n    //\n\n    /**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n    }\n\n    /**\n     * Adds to {@code errors} if any method in this class is annotated with\n     * {@code annotation}, but:\n     * <ul>\n     * <li>is not public, or\n     * <li>takes parameters, or\n     * <li>returns something other than void, or\n     * <li>is static (given {@code isStatic is false}), or\n     * <li>is not static (given {@code isStatic is true}).\n     */\n    protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,\n            boolean isStatic, List<Throwable> errors) {\n        List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);\n\n        for (FrameworkMethod eachTestMethod : methods) {\n            eachTestMethod.validatePublicVoidNoArg(isStatic, errors);\n        }\n    }\n\n    private void validateClassRules(List<Throwable> errors) {\n        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);\n        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n    }\n\n    /**\n     * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing.\n     * Here is an outline of the implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).<\/li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before any of the previous steps; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * <\/ul>\n     *\n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n        return statement;\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n     * and superclasses before executing {@code statement}; if any throws an\n     * Exception, stop execution and pass the exception on.\n     */\n    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = fTestClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n     * and superclasses before executing {@code statement}; all AfterClass methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     */\n    protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = fTestClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }\n\n    /**\n     * Returns a {@link Statement}: apply all\n     * static fields assignable to {@link TestRule}\n     * annotated with {@link ClassRule}.\n     *\n     * @param statement the base statement\n     * @return a RunRules statement if any class-level {@link Rule}s are\n     *         found, or the base statement\n     */\n    private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }\n\n    /**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = fTestClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n\n        result.addAll(fTestClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n\n        return result;\n    }\n\n    /**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier);\n            }\n        };\n    }\n\n    private void runChildren(final RunNotifier notifier) {\n        final RunnerScheduler scheduler = fScheduler;\n        try {\n            for (final T each : getFilteredChildren()) {\n                scheduler.schedule(new Runnable() {\n                    public void run() {\n                        ParentRunner.this.runChild(each, notifier);\n                    }\n                });\n            }\n        } finally {\n            scheduler.finished();\n        }\n    }\n\n    /**\n     * Returns a name used to describe this Runner\n     */\n    protected String getName() {\n        return fTestClass.getName();\n    }\n\n    //\n    // Available for subclasses\n    //\n\n    /**\n     * Returns a {@link TestClass} object wrapping the class to be executed.\n     */\n    public final TestClass getTestClass() {\n        return fTestClass;\n    }\n\n    /**\n     * Runs a {@link Statement} that represents a leaf (aka atomic) test.\n     */\n    protected final void runLeaf(Statement statement, Description description,\n            RunNotifier notifier) {\n        EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n        eachNotifier.fireTestStarted();\n        try {\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            eachNotifier.addFailedAssumption(e);\n        } catch (Throwable e) {\n            eachNotifier.addFailure(e);\n        } finally {\n            eachNotifier.fireTestFinished();\n        }\n    }\n\n    /**\n     * @return the annotations that should be attached to this runner's\n     *         description.\n     */\n    protected Annotation[] getRunnerAnnotations() {\n        return fTestClass.getAnnotations();\n    }\n\n    //\n    // Implementation of Runner\n    //\n\n    @Override\n    public Description getDescription() {\n        Description description = Description.createSuiteDescription(getName(),\n                getRunnerAnnotations());\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }\n\n    @Override\n    public void run(final RunNotifier notifier) {\n        EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n                getDescription());\n        try {\n            Statement statement = classBlock(notifier);\n            statement.evaluate();\n        } catch (AssumptionViolatedException e) {\n            testNotifier.fireTestIgnored();\n        } catch (StoppedByUserException e) {\n            throw e;\n        } catch (Throwable e) {\n            testNotifier.addFailure(e);\n        }\n    }\n\n    //\n    // Implementation of Filterable and Sortable\n    //\n\n    public void filter(Filter filter) throws NoTestsRemainException {\n        for (Iterator<T> iter = getFilteredChildren().iterator(); iter.hasNext(); ) {\n            T each = iter.next();\n            if (shouldRun(filter, each)) {\n                try {\n                    filter.apply(each);\n                } catch (NoTestsRemainException e) {\n                    iter.remove();\n                }\n            } else {\n                iter.remove();\n            }\n        }\n        if (getFilteredChildren().isEmpty()) {\n            throw new NoTestsRemainException();\n        }\n    }\n\n    public void sort(Sorter sorter) {\n        for (T each : getFilteredChildren()) {\n            sortChild(each, sorter);\n        }\n        List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n        Collections.sort(sortedChildren, comparator(sorter));\n        getFilteredChildren().clear();\n        getFilteredChildren().addAll(sortedChildren);\n    }\n\n    //\n    // Private implementation\n    //\n\n    private void validate() throws InitializationError {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        collectInitializationErrors(errors);\n        if (!errors.isEmpty()) {\n            throw new InitializationError(errors);\n        }\n    }\n\n    private Collection<T> getFilteredChildren() {\n        if (fFilteredChildren == null) {\n            fFilteredChildren = new ConcurrentLinkedQueue<T>(getChildren());\n        }\n        return fFilteredChildren;\n    }\n\n    private void sortChild(T child, Sorter sorter) {\n        sorter.apply(child);\n    }\n\n    private boolean shouldRun(Filter filter, T each) {\n        return filter.shouldRun(describeChild(each));\n    }\n\n    private Comparator<? super T> comparator(final Sorter sorter) {\n        return new Comparator<T>() {\n            public int compare(T o1, T o2) {\n                return sorter.compare(describeChild(o1), describeChild(o2));\n            }\n        };\n    }\n\n    /**\n     * Sets a scheduler that determines the order and parallelization\n     * of children.  Highly experimental feature that may change.\n     */\n    public void setScheduler(RunnerScheduler scheduler) {\n        this.fScheduler = scheduler;\n    }\n}\n","lineNo":349}
{"Smelly Sample":"package org.junit.runner;\n\nimport java.util.List;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.experimental.categories.IncludeCategories;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.tests.TestSystem;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.startsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class JUnitCommandLineParserTest {\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    private JUnitCommandLineParser jUnitCommandLineParser = new JUnitCommandLineParser(new TestSystem());\n\n    @Test\n    public void shouldStopParsingOptionsUponDoubleHyphenArg() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"--\", \"--2\", \"--3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"--2\", \"--3\"}));\n    }\n\n    @Test\n    public void shouldParseFilterArgWithEqualsSyntax() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(JUnitCommandLineParser.CommandLineParserError.class));\n    }\n\n    @Test\n    public void shouldParseFilterArgInWhichValueIsASeparateArg() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\",\n                IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldStopParsingOptionsUponNonOption() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"2\", \"3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"2\", \"3\"}));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownOption() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--unknown-option\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(JUnitCommandLineParser.CommandLineParserError.class));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUncreatedFilter() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + FilterFactoryStub.class.getName()\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(FilterFactory.FilterNotCreatedException.class));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=NonExistentFilterFactory\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(FilterFactories.FilterFactoryNotCreatedException.class));\n    }\n\n    @Test\n    public void shouldAddToClasses() {\n        jUnitCommandLineParser.parseParameters(new String[]{\n                DummyTest.class.getName()\n        });\n\n        List<Class<?>> classes = jUnitCommandLineParser.getClasses();\n        Class<?> testClass = classes.get(0);\n\n        assertThat(testClass.getName(), is(DummyTest.class.getName()));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownTestClass() throws Exception {\n        jUnitCommandLineParser.parseParameters(new String[]{\n                \"UnknownTestClass\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(ClassNotFoundException.class));\n    }\n\n    public static class FilterFactoryStub implements FilterFactory {\n        @Override\n        public Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n            throw new FilterNotCreatedException(new Exception(\"stub\"));\n        }\n    }\n\n    public static interface DummyCategory0 {\n    }\n\n    public static class DummyTest {\n        @Test\n        public void dummyTest() {\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.runner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.experimental.categories.IncludeCategories;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.tests.TestSystem;\n\nimport static org.hamcrest.CoreMatchers.allOf;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.startsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class JUnitCommandLineParserTest {\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    private JUnitCommandLineParser jUnitCommandLineParser = new JUnitCommandLineParser(new TestSystem());\n\n    @Test\n    public void shouldStopParsingOptionsUponDoubleHyphenArg() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"--\", \"--2\", \"--3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"--2\", \"--3\"}));\n    }\n\n    @Test\n    public void shouldParseFilterArgWithEqualsSyntax() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\"\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(JUnitCommandLineParser.CommandLineParserError.class.getName()),\n                containsString(\"--filter value not specified\")));\n    }\n\n    @Test\n    public void shouldParseFilterArgInWhichValueIsASeparateArg() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\",\n                IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldStopParsingOptionsUponNonOption() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"2\", \"3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"2\", \"3\"}));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownOption() throws Exception {\n        String unknownOption = \"--unknown-option\";\n        jUnitCommandLineParser.parseOptions(new String[]{\n                unknownOption\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(JUnitCommandLineParser.CommandLineParserError.class.getName()),\n                containsString(unknownOption)));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUncreatedFilter() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + FilterFactoryStub.class.getName()\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(FilterFactory.FilterNotCreatedException.class.getName()),\n                containsString(\"stub\")));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n        String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + nonExistentFilterFactory\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(FilterFactories.FilterFactoryNotCreatedException.class.getName()),\n                containsString(nonExistentFilterFactory)));\n    }\n\n    @Test\n    public void shouldAddToClasses() {\n        jUnitCommandLineParser.parseParameters(new String[]{\n                DummyTest.class.getName()\n        });\n\n        List<Class<?>> classes = jUnitCommandLineParser.getClasses();\n        Class<?> testClass = classes.get(0);\n\n        assertThat(testClass.getName(), is(DummyTest.class.getName()));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownTestClass() throws Exception {\n        String unknownTestClass = \"UnknownTestClass\";\n        jUnitCommandLineParser.parseParameters(new String[]{\n                unknownTestClass\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(ClassNotFoundException.class.getName()),\n                containsString(unknownTestClass)));\n    }\n\n    private static class RunNotifierSpy extends RunNotifier {\n        private List<Failure> failures = new ArrayList<Failure>();\n\n        @Override\n        public void fireTestFailure(Failure failure) {\n            failures.add(failure);\n        }\n\n        public List<Failure> getFailures() {\n            return failures;\n        }\n    }\n\n    public static class FilterFactoryStub implements FilterFactory {\n        @Override\n        public Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n            throw new FilterNotCreatedException(new Exception(\"stub\"));\n        }\n    }\n\n    public static interface DummyCategory0 {\n    }\n\n    public static class DummyTest {\n        @Test\n        public void dummyTest() {\n        }\n    }\n}\n","lineNo":85}
{"Smelly Sample":"package org.junit.runner;\n\nimport java.util.List;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.experimental.categories.IncludeCategories;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.tests.TestSystem;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.startsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class JUnitCommandLineParserTest {\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    private JUnitCommandLineParser jUnitCommandLineParser = new JUnitCommandLineParser(new TestSystem());\n\n    @Test\n    public void shouldStopParsingOptionsUponDoubleHyphenArg() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"--\", \"--2\", \"--3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"--2\", \"--3\"}));\n    }\n\n    @Test\n    public void shouldParseFilterArgWithEqualsSyntax() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(JUnitCommandLineParser.CommandLineParserError.class));\n    }\n\n    @Test\n    public void shouldParseFilterArgInWhichValueIsASeparateArg() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\",\n                IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldStopParsingOptionsUponNonOption() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"2\", \"3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"2\", \"3\"}));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownOption() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--unknown-option\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(JUnitCommandLineParser.CommandLineParserError.class));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUncreatedFilter() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + FilterFactoryStub.class.getName()\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(FilterFactory.FilterNotCreatedException.class));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=NonExistentFilterFactory\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(FilterFactories.FilterFactoryNotCreatedException.class));\n    }\n\n    @Test\n    public void shouldAddToClasses() {\n        jUnitCommandLineParser.parseParameters(new String[]{\n                DummyTest.class.getName()\n        });\n\n        List<Class<?>> classes = jUnitCommandLineParser.getClasses();\n        Class<?> testClass = classes.get(0);\n\n        assertThat(testClass.getName(), is(DummyTest.class.getName()));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownTestClass() throws Exception {\n        jUnitCommandLineParser.parseParameters(new String[]{\n                \"UnknownTestClass\"\n        });\n\n        List<Failure> failures = jUnitCommandLineParser.getFailures();\n        Throwable exception = failures.get(0).getException();\n\n        assertThat(exception, instanceOf(ClassNotFoundException.class));\n    }\n\n    public static class FilterFactoryStub implements FilterFactory {\n        @Override\n        public Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n            throw new FilterNotCreatedException(new Exception(\"stub\"));\n        }\n    }\n\n    public static interface DummyCategory0 {\n    }\n\n    public static class DummyTest {\n        @Test\n        public void dummyTest() {\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.runner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.experimental.categories.IncludeCategories;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.tests.TestSystem;\n\nimport static org.hamcrest.CoreMatchers.allOf;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.startsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class JUnitCommandLineParserTest {\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    private JUnitCommandLineParser jUnitCommandLineParser = new JUnitCommandLineParser(new TestSystem());\n\n    @Test\n    public void shouldStopParsingOptionsUponDoubleHyphenArg() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"--\", \"--2\", \"--3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"--2\", \"--3\"}));\n    }\n\n    @Test\n    public void shouldParseFilterArgWithEqualsSyntax() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\"\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(JUnitCommandLineParser.CommandLineParserError.class.getName()),\n                containsString(\"--filter value not specified\")));\n    }\n\n    @Test\n    public void shouldParseFilterArgInWhichValueIsASeparateArg() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter\",\n                IncludeCategories.class.getName() + \"=\" + DummyCategory0.class.getName()\n        });\n\n        Filter filter = jUnitCommandLineParser.getFilter();\n\n        assertThat(filter.describe(), startsWith(\"includes \"));\n    }\n\n    @Test\n    public void shouldStopParsingOptionsUponNonOption() throws Exception {\n        String[] restOfArgs = jUnitCommandLineParser.parseOptions(new String[]{\n                \"--0\", \"--1\", \"2\", \"3\"\n        });\n\n        assertThat(restOfArgs, is(new String[]{\"2\", \"3\"}));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownOption() throws Exception {\n        String unknownOption = \"--unknown-option\";\n        jUnitCommandLineParser.parseOptions(new String[]{\n                unknownOption\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(JUnitCommandLineParser.CommandLineParserError.class.getName()),\n                containsString(unknownOption)));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUncreatedFilter() throws Exception {\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + FilterFactoryStub.class.getName()\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(FilterFactory.FilterNotCreatedException.class.getName()),\n                containsString(\"stub\")));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n        String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n        jUnitCommandLineParser.parseOptions(new String[]{\n                \"--filter=\" + nonExistentFilterFactory\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(FilterFactories.FilterFactoryNotCreatedException.class.getName()),\n                containsString(nonExistentFilterFactory)));\n    }\n\n    @Test\n    public void shouldAddToClasses() {\n        jUnitCommandLineParser.parseParameters(new String[]{\n                DummyTest.class.getName()\n        });\n\n        List<Class<?>> classes = jUnitCommandLineParser.getClasses();\n        Class<?> testClass = classes.get(0);\n\n        assertThat(testClass.getName(), is(DummyTest.class.getName()));\n    }\n\n    @Test\n    public void shouldCreateFailureUponUnknownTestClass() throws Exception {\n        String unknownTestClass = \"UnknownTestClass\";\n        jUnitCommandLineParser.parseParameters(new String[]{\n                unknownTestClass\n        });\n\n        Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n        Description description = runner.getDescription().getChildren().get(0);\n\n        assertThat(description.toString(), allOf(\n                containsString(\"initializationError: \"),\n                containsString(ClassNotFoundException.class.getName()),\n                containsString(unknownTestClass)));\n    }\n\n    private static class RunNotifierSpy extends RunNotifier {\n        private List<Failure> failures = new ArrayList<Failure>();\n\n        @Override\n        public void fireTestFailure(Failure failure) {\n            failures.add(failure);\n        }\n\n        public List<Failure> getFailures() {\n            return failures;\n        }\n    }\n\n    public static class FilterFactoryStub implements FilterFactory {\n        @Override\n        public Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n            throw new FilterNotCreatedException(new Exception(\"stub\"));\n        }\n    }\n\n    public static interface DummyCategory0 {\n    }\n\n    public static class DummyTest {\n        @Test\n        public void dummyTest() {\n        }\n    }\n}\n","lineNo":144}
{"Smelly Sample":"package org.junit.experimental.theories;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\npublic class Theories extends BlockJUnit4ClassRunner {\n    public Theories(Class<?> klass) throws InitializationError {\n        super(klass);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n        validateDataPointFields(errors);\n        validateDataPointMethods(errors);\n    }\n\n    private void validateDataPointFields(List<Throwable> errors) {\n        Field[] fields = getTestClass().getJavaClass().getDeclaredFields();\n\n        for (Field field : fields) {\n            if (field.getAnnotation(DataPoint.class) == null && field.getAnnotation(DataPoints.class) == null) {\n                continue;\n            }\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Error(\"DataPoint field \" + field.getName() + \" must be static\"));\n            }\n            if (!Modifier.isPublic(field.getModifiers())) {\n                errors.add(new Error(\"DataPoint field \" + field.getName() + \" must be public\"));\n            }\n        }\n    }\n\n    private void validateDataPointMethods(List<Throwable> errors) {\n        Method[] methods = getTestClass().getJavaClass().getDeclaredMethods();\n        \n        for (Method method : methods) {\n            if (method.getAnnotation(DataPoint.class) == null && method.getAnnotation(DataPoints.class) == null) {\n                continue;\n            }\n            if (!Modifier.isStatic(method.getModifiers())) {\n                errors.add(new Error(\"DataPoint method \" + method.getName() + \" must be static\"));\n            }\n            if (!Modifier.isPublic(method.getModifiers())) {\n                errors.add(new Error(\"DataPoint method \" + method.getName() + \" must be public\"));\n            }\n        }\n    }\n\n    @Override\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n    }\n\n    @Override\n    protected void validateTestMethods(List<Throwable> errors) {\n        for (FrameworkMethod each : computeTestMethods()) {\n            if (each.getAnnotation(Theory.class) != null) {\n                each.validatePublicVoid(false, errors);\n                each.validateNoTypeParametersOnArgs(errors);\n            } else {\n                each.validatePublicVoidNoArg(false, errors);\n            }\n            \n            for (ParameterSignature signature : each.getParameterSignatures()) {\n                ParametersSuppliedBy annotation = signature.findDeepAnnotation(ParametersSuppliedBy.class);\n                if (annotation != null) {\n                    validateParameterSupplier(annotation.value(), errors);\n                }\n            }\n        }\n    }\n\n    private void validateParameterSupplier(Class<? extends ParameterSupplier> supplierClass, List<Throwable> errors) {\n        Constructor<?>[] constructors = supplierClass.getConstructors();\n        \n        if (constructors.length != 1) {\n            errors.add(new Error(\"ParameterSupplier \" + supplierClass.getName() + \n                                 \" must have only one constructor (either empty or taking only a TestClass)\"));\n        } else {\n            Class<?>[] paramTypes = constructors[0].getParameterTypes();\n            if (!(paramTypes.length == 0) && !paramTypes[0].equals(TestClass.class)) {\n                errors.add(new Error(\"ParameterSupplier \" + supplierClass.getName() + \n                                     \" constructor must take either nothing or a single TestClass instance\"));\n            }\n        }\n    }\n\n    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n        List<FrameworkMethod> testMethods = super.computeTestMethods();\n        List<FrameworkMethod> theoryMethods = getTestClass().getAnnotatedMethods(Theory.class);\n        testMethods.removeAll(theoryMethods);\n        testMethods.addAll(theoryMethods);\n        return testMethods;\n    }\n\n    @Override\n    public Statement methodBlock(final FrameworkMethod method) {\n        return new TheoryAnchor(method, getTestClass());\n    }\n\n    public static class TheoryAnchor extends Statement {\n        private int successes = 0;\n\n        private FrameworkMethod fTestMethod;\n        private TestClass fTestClass;\n\n        private List<AssumptionViolatedException> fInvalidParameters = new ArrayList<AssumptionViolatedException>();\n\n        public TheoryAnchor(FrameworkMethod method, TestClass testClass) {\n            fTestMethod = method;\n            fTestClass = testClass;\n        }\n\n        private TestClass getTestClass() {\n            return fTestClass;\n        }\n\n        @Override\n        public void evaluate() throws Throwable {\n            runWithAssignment(Assignments.allUnassigned(\n                    fTestMethod.getMethod(), getTestClass()));\n            \n            //if this test method is not annotated with Theory, then no successes is a valid case\n            boolean hasTheoryAnnotation = fTestMethod.getAnnotation(Theory.class) != null;\n            if (successes == 0 && hasTheoryAnnotation) {\n                Assert\n                        .fail(\"Never found parameters that satisfied method assumptions.  Violated assumptions: \"\n                                + fInvalidParameters);\n            }\n        }\n\n        protected void runWithAssignment(Assignments parameterAssignment)\n                throws Throwable {\n            if (!parameterAssignment.isComplete()) {\n                runWithIncompleteAssignment(parameterAssignment);\n            } else {\n                runWithCompleteAssignment(parameterAssignment);\n            }\n        }\n\n        protected void runWithIncompleteAssignment(Assignments incomplete)\n                throws InstantiationException, IllegalAccessException,\n                Throwable {\n            for (PotentialAssignment source : incomplete\n                    .potentialsForNextUnassigned()) {\n                runWithAssignment(incomplete.assignNext(source));\n            }\n        }\n\n        protected void runWithCompleteAssignment(final Assignments complete)\n                throws InstantiationException, IllegalAccessException,\n                InvocationTargetException, NoSuchMethodException, Throwable {\n            new BlockJUnit4ClassRunner(getTestClass().getJavaClass()) {\n                @Override\n                protected void collectInitializationErrors(\n                        List<Throwable> errors) {\n                    // do nothing\n                }\n\n                @Override\n                public Statement methodBlock(FrameworkMethod method) {\n                    final Statement statement = super.methodBlock(method);\n                    return new Statement() {\n                        @Override\n                        public void evaluate() throws Throwable {\n                            try {\n                                statement.evaluate();\n                                handleDataPointSuccess();\n                            } catch (AssumptionViolatedException e) {\n                                handleAssumptionViolation(e);\n                            } catch (Throwable e) {\n                                reportParameterizedError(e, complete\n                                        .getArgumentStrings(nullsOk()));\n                            }\n                        }\n\n                    };\n                }\n\n                @Override\n                protected Statement methodInvoker(FrameworkMethod method, Object test) {\n                    return methodCompletesWithParameters(method, complete, test);\n                }\n\n                @Override\n                public Object createTest() throws Exception {\n                    return getTestClass().getOnlyConstructor().newInstance(\n                            complete.getConstructorArguments(nullsOk()));\n                }\n            }.methodBlock(fTestMethod).evaluate();\n        }\n\n        private Statement methodCompletesWithParameters(\n                final FrameworkMethod method, final Assignments complete, final Object freshInstance) {\n            return new Statement() {\n                @Override\n                public void evaluate() throws Throwable {\n                    try {\n                        final Object[] values = complete.getMethodArguments(\n                                nullsOk());\n                        method.invokeExplosively(freshInstance, values);\n                    } catch (CouldNotGenerateValueException e) {\n                        // ignore\n                    }\n                }\n            };\n        }\n\n        protected void handleAssumptionViolation(AssumptionViolatedException e) {\n            fInvalidParameters.add(e);\n        }\n\n        protected void reportParameterizedError(Throwable e, Object... params)\n                throws Throwable {\n            if (params.length == 0) {\n                throw e;\n            }\n            throw new ParameterizedAssertionError(e, fTestMethod.getName(),\n                    params);\n        }\n\n        private boolean nullsOk() {\n            Theory annotation = fTestMethod.getMethod().getAnnotation(\n                    Theory.class);\n            if (annotation == null) {\n                return false;\n            }\n            return annotation.nullsAccepted();\n        }\n\n        protected void handleDataPointSuccess() {\n            successes++;\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.experimental.theories;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.Assume;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\npublic class Theories extends BlockJUnit4ClassRunner {\n    public Theories(Class<?> klass) throws InitializationError {\n        super(klass);\n    }\n\n    @Override\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        super.collectInitializationErrors(errors);\n        validateDataPointFields(errors);\n        validateDataPointMethods(errors);\n    }\n\n    private void validateDataPointFields(List<Throwable> errors) {\n        Field[] fields = getTestClass().getJavaClass().getDeclaredFields();\n\n        for (Field field : fields) {\n            if (field.getAnnotation(DataPoint.class) == null && field.getAnnotation(DataPoints.class) == null) {\n                continue;\n            }\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Error(\"DataPoint field \" + field.getName() + \" must be static\"));\n            }\n            if (!Modifier.isPublic(field.getModifiers())) {\n                errors.add(new Error(\"DataPoint field \" + field.getName() + \" must be public\"));\n            }\n        }\n    }\n\n    private void validateDataPointMethods(List<Throwable> errors) {\n        Method[] methods = getTestClass().getJavaClass().getDeclaredMethods();\n        \n        for (Method method : methods) {\n            if (method.getAnnotation(DataPoint.class) == null && method.getAnnotation(DataPoints.class) == null) {\n                continue;\n            }\n            if (!Modifier.isStatic(method.getModifiers())) {\n                errors.add(new Error(\"DataPoint method \" + method.getName() + \" must be static\"));\n            }\n            if (!Modifier.isPublic(method.getModifiers())) {\n                errors.add(new Error(\"DataPoint method \" + method.getName() + \" must be public\"));\n            }\n        }\n    }\n\n    @Override\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n    }\n\n    @Override\n    protected void validateTestMethods(List<Throwable> errors) {\n        for (FrameworkMethod each : computeTestMethods()) {\n            if (each.getAnnotation(Theory.class) != null) {\n                each.validatePublicVoid(false, errors);\n                each.validateNoTypeParametersOnArgs(errors);\n            } else {\n                each.validatePublicVoidNoArg(false, errors);\n            }\n            \n            for (ParameterSignature signature : each.getParameterSignatures()) {\n                ParametersSuppliedBy annotation = signature.findDeepAnnotation(ParametersSuppliedBy.class);\n                if (annotation != null) {\n                    validateParameterSupplier(annotation.value(), errors);\n                }\n            }\n        }\n    }\n\n    private void validateParameterSupplier(Class<? extends ParameterSupplier> supplierClass, List<Throwable> errors) {\n        Constructor<?>[] constructors = supplierClass.getConstructors();\n        \n        if (constructors.length != 1) {\n            errors.add(new Error(\"ParameterSupplier \" + supplierClass.getName() + \n                                 \" must have only one constructor (either empty or taking only a TestClass)\"));\n        } else {\n            Class<?>[] paramTypes = constructors[0].getParameterTypes();\n            if (!(paramTypes.length == 0) && !paramTypes[0].equals(TestClass.class)) {\n                errors.add(new Error(\"ParameterSupplier \" + supplierClass.getName() + \n                                     \" constructor must take either nothing or a single TestClass instance\"));\n            }\n        }\n    }\n\n    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n        List<FrameworkMethod> testMethods = super.computeTestMethods();\n        List<FrameworkMethod> theoryMethods = getTestClass().getAnnotatedMethods(Theory.class);\n        testMethods.removeAll(theoryMethods);\n        testMethods.addAll(theoryMethods);\n        return testMethods;\n    }\n\n    @Override\n    public Statement methodBlock(final FrameworkMethod method) {\n        return new TheoryAnchor(method, getTestClass());\n    }\n\n    public static class TheoryAnchor extends Statement {\n        private int successes = 0;\n\n        private FrameworkMethod fTestMethod;\n        private TestClass fTestClass;\n\n        private List<AssumptionViolatedException> fInvalidParameters = new ArrayList<AssumptionViolatedException>();\n\n        public TheoryAnchor(FrameworkMethod method, TestClass testClass) {\n            fTestMethod = method;\n            fTestClass = testClass;\n        }\n\n        private TestClass getTestClass() {\n            return fTestClass;\n        }\n\n        @Override\n        public void evaluate() throws Throwable {\n            runWithAssignment(Assignments.allUnassigned(\n                    fTestMethod.getMethod(), getTestClass()));\n            \n            //if this test method is not annotated with Theory, then no successes is a valid case\n            boolean hasTheoryAnnotation = fTestMethod.getAnnotation(Theory.class) != null;\n            if (successes == 0 && hasTheoryAnnotation) {\n                Assert\n                        .fail(\"Never found parameters that satisfied method assumptions.  Violated assumptions: \"\n                                + fInvalidParameters);\n            }\n        }\n\n        protected void runWithAssignment(Assignments parameterAssignment)\n                throws Throwable {\n            if (!parameterAssignment.isComplete()) {\n                runWithIncompleteAssignment(parameterAssignment);\n            } else {\n                runWithCompleteAssignment(parameterAssignment);\n            }\n        }\n\n        protected void runWithIncompleteAssignment(Assignments incomplete)\n                throws InstantiationException, IllegalAccessException,\n                Throwable {\n            for (PotentialAssignment source : incomplete\n                    .potentialsForNextUnassigned()) {\n                runWithAssignment(incomplete.assignNext(source));\n            }\n        }\n\n        protected void runWithCompleteAssignment(final Assignments complete)\n                throws InstantiationException, IllegalAccessException,\n                InvocationTargetException, NoSuchMethodException, Throwable {\n            new BlockJUnit4ClassRunner(getTestClass().getJavaClass()) {\n                @Override\n                protected void collectInitializationErrors(\n                        List<Throwable> errors) {\n                    // do nothing\n                }\n\n                @Override\n                public Statement methodBlock(FrameworkMethod method) {\n                    final Statement statement = super.methodBlock(method);\n                    return new Statement() {\n                        @Override\n                        public void evaluate() throws Throwable {\n                            try {\n                                statement.evaluate();\n                                handleDataPointSuccess();\n                            } catch (AssumptionViolatedException e) {\n                                handleAssumptionViolation(e);\n                            } catch (Throwable e) {\n                                reportParameterizedError(e, complete\n                                        .getArgumentStrings(nullsOk()));\n                            }\n                        }\n\n                    };\n                }\n\n                @Override\n                protected Statement methodInvoker(FrameworkMethod method, Object test) {\n                    return methodCompletesWithParameters(method, complete, test);\n                }\n\n                @Override\n                public Object createTest() throws Exception {\n                    Object[] params = complete.getConstructorArguments();\n                    \n                    if (!nullsOk()) {\n                        Assume.assumeNotNull(params);\n                    }\n                    \n                    return getTestClass().getOnlyConstructor().newInstance(params);\n                }\n            }.methodBlock(fTestMethod).evaluate();\n        }\n\n        private Statement methodCompletesWithParameters(\n                final FrameworkMethod method, final Assignments complete, final Object freshInstance) {\n            return new Statement() {\n                @Override\n                public void evaluate() throws Throwable {\n                    final Object[] values = complete.getMethodArguments();\n                    \n                    if (!nullsOk()) {\n                        Assume.assumeNotNull(values);\n                    }\n                    \n                    method.invokeExplosively(freshInstance, values);\n                }\n            };\n        }\n\n        protected void handleAssumptionViolation(AssumptionViolatedException e) {\n            fInvalidParameters.add(e);\n        }\n\n        protected void reportParameterizedError(Throwable e, Object... params)\n                throws Throwable {\n            if (params.length == 0) {\n                throw e;\n            }\n            throw new ParameterizedAssertionError(e, fTestMethod.getName(),\n                    params);\n        }\n\n        private boolean nullsOk() {\n            Theory annotation = fTestMethod.getMethod().getAnnotation(\n                    Theory.class);\n            if (annotation == null) {\n                return false;\n            }\n            return annotation.nullsAccepted();\n        }\n\n        protected void handleDataPointSuccess() {\n            successes++;\n        }\n    }\n}\n","lineNo":205}
{"Smelly Sample":"package org.junit.experimental.categories;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.FilterFactory;\nimport org.junit.runner.manipulation.Filter;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class CategoryFilterFactoryTest {\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    @Test\n    public void shouldCreateFilter() throws Exception {\n        CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub();\n        Filter filter = categoryFilterFactory.createFilter(CategoryFilterFactoryStub.class.getName());\n\n        assertThat(filter, is((Filter) null));\n    }\n\n    @Test\n    public void shouldThrowException() throws Exception {\n        expectedException.expect(FilterFactory.FilterNotCreatedException.class);\n\n        CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub();\n        Filter filter = categoryFilterFactory.createFilter(\"NonExistentFilter\");\n\n        assertThat(filter, is((Filter) null));\n    }\n\n    public static class DummyCategory {\n    }\n\n    private static class CategoryFilterFactoryStub extends CategoryFilterFactory {\n        @Override\n        protected Filter createFilter(Class<?>[] categories) {\n            return null;\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.experimental.categories;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.Description;\nimport org.junit.runner.FilterFactory;\nimport org.junit.runner.FilterFactoryParams;\nimport org.junit.runner.manipulation.Filter;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class CategoryFilterFactoryTest {\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    @Test\n    public void shouldCreateFilter() throws Exception {\n        CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub();\n        FilterFactoryParams params = categoryFilterFactory.parseArgs(CategoryFilterFactoryStub.class.getName());\n        Filter filter = categoryFilterFactory.createFilter(params);\n\n        assertThat(filter, instanceOf(DummyFilter.class));\n    }\n\n    @Test\n    public void shouldThrowException() throws Exception {\n        CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub();\n\n        expectedException.expect(FilterFactory.FilterNotCreatedException.class);\n\n        categoryFilterFactory.parseArgs(\"NonExistentFilter\");\n    }\n\n    private static class CategoryFilterFactoryStub extends CategoryFilterFactory {\n        @Override\n        protected Filter createFilter(Class<?>[] categories) {\n            return new DummyFilter();\n        }\n    }\n\n    private static class DummyFilter extends Filter {\n        @Override\n        public boolean shouldRun(Description description) {\n            return false;\n        }\n\n        @Override\n        public String describe() {\n            return null;\n        }\n    }\n}\n","lineNo":21}
{"Smelly Sample":"package org.junit.experimental.theories;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class ParameterSignature {\n    public static ArrayList<ParameterSignature> signatures(Method method) {\n        return signatures(method.getParameterTypes(), method\n                .getParameterAnnotations());\n    }\n\n    public static List<ParameterSignature> signatures(Constructor<?> constructor) {\n        return signatures(constructor.getParameterTypes(), constructor\n                .getParameterAnnotations());\n    }\n\n    private static ArrayList<ParameterSignature> signatures(\n            Class<?>[] parameterTypes, Annotation[][] parameterAnnotations) {\n        ArrayList<ParameterSignature> sigs = new ArrayList<ParameterSignature>();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sigs.add(new ParameterSignature(parameterTypes[i],\n                    parameterAnnotations[i]));\n        }\n        return sigs;\n    }\n\n    private final Class<?> type;\n\n    private final Annotation[] annotations;\n\n    private ParameterSignature(Class<?> type, Annotation[] annotations) {\n        this.type = type;\n        this.annotations = annotations;\n    }\n\n    public boolean canAcceptValue(Object candidate) {\n        return (candidate == null) ? !type.isPrimitive() : canAcceptType(candidate.getClass());\n    }\n\n    public boolean canAcceptType(Class<?> candidate) {\n        return type.isAssignableFrom(candidate);\n    }\n\n    public Class<?> getType() {\n        return type;\n    }\n\n    public List<Annotation> getAnnotations() {\n        return Arrays.asList(annotations);\n    }\n\n    public boolean canAcceptArrayType(Class<?> type) {\n        return type.isArray() && canAcceptType(type.getComponentType());\n    }\n\n    public boolean hasAnnotation(Class<? extends Annotation> type) {\n        return getAnnotation(type) != null;\n    }\n\n    public <T extends Annotation> T findDeepAnnotation(Class<T> annotationType) {\n        Annotation[] annotations2 = annotations;\n        return findDeepAnnotation(annotations2, annotationType, 3);\n    }\n\n    private <T extends Annotation> T findDeepAnnotation(\n            Annotation[] annotations, Class<T> annotationType, int depth) {\n        if (depth == 0) {\n            return null;\n        }\n        for (Annotation each : annotations) {\n            if (annotationType.isInstance(each)) {\n                return annotationType.cast(each);\n            }\n            Annotation candidate = findDeepAnnotation(each.annotationType()\n                    .getAnnotations(), annotationType, depth - 1);\n            if (candidate != null) {\n                return annotationType.cast(candidate);\n            }\n        }\n\n        return null;\n    }\n\n    public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        for (Annotation each : getAnnotations()) {\n            if (annotationType.isInstance(each)) {\n                return annotationType.cast(each);\n            }\n        }\n        return null;\n    }\n}\n","Method after Refactoring":"package org.junit.experimental.theories;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ParameterSignature {\n    \n    @SuppressWarnings(\"serial\")\n    private static final Map<Class<?>, Class<?>> primitivesBoxingMap = new HashMap<Class<?>, Class<?>>() {{\n        put(boolean.class, Boolean.class);\n        put(byte.class, Byte.class);\n        put(short.class, Short.class);\n        put(char.class, Character.class);\n        put(int.class, Integer.class);\n        put(long.class, Long.class);\n        put(float.class, Float.class);\n        put(double.class, Double.class);\n    }};\n    \n    public static ArrayList<ParameterSignature> signatures(Method method) {\n        return signatures(method.getParameterTypes(), method\n                .getParameterAnnotations());\n    }\n\n    public static List<ParameterSignature> signatures(Constructor<?> constructor) {\n        return signatures(constructor.getParameterTypes(), constructor\n                .getParameterAnnotations());\n    }\n\n    private static ArrayList<ParameterSignature> signatures(\n            Class<?>[] parameterTypes, Annotation[][] parameterAnnotations) {\n        ArrayList<ParameterSignature> sigs = new ArrayList<ParameterSignature>();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sigs.add(new ParameterSignature(parameterTypes[i],\n                    parameterAnnotations[i]));\n        }\n        return sigs;\n    }\n\n    private final Class<?> type;\n\n    private final Annotation[] annotations;\n\n    private ParameterSignature(Class<?> type, Annotation[] annotations) {\n        this.type = type;\n        this.annotations = annotations;\n    }\n\n    public boolean canAcceptValue(Object candidate) {\n        return (candidate == null) ? !type.isPrimitive() : canAcceptType(candidate.getClass());\n    }\n\n    public boolean canAcceptType(Class<?> candidate) {\n        return type.isAssignableFrom(candidate) ||\n                canAcceptBoxed(candidate) ||\n                canAcceptUnboxed(candidate);\n    }\n\n    private boolean canAcceptBoxed(Class<?> candidate) {\n        if (primitivesBoxingMap.containsKey(candidate)) {\n            Class<?> wrapperClass = primitivesBoxingMap.get(candidate);\n            return type.isAssignableFrom(wrapperClass);\n        } else {\n            return false;\n        }\n    }\n\n    private boolean canAcceptUnboxed(Class<?> candidate) {\n        Field primitiveClassField = null;\n        try {\n            primitiveClassField = candidate.getDeclaredField(\"TYPE\");\n        } catch (NoSuchFieldException e) {\n            return false;\n        }\n        \n        try {\n            if (Modifier.isStatic(primitiveClassField.getModifiers())) {\n                Class<?> primitiveClass = (Class<?>) primitiveClassField.get(null);\n                return type.isAssignableFrom(primitiveClass);\n            } else {\n                return false;\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\tpublic Class<?> getType() {\n        return type;\n    }\n\n    public List<Annotation> getAnnotations() {\n        return Arrays.asList(annotations);\n    }\n\n    public boolean hasAnnotation(Class<? extends Annotation> type) {\n        return getAnnotation(type) != null;\n    }\n\n    public <T extends Annotation> T findDeepAnnotation(Class<T> annotationType) {\n        Annotation[] annotations2 = annotations;\n        return findDeepAnnotation(annotations2, annotationType, 3);\n    }\n\n    private <T extends Annotation> T findDeepAnnotation(\n            Annotation[] annotations, Class<T> annotationType, int depth) {\n        if (depth == 0) {\n            return null;\n        }\n        for (Annotation each : annotations) {\n            if (annotationType.isInstance(each)) {\n                return annotationType.cast(each);\n            }\n            Annotation candidate = findDeepAnnotation(each.annotationType()\n                    .getAnnotations(), annotationType, depth - 1);\n            if (candidate != null) {\n                return annotationType.cast(candidate);\n            }\n        }\n\n        return null;\n    }\n\n    public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        for (Annotation each : getAnnotations()) {\n            if (annotationType.isInstance(each)) {\n                return annotationType.cast(each);\n            }\n        }\n        return null;\n    }\n}\n","lineNo":69}
{"Smelly Sample":"package org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.experimental.theories.DataPoint;\nimport org.junit.experimental.theories.DataPoints;\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Supplies Theory parameters based on all public members of the target class.\n */\npublic class AllMembersSupplier extends ParameterSupplier {\n    \n    private final TestClass fClass;\n\n    /**\n     * Constructs a new supplier for {@code type}\n     */\n    public AllMembersSupplier(TestClass type) {\n        fClass = type;\n    }\n\n    @Override\n    public List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n        List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n\n        addSinglePointFields(sig, list);\n        addMultiPointFields(sig, list);\n        addSinglePointMethods(sig, list);\n        addMultiPointMethods(sig, list);\n\n        return list;\n    }\n\n    private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            try {\n                addMultiPointArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n            } catch (Throwable e) {\n                // ignore and move on\n            }\n        }\n    }\n\n    private void addSinglePointMethods(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointMethod : getSingleDataPointMethods(sig)) {\n            if (sig.canAcceptType(dataPointMethod.getType())) {\n                try {\n                    list.add(PotentialAssignment.forValue(dataPointMethod.getName(), dataPointMethod.invokeExplosively(null)));\n                } catch (Throwable e) {\n                    // ignore and move on\n                }\n            }\n        }\n    }\n    \n    private void addMultiPointFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptArrayType(type)) {\n                try {\n                    addArrayValues(field.getName(), list, getStaticFieldValue(field));\n                } catch (Throwable e) {\n                    // ignore and move on\n                }\n            }\n        }\n    }    \n\n    private void addSinglePointFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : getSingleDataPointFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptType(type)) {\n                list.add(PotentialAssignment.forValue(field.getName(), getStaticFieldValue(field)));\n            }\n        }\n    }\n\n    private void addArrayValues(String name, List<PotentialAssignment> list, Object array) {\n        for (int i = 0; i < Array.getLength(array); i++) {\n            list.add(PotentialAssignment.forValue(name + \"[\" + i + \"]\", Array.get(array, i)));\n        }\n    }\n\n    private void addMultiPointArrayValues(ParameterSignature sig, String name, List<PotentialAssignment> list,\n            Object array) throws Throwable {\n        for (int i = 0; i < Array.getLength(array); i++) {\n            if (!sig.canAcceptValue(Array.get(array, i))) {\n                return;\n            }\n            list.add(PotentialAssignment.forValue(name + \"[\" + i + \"]\", Array.get(array, i)));\n        }\n    }\n\n    private Object getStaticFieldValue(final Field field) {\n        try {\n            return field.get(null);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\n                    \"unexpected: field from getClass doesn't exist on object\");\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\n                    \"unexpected: getFields returned an inaccessible field\");\n        }\n    }\n\n    protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoints.class);        \n    }\n    \n    protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoint.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoints.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoint.class);\n    }\n\n}\n","Method after Refactoring":"package org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.experimental.theories.DataPoint;\nimport org.junit.experimental.theories.DataPoints;\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Supplies Theory parameters based on all public members of the target class.\n */\npublic class AllMembersSupplier extends ParameterSupplier {\n    \n    private final TestClass fClass;\n\n    /**\n     * Constructs a new supplier for {@code type}\n     */\n    public AllMembersSupplier(TestClass type) {\n        fClass = type;\n    }\n\n    @Override\n    public List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n        List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n\n        addSinglePointFields(sig, list);\n        addMultiPointFields(sig, list);\n        addSinglePointMethods(sig, list);\n        addMultiPointMethods(sig, list);\n\n        return list;\n    }\n\n    private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            try {\n                addArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n            } catch (Throwable e) {\n                // ignore and move on\n            }\n        }\n    }\n\n    private void addSinglePointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointMethod : getSingleDataPointMethods(sig)) {\n            Object value;\n            \n            try {\n                value = dataPointMethod.invokeExplosively(null);\n            } catch (Throwable e) {\n                // ignore and move on\n                continue;\n            }\n                \n            if (sig.canAcceptValue(value)) {\n                list.add(PotentialAssignment.forValue(dataPointMethod.getName(), value));\n            }\n        }\n    }\n    \n    private void addMultiPointFields(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            addArrayValues(sig, field.getName(), list, getStaticFieldValue(field));\n        }\n    }\n\n    private void addSinglePointFields(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (final Field field : getSingleDataPointFields(sig)) {\n            Object value = getStaticFieldValue(field);\n            \n            if (sig.canAcceptValue(value)) {\n                list.add(PotentialAssignment.forValue(field.getName(), value));\n            }\n        }\n    }\n\n    private void addArrayValues(ParameterSignature sig, String name, List<PotentialAssignment> list, Object array) {\n        for (int i = 0; i < Array.getLength(array); i++) {\n            Object value = Array.get(array, i);\n            if (sig.canAcceptValue(value)) {\n                list.add(PotentialAssignment.forValue(name + \"[\" + i + \"]\", value));\n            }\n        }\n    }\n\n    private Object getStaticFieldValue(final Field field) {\n        try {\n            return field.get(null);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\n                    \"unexpected: field from getClass doesn't exist on object\");\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\n                    \"unexpected: getFields returned an inaccessible field\");\n        }\n    }\n\n    protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoints.class);        \n    }\n    \n    protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoint.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoints.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoint.class);\n    }\n\n}\n","lineNo":56}
{"Smelly Sample":"package org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.experimental.theories.DataPoint;\nimport org.junit.experimental.theories.DataPoints;\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Supplies Theory parameters based on all public members of the target class.\n */\npublic class AllMembersSupplier extends ParameterSupplier {\n    \n    private final TestClass fClass;\n\n    /**\n     * Constructs a new supplier for {@code type}\n     */\n    public AllMembersSupplier(TestClass type) {\n        fClass = type;\n    }\n\n    @Override\n    public List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n        List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n\n        addSinglePointFields(sig, list);\n        addMultiPointFields(sig, list);\n        addSinglePointMethods(sig, list);\n        addMultiPointMethods(sig, list);\n\n        return list;\n    }\n\n    private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            try {\n                addMultiPointArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n            } catch (Throwable e) {\n                // ignore and move on\n            }\n        }\n    }\n\n    private void addSinglePointMethods(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointMethod : getSingleDataPointMethods(sig)) {\n            if (sig.canAcceptType(dataPointMethod.getType())) {\n                try {\n                    list.add(PotentialAssignment.forValue(dataPointMethod.getName(), dataPointMethod.invokeExplosively(null)));\n                } catch (Throwable e) {\n                    // ignore and move on\n                }\n            }\n        }\n    }\n    \n    private void addMultiPointFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptArrayType(type)) {\n                try {\n                    addArrayValues(field.getName(), list, getStaticFieldValue(field));\n                } catch (Throwable e) {\n                    // ignore and move on\n                }\n            }\n        }\n    }    \n\n    private void addSinglePointFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : getSingleDataPointFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptType(type)) {\n                list.add(PotentialAssignment.forValue(field.getName(), getStaticFieldValue(field)));\n            }\n        }\n    }\n\n    private void addArrayValues(String name, List<PotentialAssignment> list, Object array) {\n        for (int i = 0; i < Array.getLength(array); i++) {\n            list.add(PotentialAssignment.forValue(name + \"[\" + i + \"]\", Array.get(array, i)));\n        }\n    }\n\n    private void addMultiPointArrayValues(ParameterSignature sig, String name, List<PotentialAssignment> list,\n            Object array) throws Throwable {\n        for (int i = 0; i < Array.getLength(array); i++) {\n            if (!sig.canAcceptValue(Array.get(array, i))) {\n                return;\n            }\n            list.add(PotentialAssignment.forValue(name + \"[\" + i + \"]\", Array.get(array, i)));\n        }\n    }\n\n    private Object getStaticFieldValue(final Field field) {\n        try {\n            return field.get(null);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\n                    \"unexpected: field from getClass doesn't exist on object\");\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\n                    \"unexpected: getFields returned an inaccessible field\");\n        }\n    }\n\n    protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoints.class);        \n    }\n    \n    protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoint.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoints.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoint.class);\n    }\n\n}\n","Method after Refactoring":"package org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.experimental.theories.DataPoint;\nimport org.junit.experimental.theories.DataPoints;\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.runners.model.FrameworkField;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.TestClass;\n\n/**\n * Supplies Theory parameters based on all public members of the target class.\n */\npublic class AllMembersSupplier extends ParameterSupplier {\n    \n    private final TestClass fClass;\n\n    /**\n     * Constructs a new supplier for {@code type}\n     */\n    public AllMembersSupplier(TestClass type) {\n        fClass = type;\n    }\n\n    @Override\n    public List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n        List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n\n        addSinglePointFields(sig, list);\n        addMultiPointFields(sig, list);\n        addSinglePointMethods(sig, list);\n        addMultiPointMethods(sig, list);\n\n        return list;\n    }\n\n    private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            try {\n                addArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n            } catch (Throwable e) {\n                // ignore and move on\n            }\n        }\n    }\n\n    private void addSinglePointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointMethod : getSingleDataPointMethods(sig)) {\n            Object value;\n            \n            try {\n                value = dataPointMethod.invokeExplosively(null);\n            } catch (Throwable e) {\n                // ignore and move on\n                continue;\n            }\n                \n            if (sig.canAcceptValue(value)) {\n                list.add(PotentialAssignment.forValue(dataPointMethod.getName(), value));\n            }\n        }\n    }\n    \n    private void addMultiPointFields(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            addArrayValues(sig, field.getName(), list, getStaticFieldValue(field));\n        }\n    }\n\n    private void addSinglePointFields(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (final Field field : getSingleDataPointFields(sig)) {\n            Object value = getStaticFieldValue(field);\n            \n            if (sig.canAcceptValue(value)) {\n                list.add(PotentialAssignment.forValue(field.getName(), value));\n            }\n        }\n    }\n\n    private void addArrayValues(ParameterSignature sig, String name, List<PotentialAssignment> list, Object array) {\n        for (int i = 0; i < Array.getLength(array); i++) {\n            Object value = Array.get(array, i);\n            if (sig.canAcceptValue(value)) {\n                list.add(PotentialAssignment.forValue(name + \"[\" + i + \"]\", value));\n            }\n        }\n    }\n\n    private Object getStaticFieldValue(final Field field) {\n        try {\n            return field.get(null);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\n                    \"unexpected: field from getClass doesn't exist on object\");\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\n                    \"unexpected: getFields returned an inaccessible field\");\n        }\n    }\n\n    protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoints.class);        \n    }\n    \n    protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoint.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoints.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            validFields.add(frameworkField.getField());\n        }\n\n        return validFields;\n    }\n    \n    protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoint.class);\n    }\n\n}\n","lineNo":79}
{"Smelly Sample":"package org.junit.runner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport junit.runner.Version;\nimport org.junit.internal.JUnitSystem;\nimport org.junit.internal.RealSystem;\nimport org.junit.internal.TextListener;\nimport org.junit.internal.runners.JUnit38ClassRunner;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runner.notification.RunNotifier;\n\n/**\n * <code>JUnitCore<\/code> is a facade for running tests. It supports running JUnit 4 tests,\n * JUnit 3.8.x tests, and mixtures. To run tests from the command line, run\n * <code>java org.junit.runner.JUnitCore TestClass1 TestClass2 ...<\/code>.\n * For one-shot test runs, use the static method {@link #runClasses(Class[])}.\n * If you want to add special listeners,\n * create an instance of {@link org.junit.runner.JUnitCore} first and use it to run the tests.\n *\n * @see org.junit.runner.Result\n * @see org.junit.runner.notification.RunListener\n * @see org.junit.runner.Request\n * @since 4.0\n */\npublic class JUnitCore {\n    private final RunNotifier fNotifier = new RunNotifier();\n\n    /**\n     * Run the tests contained in the classes named in the <code>args<\/code>.\n     * If all tests run successfully, exit with a status of 0. Otherwise exit with a status of 1.\n     * Write feedback while tests are running and write\n     * stack traces for all failed tests after the tests all complete.\n     *\n     * @param args names of classes in which to find tests to run\n     */\n    public static void main(String... args) {\n        runMainAndExit(new RealSystem(), args);\n    }\n\n    /**\n     * Runs main and exits\n     */\n    private static void runMainAndExit(JUnitSystem system, String... args) {\n        Result result = new JUnitCore().runMain(system, args);\n        System.exit(result.wasSuccessful() ? 0 : 1);\n    }\n\n    /**\n     * Run the tests contained in <code>classes<\/code>. Write feedback while the tests\n     * are running and write stack traces for all failed tests after all tests complete. This is\n     * similar to {@link #main(String[])}, but intended to be used programmatically.\n     *\n     * @param computer Helps construct Runners from classes\n     * @param classes Classes in which to find tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public static Result runClasses(Computer computer, Class<?>... classes) {\n        return new JUnitCore().run(computer, classes);\n    }\n\n    /**\n     * Run the tests contained in <code>classes<\/code>. Write feedback while the tests\n     * are running and write stack traces for all failed tests after all tests complete. This is\n     * similar to {@link #main(String[])}, but intended to be used programmatically.\n     *\n     * @param classes Classes in which to find tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public static Result runClasses(Class<?>... classes) {\n        return new JUnitCore().run(defaultComputer(), classes);\n    }\n\n    /**\n     * @param system\n     * @args args from main()\n     */\n    private Result runMain(JUnitSystem system, String... args) {\n        system.out().println(\"JUnit version \" + Version.id());\n        List<Class<?>> classes = new ArrayList<Class<?>>();\n        List<Failure> missingClasses = new ArrayList<Failure>();\n        for (String each : args) {\n            try {\n                classes.add(Class.forName(each));\n            } catch (ClassNotFoundException e) {\n                system.out().println(\"Could not find class: \" + each);\n                Description description = Description.createSuiteDescription(each);\n                Failure failure = new Failure(description, e);\n                missingClasses.add(failure);\n            }\n        }\n        RunListener listener = new TextListener(system);\n        addListener(listener);\n        Result result = run(classes.toArray(new Class<?>[0]));\n        for (Failure each : missingClasses) {\n            result.getFailures().add(each);\n        }\n        return result;\n    }\n\n    /**\n     * @return the version number of this release\n     */\n    public String getVersion() {\n        return Version.id();\n    }\n\n    /**\n     * Run all the tests in <code>classes<\/code>.\n     *\n     * @param classes the classes containing tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(Class<?>... classes) {\n        return run(Request.classes(defaultComputer(), classes));\n    }\n\n    /**\n     * Run all the tests in <code>classes<\/code>.\n     *\n     * @param computer Helps construct Runners from classes\n     * @param classes the classes containing tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(Computer computer, Class<?>... classes) {\n        return run(Request.classes(computer, classes));\n    }\n\n    /**\n     * Run all the tests contained in <code>request<\/code>.\n     *\n     * @param request the request describing tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(Request request) {\n        return run(request.getRunner());\n    }\n\n    /**\n     * Run all the tests contained in JUnit 3.8.x <code>test<\/code>. Here for backward compatibility.\n     *\n     * @param test the old-style test\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(junit.framework.Test test) {\n        return run(new JUnit38ClassRunner(test));\n    }\n\n    /**\n     * Do not use. Testing purposes only.\n     */\n    public Result run(Runner runner) {\n        Result result = new Result();\n        RunListener listener = result.createListener();\n        fNotifier.addFirstListener(listener);\n        try {\n            fNotifier.fireTestRunStarted(runner.getDescription());\n            runner.run(fNotifier);\n            fNotifier.fireTestRunFinished(result);\n        } finally {\n            removeListener(listener);\n        }\n        return result;\n    }\n\n    /**\n     * Add a listener to be notified as the tests run.\n     *\n     * @param listener the listener to add\n     * @see org.junit.runner.notification.RunListener\n     */\n    public void addListener(RunListener listener) {\n        fNotifier.addListener(listener);\n    }\n\n    /**\n     * Remove a listener.\n     *\n     * @param listener the listener to remove\n     */\n    public void removeListener(RunListener listener) {\n        fNotifier.removeListener(listener);\n    }\n\n    static Computer defaultComputer() {\n        return new Computer();\n    }\n\n}\n","Method after Refactoring":"package org.junit.runner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport junit.runner.Version;\nimport org.junit.filters.PassThroughFilter;\nimport org.junit.internal.JUnitSystem;\nimport org.junit.internal.RealSystem;\nimport org.junit.internal.TextListener;\nimport org.junit.internal.runners.JUnit38ClassRunner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runner.notification.RunNotifier;\n\n/**\n * <code>JUnitCore<\/code> is a facade for running tests. It supports running JUnit 4 tests,\n * JUnit 3.8.x tests, and mixtures. To run tests from the command line, run\n * <code>java org.junit.runner.JUnitCore TestClass1 TestClass2 ...<\/code>.\n * For one-shot test runs, use the static method {@link #runClasses(Class[])}.\n * If you want to add special listeners,\n * create an instance of {@link org.junit.runner.JUnitCore} first and use it to run the tests.\n *\n * @see org.junit.runner.Result\n * @see org.junit.runner.notification.RunListener\n * @see org.junit.runner.Request\n * @since 4.0\n */\npublic class JUnitCore {\n    private final RunNotifier fNotifier = new RunNotifier();\n    private Filter filter = new PassThroughFilter();\n\n    /**\n     * Run the tests contained in the classes named in the <code>args<\/code>.\n     * If all tests run successfully, exit with a status of 0. Otherwise exit with a status of 1.\n     * Write feedback while tests are running and write\n     * stack traces for all failed tests after the tests all complete.\n     *\n     * @param args names of classes in which to find tests to run\n     */\n    public static void main(String... args) {\n        runMainAndExit(new RealSystem(), args);\n    }\n\n    /**\n     * Runs main and exits\n     */\n    private static void runMainAndExit(JUnitSystem system, String... args) {\n        Result result = new JUnitCore().runMain(system, args);\n        System.exit(result.wasSuccessful() ? 0 : 1);\n    }\n\n    /**\n     * Run the tests contained in <code>classes<\/code>. Write feedback while the tests\n     * are running and write stack traces for all failed tests after all tests complete. This is\n     * similar to {@link #main(String[])}, but intended to be used programmatically.\n     *\n     * @param computer Helps construct Runners from classes\n     * @param classes Classes in which to find tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public static Result runClasses(Computer computer, Class<?>... classes) {\n        return new JUnitCore().run(computer, classes);\n    }\n\n    /**\n     * Run the tests contained in <code>classes<\/code>. Write feedback while the tests\n     * are running and write stack traces for all failed tests after all tests complete. This is\n     * similar to {@link #main(String[])}, but intended to be used programmatically.\n     *\n     * @param classes Classes in which to find tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public static Result runClasses(Class<?>... classes) {\n        return runClasses(defaultComputer(), classes);\n    }\n\n    /**\n     * @param system\n     * @args args from main()\n     */\n    public Result runMain(JUnitSystem system, String... args) {\n        system.out().println(\"JUnit version \" + Version.id());\n        List<Class<?>> classes = new ArrayList<Class<?>>();\n        List<Failure> failures = new ArrayList<Failure>();\n        FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory();\n        for (String each : args) {\n            try {\n                if (each.startsWith(\"--\")) {\n                    if (each.startsWith(\"--filter\")) {\n                        String filterSpec = each.substring(each.indexOf('=') + 1);\n\n                        Filter filter = filterFactoryFactory.apply(filterSpec);\n\n                        addFilter(filter);\n                    } else {\n                        system.out().println(\"JUnit knows nothing about the \" + each + \" option\");\n\n                        return new Result() {\n                            @Override\n                            public boolean wasSuccessful() {\n                                return false;\n                            }\n                        };\n                    }\n                } else {\n                    classes.add(Class.forName(each));\n                }\n            } catch (FilterFactory.FilterNotFoundException e) {\n                system.out().println(\"Could not find filter: \" + e.getMessage());\n                Description description = Description.createSuiteDescription(each);\n                Failure failure = new Failure(description, e);\n                failures.add(failure);\n            } catch (FilterFactoryFactory.FilterFactoryNotFoundException e) {\n                system.out().println(\"Could not find filter factory: \" + e.getMessage());\n                Description description = Description.createSuiteDescription(each);\n                Failure failure = new Failure(description, e);\n                failures.add(failure);\n            } catch (ClassNotFoundException e) {\n                system.out().println(\"Could not find class: \" + each);\n                Description description = Description.createSuiteDescription(each);\n                Failure failure = new Failure(description, e);\n                failures.add(failure);\n            }\n        }\n        RunListener listener = new TextListener(system);\n        addListener(listener);\n        Result result = run(classes.toArray(new Class<?>[0]));\n        for (Failure each : failures) {\n            result.getFailures().add(each);\n        }\n        return result;\n    }\n\n    /**\n     * @return the version number of this release\n     */\n    public String getVersion() {\n        return Version.id();\n    }\n\n    /**\n     * Run all the tests in <code>classes<\/code>.\n     *\n     * @param classes the classes containing tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(Class<?>... classes) {\n        return run(defaultComputer(), classes);\n    }\n\n    /**\n     * Run all the tests in <code>classes<\/code>.\n     *\n     * @param computer Helps construct Runners from classes\n     * @param classes the classes containing tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(Computer computer, Class<?>... classes) {\n        final Request request = Request.classes(computer, classes).filterWith(filter);\n\n        return run(request);\n    }\n\n    /**\n     * Run all the tests contained in <code>request<\/code>.\n     *\n     * @param request the request describing tests\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(Request request) {\n        return run(request.getRunner());\n    }\n\n    /**\n     * Run all the tests contained in JUnit 3.8.x <code>test<\/code>. Here for backward compatibility.\n     *\n     * @param test the old-style test\n     * @return a {@link Result} describing the details of the test run and the failed tests.\n     */\n    public Result run(junit.framework.Test test) {\n        return run(new JUnit38ClassRunner(test));\n    }\n\n    /**\n     * Do not use. Testing purposes only.\n     */\n    public Result run(Runner runner) {\n        Result result = new Result();\n        RunListener listener = result.createListener();\n        fNotifier.addFirstListener(listener);\n        try {\n            fNotifier.fireTestRunStarted(runner.getDescription());\n            runner.run(fNotifier);\n            fNotifier.fireTestRunFinished(result);\n        } finally {\n            removeListener(listener);\n        }\n        return result;\n    }\n\n    /**\n     * Add a Filter to be used to filter tests to be run.\n     *\n     * @param filter the Filter to add\n     * @see org.junit.runner.JUnitCore\n     */\n    public void addFilter(Filter filter) {\n        this.filter = this.filter.intersect(filter);\n    }\n\n    /**\n     * Add a listener to be notified as the tests run.\n     *\n     * @param listener the listener to add\n     * @see org.junit.runner.notification.RunListener\n     */\n    public void addListener(RunListener listener) {\n        fNotifier.addListener(listener);\n    }\n\n    /**\n     * Remove a listener.\n     *\n     * @param listener the listener to remove\n     */\n    public void removeListener(RunListener listener) {\n        fNotifier.removeListener(listener);\n    }\n\n    static Computer defaultComputer() {\n        return new Computer();\n    }\n\n}\n","lineNo":161}
{"Smelly Sample":"package org.junit.tests.experimental.rules;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TestRule;\nimport org.junit.rules.Timeout;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\npublic class TimeoutRuleTest {\n    private static final ReentrantLock run1Lock = new ReentrantLock();\n\n    private static volatile boolean run4done = false;\n\n    public abstract static class AbstractTimeoutTest {\n        public static final StringBuffer logger = new StringBuffer();\n\n        @Test\n        public void run1() throws InterruptedException {\n            logger.append(\"run1\");\n            TimeoutRuleTest.run1Lock.lockInterruptibly();\n            TimeoutRuleTest.run1Lock.unlock();\n        }\n\n        @Test\n        public void run2() throws InterruptedException {\n            logger.append(\"run2\");\n            Thread.currentThread().join();\n        }\n\n        @Test\n        public synchronized void run3() throws InterruptedException {\n            logger.append(\"run3\");\n            wait();\n        }\n\n        @Test\n        public void run4() {\n            logger.append(\"run4\");\n            while (!run4done) {\n            }\n        }\n\n        @Test\n        public void run5() throws IOException {\n            logger.append(\"run5\");\n            Random rnd = new Random();\n            byte[] data = new byte[1024];\n            while (true) {\n                File tmp = File.createTempFile(\"dummy\", \".tmp\");\n                tmp.deleteOnExit();\n                FileChannel in = new RandomAccessFile(tmp, \"rw\").getChannel();\n                rnd.nextBytes(data);\n                in.write(ByteBuffer.wrap(data));//Interrupted thread closes channel and throws ClosedByInterruptException.\n                in.close();\n            }\n        }\n\n        @Test\n        public void run6() throws InterruptedIOException {\n            logger.append(\"run6\");\n            //Java IO throws InterruptedIOException on SUN machines.\n            throw new InterruptedIOException();\n        }\n    }\n\n    public static class HasGlobalLongTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = Timeout.millis(50L);\n    }\n\n    public static class HasGlobalTimeUnitTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = new Timeout(50, TimeUnit.MILLISECONDS);\n    }\n\n    @Before\n    public void before() {\n        run4done = false;\n        run1Lock.lock();\n    }\n\n    @After\n    public void after() {\n        run4done = true;//to make sure that the thread won't continue at run4()\n        run1Lock.unlock();\n    }\n\n    @Test\n    public void timeUnitTimeout() throws InterruptedException {\n        HasGlobalTimeUnitTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalTimeUnitTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run6\"));\n    }\n\n    @Test\n    public void longTimeout() throws InterruptedException {\n        HasGlobalLongTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalLongTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run6\"));\n    }\n}\n","Method after Refactoring":"package org.junit.tests.experimental.rules;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TestRule;\nimport org.junit.rules.Timeout;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\npublic class TimeoutRuleTest {\n    private static final ReentrantLock run1Lock = new ReentrantLock();\n\n    private static volatile boolean run4done = false;\n\n    public abstract static class AbstractTimeoutTest {\n        public static final StringBuffer logger = new StringBuffer();\n\n        @Test\n        public void run1() throws InterruptedException {\n            logger.append(\"run1\");\n            TimeoutRuleTest.run1Lock.lockInterruptibly();\n            TimeoutRuleTest.run1Lock.unlock();\n        }\n\n        @Test\n        public void run2() throws InterruptedException {\n            logger.append(\"run2\");\n            Thread.currentThread().join();\n        }\n\n        @Test\n        public synchronized void run3() throws InterruptedException {\n            logger.append(\"run3\");\n            wait();\n        }\n\n        @Test\n        public void run4() {\n            logger.append(\"run4\");\n            while (!run4done) {\n            }\n        }\n\n        @Test\n        public void run5() throws IOException {\n            logger.append(\"run5\");\n            Random rnd = new Random();\n            byte[] data = new byte[1024];\n            File tmp = File.createTempFile(\"dummy\", \".tmp\");\n            tmp.deleteOnExit();\n            while (true) {\n                FileChannel channel = new RandomAccessFile(tmp, \"rw\").getChannel();\n                rnd.nextBytes(data);\n                ByteBuffer buffer = ByteBuffer.wrap(data);\n                channel.write(buffer);//Interrupted thread closes channel and throws ClosedByInterruptException.\n                channel.close();\n                tmp.delete();\n            }\n        }\n\n        @Test\n        public void run6() throws InterruptedIOException {\n            logger.append(\"run6\");\n            //Java IO throws InterruptedIOException on SUN machines.\n            throw new InterruptedIOException();\n        }\n    }\n\n    public static class HasGlobalLongTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = Timeout.millis(50L);\n    }\n\n    public static class HasGlobalTimeUnitTimeout extends AbstractTimeoutTest {\n\n        @Rule\n        public final TestRule globalTimeout = new Timeout(50, TimeUnit.MILLISECONDS);\n    }\n\n    @Before\n    public void before() {\n        run4done = false;\n        run1Lock.lock();\n    }\n\n    @After\n    public void after() {\n        run4done = true;//to make sure that the thread won't continue at run4()\n        run1Lock.unlock();\n    }\n\n    @Test\n    public void timeUnitTimeout() throws InterruptedException {\n        HasGlobalTimeUnitTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalTimeUnitTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run6\"));\n    }\n\n    @Test\n    public void longTimeout() throws InterruptedException {\n        HasGlobalLongTimeout.logger.setLength(0);\n        Result result = JUnitCore.runClasses(HasGlobalLongTimeout.class);\n        assertEquals(6, result.getFailureCount());\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run1\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run2\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run3\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run4\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run5\"));\n        assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run6\"));\n    }\n}\n","lineNo":70}
{"Smelly Sample":"package org.junit.rules;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\nimport static org.junit.internal.matchers.ThrowableCauseMatcher.hasCause;\nimport static org.junit.internal.matchers.ThrowableMessageMatcher.hasMessage;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.StringDescription;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.runners.model.Statement;\n\n/**\n * The ExpectedException rule allows in-test specification of expected exception\n * types and messages:\n *\n * <pre>\n * // These tests all pass.\n * public static class HasExpectedException {\n * \t&#064;Rule\n * \tpublic ExpectedException thrown= ExpectedException.none();\n *\n * \t&#064;Test\n * \tpublic void throwsNothing() {\n * \t\t// no exception expected, none thrown: passes.\n *     }\n *\n * \t&#064;Test\n * \tpublic void throwsNullPointerException() {\n * \t\tthrown.expect(NullPointerException.class);\n * \t\tthrow new NullPointerException();\n *     }\n *\n * \t&#064;Test\n * \tpublic void throwsNullPointerExceptionWithMessage() {\n * \t\tthrown.expect(NullPointerException.class);\n * \t\tthrown.expectMessage(&quot;happened?&quot;);\n * \t\tthrown.expectMessage(startsWith(&quot;What&quot;));\n * \t\tthrow new NullPointerException(&quot;What happened?&quot;);\n *     }\n *\n * \t&#064;Test\n * \tpublic void throwsIllegalArgumentExceptionWithMessageAndCause() {\n * \t\tNullPointerException expectedCause = new NullPointerException();\n * \t\tthrown.expect(IllegalArgumentException.class);\n * \t\tthrown.expectMessage(&quot;What&quot;);\n * \t\tthrown.expectCause(is(expectedCause));\n * \t\tthrow new IllegalArgumentException(&quot;What happened?&quot;, cause);\n *     }\n * }\n * <\/pre>\n *\n * By default ExpectedException rule doesn't handle AssertionErrors and\n * AssumptionViolatedExceptions, because such exceptions are used by JUnit. If\n * you want to handle such exceptions you have to call @link\n * {@link #handleAssertionErrors()} or @link\n * {@link #handleAssumptionViolatedExceptions()}.\n *\n * <pre>\n * // These tests all pass.\n * public static class HasExpectedException {\n * \t&#064;Rule\n * \tpublic ExpectedException thrown= ExpectedException.none();\n *\n * \t&#064;Test\n * \tpublic void throwExpectedAssertionError() {\n * \t\tthrown.handleAssertionErrors();\n * \t\tthrown.expect(AssertionError.class);\n * \t\tthrow new AssertionError();\n *     }\n *\n *  &#064;Test\n *  public void throwExpectAssumptionViolatedException() {\n *      thrown.handleAssumptionViolatedExceptions();\n *      thrown.expect(AssumptionViolatedException.class);\n *      throw new AssumptionViolatedException(&quot;&quot;);\n *     }\n * }\n * <\/pre>\n *\n * @since 4.7\n */\npublic class ExpectedException implements TestRule {\n    /**\n     * @return a Rule that expects no exception to be thrown (identical to\n     *         behavior without this Rule)\n     */\n    public static ExpectedException none() {\n        return new ExpectedException();\n    }\n\n    private final ExpectedExceptionMatcherBuilder fMatcherBuilder = new ExpectedExceptionMatcherBuilder();\n\n    private boolean handleAssumptionViolatedExceptions = false;\n\n    private boolean handleAssertionErrors = false;\n\n    private ExpectedException() {\n    }\n\n    public ExpectedException handleAssertionErrors() {\n        handleAssertionErrors = true;\n        return this;\n    }\n\n    public ExpectedException handleAssumptionViolatedExceptions() {\n        handleAssumptionViolatedExceptions = true;\n        return this;\n    }\n\n    public Statement apply(Statement base,\n            org.junit.runner.Description description) {\n        return new ExpectedExceptionStatement(base);\n    }\n\n    /**\n     * Adds {@code matcher} to the list of requirements for any thrown\n     * exception.\n     */\n    public void expect(Matcher<?> matcher) {\n        fMatcherBuilder.add(matcher);\n    }\n\n    /**\n     * Adds to the list of requirements for any thrown exception that it should\n     * be an instance of {@code type}\n     */\n    public void expect(Class<? extends Throwable> type) {\n        expect(instanceOf(type));\n    }\n\n    /**\n     * Adds to the list of requirements for any thrown exception that it should\n     * <em>contain<\/em> string {@code substring}\n     */\n    public void expectMessage(String substring) {\n        expectMessage(containsString(substring));\n    }\n\n    /**\n     * Adds {@code matcher} to the list of requirements for the message returned\n     * from any thrown exception.\n     */\n    public void expectMessage(Matcher<String> matcher) {\n        expect(hasMessage(matcher));\n    }\n\n    /**\n     * Adds {@code matcher} to the list of requirements for the cause of\n     * any thrown exception.\n     */\n    public void expectCause(Matcher<? extends Throwable> expectedCause) {\n        expect(hasCause(expectedCause));\n    }\n\n    private class ExpectedExceptionStatement extends Statement {\n        private final Statement fNext;\n\n        public ExpectedExceptionStatement(Statement base) {\n            fNext = base;\n        }\n\n        @Override\n        public void evaluate() throws Throwable {\n            try {\n                fNext.evaluate();\n                if (fMatcherBuilder.expectsThrowable()) {\n                    failDueToMissingException();\n                }\n            } catch (AssumptionViolatedException e) {\n                optionallyHandleException(e, handleAssumptionViolatedExceptions);\n            } catch (AssertionError e) {\n                optionallyHandleException(e, handleAssertionErrors);\n            } catch (Throwable e) {\n                handleException(e);\n            }\n        }\n    }\n\n    private void failDueToMissingException() throws AssertionError {\n        String expectation = StringDescription.toString(fMatcherBuilder.build());\n        fail(\"Expected test to throw \" + expectation);\n    }\n\n    private void optionallyHandleException(Throwable e, boolean handleException)\n            throws Throwable {\n        if (handleException) {\n            handleException(e);\n        } else {\n            throw e;\n        }\n    }\n\n    private void handleException(Throwable e) throws Throwable {\n        if (fMatcherBuilder.expectsThrowable()) {\n            assertThat(e, fMatcherBuilder.build());\n        } else {\n            throw e;\n        }\n    }\n}\n","Method after Refactoring":"package org.junit.rules;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\nimport static org.junit.internal.matchers.ThrowableCauseMatcher.hasCause;\nimport static org.junit.internal.matchers.ThrowableMessageMatcher.hasMessage;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.StringDescription;\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.runners.model.Statement;\n\n/**\n * The ExpectedException rule allows in-test specification of expected exception\n * types and messages:\n *\n * <pre>\n * // These tests all pass.\n * public static class HasExpectedException {\n * \t&#064;Rule\n * \tpublic ExpectedException thrown= ExpectedException.none();\n *\n * \t&#064;Test\n * \tpublic void throwsNothing() {\n * \t\t// no exception expected, none thrown: passes.\n *     }\n *\n * \t&#064;Test\n * \tpublic void throwsNullPointerException() {\n * \t\tthrown.expect(NullPointerException.class);\n * \t\tthrow new NullPointerException();\n *     }\n *\n * \t&#064;Test\n * \tpublic void throwsNullPointerExceptionWithMessage() {\n * \t\tthrown.expect(NullPointerException.class);\n * \t\tthrown.expectMessage(&quot;happened?&quot;);\n * \t\tthrown.expectMessage(startsWith(&quot;What&quot;));\n * \t\tthrow new NullPointerException(&quot;What happened?&quot;);\n *     }\n *\n * \t&#064;Test\n * \tpublic void throwsIllegalArgumentExceptionWithMessageAndCause() {\n * \t\tNullPointerException expectedCause = new NullPointerException();\n * \t\tthrown.expect(IllegalArgumentException.class);\n * \t\tthrown.expectMessage(&quot;What&quot;);\n * \t\tthrown.expectCause(is(expectedCause));\n * \t\tthrow new IllegalArgumentException(&quot;What happened?&quot;, cause);\n *     }\n * }\n * <\/pre>\n *\n * By default ExpectedException rule doesn't handle AssertionErrors and\n * AssumptionViolatedExceptions, because such exceptions are used by JUnit. If\n * you want to handle such exceptions you have to call @link\n * {@link #handleAssertionErrors()} or @link\n * {@link #handleAssumptionViolatedExceptions()}.\n *\n * <pre>\n * // These tests all pass.\n * public static class HasExpectedException {\n * \t&#064;Rule\n * \tpublic ExpectedException thrown= ExpectedException.none();\n *\n * \t&#064;Test\n * \tpublic void throwExpectedAssertionError() {\n * \t\tthrown.handleAssertionErrors();\n * \t\tthrown.expect(AssertionError.class);\n * \t\tthrow new AssertionError();\n *     }\n *\n *  &#064;Test\n *  public void throwExpectAssumptionViolatedException() {\n *      thrown.handleAssumptionViolatedExceptions();\n *      thrown.expect(AssumptionViolatedException.class);\n *      throw new AssumptionViolatedException(&quot;&quot;);\n *     }\n * }\n * <\/pre>\n *\n * @since 4.7\n */\npublic class ExpectedException implements TestRule {\n    /**\n     * @return a Rule that expects no exception to be thrown (identical to\n     *         behavior without this Rule)\n     */\n    public static ExpectedException none() {\n        return new ExpectedException();\n    }\n\n    private final ExpectedExceptionMatcherBuilder fMatcherBuilder = new ExpectedExceptionMatcherBuilder();\n\n    private boolean handleAssumptionViolatedExceptions = false;\n\n    private boolean handleAssertionErrors = false;\n    \n    private String missingExceptionMessage;\n\n    private ExpectedException() {\n    }\n\n    public ExpectedException handleAssertionErrors() {\n        handleAssertionErrors = true;\n        return this;\n    }\n\n    public ExpectedException handleAssumptionViolatedExceptions() {\n        handleAssumptionViolatedExceptions = true;\n        return this;\n    }\n    \n    /**\n     * Specifies the detail message for an exception to be thrown if the test does \n     * not throw the expected exception.\n     * @param providedMessage exception detail message\n     * @return self\n     */\n    public ExpectedException setMissingExceptionMessage(String providedMessage) {\n    \tmissingExceptionMessage = providedMessage;\n    \treturn this;\n    }\n\n    public Statement apply(Statement base,\n            org.junit.runner.Description description) {\n        return new ExpectedExceptionStatement(base);\n    }\n\n    /**\n     * Adds {@code matcher} to the list of requirements for any thrown\n     * exception.\n     */\n    public void expect(Matcher<?> matcher) {\n        fMatcherBuilder.add(matcher);\n    }\n\n    /**\n     * Adds to the list of requirements for any thrown exception that it should\n     * be an instance of {@code type}\n     */\n    public void expect(Class<? extends Throwable> type) {\n        expect(instanceOf(type));\n    }\n\n    /**\n     * Adds to the list of requirements for any thrown exception that it should\n     * <em>contain<\/em> string {@code substring}\n     */\n    public void expectMessage(String substring) {\n        expectMessage(containsString(substring));\n    }\n\n    /**\n     * Adds {@code matcher} to the list of requirements for the message returned\n     * from any thrown exception.\n     */\n    public void expectMessage(Matcher<String> matcher) {\n        expect(hasMessage(matcher));\n    }\n\n    /**\n     * Adds {@code matcher} to the list of requirements for the cause of\n     * any thrown exception.\n     */\n    public void expectCause(Matcher<? extends Throwable> expectedCause) {\n        expect(hasCause(expectedCause));\n    }\n\n    private class ExpectedExceptionStatement extends Statement {\n        private final Statement fNext;\n\n        public ExpectedExceptionStatement(Statement base) {\n            fNext = base;\n        }\n\n        @Override\n        public void evaluate() throws Throwable {\n            try {\n                fNext.evaluate();\n                if (fMatcherBuilder.expectsThrowable()) {\n                    failDueToMissingException();\n                }\n            } catch (AssumptionViolatedException e) {\n                optionallyHandleException(e, handleAssumptionViolatedExceptions);\n            } catch (AssertionError e) {\n                optionallyHandleException(e, handleAssertionErrors);\n            } catch (Throwable e) {\n                handleException(e);\n            }\n        }\n    }\n\n    private void failDueToMissingException() throws AssertionError {\n    \tString failureMessage;\n    \t\n    \tif ( isMissingExceptionMessageEmpty() ) {\n    \t\tString expectation = StringDescription.toString(fMatcherBuilder.build());\n    \t\tfailureMessage = \"Expected test to throw \" + expectation;\n    \t} else {\n    \t\tfailureMessage = missingExceptionMessage;\n    \t}\n\n        fail(failureMessage);\n    }\n\n    private void optionallyHandleException(Throwable e, boolean handleException)\n            throws Throwable {\n        if (handleException) {\n            handleException(e);\n        } else {\n            throw e;\n        }\n    }\n\n    private void handleException(Throwable e) throws Throwable {\n        if (fMatcherBuilder.expectsThrowable()) {\n            assertThat(e, fMatcherBuilder.build());\n        } else {\n            throw e;\n        }\n    }\n    \n    private boolean isMissingExceptionMessageEmpty() {\n    \treturn missingExceptionMessage == null || missingExceptionMessage.isEmpty();\n    }\n}\n","lineNo":196}
{"Smelly Sample":"package org.junit.tests.experimental.max;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThat;\n\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.Description;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class DescriptionTest {\n\n\t@Test\n\tpublic void parseClass_whenCantParse() {\n\t\tassertNull(Description.TEST_MECHANISM.getTestClass());\n\t}\n\n\t@Test\n\tpublic void parseMethod_whenCantParse() {\n\t\tassertNull(Description.TEST_MECHANISM.getMethodName());\n\t}\n\n\t@Test(expected= IllegalArgumentException.class)\n\tpublic void createSuiteDescription_whenZeroLength() {\n\t\tDescription.createSuiteDescription(\"\");\n\t}\n\n\t@Test(expected= IllegalArgumentException.class)\n\tpublic void createSuiteDescription_whenNull() {\n\t\tDescription.createSuiteDescription((String) null);\n\t}\n\n\t@Test\n\tpublic void parseClassAndMethodNoAnnotations() throws Exception {\n\t\tDescription description = Description.createTestDescription(Description.class, \"aTestMethod\");\n\n\t\tassertThat(description.getClassName(), equalTo(\"org.junit.runner.Description\"));\n\t\tassertThat(description.getMethodName(), equalTo(\"aTestMethod\"));\n\t\tassertThat(description.getAnnotations().size(), equalTo(0));\n\t}\n\n\t@Test\n\tpublic void parseClassAndMethodWithAnnotations() throws Exception {\n\t\tAnnotation[] annotations =\n\t\t\t\t\t\tDescriptionTest.class.getMethod(\"parseClassAndMethodWithAnnotations\").getDeclaredAnnotations();\n\n\t\tDescription description = Description.createTestDescription(Description.class, \"aTestMethod\", annotations);\n\n\t\tassertThat(description.getClassName(), equalTo(\"org.junit.runner.Description\"));\n\t\tassertThat(description.getMethodName(), equalTo(\"aTestMethod\"));\n\t\tassertThat(description.getAnnotations().size(), equalTo(1));\n\t}\n\n\t@Test\n\tpublic void parseClassNameAndMethodUniqueId() throws Exception {\n\t\tDescription description = Description.createTestDescription(\"not a class name\", \"aTestMethod\", 123);\n\n\t\tassertThat(description.getClassName(), equalTo(\"not a class name\"));\n\t\tassertThat(description.getMethodName(), equalTo(\"aTestMethod\"));\n\t\tassertThat(description.getAnnotations().size(), equalTo(0));\n\t}\n\n\t@Test\n\tpublic void sameNamesButDifferentUniqueIdAreNotEqual() throws Exception {\n\t\tassertThat(Description.createTestDescription(\"not a class name\", \"aTestMethod\", 1),\n\t\t\t\t\t\tnot(equalTo(Description.createTestDescription(\"not a class name\", \"aTestMethod\", 2))));\n\t}\n\n    @Test\n    public void roundTripsClassObject() throws Exception {\n        class URLClassLoader2 extends URLClassLoader {\n            URLClassLoader2(URL[] urls) {\n                super(urls);\n            }\n            @Override // just making public\n            public Class<?> findClass(String name) throws ClassNotFoundException {\n                return super.findClass(name);\n            }\n        }\n        URLClassLoader2 l = new URLClassLoader2(new URL[] {Sweet.class.getProtectionDomain().getCodeSource().getLocation()});\n        Class<?> clazz = l.findClass(Sweet.class.getName());\n        assertEquals(l, clazz.getClassLoader());\n        Description d = Description.createSuiteDescription(clazz);\n        assertEquals(clazz, d.getTestClass());\n        assertNull(d.getMethodName());\n        assertEquals(1, d.getAnnotations().size());\n        assertEquals(Ignore.class, d.getAnnotations().iterator().next().annotationType());\n        d = Description.createTestDescription(clazz, \"tessed\");\n        assertEquals(clazz, d.getTestClass());\n        assertEquals(\"tessed\", d.getMethodName());\n        assertEquals(0, d.getAnnotations().size());\n        d = Description.createTestDescription(clazz, \"tessed\", clazz.getMethod(\"tessed\").getAnnotations());\n        assertEquals(clazz, d.getTestClass());\n        assertEquals(\"tessed\", d.getMethodName());\n        assertEquals(1, d.getAnnotations().size());\n        assertEquals(Test.class, d.getAnnotations().iterator().next().annotationType());\n        d = d.childlessCopy();\n        assertEquals(clazz, d.getTestClass());\n        assertEquals(\"tessed\", d.getMethodName());\n        assertEquals(1, d.getAnnotations().size());\n        assertEquals(Test.class, d.getAnnotations().iterator().next().annotationType());\n    }\n    @Ignore\n    private static class Sweet {\n        @Test\n        public void tessed() {}\n    }\n\n}\n","Method after Refactoring":"package org.junit.tests.experimental.max;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThat;\n\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.Description;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class DescriptionTest {\n\n\t@Test\n\tpublic void parseClass_whenCantParse() {\n\t\tassertNull(Description.TEST_MECHANISM.getTestClass());\n\t}\n\n\t@Test\n\tpublic void parseMethod_whenCantParse() {\n\t\tassertNull(Description.TEST_MECHANISM.getMethodName());\n\t}\n\n\t@Test(expected= IllegalArgumentException.class)\n\tpublic void createSuiteDescription_whenZeroLength() {\n\t\tDescription.createSuiteDescription(\"\");\n\t}\n\n\t@Test(expected= IllegalArgumentException.class)\n\tpublic void createSuiteDescription_whenNull() {\n\t\tDescription.createSuiteDescription((String) null);\n\t}\n\n\t@Test\n\tpublic void parseClassAndMethodNoAnnotations() throws Exception {\n\t\tDescription description = Description.createTestDescription(Description.class, \"aTestMethod\");\n\n\t\tassertThat(description.getClassName(), equalTo(\"org.junit.runner.Description\"));\n\t\tassertThat(description.getMethodName(), equalTo(\"aTestMethod\"));\n\t\tassertThat(description.getAnnotations().size(), equalTo(0));\n\t}\n\n\t@Test\n\tpublic void parseClassAndMethodWithAnnotations() throws Exception {\n\t\tAnnotation[] annotations =\n\t\t\t\t\t\tDescriptionTest.class.getMethod(\"parseClassAndMethodWithAnnotations\").getDeclaredAnnotations();\n\n\t\tDescription description = Description.createTestDescription(Description.class, \"aTestMethod\", annotations);\n\n\t\tassertThat(description.getClassName(), equalTo(\"org.junit.runner.Description\"));\n\t\tassertThat(description.getMethodName(), equalTo(\"aTestMethod\"));\n\t\tassertThat(description.getAnnotations().size(), equalTo(1));\n\t}\n\n\t@Test\n\tpublic void parseClassNameAndMethodUniqueId() throws Exception {\n\t\tDescription description = Description.createTestDescription(\"not a class name\", \"aTestMethod\", 123);\n\n\t\tassertThat(description.getClassName(), equalTo(\"not a class name\"));\n\t\tassertThat(description.getMethodName(), equalTo(\"aTestMethod\"));\n\t\tassertThat(description.getAnnotations().size(), equalTo(0));\n\t}\n\n\t@Test\n\tpublic void sameNamesButDifferentUniqueIdAreNotEqual() throws Exception {\n\t\tassertThat(Description.createTestDescription(\"not a class name\", \"aTestMethod\", 1),\n\t\t\t\t\t\tnot(equalTo(Description.createTestDescription(\"not a class name\", \"aTestMethod\", 2))));\n\t}\n\n\t@Test\n\tpublic void usesPassedInClassObject() throws Exception {\n\t\tclass URLClassLoader2 extends URLClassLoader {\n\t\t\tURLClassLoader2(URL[] urls) {\n\t\t\t\tsuper(urls);\n\t\t\t}\n\t\t\t@Override // just making public\n\t\t\tpublic Class<?> findClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn super.findClass(name);\n\t\t\t}\n\t\t}\n\t\tURL classpath= Sweet.class.getProtectionDomain().getCodeSource().getLocation();\n\t\tURLClassLoader2 loader= new URLClassLoader2(new URL[] {classpath});\n\t\tClass<?> clazz= loader.findClass(Sweet.class.getName());\n\t\tassertEquals(loader, clazz.getClassLoader());\n\n\t\tDescription d= Description.createSuiteDescription(clazz);\n\t\tassertEquals(clazz, d.getTestClass());\n\t\tassertNull(d.getMethodName());\n\t\tassertEquals(1, d.getAnnotations().size());\n\t\tassertEquals(Ignore.class, d.getAnnotations().iterator().next().annotationType());\n\n\t\td= Description.createTestDescription(clazz, \"tessed\");\n\t\tassertEquals(clazz, d.getTestClass());\n\t\tassertEquals(\"tessed\", d.getMethodName());\n\t\tassertEquals(0, d.getAnnotations().size());\n\n\t\td= Description.createTestDescription(clazz, \"tessed\", clazz.getMethod(\"tessed\").getAnnotations());\n\t\tassertEquals(clazz, d.getTestClass());\n\t\tassertEquals(\"tessed\", d.getMethodName());\n\t\tassertEquals(1, d.getAnnotations().size());\n\t\tassertEquals(Test.class, d.getAnnotations().iterator().next().annotationType());\n\n\t\td= d.childlessCopy();\n\t\tassertEquals(clazz, d.getTestClass());\n\t\tassertEquals(\"tessed\", d.getMethodName());\n\t\tassertEquals(1, d.getAnnotations().size());\n\t\tassertEquals(Test.class, d.getAnnotations().iterator().next().annotationType());\n\t}\n\n\t@Ignore\n\tprivate static class Sweet {\n\t\t@Test\n\t\tpublic void tessed() {}\n\t}\n\n}\n","lineNo":86}
{"Smelly Sample":"package org.junit.runner.notification;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.runner.Description;\nimport org.junit.runner.Result;\n\n/**\n * If you write custom runners, you may need to notify JUnit of your progress running tests.\n * Do this by invoking the <code>RunNotifier<\/code> passed to your implementation of\n * {@link org.junit.runner.Runner#run(RunNotifier)}. Future evolution of this class is likely to \n * move {@link #fireTestRunStarted(Description)} and {@link #fireTestRunFinished(Result)}\n * to a separate class since they should only be called once per run.\n */\npublic class RunNotifier {\n\tprivate final List<RunListener> fListeners= \n\t\tCollections.synchronizedList(new ArrayList<RunListener>());\n\tprivate boolean fPleaseStop= false;\n\t\n\t/** Internal use only\n\t */\n\tpublic void addListener(RunListener listener) {\n\t\tfListeners.add(listener);\n\t}\n\n\t/** Internal use only\n\t */\n\tpublic void removeListener(RunListener listener) {\n\t\tfListeners.remove(listener);\n    }\n\n\tprivate abstract class SafeNotifier {\n\t\tvoid run() {\n\t\t\tsynchronized (fListeners) {\n\t\t\t\tfor (Iterator<RunListener> all= fListeners.iterator(); all.hasNext();)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnotifyListener(all.next());\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tall.remove(); // Remove the offending listener first to avoid an infinite loop\n\t\t\t\t\t\tfireTestFailure(new Failure(Description.TEST_MECHANISM, e));\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tabstract protected void notifyListener(RunListener each) throws Exception;\n\t}\n\t\n\t/**\n\t * Do not invoke. \n\t */\n\tpublic void fireTestRunStarted(final Description description) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testRunStarted(description);\n\t\t\t};\n\t\t}.run();\n\t}\n\t\n\t/**\n\t * Do not invoke.\n\t */\n\tpublic void fireTestRunFinished(final Result result) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testRunFinished(result);\n\t\t\t};\n\t\t}.run();\n\t}\n\t\n\t/**\n\t * Invoke to tell listeners that an atomic test is about to start.\n\t * @param description the description of the atomic test (generally a class and method name)\n\t * @throws StoppedByUserException thrown if a user has requested that the test run stop\n\t */\n\tpublic void fireTestStarted(final Description description) throws StoppedByUserException {\n\t\tif (fPleaseStop)\n\t\t\tthrow new StoppedByUserException();\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testStarted(description);\n\t\t\t};\n\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test failed.\n\t * @param failure the description of the test that failed and the exception thrown\n\t */\n\tpublic void fireTestFailure(final Failure failure) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testFailure(failure);\n\t\t\t};\n\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test flagged that it assumed\n\t * something false.\n\t * \n\t * @param failure\n\t *            the description of the test that failed and the\n\t *            {@link AssumptionViolatedException} thrown\n\t */\n\tpublic void fireTestAssumptionFailed(final Failure failure) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testAssumptionFailure(failure);\n\t\t\t};\n\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test was ignored.\n\t * @param description the description of the ignored test\n\t */\n\tpublic void fireTestIgnored(final Description description) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testIgnored(description);\n\t\t\t}\n\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test finished. Always invoke \n\t * {@link #fireTestFinished(Description)} if you invoke {@link #fireTestStarted(Description)} \n\t * as listeners are likely to expect them to come in pairs.\n\t * @param description the description of the test that finished\n\t */\n\tpublic void fireTestFinished(final Description description) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testFinished(description);\n\t\t\t};\n\t\t}.run();\n\t}\n\t\n\t/**\n\t * Ask that the tests run stop before starting the next test. Phrased politely because\n\t * the test currently running will not be interrupted. It seems a little odd to put this\n\t * functionality here, but the <code>RunNotifier<\/code> is the only object guaranteed \n\t * to be shared amongst the many runners involved.\n\t */\n\tpublic void pleaseStop() {\n\t\tfPleaseStop= true;\n\t}\n\n\t/**\n\t * Internal use only. The Result's listener must be first.\n\t */\n\tpublic void addFirstListener(RunListener listener) {\n\t\tfListeners.add(0, listener);\n\t}\n}\n","Method after Refactoring":"package org.junit.runner.notification;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.internal.AssumptionViolatedException;\nimport org.junit.runner.Description;\nimport org.junit.runner.Result;\n\n/**\n * If you write custom runners, you may need to notify JUnit of your progress running tests.\n * Do this by invoking the <code>RunNotifier<\/code> passed to your implementation of\n * {@link org.junit.runner.Runner#run(RunNotifier)}. Future evolution of this class is likely to \n * move {@link #fireTestRunStarted(Description)} and {@link #fireTestRunFinished(Result)}\n * to a separate class since they should only be called once per run.\n */\npublic class RunNotifier {\n\tprivate final List<RunListener> fListeners= \n\t\tCollections.synchronizedList(new ArrayList<RunListener>());\n\tprivate boolean fPleaseStop= false;\n\t\n\t/** Internal use only\n\t */\n\tpublic void addListener(RunListener listener) {\n\t\tfListeners.add(listener);\n\t}\n\n\t/** Internal use only\n\t */\n\tpublic void removeListener(RunListener listener) {\n\t\tfListeners.remove(listener);\n    }\n\n\tprivate abstract class SafeNotifier {\n\t\tprivate final List<RunListener> fCurrentListeners;\n\n\t\tSafeNotifier() {\n\t\t\tthis(fListeners);\n\t\t}\n\n\t\tSafeNotifier(List<RunListener> currentListeners) {\n\t\t\tfCurrentListeners= currentListeners;\n\t\t}\n\n\t\tvoid run() {\n\t\t\tsynchronized (fListeners) {\n\t\t\t\tList<RunListener> safeListeners= new ArrayList<RunListener>();\n\t\t\t\tList<Failure> failures= new ArrayList<Failure>();\n\t\t\t\tfor (Iterator<RunListener> all= fCurrentListeners.iterator(); all\n\t\t\t\t\t\t.hasNext();)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRunListener listener= all.next();\n\t\t\t\t\t\tnotifyListener(listener);\n\t\t\t\t\t\tsafeListeners.add(listener);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tfailures.add(new Failure(Description.TEST_MECHANISM, e));\n\t\t\t\t\t}\n\t\t\t\tfireTestFailures(safeListeners, failures);\n\t\t\t}\n\t\t}\n\t\t\n\t\tabstract protected void notifyListener(RunListener each) throws Exception;\n\t}\n\t\n\t/**\n\t * Do not invoke. \n\t */\n\tpublic void fireTestRunStarted(final Description description) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testRunStarted(description);\n\t\t\t};\n\t\t}.run();\n\t}\n\t\n\t/**\n\t * Do not invoke.\n\t */\n\tpublic void fireTestRunFinished(final Result result) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testRunFinished(result);\n\t\t\t};\n\t\t}.run();\n\t}\n\t\n\t/**\n\t * Invoke to tell listeners that an atomic test is about to start.\n\t * @param description the description of the atomic test (generally a class and method name)\n\t * @throws StoppedByUserException thrown if a user has requested that the test run stop\n\t */\n\tpublic void fireTestStarted(final Description description) throws StoppedByUserException {\n\t\tif (fPleaseStop)\n\t\t\tthrow new StoppedByUserException();\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testStarted(description);\n\t\t\t};\n\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test failed.\n\t * @param failure the description of the test that failed and the exception thrown\n\t */\n\tpublic void fireTestFailure(Failure failure) {\n\t\tfireTestFailures(fListeners, asList(failure));\n\t}\n\n\tprivate void fireTestFailures(List<RunListener> listeners,\n\t\t\tfinal List<Failure> failures) {\n\t\tif (!failures.isEmpty())\n\t\t\tnew SafeNotifier(listeners) {\n\t\t\t\t@Override\n\t\t\t\tprotected void notifyListener(RunListener listener)\n\t\t\t\t\t\tthrows Exception {\n\t\t\t\t\tfor (Failure each : failures)\n\t\t\t\t\t\tlistener.testFailure(each);\n\t\t\t\t};\n\t\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test flagged that it assumed\n\t * something false.\n\t * \n\t * @param failure\n\t *            the description of the test that failed and the\n\t *            {@link AssumptionViolatedException} thrown\n\t */\n\tpublic void fireTestAssumptionFailed(final Failure failure) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testAssumptionFailure(failure);\n\t\t\t};\n\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test was ignored.\n\t * @param description the description of the ignored test\n\t */\n\tpublic void fireTestIgnored(final Description description) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testIgnored(description);\n\t\t\t}\n\t\t}.run();\n\t}\n\n\t/**\n\t * Invoke to tell listeners that an atomic test finished. Always invoke \n\t * {@link #fireTestFinished(Description)} if you invoke {@link #fireTestStarted(Description)} \n\t * as listeners are likely to expect them to come in pairs.\n\t * @param description the description of the test that finished\n\t */\n\tpublic void fireTestFinished(final Description description) {\n\t\tnew SafeNotifier() {\n\t\t\t@Override\n\t\t\tprotected void notifyListener(RunListener each) throws Exception {\n\t\t\t\teach.testFinished(description);\n\t\t\t};\n\t\t}.run();\n\t}\n\t\n\t/**\n\t * Ask that the tests run stop before starting the next test. Phrased politely because\n\t * the test currently running will not be interrupted. It seems a little odd to put this\n\t * functionality here, but the <code>RunNotifier<\/code> is the only object guaranteed \n\t * to be shared amongst the many runners involved.\n\t */\n\tpublic void pleaseStop() {\n\t\tfPleaseStop= true;\n\t}\n\n\t/**\n\t * Internal use only. The Result's listener must be first.\n\t */\n\tpublic void addFirstListener(RunListener listener) {\n\t\tfListeners.add(0, listener);\n\t}\n}\n","lineNo":56}
{"Smelly Sample":"package org.junit.runners;\n\nimport static java.lang.String.format;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\n\n/**\n * <p>\n * The custom runner <code>Parameterized<\/code> implements parameterized tests.\n * When running a parameterized test class, instances are created for the\n * cross-product of the test methods and the test data elements.\n * <\/p>\n * \n * For example, to test a Fibonacci function, write:\n * \n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class FibonacciTest {\n * \t&#064;Parameters\n * \tpublic static Iterable&lt;Object[]&gt; data() {\n * \t\treturn Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },\n * \t\t\t\t{ 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });\n * \t}\n * \n * \tprivate int fInput;\n * \n * \tprivate int fExpected;\n * \n * \tpublic FibonacciTest(int input, int expected) {\n * \t\tfInput= input;\n * \t\tfExpected= expected;\n * \t}\n * \n * \t&#064;Test\n * \tpublic void test() {\n * \t\tassertEquals(fExpected, Fibonacci.compute(fInput));\n * \t}\n * }\n * <\/pre>\n * \n * <p>\n * Each instance of <code>FibonacciTest<\/code> will be constructed using the\n * two-argument constructor and the data values in the\n * <code>&#064;Parameters<\/code> method.\n * <\/p>\n */\npublic class Parameterized extends Suite {\n\t/**\n\t * Annotation for a method which provides parameters to be injected into the\n\t * test class constructor by <code>Parameterized<\/code>\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.METHOD)\n\tpublic static @interface Parameters {\n\t}\n\n\tprivate class TestClassRunnerForParameters extends\n\t\t\tBlockJUnit4ClassRunner {\n\t\tprivate final int fParameterSetNumber;\n\n\t\tprivate final Object[] fParameters;\n\n\t\tTestClassRunnerForParameters(Class<?> type, Object[] parameters, int i)\n\t\t\t\tthrows InitializationError {\n\t\t\tsuper(type);\n\t\t\tfParameters= parameters;\n\t\t\tfParameterSetNumber= i;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\treturn getTestClass().getOnlyConstructor().newInstance(fParameters);\n\t\t}\n\n\t\t@Override\n\t\tprotected String getName() {\n\t\t\treturn String.format(\"[%s]\", fParameterSetNumber);\n\t\t}\n\n\t\t@Override\n\t\tprotected String testName(final FrameworkMethod method) {\n\t\t\treturn String.format(\"%s[%s]\", method.getName(),\n\t\t\t\t\tfParameterSetNumber);\n\t\t}\n\n\t\t@Override\n\t\tprotected void validateConstructor(List<Throwable> errors) {\n\t\t\tvalidateOnlyOneConstructor(errors);\n\t\t}\n\n\t\t@Override\n\t\tprotected Statement classBlock(RunNotifier notifier) {\n\t\t\treturn childrenInvoker(notifier);\n\t\t}\n\t\t\n\t\t@Override\n\t\tprotected Annotation[] getRunnerAnnotations() {\n\t\t\treturn new Annotation[0];\n\t\t}\n\t}\n\n\tprivate final ArrayList<Runner> runners= new ArrayList<Runner>();\n\n\t/**\n\t * Only called reflectively. Do not use programmatically.\n\t */\n\tpublic Parameterized(Class<?> klass) throws Throwable {\n\t\tsuper(klass, Collections.<Runner> emptyList());\n\t\tIterable<Object[]> allParameters= getAllParameters();\n\t\tcreateRunnersForParameters(allParameters);\n\t}\n\n\t@Override\n\tprotected List<Runner> getChildren() {\n\t\treturn runners;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Iterable<Object[]> getAllParameters()\n\t\t\tthrows Throwable {\n\t\tObject parameters= getParametersMethod().invokeExplosively(null);\n\t\tif (parameters instanceof Iterable)\n\t\t\treturn (Iterable<Object[]>) parameters;\n\t\telse\n\t\t\tthrow parametersMethodReturnedWrongType();\n\t}\n\n\tprivate FrameworkMethod getParametersMethod()\n\t\t\tthrows Exception {\n\t\tList<FrameworkMethod> methods= getTestClass()\n\t\t\t\t.getAnnotatedMethods(Parameters.class);\n\t\tfor (FrameworkMethod each : methods) {\n\t\t\tif (each.isStatic() && each.isPublic())\n\t\t\t\treturn each;\n\t\t}\n\n\t\tthrow new Exception(\"No public static parameters method on class \"\n\t\t\t\t+ getTestClass().getName());\n\t}\n\n\tprivate void createRunnersForParameters(Iterable<Object[]> allParameters)\n\t\t\tthrows InitializationError, Exception {\n\t\ttry {\n\t\t\tint i= 0;\n\t\t\tfor (Object[] parametersOfSingleTest : allParameters) {\n\t\t\t\tTestClassRunnerForParameters runner= new TestClassRunnerForParameters(\n\t\t\t\t\t\tgetTestClass().getJavaClass(), parametersOfSingleTest,\n\t\t\t\t\t\ti);\n\t\t\t\trunners.add(runner);\n\t\t\t\t++i;\n\t\t\t}\n\t\t} catch (ClassCastException e) {\n\t\t\tthrow parametersMethodReturnedWrongType();\n\t\t}\n\t}\n\n\tprivate Exception parametersMethodReturnedWrongType() throws Exception {\n\t\tString className= getTestClass().getName();\n\t\tString methodName= getParametersMethod().getName();\n\t\tString message= format(\"%s.%s() must return an Iterable of arrays.\",\n\t\t\t\tclassName, methodName);\n\t\treturn new Exception(message);\n\t}\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static java.text.MessageFormat.format;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\n\n/**\n * <p>\n * The custom runner <code>Parameterized<\/code> implements parameterized tests.\n * When running a parameterized test class, instances are created for the\n * cross-product of the test methods and the test data elements.\n * <\/p>\n * \n * For example, to test a Fibonacci function, write:\n * \n * <pre>\n * &#064;RunWith(Parameterized.class)\n * public class FibonacciTest {\n * \t&#064;Parameters(name= &quot;fib({0})={1}&quot;)\n * \tpublic static Iterable&lt;Object[]&gt; data() {\n * \t\treturn Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },\n * \t\t\t\t{ 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });\n * \t}\n * \n * \tprivate int fInput;\n * \n * \tprivate int fExpected;\n * \n * \tpublic FibonacciTest(int input, int expected) {\n * \t\tfInput= input;\n * \t\tfExpected= expected;\n * \t}\n * \n * \t&#064;Test\n * \tpublic void test() {\n * \t\tassertEquals(fExpected, Fibonacci.compute(fInput));\n * \t}\n * }\n * <\/pre>\n * \n * <p>\n * Each instance of <code>FibonacciTest<\/code> will be constructed using the\n * two-argument constructor and the data values in the\n * <code>&#064;Parameters<\/code> method.\n * \n * <p>\n * In order that you can easily identify the individual tests, you may provide a\n * name for the <code>&#064;Parameters<\/code> annotation. This name is allowed\n * to contain placeholders, which are replaced at runtime. The placeholders are\n * <dl>\n * <dt>{index}<\/dt>\n * <dd>the current parameter index<\/dd>\n * <dt>{0}<\/dt>\n * <dd>the first parameter value<\/dd>\n * <dt>{1}<\/dt>\n * <dd>the second parameter value<\/dd>\n * <dt>...<\/dt>\n * <dd><\/dd>\n * <\/dl>\n * In the example given above, the <code>Parameterized<\/code> runner creates\n * names like <code>fib(3)=2<\/code>. If you don't use the name parameter, then\n * the current parameter index is used as name.\n * <\/p>\n */\npublic class Parameterized extends Suite {\n\t/**\n\t * Annotation for a method which provides parameters to be injected into the\n\t * test class constructor by <code>Parameterized<\/code>\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.METHOD)\n\tpublic static @interface Parameters {\n\t\t/**\n\t\t * <p>\n\t\t * Optional pattern to derive the test's name from the parameters. Use\n\t\t * numbers in braces to refer to the parameters or the additional data\n\t\t * as follows:\n\t\t * <\/p>\n\t\t * \n\t\t * <pre>\n\t\t * {index} - the current parameter index\n\t\t * {0} - the first parameter value\n\t\t * {1} - the second parameter value\n\t\t * etc...\n\t\t * <\/pre>\n\t\t * <p>\n\t\t * Default value is \"[{index}]\" for compatibility with previous JUnit\n\t\t * versions.\n\t\t * <\/p>\n\t\t * \n\t\t * @return {@link MessageFormat} pattern string, except the index\n\t\t *         placeholder.\n\t\t * @see MessageFormat\n\t\t */\n\t\tString name() default \"[{index}]\";\n\t}\n\n\tprivate class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {\n\t\tprivate final Object[] fParameters;\n\n\t\tprivate final String fName;\n\n\t\tTestClassRunnerForParameters(Class<?> type, Object[] parameters,\n\t\t\t\tString name) throws InitializationError {\n\t\t\tsuper(type);\n\t\t\tfParameters= parameters;\n\t\t\tfName= name;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\treturn getTestClass().getOnlyConstructor().newInstance(fParameters);\n\t\t}\n\n\t\t@Override\n\t\tprotected String getName() {\n\t\t\treturn fName;\n\t\t}\n\n\t\t@Override\n\t\tprotected String testName(FrameworkMethod method) {\n\t\t\treturn method.getName() + getName();\n\t\t}\n\n\t\t@Override\n\t\tprotected void validateConstructor(List<Throwable> errors) {\n\t\t\tvalidateOnlyOneConstructor(errors);\n\t\t}\n\n\t\t@Override\n\t\tprotected Statement classBlock(RunNotifier notifier) {\n\t\t\treturn childrenInvoker(notifier);\n\t\t}\n\n\t\t@Override\n\t\tprotected Annotation[] getRunnerAnnotations() {\n\t\t\treturn new Annotation[0];\n\t\t}\n\t}\n\n\tprivate static final List<Runner> NO_RUNNERS= Collections\n\t\t\t.<Runner> emptyList();\n\n\tprivate final ArrayList<Runner> runners= new ArrayList<Runner>();\n\n\t/**\n\t * Only called reflectively. Do not use programmatically.\n\t */\n\tpublic Parameterized(Class<?> klass) throws Throwable {\n\t\tsuper(klass, NO_RUNNERS);\n\t\tParameters parameters= getParametersMethod().getAnnotation(\n\t\t\t\tParameters.class);\n\t\tcreateRunnersForParameters(allParameters(), parameters.name());\n\t}\n\n\t@Override\n\tprotected List<Runner> getChildren() {\n\t\treturn runners;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Iterable<Object[]> allParameters() throws Throwable {\n\t\tObject parameters= getParametersMethod().invokeExplosively(null);\n\t\tif (parameters instanceof Iterable)\n\t\t\treturn (Iterable<Object[]>) parameters;\n\t\telse\n\t\t\tthrow parametersMethodReturnedWrongType();\n\t}\n\n\tprivate FrameworkMethod getParametersMethod() throws Exception {\n\t\tList<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(\n\t\t\t\tParameters.class);\n\t\tfor (FrameworkMethod each : methods) {\n\t\t\tif (each.isStatic() && each.isPublic())\n\t\t\t\treturn each;\n\t\t}\n\n\t\tthrow new Exception(\"No public static parameters method on class \"\n\t\t\t\t+ getTestClass().getName());\n\t}\n\n\tprivate void createRunnersForParameters(Iterable<Object[]> allParameters,\n\t\t\tString namePattern) throws InitializationError, Exception {\n\t\ttry {\n\t\t\tint i= 0;\n\t\t\tfor (Object[] parametersOfSingleTest : allParameters) {\n\t\t\t\tString name= nameFor(namePattern, i, parametersOfSingleTest);\n\t\t\t\tTestClassRunnerForParameters runner= new TestClassRunnerForParameters(\n\t\t\t\t\t\tgetTestClass().getJavaClass(), parametersOfSingleTest,\n\t\t\t\t\t\tname);\n\t\t\t\trunners.add(runner);\n\t\t\t\t++i;\n\t\t\t}\n\t\t} catch (ClassCastException e) {\n\t\t\tthrow parametersMethodReturnedWrongType();\n\t\t}\n\t}\n\n\tprivate String nameFor(String namePattern, int index, Object[] parameters) {\n\t\tString finalPattern= namePattern.replaceAll(\"\\\\{index\\\\}\",\n\t\t\t\tInteger.toString(index));\n\t\treturn format(finalPattern, parameters);\n\t}\n\n\tprivate Exception parametersMethodReturnedWrongType() throws Exception {\n\t\tString className= getTestClass().getName();\n\t\tString methodName= getParametersMethod().getName();\n\t\tString message= format(\"{0}.{1}() must return an Iterable of arrays.\",\n\t\t\t\tclassName, methodName);\n\t\treturn new Exception(message);\n\t}\n}\n","lineNo":201}
{"Smelly Sample":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.RULE_VALIDATOR;\n\nimport java.util.List;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * \n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n * \n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n * \n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n\t/**\n\t * Creates a BlockJUnit4ClassRunner to run {@code klass}\n\t * \n\t * @throws InitializationError\n\t *             if the test class is malformed.\n\t */\n\tpublic BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t//\n\t// Implementation of ParentRunner\n\t// \n\n\t@Override\n\tprotected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n\t\tDescription description= describeChild(method);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\tnotifier.fireTestIgnored(description);\n\t\t} else {\n\t\t\trunLeaf(methodBlock(method), description, notifier);\n\t\t}\n\t}\n\n\t@Override\n\tprotected Description describeChild(FrameworkMethod method) {\n\t\treturn Description.createTestDescription(getTestClass().getJavaClass(),\n\t\t\t\ttestName(method), method.getAnnotations());\n\t}\n\n\t@Override\n\tprotected List<FrameworkMethod> getChildren() {\n\t\treturn computeTestMethods();\n\t}\n\n\t//\n\t// Override in subclasses\n\t//\n\n\t/**\n\t * Returns the methods that run tests. Default implementation returns all\n\t * methods annotated with {@code @Test} on this class and superclasses that\n\t * are not overridden.\n\t */\n\tprotected List<FrameworkMethod> computeTestMethods() {\n\t\treturn getTestClass().getAnnotatedMethods(Test.class);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tsuper.collectInitializationErrors(errors);\n\n\t\tvalidateNoNonStaticInnerClass(errors);\n\t\tvalidateConstructor(errors);\n\t\tvalidateInstanceMethods(errors);\n\t\tvalidateFields(errors);\n\t}\n\n\tprotected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n\t\tif (getTestClass().isANonStaticInnerClass()) {\n\t\t\tString gripe= \"The inner class \" + getTestClass().getName()\n\t\t\t\t\t+ \" is not static.\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}\n\n\t/**\n\t * Adds to {@code errors} if the test class has more than one constructor,\n\t * or if the constructor takes parameters. Override if a subclass requires\n\t * different validation rules.\n\t */\n\tprotected void validateConstructor(List<Throwable> errors) {\n\t\tvalidateOnlyOneConstructor(errors);\n\t\tvalidateZeroArgConstructor(errors);\n\t}\n\n\t/**\n\t * Adds to {@code errors} if the test class has more than one constructor\n\t * (do not override)\n\t */\n\tprotected void validateOnlyOneConstructor(List<Throwable> errors) {\n\t\tif (!hasOneConstructor()) {\n\t\t\tString gripe= \"Test class should have exactly one public constructor\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}\n\n\t/**\n\t * Adds to {@code errors} if the test class's single constructor takes\n\t * parameters (do not override)\n\t */\n\tprotected void validateZeroArgConstructor(List<Throwable> errors) {\n\t\tif (!getTestClass().isANonStaticInnerClass()\n\t\t\t\t&& hasOneConstructor()\n\t\t\t\t&& (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n\t\t\tString gripe= \"Test class should have exactly one public zero-argument constructor\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}\n\n\tprivate boolean hasOneConstructor() {\n\t\treturn getTestClass().getJavaClass().getConstructors().length == 1;\n\t}\n\n\t/**\n\t * Adds to {@code errors} for each method annotated with {@code @Test},\n\t * {@code @Before}, or {@code @After} that is not a public, void instance\n\t * method with no arguments.\n\t * \n\t * @deprecated unused API, will go away in future version\n\t */\n\t@Deprecated\n\tprotected void validateInstanceMethods(List<Throwable> errors) {\n\t\tvalidatePublicVoidNoArgMethods(After.class, false, errors);\n\t\tvalidatePublicVoidNoArgMethods(Before.class, false, errors);\n\t\tvalidateTestMethods(errors);\n\n\t\tif (computeTestMethods().size() == 0)\n\t\t\terrors.add(new Exception(\"No runnable methods\"));\n\t}\n\n\tprivate void validateFields(List<Throwable> errors) {\n\t\tRULE_VALIDATOR.validate(getTestClass(), errors);\n\t}\n\n\t/**\n\t * Adds to {@code errors} for each method annotated with {@code @Test}that\n\t * is not a public, void instance method with no arguments.\n\t */\n\tprotected void validateTestMethods(List<Throwable> errors) {\n\t\tvalidatePublicVoidNoArgMethods(Test.class, false, errors);\n\t}\n\n\t/**\n\t * Returns a new fixture for running a test. Default implementation executes\n\t * the test class's no-argument constructor (validation should have ensured\n\t * one exists).\n\t */\n\tprotected Object createTest() throws Exception {\n\t\treturn getTestClass().getOnlyConstructor().newInstance();\n\t}\n\n\t/**\n\t * Returns the name that describes {@code method} for {@link Description}s.\n\t * Default implementation is the method's name\n\t */\n\tprotected String testName(FrameworkMethod method) {\n\t\treturn method.getName();\n\t}\n\n\t/**\n\t * Returns a Statement that, when executed, either returns normally if\n\t * {@code method} passes, or throws an exception if {@code method} fails.\n\t * \n\t * Here is an outline of the default implementation:\n\t * \n\t * <ul>\n\t * <li>Invoke {@code method} on the result of {@code createTest()}, and\n\t * throw any exceptions thrown by either operation.\n\t * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n\t * expecting} attribute, return normally only if the previous step threw an\n\t * exception of the correct type, and throw an exception otherwise.\n\t * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n\t * timeout} attribute, throw an exception if the previous step takes more\n\t * than the specified number of milliseconds.\n\t * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n\t * and superclasses before any of the previous steps; if any throws an\n\t * Exception, stop execution and pass the exception on.\n\t * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n\t * and superclasses after any of the previous steps; all After methods are\n\t * always executed: exceptions thrown by previous steps are combined, if\n\t * necessary, with exceptions from After methods into a\n\t * {@link MultipleFailureException}.\n\t * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n\t * above steps. A {@code Rule} may prevent all execution of the above steps,\n\t * or add additional behavior before and after, or modify thrown exceptions.\n\t * For more information, see {@link TestRule}\n\t * <\/ul>\n\t * \n\t * This can be overridden in subclasses, either by overriding this method,\n\t * or the implementations creating each sub-statement.\n\t */\n\tprotected Statement methodBlock(FrameworkMethod method) {\n\t\tObject test;\n\t\ttry {\n\t\t\ttest= new ReflectiveCallable() {\n\t\t\t\t@Override\n\t\t\t\tprotected Object runReflectiveCall() throws Throwable {\n\t\t\t\t\treturn createTest();\n\t\t\t\t}\n\t\t\t}.run();\n\t\t} catch (Throwable e) {\n\t\t\treturn new Fail(e);\n\t\t}\n\n\t\tStatement statement= methodInvoker(method, test);\n\t\tstatement= possiblyExpectingExceptions(method, test, statement);\n\t\tstatement= withPotentialTimeout(method, test, statement);\n\t\tstatement= withBefores(method, test, statement);\n\t\tstatement= withAfters(method, test, statement);\n\t\tstatement= withRules(method, test, statement);\n\t\treturn statement;\n\t}\n\n\t//\n\t// Statement builders\n\t//\n\n\t/**\n\t * Returns a {@link Statement} that invokes {@code method} on {@code test}\n\t */\n\tprotected Statement methodInvoker(FrameworkMethod method, Object test) {\n\t\treturn new InvokeMethod(method, test);\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n\t * has the {@code expecting} attribute, return normally only if {@code next}\n\t * throws an exception of the correct type, and throw an exception\n\t * otherwise.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement possiblyExpectingExceptions(FrameworkMethod method,\n\t\t\tObject test, Statement next) {\n\t\tTest annotation= method.getAnnotation(Test.class);\n\t\treturn expectsException(annotation) ? new ExpectException(next,\n\t\t\t\tgetExpectedException(annotation)) : next;\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n\t * has the {@code timeout} attribute, throw an exception if {@code next}\n\t * takes more than the specified number of milliseconds.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement withPotentialTimeout(FrameworkMethod method,\n\t\t\tObject test, Statement next) {\n\t\tlong timeout= getTimeout(method.getAnnotation(Test.class));\n\t\treturn timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: run all non-overridden {@code @Before}\n\t * methods on this class and superclasses before running {@code next}; if\n\t * any throws an Exception, stop execution and pass the exception on.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement withBefores(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tList<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(\n\t\t\t\tBefore.class);\n\t\treturn befores.isEmpty() ? statement : new RunBefores(statement,\n\t\t\t\tbefores, target);\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: run all non-overridden {@code @After}\n\t * methods on this class and superclasses before running {@code next}; all\n\t * After methods are always executed: exceptions thrown by previous steps\n\t * are combined, if necessary, with exceptions from After methods into a\n\t * {@link MultipleFailureException}.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement withAfters(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tList<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(\n\t\t\t\tAfter.class);\n\t\treturn afters.isEmpty() ? statement : new RunAfters(statement, afters,\n\t\t\t\ttarget);\n\t}\n\n\tprivate Statement withRules(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tStatement result= statement;\n\t\tresult= withMethodRules(method, target, result);\n\t\tresult= withTestRules(method, target, result);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tList<TestRule> testRules= getTestRules(target);\n\t\tfor (org.junit.rules.MethodRule each : getMethodRules(target))\n\t\t\tif (! testRules.contains(each))\n\t\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn rules(target);\n\t}\n\n\t/**\n\t * @param target\n\t *            the test case instance\n\t * @return a list of MethodRules that should be applied when executing this\n\t *         test\n\t * @deprecated {@link org.junit.rules.MethodRule} is a deprecated interface. Port to\n\t *             {@link TestRule} and\n\t *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}\n\t */\n\t@Deprecated\n\tprotected List<org.junit.rules.MethodRule> rules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target, Rule.class,\n\t\t\t\torg.junit.rules.MethodRule.class);\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: apply all non-static {@link Value} fields\n\t * annotated with {@link Rule}.\n\t *\n\t * @param statement The base statement\n\t * @return a RunRules statement if any class-level {@link Rule}s are\n\t *         found, or the base statement\n\t */\n\tprivate Statement withTestRules(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tList<TestRule> testRules= getTestRules(target);\n\t\treturn testRules.isEmpty() ? statement :\n\t\t\tnew RunRules(statement, testRules, describeChild(method));\n\t}\n\n\t/**\n\t * @param target\n\t *            the test case instance\n\t * @return a list of TestRules that should be applied when executing this\n\t *         test\n\t */\n\tprotected List<TestRule> getTestRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, TestRule.class);\n\t}\n\n\tprivate Class<? extends Throwable> getExpectedException(Test annotation) {\n\t\tif (annotation == null || annotation.expected() == None.class)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn annotation.expected();\n\t}\n\n\tprivate boolean expectsException(Test annotation) {\n\t\treturn getExpectedException(annotation) != null;\n\t}\n\n\tprivate long getTimeout(Test annotation) {\n\t\tif (annotation == null)\n\t\t\treturn 0;\n\t\treturn annotation.timeout();\n\t}\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport static org.junit.internal.runners.rules.RuleFieldValidator.RULE_VALIDATOR;\nimport static org.junit.internal.runners.rules.RuleFieldValidator.RULE_METHOD_VALIDATOR;\n\nimport java.util.List;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.Test.None;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.statements.ExpectException;\nimport org.junit.internal.runners.statements.Fail;\nimport org.junit.internal.runners.statements.FailOnTimeout;\nimport org.junit.internal.runners.statements.InvokeMethod;\nimport org.junit.internal.runners.statements.RunAfters;\nimport org.junit.internal.runners.statements.RunBefores;\nimport org.junit.rules.RunRules;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.MultipleFailureException;\nimport org.junit.runners.model.Statement;\n\n/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n * \n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n * \n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n * \n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * <\/ul>\n */\npublic class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {\n\t/**\n\t * Creates a BlockJUnit4ClassRunner to run {@code klass}\n\t * \n\t * @throws InitializationError\n\t *             if the test class is malformed.\n\t */\n\tpublic BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t//\n\t// Implementation of ParentRunner\n\t// \n\n\t@Override\n\tprotected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n\t\tDescription description= describeChild(method);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\tnotifier.fireTestIgnored(description);\n\t\t} else {\n\t\t\trunLeaf(methodBlock(method), description, notifier);\n\t\t}\n\t}\n\n\t@Override\n\tprotected Description describeChild(FrameworkMethod method) {\n\t\treturn Description.createTestDescription(getTestClass().getJavaClass(),\n\t\t\t\ttestName(method), method.getAnnotations());\n\t}\n\n\t@Override\n\tprotected List<FrameworkMethod> getChildren() {\n\t\treturn computeTestMethods();\n\t}\n\n\t//\n\t// Override in subclasses\n\t//\n\n\t/**\n\t * Returns the methods that run tests. Default implementation returns all\n\t * methods annotated with {@code @Test} on this class and superclasses that\n\t * are not overridden.\n\t */\n\tprotected List<FrameworkMethod> computeTestMethods() {\n\t\treturn getTestClass().getAnnotatedMethods(Test.class);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tsuper.collectInitializationErrors(errors);\n\n\t\tvalidateNoNonStaticInnerClass(errors);\n\t\tvalidateConstructor(errors);\n\t\tvalidateInstanceMethods(errors);\n\t\tvalidateFields(errors);\n\t\tvalidateMethods(errors);\n\t}\n\n\tprotected void validateNoNonStaticInnerClass(List<Throwable> errors) {\n\t\tif (getTestClass().isANonStaticInnerClass()) {\n\t\t\tString gripe= \"The inner class \" + getTestClass().getName()\n\t\t\t\t\t+ \" is not static.\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}\n\n\t/**\n\t * Adds to {@code errors} if the test class has more than one constructor,\n\t * or if the constructor takes parameters. Override if a subclass requires\n\t * different validation rules.\n\t */\n\tprotected void validateConstructor(List<Throwable> errors) {\n\t\tvalidateOnlyOneConstructor(errors);\n\t\tvalidateZeroArgConstructor(errors);\n\t}\n\n\t/**\n\t * Adds to {@code errors} if the test class has more than one constructor\n\t * (do not override)\n\t */\n\tprotected void validateOnlyOneConstructor(List<Throwable> errors) {\n\t\tif (!hasOneConstructor()) {\n\t\t\tString gripe= \"Test class should have exactly one public constructor\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}\n\n\t/**\n\t * Adds to {@code errors} if the test class's single constructor takes\n\t * parameters (do not override)\n\t */\n\tprotected void validateZeroArgConstructor(List<Throwable> errors) {\n\t\tif (!getTestClass().isANonStaticInnerClass()\n\t\t\t\t&& hasOneConstructor()\n\t\t\t\t&& (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n\t\t\tString gripe= \"Test class should have exactly one public zero-argument constructor\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}\n\n\tprivate boolean hasOneConstructor() {\n\t\treturn getTestClass().getJavaClass().getConstructors().length == 1;\n\t}\n\n\t/**\n\t * Adds to {@code errors} for each method annotated with {@code @Test},\n\t * {@code @Before}, or {@code @After} that is not a public, void instance\n\t * method with no arguments.\n\t * \n\t * @deprecated unused API, will go away in future version\n\t */\n\t@Deprecated\n\tprotected void validateInstanceMethods(List<Throwable> errors) {\n\t\tvalidatePublicVoidNoArgMethods(After.class, false, errors);\n\t\tvalidatePublicVoidNoArgMethods(Before.class, false, errors);\n\t\tvalidateTestMethods(errors);\n\n\t\tif (computeTestMethods().size() == 0)\n\t\t\terrors.add(new Exception(\"No runnable methods\"));\n\t}\n\n\tprivate void validateFields(List<Throwable> errors) {\n\t\tRULE_VALIDATOR.validate(getTestClass(), errors);\n\t}\n\n\tprivate void validateMethods(List<Throwable> errors) {\n\t\tRULE_METHOD_VALIDATOR.validate(getTestClass(), errors);\n\t}\n\n\t/**\n\t * Adds to {@code errors} for each method annotated with {@code @Test}that\n\t * is not a public, void instance method with no arguments.\n\t */\n\tprotected void validateTestMethods(List<Throwable> errors) {\n\t\tvalidatePublicVoidNoArgMethods(Test.class, false, errors);\n\t}\n\n\t/**\n\t * Returns a new fixture for running a test. Default implementation executes\n\t * the test class's no-argument constructor (validation should have ensured\n\t * one exists).\n\t */\n\tprotected Object createTest() throws Exception {\n\t\treturn getTestClass().getOnlyConstructor().newInstance();\n\t}\n\n\t/**\n\t * Returns the name that describes {@code method} for {@link Description}s.\n\t * Default implementation is the method's name\n\t */\n\tprotected String testName(FrameworkMethod method) {\n\t\treturn method.getName();\n\t}\n\n\t/**\n\t * Returns a Statement that, when executed, either returns normally if\n\t * {@code method} passes, or throws an exception if {@code method} fails.\n\t * \n\t * Here is an outline of the default implementation:\n\t * \n\t * <ul>\n\t * <li>Invoke {@code method} on the result of {@code createTest()}, and\n\t * throw any exceptions thrown by either operation.\n\t * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n\t * expecting} attribute, return normally only if the previous step threw an\n\t * exception of the correct type, and throw an exception otherwise.\n\t * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n\t * timeout} attribute, throw an exception if the previous step takes more\n\t * than the specified number of milliseconds.\n\t * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n\t * and superclasses before any of the previous steps; if any throws an\n\t * Exception, stop execution and pass the exception on.\n\t * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n\t * and superclasses after any of the previous steps; all After methods are\n\t * always executed: exceptions thrown by previous steps are combined, if\n\t * necessary, with exceptions from After methods into a\n\t * {@link MultipleFailureException}.\n\t * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n\t * above steps. A {@code Rule} may prevent all execution of the above steps,\n\t * or add additional behavior before and after, or modify thrown exceptions.\n\t * For more information, see {@link TestRule}\n\t * <\/ul>\n\t * \n\t * This can be overridden in subclasses, either by overriding this method,\n\t * or the implementations creating each sub-statement.\n\t */\n\tprotected Statement methodBlock(FrameworkMethod method) {\n\t\tObject test;\n\t\ttry {\n\t\t\ttest= new ReflectiveCallable() {\n\t\t\t\t@Override\n\t\t\t\tprotected Object runReflectiveCall() throws Throwable {\n\t\t\t\t\treturn createTest();\n\t\t\t\t}\n\t\t\t}.run();\n\t\t} catch (Throwable e) {\n\t\t\treturn new Fail(e);\n\t\t}\n\n\t\tStatement statement= methodInvoker(method, test);\n\t\tstatement= possiblyExpectingExceptions(method, test, statement);\n\t\tstatement= withPotentialTimeout(method, test, statement);\n\t\tstatement= withBefores(method, test, statement);\n\t\tstatement= withAfters(method, test, statement);\n\t\tstatement= withRules(method, test, statement);\n\t\treturn statement;\n\t}\n\n\t//\n\t// Statement builders\n\t//\n\n\t/**\n\t * Returns a {@link Statement} that invokes {@code method} on {@code test}\n\t */\n\tprotected Statement methodInvoker(FrameworkMethod method, Object test) {\n\t\treturn new InvokeMethod(method, test);\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n\t * has the {@code expecting} attribute, return normally only if {@code next}\n\t * throws an exception of the correct type, and throw an exception\n\t * otherwise.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement possiblyExpectingExceptions(FrameworkMethod method,\n\t\t\tObject test, Statement next) {\n\t\tTest annotation= method.getAnnotation(Test.class);\n\t\treturn expectsException(annotation) ? new ExpectException(next,\n\t\t\t\tgetExpectedException(annotation)) : next;\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation\n\t * has the {@code timeout} attribute, throw an exception if {@code next}\n\t * takes more than the specified number of milliseconds.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement withPotentialTimeout(FrameworkMethod method,\n\t\t\tObject test, Statement next) {\n\t\tlong timeout= getTimeout(method.getAnnotation(Test.class));\n\t\treturn timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: run all non-overridden {@code @Before}\n\t * methods on this class and superclasses before running {@code next}; if\n\t * any throws an Exception, stop execution and pass the exception on.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement withBefores(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tList<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(\n\t\t\t\tBefore.class);\n\t\treturn befores.isEmpty() ? statement : new RunBefores(statement,\n\t\t\t\tbefores, target);\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: run all non-overridden {@code @After}\n\t * methods on this class and superclasses before running {@code next}; all\n\t * After methods are always executed: exceptions thrown by previous steps\n\t * are combined, if necessary, with exceptions from After methods into a\n\t * {@link MultipleFailureException}.\n\t * \n\t * @deprecated Will be private soon: use Rules instead\n\t */\n\t@Deprecated\n\tprotected Statement withAfters(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tList<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(\n\t\t\t\tAfter.class);\n\t\treturn afters.isEmpty() ? statement : new RunAfters(statement, afters,\n\t\t\t\ttarget);\n\t}\n\n\tprivate Statement withRules(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tList<TestRule> testRules= getTestRules(target);\n\t\tStatement result= statement;\n\t\tresult= withMethodRules(method, testRules, target, result);\n\t\tresult= withTestRules(method, testRules, result);\n\t\t\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,\n\t\t\tObject target, Statement result) {\n\t\tfor (org.junit.rules.MethodRule each : getMethodRules(target))\n\t\t\tif (! testRules.contains(each))\n\t\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn rules(target);\n\t}\n\n\t/**\n\t * @param target\n\t *            the test case instance\n\t * @return a list of MethodRules that should be applied when executing this\n\t *         test\n\t * @deprecated {@link org.junit.rules.MethodRule} is a deprecated interface. Port to\n\t *             {@link TestRule} and\n\t *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}\n\t */\n\t@Deprecated\n\tprotected List<org.junit.rules.MethodRule> rules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target, Rule.class,\n\t\t\t\torg.junit.rules.MethodRule.class);\n\t}\n\n\t/**\n\t * Returns a {@link Statement}: apply all non-static {@link Value} fields\n\t * annotated with {@link Rule}.\n\t * @param method \n\t * @param testRules \n\t * @param statement The base statement\n\t * @return a RunRules statement if any class-level {@link Rule}s are\n\t *         found, or the base statement\n\t */\n\tprivate Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,\n\t\t\tStatement statement) {\n\t\treturn testRules.isEmpty() ? statement :\n\t\t\tnew RunRules(statement, testRules, describeChild(method));\n\t}\n\n\t/**\n\t * @param target\n\t *            the test case instance\n\t * @return a list of TestRules that should be applied when executing this\n\t *         test\n\t */\n\tprotected List<TestRule> getTestRules(Object target) {\n\t\tList<TestRule> result = getTestClass().getAnnotatedMethodValues(target,\n\t\t\t\tRule.class, TestRule.class);\n\t\t\t\n\t\tresult.addAll(getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, TestRule.class));\n\n\t\treturn result;\n\t}\n\t\n\tprivate Class<? extends Throwable> getExpectedException(Test annotation) {\n\t\tif (annotation == null || annotation.expected() == None.class)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn annotation.expected();\n\t}\n\n\tprivate boolean expectsException(Test annotation) {\n\t\treturn getExpectedException(annotation) != null;\n\t}\n\n\tprivate long getTimeout(Test annotation) {\n\t\tif (annotation == null)\n\t\t\treturn 0;\n\t\treturn annotation.timeout();\n\t}\n}\n","lineNo":335}
{"Smelly Sample":"package org.junit.rules;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\n\n/**\n * The TemporaryFolder Rule allows creation of files and folders that are\n * guaranteed to be deleted when the test method finishes (whether it passes or\n * fails):\n * \n * <pre>\n * public static class HasTempFolder {\n * \t&#064;Rule\n * \tpublic TemporaryFolder folder= new TemporaryFolder();\n * \n * \t&#064;Test\n * \tpublic void testUsingTempFolder() throws IOException {\n * \t\tFile createdFile= folder.newFile(&quot;myfile.txt&quot;);\n * \t\tFile createdFolder= folder.newFolder(&quot;subfolder&quot;);\n * \t\t// ...\n * \t}\n * }\n * <\/pre>\n */\npublic class TemporaryFolder extends ExternalResource {\n\tprivate File folder;\n\n\t@Override\n\tprotected void before() throws Throwable {\n\t\tcreate();\n\t}\n\n\t@Override\n\tprotected void after() {\n\t\tdelete();\n\t}\n\n\t// testing purposes only\n\t/**\n\t * for testing purposes only.  Do not use.\n\t */\n\tpublic void create() throws IOException {\n\t\tfolder= File.createTempFile(\"junit\", \"\");\n\t\tfolder.delete();\n\t\tfolder.mkdir();\n\t}\n\n\t/**\n\t * Returns a new fresh file with the given name under the temporary folder.\n\t */\n\tpublic File newFile(String fileName) throws IOException {\n\t\tFile file= new File(folder, fileName);\n\t\tfile.createNewFile();\n\t\treturn file;\n\t}\n\n\t/**\n\t * Returns a new fresh folder with the given name under the temporary folder.\n\t */\n\tpublic File newFolder(String... folderNames) {\n\t\tFile file = folder;\n\t\tfor (String folderName : folderNames) {\n\t\t\tfile = new File(file, folderName);\n\t\t\tfile.mkdir();\n\t\t}\n\t\treturn file;\n\t}\n\n\t/**\n\t * @return the location of this temporary folder.\n\t */\n\tpublic File getRoot() {\n\t\treturn folder;\n\t}\n\n\t/**\n\t * Delete all files and folders under the temporary folder.\n\t * Usually not called directly, since it is automatically applied \n\t * by the {@link Rule}\n\t */\n\tpublic void delete() {\n\t\trecursiveDelete(folder);\n\t}\n\n\tprivate void recursiveDelete(File file) {\n\t\tFile[] files= file.listFiles();\n\t\tif (files != null)\n\t\t\tfor (File each : files)\n\t\t\t\trecursiveDelete(each);\n\t\tfile.delete();\n\t}\n}\n","Method after Refactoring":"package org.junit.rules;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\n\n/**\n * The TemporaryFolder Rule allows creation of files and folders that are\n * guaranteed to be deleted when the test method finishes (whether it passes or\n * fails):\n * \n * <pre>\n * public static class HasTempFolder {\n * \t&#064;Rule\n * \tpublic TemporaryFolder folder= new TemporaryFolder();\n * \n * \t&#064;Test\n * \tpublic void testUsingTempFolder() throws IOException {\n * \t\tFile createdFile= folder.newFile(&quot;myfile.txt&quot;);\n * \t\tFile createdFolder= folder.newFolder(&quot;subfolder&quot;);\n * \t\t// ...\n * \t}\n * }\n * <\/pre>\n */\npublic class TemporaryFolder extends ExternalResource {\n\tprivate File folder;\n\n\t@Override\n\tprotected void before() throws Throwable {\n\t\tcreate();\n\t}\n\n\t@Override\n\tprotected void after() {\n\t\tdelete();\n\t}\n\n\t// testing purposes only\n\t/**\n\t * for testing purposes only.  Do not use.\n\t */\n\tpublic void create() throws IOException {\n\t\tfolder= newFolder();\n\t}\n\n\t/**\n\t * Returns a new fresh file with the given name under the temporary folder.\n\t */\n\tpublic File newFile(String fileName) throws IOException {\n\t\tFile file= new File(folder, fileName);\n\t\tfile.createNewFile();\n\t\treturn file;\n\t}\n\n\t/**\n\t * Returns a new fresh file with a random name under the temporary folder.\n\t */\n\tpublic File newFile() throws IOException {\n\t\treturn File.createTempFile(\"junit\", null, folder);\n\t}\n\n\t/**\n\t * Returns a new fresh folder with the given name under the temporary folder.\n\t */\n\tpublic File newFolder(String... folderNames) {\n\t\tFile file = folder;\n\t\tfor (String folderName : folderNames) {\n\t\t\tfile = new File(file, folderName);\n\t\t\tfile.mkdir();\n\t\t}\n\t\treturn file;\n\t}\n\n\t/**\n\t * Returns a new fresh folder with a random name under the temporary\n\t * folder.\n\t */\n\tpublic File newFolder() throws IOException {\n\t\tFile createdFolder= File.createTempFile(\"junit\", \"\", folder);\n\t\tcreatedFolder.delete();\n\t\tcreatedFolder.mkdir();\n\t\treturn createdFolder;\n\t}\n\n\t/**\n\t * @return the location of this temporary folder.\n\t */\n\tpublic File getRoot() {\n\t\treturn folder;\n\t}\n\n\t/**\n\t * Delete all files and folders under the temporary folder.\n\t * Usually not called directly, since it is automatically applied \n\t * by the {@link Rule}\n\t */\n\tpublic void delete() {\n\t\trecursiveDelete(folder);\n\t}\n\n\tprivate void recursiveDelete(File file) {\n\t\tFile[] files= file.listFiles();\n\t\tif (files != null)\n\t\t\tfor (File each : files)\n\t\t\t\trecursiveDelete(each);\n\t\tfile.delete();\n\t}\n}\n","lineNo":81}
{"Smelly Sample":"package org.junit.rules;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\n\n/**\n * The TemporaryFolder Rule allows creation of files and folders that are\n * guaranteed to be deleted when the test method finishes (whether it passes or\n * fails):\n * \n * <pre>\n * public static class HasTempFolder {\n * \t&#064;Rule\n * \tpublic TemporaryFolder folder= new TemporaryFolder();\n * \n * \t&#064;Test\n * \tpublic void testUsingTempFolder() throws IOException {\n * \t\tFile createdFile= folder.newFile(&quot;myfile.txt&quot;);\n * \t\tFile createdFolder= folder.newFolder(&quot;subfolder&quot;);\n * \t\t// ...\n * \t}\n * }\n * <\/pre>\n */\npublic class TemporaryFolder extends ExternalResource {\n\tprivate File folder;\n\n\t@Override\n\tprotected void before() throws Throwable {\n\t\tcreate();\n\t}\n\n\t@Override\n\tprotected void after() {\n\t\tdelete();\n\t}\n\n\t// testing purposes only\n\t/**\n\t * for testing purposes only.  Do not use.\n\t */\n\tpublic void create() throws IOException {\n\t\tfolder= File.createTempFile(\"junit\", \"\");\n\t\tfolder.delete();\n\t\tfolder.mkdir();\n\t}\n\n\t/**\n\t * Returns a new fresh file with the given name under the temporary folder.\n\t */\n\tpublic File newFile(String fileName) throws IOException {\n\t\tFile file= new File(folder, fileName);\n\t\tfile.createNewFile();\n\t\treturn file;\n\t}\n\n\t/**\n\t * Returns a new fresh folder with the given name under the temporary folder.\n\t */\n\tpublic File newFolder(String folderName) {\n\t\tFile file= new File(folder, folderName);\n\t\tfile.mkdir();\n\t\treturn file;\n\t}\n\n\t/**\n\t * @return the location of this temporary folder.\n\t */\n\tpublic File getRoot() {\n\t\treturn folder;\n\t}\n\n\t/**\n\t * Delete all files and folders under the temporary folder.\n\t * Usually not called directly, since it is automatically applied \n\t * by the {@link Rule}\n\t */\n\tpublic void delete() {\n\t\trecursiveDelete(folder);\n\t}\n\n\tprivate void recursiveDelete(File file) {\n\t\tFile[] files= file.listFiles();\n\t\tif (files != null)\n\t\t\tfor (File each : files)\n\t\t\t\trecursiveDelete(each);\n\t\tfile.delete();\n\t}\n}\n","Method after Refactoring":"package org.junit.rules;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\n\n/**\n * The TemporaryFolder Rule allows creation of files and folders that are\n * guaranteed to be deleted when the test method finishes (whether it passes or\n * fails):\n * \n * <pre>\n * public static class HasTempFolder {\n * \t&#064;Rule\n * \tpublic TemporaryFolder folder= new TemporaryFolder();\n * \n * \t&#064;Test\n * \tpublic void testUsingTempFolder() throws IOException {\n * \t\tFile createdFile= folder.newFile(&quot;myfile.txt&quot;);\n * \t\tFile createdFolder= folder.newFolder(&quot;subfolder&quot;);\n * \t\t// ...\n * \t}\n * }\n * <\/pre>\n */\npublic class TemporaryFolder extends ExternalResource {\n\tprivate File folder;\n\n\t@Override\n\tprotected void before() throws Throwable {\n\t\tcreate();\n\t}\n\n\t@Override\n\tprotected void after() {\n\t\tdelete();\n\t}\n\n\t// testing purposes only\n\t/**\n\t * for testing purposes only.  Do not use.\n\t */\n\tpublic void create() throws IOException {\n\t\tfolder= File.createTempFile(\"junit\", \"\");\n\t\tfolder.delete();\n\t\tfolder.mkdir();\n\t}\n\n\t/**\n\t * Returns a new fresh file with the given name under the temporary folder.\n\t */\n\tpublic File newFile(String fileName) throws IOException {\n\t\tFile file= new File(folder, fileName);\n\t\tfile.createNewFile();\n\t\treturn file;\n\t}\n\n\t/**\n\t * Returns a new fresh folder with the given name under the temporary folder.\n\t */\n\tpublic File newFolder(String... folderNames) {\n\t\tFile file = folder;\n\t\tfor (String folderName : folderNames) {\n\t\t\tfile = new File(file, folderName);\n\t\t\tfile.mkdir();\n\t\t}\n\t\treturn file;\n\t}\n\n\t/**\n\t * @return the location of this temporary folder.\n\t */\n\tpublic File getRoot() {\n\t\treturn folder;\n\t}\n\n\t/**\n\t * Delete all files and folders under the temporary folder.\n\t * Usually not called directly, since it is automatically applied \n\t * by the {@link Rule}\n\t */\n\tpublic void delete() {\n\t\trecursiveDelete(folder);\n\t}\n\n\tprivate void recursiveDelete(File file) {\n\t\tFile[] files= file.listFiles();\n\t\tif (files != null)\n\t\t\tfor (File each : files)\n\t\t\t\trecursiveDelete(each);\n\t\tfile.delete();\n\t}\n}\n","lineNo":63}
{"Smelly Sample":"package org.junit.tests.experimental.rules;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\npublic class TempFolderRuleTest {\n\tprivate static File createdFile;\n\n\tpublic static class HasTempFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tcreatedFile= folder.newFile(\"myfile.txt\");\n\t\t\tassertTrue(createdFile.exists());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void tempFolderIsDeleted() {\n\t\tassertThat(testResult(HasTempFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\tpublic static class CreatesSubFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tcreatedFile= folder.newFolder(\"subfolder\");\n\t\t\tnew File(createdFile, \"a.txt\").createNewFile();\n\t\t\tassertTrue(createdFile.exists());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void subFolderIsDeleted() {\n\t\tassertThat(testResult(CreatesSubFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithOneElement() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tFile file= folder.newFile(\"a\");\n\t\tfolder.delete();\n\t\tassertFalse(file.exists());\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithZeroElements() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tfolder.delete();\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.experimental.rules;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\npublic class TempFolderRuleTest {\n\tprivate static File createdFile;\n\n\tpublic static class HasTempFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tcreatedFile= folder.newFile(\"myfile.txt\");\n\t\t\tassertTrue(createdFile.exists());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void tempFolderIsDeleted() {\n\t\tassertThat(testResult(HasTempFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\tpublic static class CreatesSubFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tString subfolder = \"subfolder\";\n\t\t\tString filename = \"a.txt\";\n\t\t\tcreatedFile= folder.newFolder(subfolder);\n\t\t\tnew File(createdFile, filename).createNewFile();\n\t\t\t\n\t\t\tFile expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\t\t\t\n\t\t\tassertTrue(expectedFile.exists());\n\t\t}\n\n\t\t@Test\n\t\tpublic void testUsingTempTreeFolders() throws IOException {\n\t\t\tString subfolder = \"subfolder\";\n\t\t\tString anotherfolder = \"anotherfolder\";\n\t\t\tString filename = \"a.txt\";\n\n\t\t\tcreatedFile = folder.newFolder(subfolder, anotherfolder);\n\t\t\tnew File(createdFile, filename).createNewFile();\n\n\t\t\tFile expectedFile = new File(folder.getRoot(), join(subfolder, anotherfolder, filename));\n\t\t\t\n\t\t\tassertTrue(expectedFile.exists());\n\t\t}\n\t\t\n\t\tprivate String join(String... folderNames) {\n\t\t\tStringBuilder path = new StringBuilder();\n\t\t\tfor (String folderName : folderNames) {\n\t\t\t\tpath.append(File.separator).append(folderName);\n\t\t\t}\n\t\t\treturn path.toString();\n\t\t}\n\t}\n\n\t@Test\n\tpublic void subFolderIsDeleted() {\n\t\tassertThat(testResult(CreatesSubFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithOneElement() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tFile file= folder.newFile(\"a\");\n\t\tfolder.delete();\n\t\tassertFalse(file.exists());\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithZeroElements() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tfolder.delete();\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n}\n","lineNo":42}
{"Smelly Sample":"package org.junit.tests.experimental.rules;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\npublic class TempFolderRuleTest {\n\tprivate static File createdFile;\n\n\tpublic static class HasTempFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tcreatedFile= folder.newFile(\"myfile.txt\");\n\t\t\tassertTrue(createdFile.exists());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void tempFolderIsDeleted() {\n\t\tassertThat(testResult(HasTempFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\tpublic static class CreatesSubFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tcreatedFile= folder.newFolder(\"subfolder\");\n\t\t\tnew File(createdFile, \"a.txt\").createNewFile();\n\t\t\tassertTrue(createdFile.exists());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void subFolderIsDeleted() {\n\t\tassertThat(testResult(CreatesSubFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithOneElement() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tFile file= folder.newFile(\"a\");\n\t\tfolder.delete();\n\t\tassertFalse(file.exists());\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithZeroElements() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tfolder.delete();\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.experimental.rules;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\npublic class TempFolderRuleTest {\n\tprivate static File createdFile;\n\n\tpublic static class HasTempFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tcreatedFile= folder.newFile(\"myfile.txt\");\n\t\t\tassertTrue(createdFile.exists());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void tempFolderIsDeleted() {\n\t\tassertThat(testResult(HasTempFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\tpublic static class CreatesSubFolder {\n\t\t@Rule\n\t\tpublic TemporaryFolder folder= new TemporaryFolder();\n\n\t\t@Test\n\t\tpublic void testUsingTempFolder() throws IOException {\n\t\t\tString subfolder = \"subfolder\";\n\t\t\tString filename = \"a.txt\";\n\t\t\tcreatedFile= folder.newFolder(subfolder);\n\t\t\tnew File(createdFile, filename).createNewFile();\n\t\t\t\n\t\t\tFile expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\t\t\t\n\t\t\tassertTrue(expectedFile.exists());\n\t\t}\n\n\t\t@Test\n\t\tpublic void testUsingTempTreeFolders() throws IOException {\n\t\t\tString subfolder = \"subfolder\";\n\t\t\tString anotherfolder = \"anotherfolder\";\n\t\t\tString filename = \"a.txt\";\n\n\t\t\tcreatedFile = folder.newFolder(subfolder, anotherfolder);\n\t\t\tnew File(createdFile, filename).createNewFile();\n\n\t\t\tFile expectedFile = new File(folder.getRoot(), join(subfolder, anotherfolder, filename));\n\t\t\t\n\t\t\tassertTrue(expectedFile.exists());\n\t\t}\n\t\t\n\t\tprivate String join(String... folderNames) {\n\t\t\tStringBuilder path = new StringBuilder();\n\t\t\tfor (String folderName : folderNames) {\n\t\t\t\tpath.append(File.separator).append(folderName);\n\t\t\t}\n\t\t\treturn path.toString();\n\t\t}\n\t}\n\n\t@Test\n\tpublic void subFolderIsDeleted() {\n\t\tassertThat(testResult(CreatesSubFolder.class), isSuccessful());\n\t\tassertFalse(createdFile.exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithOneElement() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tFile file= folder.newFile(\"a\");\n\t\tfolder.delete();\n\t\tassertFalse(file.exists());\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n\n\t@Test\n\tpublic void recursiveDeleteFolderWithZeroElements() throws IOException {\n\t\tTemporaryFolder folder= new TemporaryFolder();\n\t\tfolder.create();\n\t\tfolder.delete();\n\t\tassertFalse(folder.getRoot().exists());\n\t}\n}\n","lineNo":43}
{"Smelly Sample":"package junit.framework;\n\n/**\n * A set of assert methods.  Messages are only displayed when an assert fails.\n */\n\npublic class Assert {\n\t/**\n\t * Protect constructor since it is a static only class\n\t */\n\tprotected Assert() {\n\t}\n\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws\n\t * an AssertionFailedError with the given message.\n\t */\n\tstatic public void assertTrue(String message, boolean condition) {\n\t\tif (!condition)\n\t\t\tfail(message);\n\t}\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws\n\t * an AssertionFailedError.\n\t */\n\tstatic public void assertTrue(boolean condition) {\n\t\tassertTrue(null, condition);\n\t}\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws\n\t * an AssertionFailedError with the given message.\n\t */\n\tstatic public void assertFalse(String message, boolean condition) {\n\t\tassertTrue(message, !condition);\n\t}\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws\n\t * an AssertionFailedError.\n\t */\n\tstatic public void assertFalse(boolean condition) {\n\t\tassertFalse(null, condition);\n\t}\n\t/**\n\t * Fails a test with the given message.\n\t */\n\tstatic public void fail(String message) {\n\t\tthrow new AssertionFailedError(message);\n\t}\n\t/**\n\t * Fails a test with no message.\n\t */\n\tstatic public void fail() {\n\t\tfail(null);\n\t}\n\t/**\n\t * Asserts that two objects are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, Object expected, Object actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && expected.equals(actual))\n\t\t\treturn;\n\t\tfailNotEquals(message, expected, actual);\n\t}\n\t/**\n\t * Asserts that two objects are equal. If they are not\n\t * an AssertionFailedError is thrown.\n\t */\n\tstatic public void assertEquals(Object expected, Object actual) {\n\t    assertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two Strings are equal. \n\t */\n\tstatic public void assertEquals(String message, String expected, String actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && expected.equals(actual))\n\t\t\treturn;\n\t\tthrow new ComparisonFailure(message, expected, actual);\n\t}\n\t/**\n\t * Asserts that two Strings are equal. \n\t */\n\tstatic public void assertEquals(String expected, String actual) {\n\t    assertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two doubles are equal concerning a delta.  If they are not\n\t * an AssertionFailedError is thrown with the given message.  If the expected\n\t * value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(String message, double expected, double actual, double delta) {\n\t\tif (Double.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected-actual) <= delta))\n\t\t\tfailNotEquals(message, new Double(expected), new Double(actual));\n\t}\n\t/**\n\t * Asserts that two doubles are equal concerning a delta. If the expected\n\t * value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(double expected, double actual, double delta) {\n\t    assertEquals(null, expected, actual, delta);\n\t}\n\t/**\n\t * Asserts that two floats are equal concerning a positive delta. If they\n\t * are not an AssertionFailedError is thrown with the given message. If the\n\t * expected value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(String message, float expected, float actual, float delta) {\n\t\tif (Float.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected - actual) <= delta))\n\t\t\t\tfailNotEquals(message, new Float(expected), new Float(actual));\n\t}\n\t/**\n\t * Asserts that two floats are equal concerning a delta. If the expected\n\t * value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(float expected, float actual, float delta) {\n\t\tassertEquals(null, expected, actual, delta);\n\t}\n\t/**\n\t * Asserts that two longs are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, long expected, long actual) {\n\t    assertEquals(message, new Long(expected), new Long(actual));\n\t}\n\t/**\n\t * Asserts that two longs are equal.\n\t */\n\tstatic public void assertEquals(long expected, long actual) {\n\t    assertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two booleans are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, boolean expected, boolean actual) {\n    \t\tassertEquals(message, Boolean.valueOf(expected), Boolean.valueOf(actual));\n  \t}\n\t/**\n\t * Asserts that two booleans are equal.\n \t */\n\tstatic public void assertEquals(boolean expected, boolean actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two bytes are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n  \tstatic public void assertEquals(String message, byte expected, byte actual) {\n\t\tassertEquals(message, new Byte(expected), new Byte(actual));\n\t}\n\t/**\n   \t * Asserts that two bytes are equal.\n\t */\n\tstatic public void assertEquals(byte expected, byte actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two chars are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n  \tstatic public void assertEquals(String message, char expected, char actual) {\n    \t\tassertEquals(message, new Character(expected), new Character(actual));\n  \t}\n\t/**\n\t * Asserts that two chars are equal.\n\t */\n  \tstatic public void assertEquals(char expected, char actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two shorts are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, short expected, short actual) {\n    \t\tassertEquals(message, new Short(expected), new Short(actual));\n\t}\n  \t/**\n\t * Asserts that two shorts are equal.\n\t */\n\tstatic public void assertEquals(short expected, short actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two ints are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n  \tstatic public void assertEquals(String message, int expected, int actual) {\n\t\tassertEquals(message, new Integer(expected), new Integer(actual));\n  \t}\n  \t/**\n   \t * Asserts that two ints are equal.\n\t */\n  \tstatic public void assertEquals(int expected, int actual) {\n  \t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that an object isn't null.\n\t */\n\tstatic public void assertNotNull(Object object) {\n\t\tassertNotNull(null, object);\n\t}\n\t/**\n\t * Asserts that an object isn't null. If it is\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertNotNull(String message, Object object) {\n\t\tassertTrue(message, object != null);\n\t}\n\t/**\n\t * Asserts that an object is null. If it isn't an {@link AssertionError} is\n\t * thrown.\n\t * Message contains: Expected: <null> but was: object\n\t * \n\t * @param object\n\t *            Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNull(Object object) {\n\t\tString message = \"Expected: <null> but was: \" + String.valueOf(object);\n\t\tassertNull(message, object);\n\t}\n\t/**\n\t * Asserts that an object is null.  If it is not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertNull(String message, Object object) {\n\t\tassertTrue(message, object == null);\n\t}\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertSame(String message, Object expected, Object actual) {\n\t\tif (expected == actual)\n\t\t\treturn;\n\t\tfailNotSame(message, expected, actual);\n\t}\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not\n\t * the same an AssertionFailedError is thrown.\n\t */\n\tstatic public void assertSame(Object expected, Object actual) {\n\t    assertSame(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object an AssertionFailedError is thrown with the\n\t * given message.\n\t */\n\tstatic public void assertNotSame(String message, Object expected, Object actual) {\n\t\tif (expected == actual)\n\t\t\tfailSame(message);\n\t}\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object an AssertionFailedError is thrown.\n\t */\n\tstatic public void assertNotSame(Object expected, Object actual) {\n\t\tassertNotSame(null, expected, actual);\n\t}\n\n\tstatic public void failSame(String message) {\n\t\tString formatted= \"\";\n \t\tif (message != null)\n \t\t\tformatted= message+\" \";\n \t\tfail(formatted+\"expected not same\");\n\t}\n\n\tstatic public void failNotSame(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message+\" \";\n\t\tfail(formatted+\"expected same:<\"+expected+\"> was not:<\"+actual+\">\");\n\t}\n\n\tstatic public void failNotEquals(String message, Object expected, Object actual) {\n\t\tfail(format(message, expected, actual));\n\t}\n\n\tpublic static String format(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message+\" \";\n\t\treturn formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\";\n\t}\n}\n","Method after Refactoring":"package junit.framework;\n\n/**\n * A set of assert methods.  Messages are only displayed when an assert fails.\n */\n\npublic class Assert {\n\t/**\n\t * Protect constructor since it is a static only class\n\t */\n\tprotected Assert() {\n\t}\n\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws\n\t * an AssertionFailedError with the given message.\n\t */\n\tstatic public void assertTrue(String message, boolean condition) {\n\t\tif (!condition)\n\t\t\tfail(message);\n\t}\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws\n\t * an AssertionFailedError.\n\t */\n\tstatic public void assertTrue(boolean condition) {\n\t\tassertTrue(null, condition);\n\t}\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws\n\t * an AssertionFailedError with the given message.\n\t */\n\tstatic public void assertFalse(String message, boolean condition) {\n\t\tassertTrue(message, !condition);\n\t}\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws\n\t * an AssertionFailedError.\n\t */\n\tstatic public void assertFalse(boolean condition) {\n\t\tassertFalse(null, condition);\n\t}\n\t/**\n\t * Fails a test with the given message.\n\t */\n\tstatic public void fail(String message) {\n\t\tif (message == null) {\n\t\t\tthrow new AssertionFailedError();\n\t\t}\n\t\tthrow new AssertionFailedError(message);\n\t}\n\t/**\n\t * Fails a test with no message.\n\t */\n\tstatic public void fail() {\n\t\tfail(null);\n\t}\n\t/**\n\t * Asserts that two objects are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, Object expected, Object actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && expected.equals(actual))\n\t\t\treturn;\n\t\tfailNotEquals(message, expected, actual);\n\t}\n\t/**\n\t * Asserts that two objects are equal. If they are not\n\t * an AssertionFailedError is thrown.\n\t */\n\tstatic public void assertEquals(Object expected, Object actual) {\n\t    assertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two Strings are equal. \n\t */\n\tstatic public void assertEquals(String message, String expected, String actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && expected.equals(actual))\n\t\t\treturn;\n\t\tString cleanMessage= message == null ? \"\" : message;\n\t\tthrow new ComparisonFailure(cleanMessage, expected, actual);\n\t}\n\t/**\n\t * Asserts that two Strings are equal. \n\t */\n\tstatic public void assertEquals(String expected, String actual) {\n\t    assertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two doubles are equal concerning a delta.  If they are not\n\t * an AssertionFailedError is thrown with the given message.  If the expected\n\t * value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(String message, double expected, double actual, double delta) {\n\t\tif (Double.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected-actual) <= delta))\n\t\t\tfailNotEquals(message, new Double(expected), new Double(actual));\n\t}\n\t/**\n\t * Asserts that two doubles are equal concerning a delta. If the expected\n\t * value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(double expected, double actual, double delta) {\n\t    assertEquals(null, expected, actual, delta);\n\t}\n\t/**\n\t * Asserts that two floats are equal concerning a positive delta. If they\n\t * are not an AssertionFailedError is thrown with the given message. If the\n\t * expected value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(String message, float expected, float actual, float delta) {\n\t\tif (Float.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected - actual) <= delta))\n\t\t\t\tfailNotEquals(message, new Float(expected), new Float(actual));\n\t}\n\t/**\n\t * Asserts that two floats are equal concerning a delta. If the expected\n\t * value is infinity then the delta value is ignored.\n\t */\n\tstatic public void assertEquals(float expected, float actual, float delta) {\n\t\tassertEquals(null, expected, actual, delta);\n\t}\n\t/**\n\t * Asserts that two longs are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, long expected, long actual) {\n\t    assertEquals(message, new Long(expected), new Long(actual));\n\t}\n\t/**\n\t * Asserts that two longs are equal.\n\t */\n\tstatic public void assertEquals(long expected, long actual) {\n\t    assertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two booleans are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, boolean expected, boolean actual) {\n    \t\tassertEquals(message, Boolean.valueOf(expected), Boolean.valueOf(actual));\n  \t}\n\t/**\n\t * Asserts that two booleans are equal.\n \t */\n\tstatic public void assertEquals(boolean expected, boolean actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two bytes are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n  \tstatic public void assertEquals(String message, byte expected, byte actual) {\n\t\tassertEquals(message, new Byte(expected), new Byte(actual));\n\t}\n\t/**\n   \t * Asserts that two bytes are equal.\n\t */\n\tstatic public void assertEquals(byte expected, byte actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two chars are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n  \tstatic public void assertEquals(String message, char expected, char actual) {\n    \t\tassertEquals(message, new Character(expected), new Character(actual));\n  \t}\n\t/**\n\t * Asserts that two chars are equal.\n\t */\n  \tstatic public void assertEquals(char expected, char actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two shorts are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertEquals(String message, short expected, short actual) {\n    \t\tassertEquals(message, new Short(expected), new Short(actual));\n\t}\n  \t/**\n\t * Asserts that two shorts are equal.\n\t */\n\tstatic public void assertEquals(short expected, short actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two ints are equal. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n  \tstatic public void assertEquals(String message, int expected, int actual) {\n\t\tassertEquals(message, new Integer(expected), new Integer(actual));\n  \t}\n  \t/**\n   \t * Asserts that two ints are equal.\n\t */\n  \tstatic public void assertEquals(int expected, int actual) {\n  \t\tassertEquals(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that an object isn't null.\n\t */\n\tstatic public void assertNotNull(Object object) {\n\t\tassertNotNull(null, object);\n\t}\n\t/**\n\t * Asserts that an object isn't null. If it is\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertNotNull(String message, Object object) {\n\t\tassertTrue(message, object != null);\n\t}\n\t/**\n\t * Asserts that an object is null. If it isn't an {@link AssertionError} is\n\t * thrown.\n\t * Message contains: Expected: <null> but was: object\n\t * \n\t * @param object\n\t *            Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNull(Object object) {\n\t\tString message = \"Expected: <null> but was: \" + String.valueOf(object);\n\t\tassertNull(message, object);\n\t}\n\t/**\n\t * Asserts that an object is null.  If it is not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertNull(String message, Object object) {\n\t\tassertTrue(message, object == null);\n\t}\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not\n\t * an AssertionFailedError is thrown with the given message.\n\t */\n\tstatic public void assertSame(String message, Object expected, Object actual) {\n\t\tif (expected == actual)\n\t\t\treturn;\n\t\tfailNotSame(message, expected, actual);\n\t}\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not\n\t * the same an AssertionFailedError is thrown.\n\t */\n\tstatic public void assertSame(Object expected, Object actual) {\n\t    assertSame(null, expected, actual);\n\t}\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object an AssertionFailedError is thrown with the\n\t * given message.\n\t */\n\tstatic public void assertNotSame(String message, Object expected, Object actual) {\n\t\tif (expected == actual)\n\t\t\tfailSame(message);\n\t}\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object an AssertionFailedError is thrown.\n\t */\n\tstatic public void assertNotSame(Object expected, Object actual) {\n\t\tassertNotSame(null, expected, actual);\n\t}\n\n\tstatic public void failSame(String message) {\n\t\tString formatted= \"\";\n \t\tif (message != null)\n \t\t\tformatted= message+\" \";\n \t\tfail(formatted+\"expected not same\");\n\t}\n\n\tstatic public void failNotSame(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message+\" \";\n\t\tfail(formatted+\"expected same:<\"+expected+\"> was not:<\"+actual+\">\");\n\t}\n\n\tstatic public void failNotEquals(String message, Object expected, Object actual) {\n\t\tfail(format(message, expected, actual));\n\t}\n\n\tpublic static String format(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null && !message.isEmpty())\n\t\t\tformatted= message+\" \";\n\t\treturn formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\";\n\t}\n}\n","lineNo":84}
{"Smelly Sample":"package org.junit.runners.model;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n */\npublic class TestClass {\n\tprivate final Class<?> fClass;\n\n\tprivate Map<Class<?>, List<FrameworkMethod>> fMethodsForAnnotations= new HashMap<Class<?>, List<FrameworkMethod>>();\n\n\tprivate Map<Class<?>, List<FrameworkField>> fFieldsForAnnotations= new HashMap<Class<?>, List<FrameworkField>>();\n\n\t/**\n\t * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n\t * constructor executes, the class is scanned for annotations, which can be\n\t * an expensive process (we hope in future JDK's it will not be.) Therefore,\n\t * try to share instances of {@code TestClass} where possible.\n\t */\n\tpublic TestClass(Class<?> klass) {\n\t\tfClass= klass;\n\t\tif (klass != null && klass.getConstructors().length > 1)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Test class can only have one constructor\");\n\n\t\tfor (Class<?> eachClass : getSuperClasses(fClass)) {\n\t\t\tfor (Method eachMethod : eachClass.getDeclaredMethods())\n\t\t\t\taddToAnnotationLists(new FrameworkMethod(eachMethod),\n\t\t\t\t\t\tfMethodsForAnnotations);\n\t\t\tfor (Field eachField : eachClass.getDeclaredFields())\n\t\t\t\taddToAnnotationLists(new FrameworkField(eachField),\n\t\t\t\t\t\tfFieldsForAnnotations);\n\t\t}\n\t}\n\n\tprivate <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n\t\t\tMap<Class<?>, List<T>> map) {\n\t\tfor (Annotation each : member.getAnnotations()) {\n\t\t\tClass<? extends Annotation> type= each.annotationType();\n\t\t\tList<T> members= getAnnotatedMembers(map, type);\n\t\t\tif (member.isShadowedBy(members))\n\t\t\t\treturn;\n\t\t\tif (runsTopToBottom(type))\n\t\t\t\tmembers.add(0, member);\n\t\t\telse\n\t\t\t\tmembers.add(member);\n\t\t}\n\t}\n\n\t/**\n\t * Returns, efficiently, all the non-overridden methods in this class and\n\t * its superclasses that are annotated with {@code annotationClass}.\n\t */\n\tpublic List<FrameworkMethod> getAnnotatedMethods(\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\treturn getAnnotatedMembers(fMethodsForAnnotations, annotationClass);\n\t}\n\n\t/**\n\t * Returns, efficiently, all the non-overridden fields in this class and its\n\t * superclasses that are annotated with {@code annotationClass}.\n\t */\n\tpublic List<FrameworkField> getAnnotatedFields(\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\treturn getAnnotatedMembers(fFieldsForAnnotations, annotationClass);\n\t}\n\n\tprivate <T> List<T> getAnnotatedMembers(Map<Class<?>, List<T>> map,\n\t\t\tClass<? extends Annotation> type) {\n\t\tif (!map.containsKey(type))\n\t\t\tmap.put(type, new ArrayList<T>());\n\t\treturn map.get(type);\n\t}\n\n\tprivate boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n\t\treturn annotation.equals(Before.class)\n\t\t\t\t|| annotation.equals(BeforeClass.class);\n\t}\n\n\tprivate List<Class<?>> getSuperClasses(Class<?> testClass) {\n\t\tArrayList<Class<?>> results= new ArrayList<Class<?>>();\n\t\tClass<?> current= testClass;\n\t\twhile (current != null) {\n\t\t\tresults.add(current);\n\t\t\tcurrent= current.getSuperclass();\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Returns the underlying Java class.\n\t */\n\tpublic Class<?> getJavaClass() {\n\t\treturn fClass;\n\t}\n\n\t/**\n\t * Returns the class's name.\n\t */\n\tpublic String getName() {\n\t\tif (fClass == null)\n\t\t\treturn \"null\";\n\t\treturn fClass.getName();\n\t}\n\n\t/**\n\t * Returns the only public constructor in the class, or throws an {@code\n\t * AssertionError} if there are more or less than one.\n\t */\n\n\tpublic Constructor<?> getOnlyConstructor() {\n\t\tConstructor<?>[] constructors= fClass.getConstructors();\n\t\tAssert.assertEquals(1, constructors.length);\n\t\treturn constructors[0];\n\t}\n\n\t/**\n\t * Returns the annotations on this class\n\t */\n\tpublic Annotation[] getAnnotations() {\n\t\tif (fClass == null)\n\t\t\treturn new Annotation[0];\n\t\treturn fClass.getAnnotations();\n\t}\n\n\tpublic <T> List<T> getAnnotatedFieldValues(Object test,\n\t\t\tClass<? extends Annotation> annotationClass, Class<T> valueClass) {\n\t\tList<T> results= new ArrayList<T>();\n\t\tfor (FrameworkField each : getAnnotatedFields(annotationClass)) {\n\t\t\ttry {\n\t\t\t\tresults.add(valueClass.cast(each.get(test)));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n}\n","Method after Refactoring":"package org.junit.runners.model;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\n\n/**\n * Wraps a class to be run, providing method validation and annotation searching\n */\npublic class TestClass {\n\tprivate final Class<?> fClass;\n\n\tprivate Map<Class<?>, List<FrameworkMethod>> fMethodsForAnnotations= new HashMap<Class<?>, List<FrameworkMethod>>();\n\n\tprivate Map<Class<?>, List<FrameworkField>> fFieldsForAnnotations= new HashMap<Class<?>, List<FrameworkField>>();\n\n\t/**\n\t * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n\t * constructor executes, the class is scanned for annotations, which can be\n\t * an expensive process (we hope in future JDK's it will not be.) Therefore,\n\t * try to share instances of {@code TestClass} where possible.\n\t */\n\tpublic TestClass(Class<?> klass) {\n\t\tfClass= klass;\n\t\tif (klass != null && klass.getConstructors().length > 1)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Test class can only have one constructor\");\n\n\t\tfor (Class<?> eachClass : getSuperClasses(fClass)) {\n\t\t\tfor (Method eachMethod : eachClass.getDeclaredMethods())\n\t\t\t\taddToAnnotationLists(new FrameworkMethod(eachMethod),\n\t\t\t\t\t\tfMethodsForAnnotations);\n\t\t\tfor (Field eachField : eachClass.getDeclaredFields())\n\t\t\t\taddToAnnotationLists(new FrameworkField(eachField),\n\t\t\t\t\t\tfFieldsForAnnotations);\n\t\t}\n\t}\n\n\tprivate <T extends FrameworkMember<T>> void addToAnnotationLists(T member,\n\t\t\tMap<Class<?>, List<T>> map) {\n\t\tfor (Annotation each : member.getAnnotations()) {\n\t\t\tClass<? extends Annotation> type= each.annotationType();\n\t\t\tList<T> members= getAnnotatedMembers(map, type);\n\t\t\tif (member.isShadowedBy(members))\n\t\t\t\treturn;\n\t\t\tif (runsTopToBottom(type))\n\t\t\t\tmembers.add(0, member);\n\t\t\telse\n\t\t\t\tmembers.add(member);\n\t\t}\n\t}\n\n\t/**\n\t * Returns, efficiently, all the non-overridden methods in this class and\n\t * its superclasses that are annotated with {@code annotationClass}.\n\t */\n\tpublic List<FrameworkMethod> getAnnotatedMethods(\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\treturn getAnnotatedMembers(fMethodsForAnnotations, annotationClass);\n\t}\n\n\t/**\n\t * Returns, efficiently, all the non-overridden fields in this class and its\n\t * superclasses that are annotated with {@code annotationClass}.\n\t */\n\tpublic List<FrameworkField> getAnnotatedFields(\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\treturn getAnnotatedMembers(fFieldsForAnnotations, annotationClass);\n\t}\n\n\tprivate <T> List<T> getAnnotatedMembers(Map<Class<?>, List<T>> map,\n\t\t\tClass<? extends Annotation> type) {\n\t\tif (!map.containsKey(type))\n\t\t\tmap.put(type, new ArrayList<T>());\n\t\treturn map.get(type);\n\t}\n\n\tprivate boolean runsTopToBottom(Class<? extends Annotation> annotation) {\n\t\treturn annotation.equals(Before.class)\n\t\t\t\t|| annotation.equals(BeforeClass.class);\n\t}\n\n\tprivate List<Class<?>> getSuperClasses(Class<?> testClass) {\n\t\tArrayList<Class<?>> results= new ArrayList<Class<?>>();\n\t\tClass<?> current= testClass;\n\t\twhile (current != null) {\n\t\t\tresults.add(current);\n\t\t\tcurrent= current.getSuperclass();\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Returns the underlying Java class.\n\t */\n\tpublic Class<?> getJavaClass() {\n\t\treturn fClass;\n\t}\n\n\t/**\n\t * Returns the class's name.\n\t */\n\tpublic String getName() {\n\t\tif (fClass == null)\n\t\t\treturn \"null\";\n\t\treturn fClass.getName();\n\t}\n\n\t/**\n\t * Returns the only public constructor in the class, or throws an {@code\n\t * AssertionError} if there are more or less than one.\n\t */\n\n\tpublic Constructor<?> getOnlyConstructor() {\n\t\tConstructor<?>[] constructors= fClass.getConstructors();\n\t\tAssert.assertEquals(1, constructors.length);\n\t\treturn constructors[0];\n\t}\n\n\t/**\n\t * Returns the annotations on this class\n\t */\n\tpublic Annotation[] getAnnotations() {\n\t\tif (fClass == null)\n\t\t\treturn new Annotation[0];\n\t\treturn fClass.getAnnotations();\n\t}\n\n\tpublic <T> List<T> getAnnotatedFieldValues(Object test,\n\t\t\tClass<? extends Annotation> annotationClass, Class<T> valueClass) {\n\t\tList<T> results= new ArrayList<T>();\n\t\tfor (FrameworkField each : getAnnotatedFields(annotationClass)) {\n\t\t\ttry {\n\t\t\t\tObject fieldValue= each.get(test);\n\t\t\t\tif (valueClass.isInstance(fieldValue))\n\t\t\t\t\tresults.add(valueClass.cast(fieldValue));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n}\n","lineNo":143}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.categories;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.RunWith;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerBuilder;\n\n/**\n * From a given set of test classes, runs only the classes and methods that are\n * annotated with either the category given with the @IncludeCategory\n * annotation, or a subtype of that category.\n * \n * Note that, for now, annotating suites with {@code @Category} has no effect.\n * Categories must be annotated on the direct method or class.\n * \n * Example:\n * \n * <pre>\n * public interface FastTests {\n * }\n * \t\n * public interface SlowTests {\n * }\n * \n * public static class A {\n * \t&#064;Test\n * \tpublic void a() {\n * \t\tfail();\n * \t}\n * \n * \t&#064;Category(SlowTests.class)\n * \t&#064;Test\n * \tpublic void b() {\n * \t}\n * }\n * \n * &#064;Category( { SlowTests.class, FastTests.class })\n * public static class B {\n * \t&#064;Test\n * \tpublic void c() {\n * \n * \t}\n * }\n * \n * &#064;RunWith(Categories.class)\n * &#064;IncludeCategory(SlowTests.class)\n * &#064;SuiteClasses( { A.class, B.class })\n * // Note that Categories is a kind of Suite\n * public static class SlowTestSuite {\n * }\n * <\/pre>\n */\npublic class Categories extends Suite {\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IncludeCategory {\n\t\tpublic Class<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ExcludeCategory {\n\t\tpublic Class<?> value();\n\t}\n\n\tpublic static class CategoryFilter extends Filter {\n\t\tpublic static CategoryFilter include(Class<?> categoryType) {\n\t\t\treturn new CategoryFilter(categoryType, null);\n\t\t}\n\n\t\tprivate final Class<?> fIncluded;\n\n\t\tprivate final Class<?> fExcluded;\n\n\t\tpublic CategoryFilter(Class<?> includedCategory,\n\t\t\t\tClass<?> excludedCategory) {\n\t\t\tfIncluded= includedCategory;\n\t\t\tfExcluded= excludedCategory;\n\t\t}\n\n\t\t@Override\n\t\tpublic String describe() {\n\t\t\treturn \"category \" + fIncluded;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (hasCorrectCategoryAnnotation(description))\n\t\t\t\treturn true;\n\t\t\tif (isParameterizedClass(description))\n\t\t\t\treturn false;\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tif (shouldRun(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean isParameterizedClass(Description description) {\n\t\t\tRunWith annotation= description.getAnnotation(RunWith.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.value().equals(Parameterized.class);\n\t\t}\n\n\t\tprivate boolean hasCorrectCategoryAnnotation(Description description) {\n\t\t\tList<Class<?>> categories= categories(description);\n\t\t\tif (categories.isEmpty())\n\t\t\t\treturn fIncluded == null;\n\t\t\tfor (Class<?> each : categories)\n\t\t\t\tif (fExcluded != null && fExcluded.isAssignableFrom(each))\n\t\t\t\t\treturn false;\n\t\t\tfor (Class<?> each : categories)\n\t\t\t\tif (fIncluded == null || fIncluded.isAssignableFrom(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate List<Class<?>> categories(Description description) {\n\t\t\tArrayList<Class<?>> categories= new ArrayList<Class<?>>();\n\t\t\tcategories.addAll(Arrays.asList(directCategories(description)));\n\t\t\tcategories.addAll(Arrays.asList(directCategories(parentDescription(description))));\n\t\t\treturn categories;\n\t\t}\n\n\t\tprivate Description parentDescription(Description description) {\n\t\t\t// TODO: how heavy are we cringing?\n\t\t\treturn Description.createSuiteDescription(description.getTestClass());\n\t\t}\n\n\t\tprivate Class<?>[] directCategories(Description description) {\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn new Class<?>[0];\n\t\t\treturn annotation.value();\n\t\t}\n\t}\n\n\tpublic Categories(Class<?> klass, RunnerBuilder builder)\n\t\t\tthrows InitializationError {\n\t\tsuper(klass, builder);\n\t\ttry {\n\t\t\tfilter(new CategoryFilter(getIncludedCategory(klass),\n\t\t\t\t\tgetExcludedCategory(klass)));\n\t\t} catch (NoTestsRemainException e) {\n\t\t\tthrow new InitializationError(e);\n\t\t}\n\t}\n\n\tprivate Class<?> getIncludedCategory(Class<?> klass) {\n\t\tIncludeCategory annotation= klass.getAnnotation(IncludeCategory.class);\n\t\treturn annotation == null ? null : annotation.value();\n\t}\n\n\tprivate Class<?> getExcludedCategory(Class<?> klass) {\n\t\tExcludeCategory annotation= klass.getAnnotation(ExcludeCategory.class);\n\t\treturn annotation == null ? null : annotation.value();\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.categories;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.RunWith;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerBuilder;\n\n/**\n * From a given set of test classes, runs only the classes and methods that are\n * annotated with either the category given with the @IncludeCategory\n * annotation, or a subtype of that category.\n * \n * Note that, for now, annotating suites with {@code @Category} has no effect.\n * Categories must be annotated on the direct method or class.\n * \n * Example:\n * \n * <pre>\n * public interface FastTests {\n * }\n * \t\n * public interface SlowTests {\n * }\n * \n * public static class A {\n * \t&#064;Test\n * \tpublic void a() {\n * \t\tfail();\n * \t}\n * \n * \t&#064;Category(SlowTests.class)\n * \t&#064;Test\n * \tpublic void b() {\n * \t}\n * }\n * \n * &#064;Category( { SlowTests.class, FastTests.class })\n * public static class B {\n * \t&#064;Test\n * \tpublic void c() {\n * \n * \t}\n * }\n * \n * &#064;RunWith(Categories.class)\n * &#064;IncludeCategory(SlowTests.class)\n * &#064;SuiteClasses( { A.class, B.class })\n * // Note that Categories is a kind of Suite\n * public static class SlowTestSuite {\n * }\n * <\/pre>\n */\npublic class Categories extends Suite {\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IncludeCategory {\n\t\tpublic Class<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ExcludeCategory {\n\t\tpublic Class<?> value();\n\t}\n\n\tpublic static class CategoryFilter extends Filter {\n\t\tpublic static CategoryFilter include(Class<?> categoryType) {\n\t\t\treturn new CategoryFilter(categoryType, null);\n\t\t}\n\n\t\tprivate final Class<?> fIncluded;\n\n\t\tprivate final Class<?> fExcluded;\n\n\t\tpublic CategoryFilter(Class<?> includedCategory,\n\t\t\t\tClass<?> excludedCategory) {\n\t\t\tfIncluded= includedCategory;\n\t\t\tfExcluded= excludedCategory;\n\t\t}\n\n\t\t@Override\n\t\tpublic String describe() {\n\t\t\treturn \"category \" + fIncluded;\n\t\t}\n\n\t\t// TODO: why do we have two CategoryFilters?\n\t\t@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (hasCorrectCategoryAnnotation(description))\n\t\t\t\treturn true;\n//\t\t\tif (!canHaveCategorizedChildren(description))\n//\t\t\t\treturn false;\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tif (shouldRun(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean hasCorrectCategoryAnnotation(Description description) {\n\t\t\tList<Class<?>> categories= categories(description);\n\t\t\tif (categories.isEmpty())\n\t\t\t\treturn fIncluded == null;\n\t\t\tfor (Class<?> each : categories)\n\t\t\t\tif (fExcluded != null && fExcluded.isAssignableFrom(each))\n\t\t\t\t\treturn false;\n\t\t\tfor (Class<?> each : categories)\n\t\t\t\tif (fIncluded == null || fIncluded.isAssignableFrom(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate List<Class<?>> categories(Description description) {\n\t\t\tArrayList<Class<?>> categories= new ArrayList<Class<?>>();\n\t\t\tcategories.addAll(Arrays.asList(directCategories(description)));\n\t\t\tcategories.addAll(Arrays.asList(directCategories(parentDescription(description))));\n\t\t\treturn categories;\n\t\t}\n\n\t\tprivate Description parentDescription(Description description) {\n\t\t\t// TODO: how heavy are we cringing?\n\t\t\tClass<?> testClass= description.getTestClass();\n\t\t\tif (testClass == null)\n\t\t\t\treturn null;\n\t\t\treturn Description.createSuiteDescription(testClass);\n\t\t}\n\n\t\tprivate Class<?>[] directCategories(Description description) {\n\t\t\tif (description == null)\n\t\t\t\treturn new Class<?>[0];\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn new Class<?>[0];\n\t\t\treturn annotation.value();\n\t\t}\n\t}\n\n\tpublic Categories(Class<?> klass, RunnerBuilder builder)\n\t\t\tthrows InitializationError {\n\t\tsuper(klass, builder);\n\t\ttry {\n\t\t\t// TODO: too much work in constructors\n\t\t\tfilter(new CategoryFilter(getIncludedCategory(klass),\n\t\t\t\t\tgetExcludedCategory(klass)));\n\t\t} catch (NoTestsRemainException e) {\n\t\t\tthrow new InitializationError(e);\n\t\t}\n\t\tassertNoCategorizedDescendentsOfUncategorizeableParents(getDescription());\n\t}\n\n\tprivate Class<?> getIncludedCategory(Class<?> klass) {\n\t\tIncludeCategory annotation= klass.getAnnotation(IncludeCategory.class);\n\t\treturn annotation == null ? null : annotation.value();\n\t}\n\n\tprivate Class<?> getExcludedCategory(Class<?> klass) {\n\t\tExcludeCategory annotation= klass.getAnnotation(ExcludeCategory.class);\n\t\treturn annotation == null ? null : annotation.value();\n\t}\n\n\tprivate void assertNoCategorizedDescendentsOfUncategorizeableParents(Description description) throws InitializationError {\n\t\tif (!canHaveCategorizedChildren(description))\n\t\t\tassertNoDescendantsHaveCategoryAnnotations(description);\n\t\tfor (Description each : description.getChildren())\n\t\t\tassertNoCategorizedDescendentsOfUncategorizeableParents(each);\n\t}\n\t\n\tprivate void assertNoDescendantsHaveCategoryAnnotations(Description description) throws InitializationError {\t\t\t\n\t\tfor (Description each : description.getChildren()) {\n\t\t\tif (each.getAnnotation(Category.class) != null)\n\t\t\t\tthrow new InitializationError(\"Category annotations on Parameterized classes are not supported on individual methods.\");\n\t\t\tassertNoDescendantsHaveCategoryAnnotations(each);\n\t\t}\n\t}\n\n\tprivate static boolean canHaveCategorizedChildren(Description description) {\n\t\tRunWith annotation= description.getAnnotation(RunWith.class);\n\t\tif (annotation == null)\n\t\t\treturn true;\n\t\t// TODO: something more general\n\t\treturn !annotation.value().equals(Parameterized.class);\n\t}\n}\n","lineNo":132}
{"Smelly Sample":"package org.junit.tests.experimental.categories;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\nimport org.junit.runner.RunWith;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.TestClass;\n\npublic class CategoriesMark2Test {\n\tpublic static class CategoryFilter extends Filter2 {\n\t\tprivate final Class<?> fIncluded;\n\n\t\tpublic CategoryFilter(Class<?> included) {\n\t\t\tfIncluded= included;\n\t\t}\n\n\t\tpublic static CategoryFilter include(Class<?> included) {\n\t\t\treturn new CategoryFilter(included);\n\t\t}\n\n\t\t// TODO: this type correct?\n\t\t@Override\n\t\tpublic List<Runner> matchingRunners(\n\t\t\t\tList<? extends Runner> allPossibleRunners) {\n\t\t\tArrayList<Runner> result= new ArrayList<Runner>();\n\t\t\tfor (Runner eachRunner : allPossibleRunners) {\n\t\t\t\tCollection<Annotation> annotations= eachRunner.getDescription()\n\t\t\t\t\t\t.getAnnotations();\n\t\t\t\t// TODO: extract method\n\t\t\t\tfor (Annotation eachAnnotation : annotations) {\n\t\t\t\t\tif (eachAnnotation.annotationType().equals(Category.class)) {\n\t\t\t\t\t\tCategory category= (Category) eachAnnotation;\n\t\t\t\t\t\tClass<?>[] categories= category.value();\n\t\t\t\t\t\tif (Arrays.asList(categories).contains(fIncluded))\n\t\t\t\t\t\t\tresult.add(eachRunner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tpublic static abstract class Filter2 {\n\t\tpublic abstract List<Runner> matchingRunners(\n\t\t\t\tList<? extends Runner> allPossibleRunners);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface FilterWith {\n\n\t}\n\n\tpublic static class Listed extends Classes {\n\t\tprivate final Class<?>[] fClasses;\n\n\t\tpublic Listed(Class<?>... classes) {\n\t\t\tfClasses= classes;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<? extends Class<?>> get() {\n\t\t\treturn Arrays.asList(fClasses);\n\t\t}\n\t}\n\n\t// Classes -> RunnerBuilder\n\n\tpublic static abstract class Classes {\n\n\t\tpublic abstract Collection<? extends Class<?>> get();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SuiteClasses2 {\n\n\t}\n\n\tpublic static class Suite2 extends Runner {\n\t\tprivate final TestClass fTestClass;\n\n\t\tprivate final Object fInstance;\n\n\t\tpublic Suite2(Class<?> testClass) throws InitializationError {\n\t\t\tfTestClass= new TestClass(testClass);\n\t\t\ttry {\n\t\t\t\tfInstance= fTestClass.getOnlyConstructor().newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new InitializationError(e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Description getDescription() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: require an instance?\n\t\t@Override\n\t\tpublic void run(RunNotifier notifier) {\n\t\t\tList<Class<?>> allPossibleClasses= gatherClasses();\n\t\t\tList<Runner> allPossibleRunners= runnersForClasses(allPossibleClasses);\n\t\t\tList<Runner> valid= filterRunners(allPossibleRunners);\n\t\t\tfor (Runner each : valid)\n\t\t\t\teach.run(notifier);\n\t\t}\n\n\t\tprivate List<Runner> filterRunners(List<Runner> allPossibleRunners) {\n\t\t\tList<Runner> result= allPossibleRunners;\n\t\t\tList<Filter2> filters= getFilters();\n\t\t\tfor (Filter2 each : filters)\n\t\t\t\tresult= each.matchingRunners(result);\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Filter2> getFilters() {\n\t\t\treturn fTestClass.getAnnotatedFieldValues(fInstance,\n\t\t\t\t\tFilterWith.class, Filter2.class);\n\t\t}\n\n\t\tprivate List<Runner> runnersForClasses(List<Class<?>> allPossibleClasses) {\n\t\t\t// TODO: cheating\n\t\t\tArrayList<Runner> result= new ArrayList<Runner>();\n\t\t\tfor (Class<?> each : allPossibleClasses) {\n\t\t\t\ttry {\n\t\t\t\t\tresult.add(new BlockJUnit4ClassRunner(each));\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Class<?>> gatherClasses() {\n\t\t\tArrayList<Class<?>> result= new ArrayList<Class<?>>();\n\t\t\tList<Classes> classeses= fTestClass.getAnnotatedFieldValues(\n\t\t\t\t\tfInstance, SuiteClasses2.class, Classes.class);\n\t\t\tfor (Classes each : classeses)\n\t\t\t\tresult.addAll(each.get());\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic class Yes {\n\t}\n\n\tstatic class No {\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes1 {\n\t\t@Test\n\t\tpublic void yes1() {\n\t\t}\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes2 {\n\t\t@Test\n\t\tpublic void yes2() {\n\t\t}\n\t}\n\n\t@Category(No.class)\n\tpublic static class No1 {\n\t\t@Test\n\t\tpublic void no1() {\n\t\t}\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesJustOne {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesMaybeTwo {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Everything {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Nos {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(No.class);\n\t}\n\n\t@Test\n\tpublic void gatherClasses() throws InitializationError {\n\t\tassertEquals(2, new Suite2(OnlyYesJustOne.class).gatherClasses().size());\n\t}\n\n\t@Test\n\tpublic void onlyRunOne() {\n\t\tResult result= new JUnitCore().run(OnlyYesJustOne.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesJustOne.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runTwo() {\n\t\tResult result= new JUnitCore().run(OnlyYesMaybeTwo.class);\n\t\tassertEquals(2, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesMaybeTwo.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runAllThree() {\n\t\tResult result= new JUnitCore().run(Everything.class);\n\t\tassertEquals(3, result.getRunCount());\n\t\tassertThat(testResult(Everything.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runOneNo() {\n\t\tResult result= new JUnitCore().run(Nos.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(Nos.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void matchingRunnersOnCategories() throws InitializationError {\n\t\tassertEquals(1, CategoryFilter.include(Yes.class).matchingRunners(\n\t\t\t\tArrays.asList(new BlockJUnit4ClassRunner(Yes1.class))).size());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.experimental.categories;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.experimental.categories.CategoryFilter;\nimport org.junit.experimental.categories.Filter2;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\nimport org.junit.runner.RunWith;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.TestClass;\n\npublic class CategoriesMark2Test {\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface FilterWith {\n\n\t}\n\n\tpublic static class Listed extends Classes {\n\t\tprivate final Class<?>[] fClasses;\n\n\t\tpublic Listed(Class<?>... classes) {\n\t\t\tfClasses= classes;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<? extends Class<?>> get() {\n\t\t\treturn Arrays.asList(fClasses);\n\t\t}\n\t}\n\n\t// Classes -> RunnerBuilder\n\n\tpublic static abstract class Classes {\n\n\t\tpublic abstract Collection<? extends Class<?>> get();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SuiteClasses2 {\n\n\t}\n\n\tpublic static class Suite2 extends Runner {\n\t\tprivate final TestClass fTestClass;\n\n\t\tprivate final Object fInstance;\n\n\t\tpublic Suite2(Class<?> testClass) throws InitializationError {\n\t\t\tfTestClass= new TestClass(testClass);\n\t\t\ttry {\n\t\t\t\tfInstance= fTestClass.getOnlyConstructor().newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new InitializationError(e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Description getDescription() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: require an instance?\n\t\t@Override\n\t\tpublic void run(RunNotifier notifier) {\n\t\t\tList<Class<?>> allPossibleClasses= gatherClasses();\n\t\t\tList<Runner> allPossibleRunners= runnersForClasses(allPossibleClasses);\n\t\t\tList<Runner> valid= filterRunners(allPossibleRunners);\n\t\t\tfor (Runner each : valid)\n\t\t\t\teach.run(notifier);\n\t\t}\n\n\t\tprivate List<Runner> filterRunners(List<Runner> allPossibleRunners) {\n\t\t\tList<Runner> result= allPossibleRunners;\n\t\t\tList<Filter2> filters= getFilters();\n\t\t\tfor (Filter2 each : filters)\n\t\t\t\tresult= each.matchingRunners(result);\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Filter2> getFilters() {\n\t\t\treturn fTestClass.getAnnotatedFieldValues(fInstance,\n\t\t\t\t\tFilterWith.class, Filter2.class);\n\t\t}\n\n\t\tprivate List<Runner> runnersForClasses(List<Class<?>> allPossibleClasses) {\n\t\t\t// TODO: cheating\n\t\t\tArrayList<Runner> result= new ArrayList<Runner>();\n\t\t\tfor (Class<?> each : allPossibleClasses) {\n\t\t\t\ttry {\n\t\t\t\t\tresult.add(new BlockJUnit4ClassRunner(each));\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Class<?>> gatherClasses() {\n\t\t\tArrayList<Class<?>> result= new ArrayList<Class<?>>();\n\t\t\tList<Classes> classeses= fTestClass.getAnnotatedFieldValues(\n\t\t\t\t\tfInstance, SuiteClasses2.class, Classes.class);\n\t\t\tfor (Classes each : classeses)\n\t\t\t\tresult.addAll(each.get());\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic class Yes {\n\t}\n\n\tstatic class No {\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes1 {\n\t\t@Test\n\t\tpublic void yes1() {\n\t\t}\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes2 {\n\t\t@Test\n\t\tpublic void yes2() {\n\t\t}\n\t}\n\n\t@Category(No.class)\n\tpublic static class No1 {\n\t\t@Test\n\t\tpublic void no1() {\n\t\t}\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesJustOne {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesMaybeTwo {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Everything {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Nos {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(No.class);\n\t}\n\n\t@Test\n\tpublic void gatherClasses() throws InitializationError {\n\t\tassertEquals(2, new Suite2(OnlyYesJustOne.class).gatherClasses().size());\n\t}\n\n\t@Test\n\tpublic void onlyRunOne() {\n\t\tResult result= new JUnitCore().run(OnlyYesJustOne.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesJustOne.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runTwo() {\n\t\tResult result= new JUnitCore().run(OnlyYesMaybeTwo.class);\n\t\tassertEquals(2, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesMaybeTwo.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runAllThree() {\n\t\tResult result= new JUnitCore().run(Everything.class);\n\t\tassertEquals(3, result.getRunCount());\n\t\tassertThat(testResult(Everything.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runOneNo() {\n\t\tResult result= new JUnitCore().run(Nos.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(Nos.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void matchingRunnersOnCategories() throws InitializationError {\n\t\tRunner blockJUnit4ClassRunner= new BlockJUnit4ClassRunner(Yes1.class);\n\t\tassertEquals(1, CategoryFilter.include(Yes.class).matchingRunners(\n\t\t\t\tArrays.asList(blockJUnit4ClassRunner)).size());\n\t}\n}\n","lineNo":223}
{"Smelly Sample":"package org.junit.tests.experimental.categories;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\nimport org.junit.runner.RunWith;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.TestClass;\n\npublic class CategoriesMark2Test {\n\tpublic static class CategoryFilter extends Filter2 {\n\t\tprivate final Class<?> fIncluded;\n\n\t\tpublic CategoryFilter(Class<?> included) {\n\t\t\tfIncluded= included;\n\t\t}\n\n\t\tpublic static CategoryFilter include(Class<?> included) {\n\t\t\treturn new CategoryFilter(included);\n\t\t}\n\n\t\t// TODO: this type correct?\n\t\t@Override\n\t\tpublic List<Runner> matchingRunners(\n\t\t\t\tList<? extends Runner> allPossibleRunners) {\n\t\t\tArrayList<Runner> result= new ArrayList<Runner>();\n\t\t\tfor (Runner eachRunner : allPossibleRunners) {\n\t\t\t\tCollection<Annotation> annotations= eachRunner.getDescription()\n\t\t\t\t\t\t.getAnnotations();\n\t\t\t\t// TODO: extract method\n\t\t\t\tfor (Annotation eachAnnotation : annotations) {\n\t\t\t\t\tif (eachAnnotation.annotationType().equals(Category.class)) {\n\t\t\t\t\t\tCategory category= (Category) eachAnnotation;\n\t\t\t\t\t\tClass<?>[] categories= category.value();\n\t\t\t\t\t\tif (Arrays.asList(categories).contains(fIncluded))\n\t\t\t\t\t\t\tresult.add(eachRunner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tpublic static abstract class Filter2 {\n\t\tpublic abstract List<Runner> matchingRunners(\n\t\t\t\tList<? extends Runner> allPossibleRunners);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface FilterWith {\n\n\t}\n\n\tpublic static class Listed extends Classes {\n\t\tprivate final Class<?>[] fClasses;\n\n\t\tpublic Listed(Class<?>... classes) {\n\t\t\tfClasses= classes;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<? extends Class<?>> get() {\n\t\t\treturn Arrays.asList(fClasses);\n\t\t}\n\t}\n\n\t// Classes -> RunnerBuilder\n\n\tpublic static abstract class Classes {\n\n\t\tpublic abstract Collection<? extends Class<?>> get();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SuiteClasses2 {\n\n\t}\n\n\tpublic static class Suite2 extends Runner {\n\t\tprivate final TestClass fTestClass;\n\n\t\tprivate final Object fInstance;\n\n\t\tpublic Suite2(Class<?> testClass) throws InitializationError {\n\t\t\tfTestClass= new TestClass(testClass);\n\t\t\ttry {\n\t\t\t\tfInstance= fTestClass.getOnlyConstructor().newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new InitializationError(e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Description getDescription() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: require an instance?\n\t\t@Override\n\t\tpublic void run(RunNotifier notifier) {\n\t\t\tList<Class<?>> allPossibleClasses= gatherClasses();\n\t\t\tList<Runner> allPossibleRunners= runnersForClasses(allPossibleClasses);\n\t\t\tList<Runner> valid= filterRunners(allPossibleRunners);\n\t\t\tfor (Runner each : valid)\n\t\t\t\teach.run(notifier);\n\t\t}\n\n\t\tprivate List<Runner> filterRunners(List<Runner> allPossibleRunners) {\n\t\t\tList<Runner> result= allPossibleRunners;\n\t\t\tList<Filter2> filters= getFilters();\n\t\t\tfor (Filter2 each : filters)\n\t\t\t\tresult= each.matchingRunners(result);\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Filter2> getFilters() {\n\t\t\treturn fTestClass.getAnnotatedFieldValues(fInstance,\n\t\t\t\t\tFilterWith.class, Filter2.class);\n\t\t}\n\n\t\tprivate List<Runner> runnersForClasses(List<Class<?>> allPossibleClasses) {\n\t\t\t// TODO: cheating\n\t\t\tArrayList<Runner> result= new ArrayList<Runner>();\n\t\t\tfor (Class<?> each : allPossibleClasses) {\n\t\t\t\ttry {\n\t\t\t\t\tresult.add(new BlockJUnit4ClassRunner(each));\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Class<?>> gatherClasses() {\n\t\t\tArrayList<Class<?>> result= new ArrayList<Class<?>>();\n\t\t\tList<Classes> classeses= fTestClass.getAnnotatedFieldValues(\n\t\t\t\t\tfInstance, SuiteClasses2.class, Classes.class);\n\t\t\tfor (Classes each : classeses)\n\t\t\t\tresult.addAll(each.get());\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic class Yes {\n\t}\n\n\tstatic class No {\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes1 {\n\t\t@Test\n\t\tpublic void yes1() {\n\t\t}\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes2 {\n\t\t@Test\n\t\tpublic void yes2() {\n\t\t}\n\t}\n\n\t@Category(No.class)\n\tpublic static class No1 {\n\t\t@Test\n\t\tpublic void no1() {\n\t\t}\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesJustOne {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesMaybeTwo {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Everything {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Nos {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(No.class);\n\t}\n\n\t@Test\n\tpublic void gatherClasses() throws InitializationError {\n\t\tassertEquals(2, new Suite2(OnlyYesJustOne.class).gatherClasses().size());\n\t}\n\n\t@Test\n\tpublic void onlyRunOne() {\n\t\tResult result= new JUnitCore().run(OnlyYesJustOne.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesJustOne.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runTwo() {\n\t\tResult result= new JUnitCore().run(OnlyYesMaybeTwo.class);\n\t\tassertEquals(2, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesMaybeTwo.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runAllThree() {\n\t\tResult result= new JUnitCore().run(Everything.class);\n\t\tassertEquals(3, result.getRunCount());\n\t\tassertThat(testResult(Everything.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runOneNo() {\n\t\tResult result= new JUnitCore().run(Nos.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(Nos.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void matchingRunnersOnCategories() throws InitializationError {\n\t\tassertEquals(1, CategoryFilter.include(Yes.class).matchingRunners(\n\t\t\t\tArrays.asList(new BlockJUnit4ClassRunner(Yes1.class))).size());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.experimental.categories;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.experimental.categories.CategoryFilter;\nimport org.junit.experimental.categories.Filter2;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\nimport org.junit.runner.RunWith;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.TestClass;\n\npublic class CategoriesMark2Test {\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface FilterWith {\n\n\t}\n\n\tpublic static class Listed extends Classes {\n\t\tprivate final Class<?>[] fClasses;\n\n\t\tpublic Listed(Class<?>... classes) {\n\t\t\tfClasses= classes;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<? extends Class<?>> get() {\n\t\t\treturn Arrays.asList(fClasses);\n\t\t}\n\t}\n\n\t// Classes -> RunnerBuilder\n\n\tpublic static abstract class Classes {\n\n\t\tpublic abstract Collection<? extends Class<?>> get();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SuiteClasses2 {\n\n\t}\n\n\tpublic static class Suite2 extends Runner {\n\t\tprivate final TestClass fTestClass;\n\n\t\tprivate final Object fInstance;\n\n\t\tpublic Suite2(Class<?> testClass) throws InitializationError {\n\t\t\tfTestClass= new TestClass(testClass);\n\t\t\ttry {\n\t\t\t\tfInstance= fTestClass.getOnlyConstructor().newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new InitializationError(e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Description getDescription() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: require an instance?\n\t\t@Override\n\t\tpublic void run(RunNotifier notifier) {\n\t\t\tList<Class<?>> allPossibleClasses= gatherClasses();\n\t\t\tList<Runner> allPossibleRunners= runnersForClasses(allPossibleClasses);\n\t\t\tList<Runner> valid= filterRunners(allPossibleRunners);\n\t\t\tfor (Runner each : valid)\n\t\t\t\teach.run(notifier);\n\t\t}\n\n\t\tprivate List<Runner> filterRunners(List<Runner> allPossibleRunners) {\n\t\t\tList<Runner> result= allPossibleRunners;\n\t\t\tList<Filter2> filters= getFilters();\n\t\t\tfor (Filter2 each : filters)\n\t\t\t\tresult= each.matchingRunners(result);\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Filter2> getFilters() {\n\t\t\treturn fTestClass.getAnnotatedFieldValues(fInstance,\n\t\t\t\t\tFilterWith.class, Filter2.class);\n\t\t}\n\n\t\tprivate List<Runner> runnersForClasses(List<Class<?>> allPossibleClasses) {\n\t\t\t// TODO: cheating\n\t\t\tArrayList<Runner> result= new ArrayList<Runner>();\n\t\t\tfor (Class<?> each : allPossibleClasses) {\n\t\t\t\ttry {\n\t\t\t\t\tresult.add(new BlockJUnit4ClassRunner(each));\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate List<Class<?>> gatherClasses() {\n\t\t\tArrayList<Class<?>> result= new ArrayList<Class<?>>();\n\t\t\tList<Classes> classeses= fTestClass.getAnnotatedFieldValues(\n\t\t\t\t\tfInstance, SuiteClasses2.class, Classes.class);\n\t\t\tfor (Classes each : classeses)\n\t\t\t\tresult.addAll(each.get());\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic class Yes {\n\t}\n\n\tstatic class No {\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes1 {\n\t\t@Test\n\t\tpublic void yes1() {\n\t\t}\n\t}\n\n\t@Category(Yes.class)\n\tpublic static class Yes2 {\n\t\t@Test\n\t\tpublic void yes2() {\n\t\t}\n\t}\n\n\t@Category(No.class)\n\tpublic static class No1 {\n\t\t@Test\n\t\tpublic void no1() {\n\t\t}\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesJustOne {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class OnlyYesMaybeTwo {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(Yes.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Everything {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\t}\n\n\t@RunWith(Suite2.class)\n\tpublic static class Nos {\n\t\t@SuiteClasses2\n\t\tpublic Classes classes= new Listed(Yes1.class, Yes2.class, No1.class);\n\n\t\t@FilterWith\n\t\tpublic Filter2 filter= CategoryFilter.include(No.class);\n\t}\n\n\t@Test\n\tpublic void gatherClasses() throws InitializationError {\n\t\tassertEquals(2, new Suite2(OnlyYesJustOne.class).gatherClasses().size());\n\t}\n\n\t@Test\n\tpublic void onlyRunOne() {\n\t\tResult result= new JUnitCore().run(OnlyYesJustOne.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesJustOne.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runTwo() {\n\t\tResult result= new JUnitCore().run(OnlyYesMaybeTwo.class);\n\t\tassertEquals(2, result.getRunCount());\n\t\tassertThat(testResult(OnlyYesMaybeTwo.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runAllThree() {\n\t\tResult result= new JUnitCore().run(Everything.class);\n\t\tassertEquals(3, result.getRunCount());\n\t\tassertThat(testResult(Everything.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void runOneNo() {\n\t\tResult result= new JUnitCore().run(Nos.class);\n\t\tassertEquals(1, result.getRunCount());\n\t\tassertThat(testResult(Nos.class), isSuccessful());\n\t}\n\n\t@Test\n\tpublic void matchingRunnersOnCategories() throws InitializationError {\n\t\tRunner blockJUnit4ClassRunner= new BlockJUnit4ClassRunner(Yes1.class);\n\t\tassertEquals(1, CategoryFilter.include(Yes.class).matchingRunners(\n\t\t\t\tArrays.asList(blockJUnit4ClassRunner)).size());\n\t}\n}\n","lineNo":223}
{"Smelly Sample":"package org.junit.tests.junit3compatibility;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\n\npublic class SuiteMethodTest {\n\tpublic static boolean wasRun;\n\n\tstatic public class OldTest extends TestCase {\n\t\tpublic OldTest(String name) {\n\t\t\tsuper(name);\n\t\t}\n\t\t\n\t\tpublic static junit.framework.Test suite() {\n\t\t\tTestSuite result= new TestSuite();\n\t\t\tresult.addTest(new OldTest(\"notObviouslyATest\"));\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tpublic void notObviouslyATest() {\n\t\t\twasRun= true;\n\t\t}\n\t}\n\t\n\t@Test public void makeSureSuiteIsCalled() {\n\t\twasRun= false;\n\t\tJUnitCore.runClasses(OldTest.class);\n\t\tassertTrue(wasRun);\n\t}\n\t\n\tstatic public class NewTest {\n\t\t@Test public void sample() {\n\t\t\twasRun= true;\n\t\t}\n\n\t\tpublic static junit.framework.Test suite() {\n\t\t\treturn new JUnit4TestAdapter(NewTest.class);\n\t\t}\n\t}\n\t\n\t@Test public void makeSureSuiteWorksWithJUnit4Classes() {\n\t\twasRun= false;\n\t\tJUnitCore.runClasses(NewTest.class);\n\t\tassertTrue(wasRun);\n\t}\n\t\n\n\tpublic static class CompatibilityTest {\n\t\t@Ignore\t@Test\n\t\tpublic void ignored() {\n\t\t}\n\t\t\n\t\tpublic static junit.framework.Test suite() {\n\t\t\treturn new JUnit4TestAdapter(CompatibilityTest.class);\n\t\t}\n\t}\n\t\n\t@Test public void descriptionAndRunNotificationsAreConsistent() {\n\t\tResult result= JUnitCore.runClasses(CompatibilityTest.class);\n\t\tassertEquals(0, result.getIgnoreCount());\n\t\t\n\t\tDescription description= Request.aClass(CompatibilityTest.class).getRunner().getDescription();\n\t\tassertEquals(0, description.getChildren().size());\n\t}\n\t\n\tstatic public class NewTestSuiteFails {\n\t\t@Test public void sample() {\n\t\t\twasRun= true;\n\t\t}\n\t\t\n\t\tpublic static junit.framework.Test suite() {\n\t\t\tfail(\"called with JUnit 4 runner\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t@Test public void suiteIsUsedWithJUnit4Classes() {\n\t\twasRun= false;\n\t\tResult result= JUnitCore.runClasses(NewTestSuiteFails.class);\n\t\tassertEquals(1, result.getFailureCount());\n\t\tassertFalse(wasRun);\n\t}\n\t\n\tstatic public class NewTestSuiteNotUsed {\n\t\tprivate static boolean wasIgnoredRun;\n\t\t\n\t\t@Test public void sample() {\n\t\t\twasRun= true;\n\t\t}\n\t\t\n\t\t@Ignore @Test public void ignore() {\n\t\t\twasIgnoredRun= true;\n\t\t}\n\t\t\n\t\tpublic static junit.framework.Test suite() {\n\t\t\treturn new JUnit4TestAdapter(NewTestSuiteNotUsed.class);\n\t\t}\n\t}\n\t\n\t@Test public void makeSureSuiteNotUsedWithJUnit4Classes2() {\n\t\twasRun= false;\n\t\tNewTestSuiteNotUsed.wasIgnoredRun= false;\n\t\tResult res= JUnitCore.runClasses(NewTestSuiteNotUsed.class);\n\t\tassertTrue(wasRun);\n\t\tassertFalse(NewTestSuiteNotUsed.wasIgnoredRun);\n\t\tassertEquals(0, res.getFailureCount());\n\t\tassertEquals(1, res.getRunCount());\n\t\tassertEquals(0, res.getIgnoreCount());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.junit3compatibility;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.Runner;\n\npublic class SuiteMethodTest {\n\tpublic static boolean wasRun;\n\n\tstatic public class OldTest extends TestCase {\n\t\tpublic OldTest(String name) {\n\t\t\tsuper(name);\n\t\t}\n\n\t\tpublic static junit.framework.Test suite() {\n\t\t\tTestSuite result= new TestSuite();\n\t\t\tresult.addTest(new OldTest(\"notObviouslyATest\"));\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void notObviouslyATest() {\n\t\t\twasRun= true;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void makeSureSuiteIsCalled() {\n\t\twasRun= false;\n\t\tJUnitCore.runClasses(OldTest.class);\n\t\tassertTrue(wasRun);\n\t}\n\n\tstatic public class NewTest {\n\t\t@Test\n\t\tpublic void sample() {\n\t\t\twasRun= true;\n\t\t}\n\n\t\tpublic static junit.framework.Test suite() {\n\t\t\treturn new JUnit4TestAdapter(NewTest.class);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void makeSureSuiteWorksWithJUnit4Classes() {\n\t\twasRun= false;\n\t\tJUnitCore.runClasses(NewTest.class);\n\t\tassertTrue(wasRun);\n\t}\n\n\tpublic static class CompatibilityTest {\n\t\t@Ignore\n\t\t@Test\n\t\tpublic void ignored() {\n\t\t}\n\n\t\tpublic static junit.framework.Test suite() {\n\t\t\treturn new JUnit4TestAdapter(CompatibilityTest.class);\n\t\t}\n\t}\n\n\t// when executing as JUnit 3, ignored tests are stripped out before execution\n\t@Test\n\tpublic void descriptionAndRunNotificationsAreConsistent() {\n\t\tResult result= JUnitCore.runClasses(CompatibilityTest.class);\n\t\tassertEquals(0, result.getIgnoreCount());\n\n\t\tRunner runner= Request.aClass(CompatibilityTest.class).getRunner();\n\t\tDescription description= runner.getDescription();\n\t\tassertEquals(1, description.getChildren().size());\n\t\tassertEquals(\"initializationError\", description.getChildren().get(0)\n\t\t\t\t.getMethodName());\n\t}\n\n\tstatic public class NewTestSuiteFails {\n\t\t@Test\n\t\tpublic void sample() {\n\t\t\twasRun= true;\n\t\t}\n\n\t\tpublic static junit.framework.Test suite() {\n\t\t\tfail(\"called with JUnit 4 runner\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void suiteIsUsedWithJUnit4Classes() {\n\t\twasRun= false;\n\t\tResult result= JUnitCore.runClasses(NewTestSuiteFails.class);\n\t\tassertEquals(1, result.getFailureCount());\n\t\tassertFalse(wasRun);\n\t}\n\n\tstatic public class NewTestSuiteNotUsed {\n\t\tprivate static boolean wasIgnoredRun;\n\n\t\t@Test\n\t\tpublic void sample() {\n\t\t\twasRun= true;\n\t\t}\n\n\t\t@Ignore\n\t\t@Test\n\t\tpublic void ignore() {\n\t\t\twasIgnoredRun= true;\n\t\t}\n\n\t\tpublic static junit.framework.Test suite() {\n\t\t\treturn new JUnit4TestAdapter(NewTestSuiteNotUsed.class);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void makeSureSuiteNotUsedWithJUnit4Classes2() {\n\t\twasRun= false;\n\t\tNewTestSuiteNotUsed.wasIgnoredRun= false;\n\t\tResult res= JUnitCore.runClasses(NewTestSuiteNotUsed.class);\n\t\tassertTrue(wasRun);\n\t\tassertFalse(NewTestSuiteNotUsed.wasIgnoredRun);\n\t\tassertEquals(0, res.getFailureCount());\n\t\tassertEquals(1, res.getRunCount());\n\t\tassertEquals(0, res.getIgnoreCount());\n\t}\n}\n","lineNo":79}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.categories;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerBuilder;\n\n/**\n * From a given set of test classes, runs only the classes and methods\n * that are annotated with either the category given with the @IncludeCategory\n * annotation, or a subtype of that category.\n * \n * Example:\n<pre>\n\tpublic interface FastTests extends CategoryType {}\n\tpublic interface SlowTests extends CategoryType {}\n\n\tpublic static class A {\n\t\t@Test\n\t\tpublic void a() {\n\t\t\tfail();\n\t\t}\n\n\t\t@Category(SlowTests.class)\n\t\t@Test\n\t\tpublic void b() {\n\t\t}\n\t}\n\n\t@Category({SlowTests.class, FastTests.class})\n\tpublic static class B {\n\t\t@Test\n\t\tpublic void c() {\n\n\t\t}\n\t}\n\n\t@RunWith(Categories.class)\n\t@IncludeCategory(SlowTests.class)\n\t@SuiteClasses( { A.class, B.class }) // Note that Categories is a kind of Suite\n\tpublic static class SlowTestSuite {}\n<\/pre>\n */\npublic class Categories extends Suite {\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IncludeCategory {\n\t\tpublic Class<? extends CategoryType> value();\n\t}\n\t\n\tpublic static class CategoryFilter extends Filter {\n\t\tpublic static CategoryFilter include(\n\t\t\t\tClass<? extends CategoryType> categoryClass) {\n\t\t\treturn new CategoryFilter(categoryClass);\n\t\t}\n\n\t\tprivate final Class<? extends CategoryType> fCategoryClass;\n\n\t\tpublic CategoryFilter(Class<? extends CategoryType> categoryClass) {\n\t\t\tfCategoryClass= categoryClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic String describe() {\n\t\t\treturn \"category \" + fCategoryClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (hasCorrectCategoryAnnotation(description))\n\t\t\t\treturn true;\n\n\t\t\t// TODO: feels as if we've done this child crawl several times.\n\t\t\t// Change design?\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tif (shouldRun(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean hasCorrectCategoryAnnotation(Description description) {\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\tfor (Class<? extends CategoryType> each : annotation.value())\n\t\t\t\tif (fCategoryClass.isAssignableFrom(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic Categories(Class<?> klass, RunnerBuilder builder)\n\t\t\tthrows InitializationError {\n\t\tsuper(klass, builder);\n\t\ttry {\n\t\t\tfilter(new CategoryFilter(getCategory(klass)));\n\t\t} catch (NoTestsRemainException e) {\n\t\t\tthrow new InitializationError(e);\n\t\t}\n\t}\n\n\tprivate Class<? extends CategoryType> getCategory(Class<?> klass) {\n\t\treturn klass.getAnnotation(IncludeCategory.class).value();\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.categories;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.RunnerBuilder;\n\n/**\n * From a given set of test classes, runs only the classes and methods that are\n * annotated with either the category given with the @IncludeCategory\n * annotation, or a subtype of that category.\n * \n * Example:\n * \n * <pre>\n * public interface FastTests extends CategoryType {\n * }\n * \n * public interface SlowTests extends CategoryType {\n * }\n * \n * public static class A {\n * \t&#064;Test\n * \tpublic void a() {\n * \t\tfail();\n * \t}\n * \n * \t&#064;Category(SlowTests.class)\n * \t&#064;Test\n * \tpublic void b() {\n * \t}\n * }\n * \n * &#064;Category( { SlowTests.class, FastTests.class })\n * public static class B {\n * \t&#064;Test\n * \tpublic void c() {\n * \n * \t}\n * }\n * \n * &#064;RunWith(Categories.class)\n * &#064;IncludeCategory(SlowTests.class)\n * &#064;SuiteClasses( { A.class, B.class })\n * // Note that Categories is a kind of Suite\n * public static class SlowTestSuite {\n * }\n * <\/pre>\n */\npublic class Categories extends Suite {\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IncludeCategory {\n\t\tpublic Class<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ExcludeCategory {\n\t\tpublic Class<?> value();\n\t}\n\n\tpublic static class CategoryFilter extends Filter {\n\t\tpublic static CategoryFilter include(Class<?> categoryType) {\n\t\t\treturn new CategoryFilter(categoryType, null);\n\t\t}\n\n\t\tprivate final Class<?> fIncluded;\n\n\t\tprivate final Class<?> fExcluded;\n\n\t\tpublic CategoryFilter(Class<?> includedCategory,\n\t\t\t\tClass<?> excludedCategory) {\n\t\t\tfIncluded= includedCategory;\n\t\t\tfExcluded= excludedCategory;\n\t\t}\n\n\t\t@Override\n\t\tpublic String describe() {\n\t\t\treturn \"category \" + fIncluded;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (hasCorrectCategoryAnnotation(description))\n\t\t\t\treturn true;\n\n\t\t\t// TODO: feels as if we've done this child crawl several times.\n\t\t\t// Change design?\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tif (shouldRun(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean hasCorrectCategoryAnnotation(Description description) {\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn fIncluded == null;\n\t\t\tfor (Class<?> each : annotation.value()) {\n\t\t\t\tif (fExcluded != null && fExcluded.isAssignableFrom(each))\n\t\t\t\t\treturn false;\n\t\t\t\tif (fIncluded == null || fIncluded.isAssignableFrom(each))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic Categories(Class<?> klass, RunnerBuilder builder)\n\t\t\tthrows InitializationError {\n\t\tsuper(klass, builder);\n\t\ttry {\n\t\t\tfilter(new CategoryFilter(getIncludedCategory(klass),\n\t\t\t\t\tgetExcludedCategory(klass)));\n\t\t} catch (NoTestsRemainException e) {\n\t\t\tthrow new InitializationError(e);\n\t\t}\n\t}\n\n\tprivate Class<?> getIncludedCategory(Class<?> klass) {\n\t\tIncludeCategory annotation= klass.getAnnotation(IncludeCategory.class);\n\t\treturn annotation == null ? null : annotation.value();\n\t}\n\n\tprivate Class<?> getExcludedCategory(Class<?> klass) {\n\t\tExcludeCategory annotation= klass.getAnnotation(ExcludeCategory.class);\n\t\treturn annotation == null ? null : annotation.value();\n\t}\n}\n","lineNo":133}
{"Smelly Sample":"package org.junit.tests.experimental.interceptor;\n\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.hasFailureContaining;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\nimport org.junit.Test;\nimport org.junit.experimental.interceptor.ErrorCollector;\nimport org.junit.experimental.interceptor.Interceptor;\nimport org.junit.experimental.interceptor.Verifier;\n\npublic class VerifierInterceptorTest {\n\tpublic static class UsesErrorCollector {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"message\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorShouldFail() {\n\t\tassertThat(testResult(UsesErrorCollector.class), hasFailureContaining(\"message\"));\n\t}\n\t\n\tpublic static class UsesErrorCollectorTwice {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"first thing went wrong\"));\n\t\t\tcollector.addError(new Throwable(\"second thing went wrong\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorTwiceShouldFail() {\n\t\tassertThat(testResult(UsesErrorCollectorTwice.class), hasFailureContaining(\"first thing went wrong\"));\n\t\tassertThat(testResult(UsesErrorCollectorTwice.class), hasFailureContaining(\"second thing went wrong\"));\n\t}\n\t\n\tprivate static String sequence;\n\t\n\tpublic static class UsesVerifier {\n\t\t@Interceptor\n\t\tpublic Verifier collector= new Verifier() {\n\t\t\t@Override\n\t\t\tpublic void verify() {\n\t\t\t\tsequence+= \"verify \";\n\t\t\t}\n\t\t};\n\t\t\n\t\t@Test public void example() {\n\t\t\tsequence+= \"test \";\n\t\t}\n\t}\n\t\n\t@Test public void verifierRunsAfterTest() {\n\t\tassertThat(testResult(UsesVerifier.class), isSuccessful());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.experimental.interceptor;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.hasFailureContaining;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.util.concurrent.Callable;\n\nimport org.junit.Test;\nimport org.junit.experimental.interceptor.ErrorCollector;\nimport org.junit.experimental.interceptor.Interceptor;\nimport org.junit.experimental.interceptor.Verifier;\nimport org.junit.experimental.results.PrintableResult;\n\npublic class VerifierInterceptorTest {\n\tpublic static class UsesErrorCollector {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"message\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorShouldFail() {\n\t\tassertThat(testResult(UsesErrorCollector.class), hasFailureContaining(\"message\"));\n\t}\n\t\n\tpublic static class UsesErrorCollectorTwice {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"first thing went wrong\"));\n\t\t\tcollector.addError(new Throwable(\"second thing went wrong\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorTwiceShouldFail() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorTwice.class);\n\t\tassertThat(testResult, hasFailureContaining(\"first thing went wrong\"));\n\t\tassertThat(testResult, hasFailureContaining(\"second thing went wrong\"));\n\t}\n\t\n\tpublic static class UsesErrorCollectorCheckThat {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.checkThat(3, is(4));\n\t\t\tcollector.checkThat(5, is(6));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorCheckThatShouldFail() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorCheckThat.class);\n\t\tassertThat(testResult, hasFailureContaining(\"was <3>\"));\n\t\tassertThat(testResult, hasFailureContaining(\"was <5>\"));\n\t}\n\n\tpublic static class UsesErrorCollectorCheckSucceeds {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.checkSucceeds(new Callable<Object>() {\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tthrow new RuntimeException(\"first!\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tcollector.checkSucceeds(new Callable<Object>() {\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tthrow new RuntimeException(\"second!\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorCheckSucceedsShouldFail() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorCheckSucceeds.class);\n\t\tassertThat(testResult, hasFailureContaining(\"first!\"));\n\t\tassertThat(testResult, hasFailureContaining(\"second!\"));\n\t}\n\n\tpublic static class UsesErrorCollectorCheckSucceedsPasses {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tassertEquals(3, collector.checkSucceeds(new Callable<Object>() {\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorCheckSucceedsShouldPass() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorCheckSucceedsPasses.class);\n\t\tassertThat(testResult, isSuccessful());\n\t}\n\t\n\tprivate static String sequence;\n\t\n\tpublic static class UsesVerifier {\n\t\t@Interceptor\n\t\tpublic Verifier collector= new Verifier() {\n\t\t\t@Override\n\t\t\tpublic void verify() {\n\t\t\t\tsequence+= \"verify \";\n\t\t\t}\n\t\t};\n\t\t\n\t\t@Test public void example() {\n\t\t\tsequence+= \"test \";\n\t\t}\n\t}\n\t\n\t@Test public void verifierRunsAfterTest() {\n\t\tassertThat(testResult(UsesVerifier.class), isSuccessful());\n\t}\n}\n","lineNo":43}
{"Smelly Sample":"package org.junit.tests.experimental.interceptor;\n\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.hasFailureContaining;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\nimport org.junit.Test;\nimport org.junit.experimental.interceptor.ErrorCollector;\nimport org.junit.experimental.interceptor.Interceptor;\nimport org.junit.experimental.interceptor.Verifier;\n\npublic class VerifierInterceptorTest {\n\tpublic static class UsesErrorCollector {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"message\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorShouldFail() {\n\t\tassertThat(testResult(UsesErrorCollector.class), hasFailureContaining(\"message\"));\n\t}\n\t\n\tpublic static class UsesErrorCollectorTwice {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"first thing went wrong\"));\n\t\t\tcollector.addError(new Throwable(\"second thing went wrong\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorTwiceShouldFail() {\n\t\tassertThat(testResult(UsesErrorCollectorTwice.class), hasFailureContaining(\"first thing went wrong\"));\n\t\tassertThat(testResult(UsesErrorCollectorTwice.class), hasFailureContaining(\"second thing went wrong\"));\n\t}\n\t\n\tprivate static String sequence;\n\t\n\tpublic static class UsesVerifier {\n\t\t@Interceptor\n\t\tpublic Verifier collector= new Verifier() {\n\t\t\t@Override\n\t\t\tpublic void verify() {\n\t\t\t\tsequence+= \"verify \";\n\t\t\t}\n\t\t};\n\t\t\n\t\t@Test public void example() {\n\t\t\tsequence+= \"test \";\n\t\t}\n\t}\n\t\n\t@Test public void verifierRunsAfterTest() {\n\t\tassertThat(testResult(UsesVerifier.class), isSuccessful());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.experimental.interceptor;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.hasFailureContaining;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.util.concurrent.Callable;\n\nimport org.junit.Test;\nimport org.junit.experimental.interceptor.ErrorCollector;\nimport org.junit.experimental.interceptor.Interceptor;\nimport org.junit.experimental.interceptor.Verifier;\nimport org.junit.experimental.results.PrintableResult;\n\npublic class VerifierInterceptorTest {\n\tpublic static class UsesErrorCollector {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"message\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorShouldFail() {\n\t\tassertThat(testResult(UsesErrorCollector.class), hasFailureContaining(\"message\"));\n\t}\n\t\n\tpublic static class UsesErrorCollectorTwice {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.addError(new Throwable(\"first thing went wrong\"));\n\t\t\tcollector.addError(new Throwable(\"second thing went wrong\"));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorTwiceShouldFail() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorTwice.class);\n\t\tassertThat(testResult, hasFailureContaining(\"first thing went wrong\"));\n\t\tassertThat(testResult, hasFailureContaining(\"second thing went wrong\"));\n\t}\n\t\n\tpublic static class UsesErrorCollectorCheckThat {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.checkThat(3, is(4));\n\t\t\tcollector.checkThat(5, is(6));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorCheckThatShouldFail() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorCheckThat.class);\n\t\tassertThat(testResult, hasFailureContaining(\"was <3>\"));\n\t\tassertThat(testResult, hasFailureContaining(\"was <5>\"));\n\t}\n\n\tpublic static class UsesErrorCollectorCheckSucceeds {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tcollector.checkSucceeds(new Callable<Object>() {\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tthrow new RuntimeException(\"first!\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tcollector.checkSucceeds(new Callable<Object>() {\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tthrow new RuntimeException(\"second!\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorCheckSucceedsShouldFail() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorCheckSucceeds.class);\n\t\tassertThat(testResult, hasFailureContaining(\"first!\"));\n\t\tassertThat(testResult, hasFailureContaining(\"second!\"));\n\t}\n\n\tpublic static class UsesErrorCollectorCheckSucceedsPasses {\n\t\t@Interceptor\n\t\tpublic ErrorCollector collector= new ErrorCollector();\n\t\t\n\t\t@Test public void example() {\n\t\t\tassertEquals(3, collector.checkSucceeds(new Callable<Object>() {\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\t\n\t@Test public void usedErrorCollectorCheckSucceedsShouldPass() {\n\t\tPrintableResult testResult= testResult(UsesErrorCollectorCheckSucceedsPasses.class);\n\t\tassertThat(testResult, isSuccessful());\n\t}\n\t\n\tprivate static String sequence;\n\t\n\tpublic static class UsesVerifier {\n\t\t@Interceptor\n\t\tpublic Verifier collector= new Verifier() {\n\t\t\t@Override\n\t\t\tpublic void verify() {\n\t\t\t\tsequence+= \"verify \";\n\t\t\t}\n\t\t};\n\t\t\n\t\t@Test public void example() {\n\t\t\tsequence+= \"test \";\n\t\t}\n\t}\n\t\n\t@Test public void verifierRunsAfterTest() {\n\t\tassertThat(testResult(UsesVerifier.class), isSuccessful());\n\t}\n}\n","lineNo":43}
{"Smelly Sample":"package org.junit.experimental.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\n\npublic class MaxHistory implements Serializable {\n\tprivate static final long serialVersionUID= 1L;\n\n\n\tpublic static MaxHistory forFolder(File storedResults) {\n\t\ttry {\n\t\t\tif (storedResults.exists())\n\t\t\t\treturn readHistory(storedResults);\n\t\t} catch (CouldNotReadCoreException e) {\n\t\t\te.printStackTrace();\n\t\t\tstoredResults.delete();\n\t\t}\n\t\treturn new MaxHistory(storedResults);\n\t}\n\t\n//\tpublic static MaxHistory forFolder(String folder) {\n//\t\tFile serializedFile= new File(folder + \".ser\");\n//\t\ttry {\n//\t\t\tif (serializedFile.exists())\n//\t\t\t\treturn readHistory(folder);\n//\t\t} catch (CouldNotReadCoreException e) {\n//\t\t\te.printStackTrace();\n//\t\t\tserializedFile.delete();\n//\t\t}\n//\t\treturn new MaxHistory(folder);\n//\t}\n\n\tprivate static MaxHistory readHistory(File storedResults) throws CouldNotReadCoreException {\n\t\t// TODO: rule of three\n\t\t// TODO: Really?\n\t\tObjectInputStream stream;\n\t\ttry {\n\t\t\tstream= new ObjectInputStream(new FileInputStream(storedResults));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t}\n\t\ttry {\n\t\t\treturn (MaxHistory) stream.readObject();\n\t\t} catch (Exception e) {\n\t\t\tthrow new CouldNotReadCoreException(e); //TODO think about what we can do better here\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t\t}\n\t\t}\n\t}\n\tpublic final Map<String, Long> fDurations= new HashMap<String, Long>();\n\n\tpublic final Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();\n\n\tpublic final File fFolder;\n\n\tpublic MaxHistory(File storedResults) {\n\t\tfFolder= storedResults;\n\t}\n\n\tpublic File getFile() {\n\t\treturn fFolder;\n\t}\n\n\tpublic void save() throws IOException {\n\t\tObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(\n\t\t\t\tfFolder));\n\t\tstream.writeObject(this);\n\t\tstream.close();\n\t}\n\n\tLong getFailureTimestamp(Description key) {\n\t\treturn fFailureTimestamps.get(key.toString());\n\t}\n\n\tvoid putTestFailureTimestamp(Description key, long end) {\n\t\tfFailureTimestamps.put(key.toString(), end);\n\t}\n\n\tboolean isNewTest(Description key) {\n\t\treturn !fDurations.containsKey(key.toString());\n\t}\n\n\tLong getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}\n\n\tvoid putTestDuration(Description description, long duration) {\n\t\tfDurations.put(description.toString(), duration);\n\t}\n\n\tprivate final class RememberingListener extends RunListener {\n\t\tprivate long overallStart= System.currentTimeMillis();\n\n\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t@Override\n\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// possible time\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\tlong end= System.nanoTime();\n\t\t\tlong start= starts.get(description);\n\t\t\tputTestDuration(description, end - start);\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\tputTestFailureTimestamp(failure.getDescription(), overallStart);\n\t\t}\n\t}\n\n\tprivate class TestComparator implements Comparator<Description> {\n\t\tpublic int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\t\n\t\tprivate Long getFailure(Description key) {\n\t\t\tLong result= getFailureTimestamp(key);\n\t\t\tif (result == null) \n\t\t\t\treturn 0L; // 0 = \"never failed (that I know about)\"\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\tpublic RememberingListener listener() {\n\t\treturn new RememberingListener();\n\t}\n\n\t// TODO (Feb 23, 2009 10:41:36 PM): V\n\tpublic Comparator<Description> testComparator() {\n\t\treturn new TestComparator();\n\t}\n}\n","Method after Refactoring":"package org.junit.experimental.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\n\npublic class MaxHistory implements Serializable {\n\tprivate static final long serialVersionUID= 1L;\n\n\n\tpublic static MaxHistory forFolder(File storedResults) {\n\t\ttry {\n\t\t\tif (storedResults.exists())\n\t\t\t\treturn readHistory(storedResults);\n\t\t} catch (CouldNotReadCoreException e) {\n\t\t\te.printStackTrace();\n\t\t\tstoredResults.delete();\n\t\t}\n\t\treturn new MaxHistory(storedResults);\n\t}\n\t\n\tprivate static MaxHistory readHistory(File storedResults) throws CouldNotReadCoreException {\n\t\t// TODO: rule of three\n\t\t// TODO: Really?\n\t\tObjectInputStream stream;\n\t\tFileInputStream file= null;\n\t\ttry {\n\t\t\tfile= new FileInputStream(storedResults);\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t}\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tstream= new ObjectInputStream(file);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (MaxHistory) stream.readObject();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new CouldNotReadCoreException(e); //TODO think about what we can do better here\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tstream.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tfile.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO can't imagine what's gone wrong here, but who cares?\n\t\t\t}\n\t\t}\n\t}\n\tpublic final Map<String, Long> fDurations= new HashMap<String, Long>();\n\n\tpublic final Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();\n\n\tpublic final File fFolder;\n\n\tpublic MaxHistory(File storedResults) {\n\t\tfFolder= storedResults;\n\t}\n\n\tpublic File getFile() {\n\t\treturn fFolder;\n\t}\n\n\tpublic void save() throws IOException {\n\t\tObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(\n\t\t\t\tfFolder));\n\t\tstream.writeObject(this);\n\t\tstream.close();\n\t}\n\n\tLong getFailureTimestamp(Description key) {\n\t\treturn fFailureTimestamps.get(key.toString());\n\t}\n\n\tvoid putTestFailureTimestamp(Description key, long end) {\n\t\tfFailureTimestamps.put(key.toString(), end);\n\t}\n\n\tboolean isNewTest(Description key) {\n\t\treturn !fDurations.containsKey(key.toString());\n\t}\n\n\tLong getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}\n\n\tvoid putTestDuration(Description description, long duration) {\n\t\tfDurations.put(description.toString(), duration);\n\t}\n\n\tprivate final class RememberingListener extends RunListener {\n\t\tprivate long overallStart= System.currentTimeMillis();\n\n\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t@Override\n\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// possible time\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\tlong end= System.nanoTime();\n\t\t\tlong start= starts.get(description);\n\t\t\tputTestDuration(description, end - start);\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\tputTestFailureTimestamp(failure.getDescription(), overallStart);\n\t\t}\n\t}\n\n\tprivate class TestComparator implements Comparator<Description> {\n\t\tpublic int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\t\n\t\tprivate Long getFailure(Description key) {\n\t\t\tLong result= getFailureTimestamp(key);\n\t\t\tif (result == null) \n\t\t\t\treturn 0L; // 0 = \"never failed (that I know about)\"\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\tpublic RememberingListener listener() {\n\t\treturn new RememberingListener();\n\t}\n\n\t// TODO (Feb 23, 2009 10:41:36 PM): V\n\tpublic Comparator<Description> testComparator() {\n\t\treturn new TestComparator();\n\t}\n}\n","lineNo":38}
{"Smelly Sample":"package org.junit.experimental.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.internal.requests.SortingRequest;\nimport org.junit.internal.runners.ErrorReportingRunner;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\n\n// TODO (Nov 18, 2008 1:40:42 PM): Is this doing too much?\npublic class MaxCore implements Serializable {\n\tprivate static final long serialVersionUID= 1L;\n\n\tpublic static MaxCore forFolder(String folder) throws CouldNotReadCoreException {\n\t\tif (new File(folder + \".ser\").exists())\n\t\t\treturn readCore(folder);\n\t\treturn new MaxCore(folder);\n\t}\n\n\tprivate static MaxCore readCore(String folder) throws CouldNotReadCoreException {\n\t\t// TODO: rule of three\n\t\t// TODO: Really?\n\t\tObjectInputStream stream;\n\t\ttry {\n\t\t\tstream= new ObjectInputStream(new FileInputStream(folder + \".ser\"));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t}\n\t\ttry {\n\t\t\treturn (MaxCore) stream.readObject();\n\t\t} catch (Exception e) {\n\t\t\tthrow new CouldNotReadCoreException(e); //TODO think about what we can do better here\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static MaxCore createFresh() {\n\t\treturn new MaxCore();\n\t}\n\n\tprotected Map<String, Long> fDurations= new HashMap<String, Long>();\n\tprotected Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();\n\tprivate final String fFolder;\n\t\n\tprivate MaxCore(String folder) {\n\t\tfFolder= folder;\n\t}\n\n\tprivate MaxCore() {\n\t\t// TODO: ensure fresh\n\t\tthis(\"MaxCore\");\n\t}\n\n\tpublic Result run(Request request) {\n\t\treturn run(request, new JUnitCore());\n\t}\n\n\tpublic Result run(Request request, JUnitCore core) {\n\t\tcore.addListener(new RememberingListener());\n\t\ttry { \n\t\t\treturn core.run(sortRequest(request).getRunner());\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tsave();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic String getFolder() {\n\t\treturn fFolder;\n\t}\n\n\tpublic void forget() {\n\t\tnew File(fFolder).delete();\n\t}\n\n\tprivate Request sortRequest(Request request) {\n\t\tif (request instanceof SortingRequest) // We'll pay big karma points for this\n\t\t\treturn request;\n\t\tList<Description> leaves= findLeaves(request);\n\t\tCollections.sort(leaves, new TestComparator());\n\t\treturn constructLeafRequest(leaves);\n\t}\n\n\tprivate Request constructLeafRequest(List<Description> leaves) {\n\t\tfinal List<Runner> runners = new ArrayList<Runner>();\n\t\tfor (Description each : leaves)\n\t\t\trunners.add(buildRunner(each));\n\t\treturn new Request() {\n\t\t\t@Override\n\t\t\tpublic Runner getRunner() {\n\t\t\t\ttry {\n\t\t\t\t\treturn new Suite((Class<?>)null, runners) {};\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\treturn new ErrorReportingRunner(null, e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate Runner buildRunner(Description each) {\n\t\tif (each.toString().equals(\"TestSuite with 0 tests\"))\n\t\t\ttry {\n\t\t\t\t// TODO (Nov 18, 2008 2:18:28 PM): move to Suite\n\t\t\t\treturn new Suite(null, new Class<?>[0]);\n\t\t\t} catch (InitializationError e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\tClass<?> type= each.getTestClass();\n\t\tif (type == null)\n\t\t\t// TODO (Nov 18, 2008 2:04:09 PM): add a check if building a runner is possible\n\t\t\tthrow new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");\n\t\treturn Request.method(type, each.getMethodName()).getRunner();\n\t}\n\n\tprivate void save() throws FileNotFoundException, IOException {\n\t\tObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(fFolder + \".ser\"));\n\t\tstream.writeObject(this);\n\t\tstream.close();\n\t}\n\n\tpublic List<Description> sortedLeavesForTest(Request request) {\n\t\treturn findLeaves(sortRequest(request));\n\t}\n\n\tprivate final class RememberingListener extends RunListener {\n\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t@Override\n\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\tlong end= System.nanoTime();\n\t\t\tlong start= starts.get(description);\n\t\t\tputTestDuration(description, end - start);\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t}\n\t}\n\n\tprivate class TestComparator implements Comparator<Description> {\n\t\tpublic int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\t\n\t\tprivate Long getFailure(Description key) {\n\t\t\tLong result= getFailureTimestamp(key);\n\t\t\tif (result == null) \n\t\t\t\treturn 0L; // 0 = \"never failed (that I know about)\"\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\tprivate List<Description> findLeaves(Request request) {\n\t\tList<Description> results= new ArrayList<Description>();\n\t\tfindLeaves(request.getRunner().getDescription(), results);\n\t\treturn results;\n\t}\n\t\n\tprivate void findLeaves(Description description, List<Description> results) {\n\t\tif (description.getChildren().isEmpty())\n\t\t\tresults.add(description);\n\t\telse\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tfindLeaves(each, results);\n\t}\n\t\n\tprivate Long getFailureTimestamp(Description key) {\n\t\treturn fFailureTimestamps.get(key.toString());\n\t}\n\n\tprivate void putTestFailureTimestamp(Description key, long end) {\n\t\tfFailureTimestamps.put(key.toString(), end);\n\t}\n\n\tprivate boolean isNewTest(Description key) {\n\t\treturn ! fDurations.containsKey(key.toString());\n\t}\n\t\n\tprivate Long getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}\n\t\n\tprivate void putTestDuration(Description description, long duration) {\n\t\tfDurations.put(description.toString(), duration);\n\t}\n}\n\n","Method after Refactoring":"package org.junit.experimental.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.internal.requests.SortingRequest;\nimport org.junit.internal.runners.ErrorReportingRunner;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\n\n// TODO (Nov 18, 2008 1:40:42 PM): Is this doing too much?\npublic class MaxCore implements Serializable {\n\tprivate static final long serialVersionUID= 1L;\n\n\tpublic static MaxCore forFolder(String folder) throws CouldNotReadCoreException {\n\t\tif (new File(folder + \".ser\").exists())\n\t\t\treturn readCore(folder);\n\t\treturn new MaxCore(folder);\n\t}\n\n\tprivate static MaxCore readCore(String folder) throws CouldNotReadCoreException {\n\t\t// TODO: rule of three\n\t\t// TODO: Really?\n\t\tObjectInputStream stream;\n\t\ttry {\n\t\t\tstream= new ObjectInputStream(new FileInputStream(folder + \".ser\"));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t}\n\t\ttry {\n\t\t\treturn (MaxCore) stream.readObject();\n\t\t} catch (Exception e) {\n\t\t\tthrow new CouldNotReadCoreException(e); //TODO think about what we can do better here\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static MaxCore createFresh() {\n\t\treturn new MaxCore();\n\t}\n\n\tprotected Map<String, Long> fDurations= new HashMap<String, Long>();\n\tprotected Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();\n\tprivate final String fFolder;\n\t\n\tprivate MaxCore(String folder) {\n\t\tfFolder= folder;\n\t}\n\n\tprivate MaxCore() {\n\t\t// TODO: ensure fresh\n\t\tthis(\"MaxCore\");\n\t}\n\n\tpublic Result run(Request request) {\n\t\treturn run(request, new JUnitCore());\n\t}\n\n\tpublic Result run(Request request, JUnitCore core) {\n\t\tcore.addListener(new RememberingListener());\n\t\ttry { \n\t\t\treturn core.run(sortRequest(request).getRunner());\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tsave();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic String getFolder() {\n\t\treturn fFolder;\n\t}\n\n\tpublic void forget() {\n\t\tnew File(fFolder).delete();\n\t}\n\n\t// TODO (Feb 23, 2009 10:14:05 PM): publicized for squeeze\n\tpublic Request sortRequest(Request request) {\n\t\tif (request instanceof SortingRequest) // We'll pay big karma points for this\n\t\t\treturn request;\n\t\tList<Description> leaves= findLeaves(request);\n\t\tCollections.sort(leaves, testComparator());\n\t\treturn constructLeafRequest(leaves);\n\t}\n\n\t// TODO (Feb 23, 2009 10:41:36 PM): V\n\tpublic Comparator<Description> testComparator() {\n\t\treturn new TestComparator();\n\t}\n\n\t// TODO (Feb 23, 2009 10:42:05 PM): V\n\tpublic Request constructLeafRequest(List<Description> leaves) {\n\t\tfinal List<Runner> runners = new ArrayList<Runner>();\n\t\tfor (Description each : leaves)\n\t\t\trunners.add(buildRunner(each));\n\t\treturn new Request() {\n\t\t\t@Override\n\t\t\tpublic Runner getRunner() {\n\t\t\t\ttry {\n\t\t\t\t\treturn new Suite((Class<?>)null, runners) {};\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\treturn new ErrorReportingRunner(null, e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// TODO (Feb 23, 2009 11:17:01 PM): V\n\tpublic Runner buildRunner(Description each) {\n\t\tif (each.toString().equals(\"TestSuite with 0 tests\"))\n\t\t\ttry {\n\t\t\t\t// TODO (Nov 18, 2008 2:18:28 PM): move to Suite\n\t\t\t\treturn new Suite(null, new Class<?>[0]);\n\t\t\t} catch (InitializationError e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\tClass<?> type= each.getTestClass();\n\t\tif (type == null)\n\t\t\t// TODO (Nov 18, 2008 2:04:09 PM): add a check if building a runner is possible\n\t\t\tthrow new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");\n\t\tString methodName= each.getMethodName();\n\t\tif (methodName == null)\n\t\t\treturn Request.aClass(type).getRunner();\n\t\treturn Request.method(type, methodName).getRunner();\n\t}\n\n\tprivate void save() throws FileNotFoundException, IOException {\n\t\tObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(fFolder + \".ser\"));\n\t\tstream.writeObject(this);\n\t\tstream.close();\n\t}\n\n\tpublic List<Description> sortedLeavesForTest(Request request) {\n\t\treturn findLeaves(sortRequest(request));\n\t}\n\n\tprivate final class RememberingListener extends RunListener {\n\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t@Override\n\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\tlong end= System.nanoTime();\n\t\t\tlong start= starts.get(description);\n\t\t\tputTestDuration(description, end - start);\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t}\n\t}\n\n\tprivate class TestComparator implements Comparator<Description> {\n\t\tpublic int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\t\n\t\tprivate Long getFailure(Description key) {\n\t\t\tLong result= getFailureTimestamp(key);\n\t\t\tif (result == null) \n\t\t\t\treturn 0L; // 0 = \"never failed (that I know about)\"\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\t// TODO (Feb 23, 2009 10:40:23 PM): V\n\tpublic List<Description> findLeaves(Request request) {\n\t\tList<Description> results= new ArrayList<Description>();\n\t\tfindLeaves(request.getRunner().getDescription(), results);\n\t\treturn results;\n\t}\n\t\n\t// TODO (Feb 23, 2009 10:50:48 PM): V\n\tpublic void findLeaves(Description description, List<Description> results) {\n\t\tif (description.getChildren().isEmpty())\n\t\t\tresults.add(description);\n\t\telse\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tfindLeaves(each, results);\n\t}\n\n\tprivate Long getFailureTimestamp(Description key) {\n\t\treturn fFailureTimestamps.get(key.toString());\n\t}\n\n\tprivate void putTestFailureTimestamp(Description key, long end) {\n\t\tfFailureTimestamps.put(key.toString(), end);\n\t}\n\n\tprivate boolean isNewTest(Description key) {\n\t\treturn ! fDurations.containsKey(key.toString());\n\t}\n\t\n\tprivate Long getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}\n\t\n\tprivate void putTestDuration(Description description, long duration) {\n\t\tfDurations.put(description.toString(), duration);\n\t}\n}\n\n","lineNo":153}
{"Smelly Sample":"package org.junit.internal.runners;\n\nimport junit.extensions.TestDecorator;\nimport junit.framework.AssertionFailedError;\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestListener;\nimport junit.framework.TestResult;\nimport junit.framework.TestSuite;\nimport org.junit.runner.Describable;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit38ClassRunner extends Runner implements Filterable, Sortable {\n\tprivate static final class OldTestClassAdaptingListener implements\n\t\t\tTestListener {\n\t\tprivate final RunNotifier fNotifier;\n\n\t\tprivate OldTestClassAdaptingListener(RunNotifier notifier) {\n\t\t\tfNotifier= notifier;\n\t\t}\n\n\t\tpublic void endTest(Test test) {\n\t\t\tfNotifier.fireTestFinished(asDescription(test));\n\t\t}\n\n\t\tpublic void startTest(Test test) {\n\t\t\tfNotifier.fireTestStarted(asDescription(test));\n\t\t}\n\n\t\t// Implement junit.framework.TestListener\n\t\tpublic void addError(Test test, Throwable t) {\n\t\t\tFailure failure= new Failure(asDescription(test), t);\n\t\t\tfNotifier.fireTestFailure(failure);\n\t\t}\n\n\t\tprivate Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(test.getClass(), getName(test));\n\t\t}\n\n\t\tprivate String getName(Test test) {\n\t\t\tif (test instanceof TestCase)\n\t\t\t\treturn ((TestCase) test).getName();\n\t\t\telse\n\t\t\t\treturn test.toString();\n\t\t}\n\n\t\tpublic void addFailure(Test test, AssertionFailedError t) {\n\t\t\taddError(test, t);\n\t\t}\n\t}\n\n\tprivate Test fTest;\n\t\n\tpublic JUnit38ClassRunner(Class<?> klass) {\n\t\tthis(new TestSuite(klass.asSubclass(TestCase.class)));\n\t}\n\n\tpublic JUnit38ClassRunner(Test test) {\n\t\tsuper();\n\t\tsetTest(test);\n\t}\n\n\t@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tTestResult result= new TestResult();\n\t\tresult.addListener(createAdaptingListener(notifier));\n\t\tgetTest().run(result);\n\t}\n\n\tpublic static TestListener createAdaptingListener(final RunNotifier notifier) {\n\t\treturn new OldTestClassAdaptingListener(notifier);\n\t}\n\t\n\t@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(getTest());\n\t}\n\n\tprivate static Description makeDescription(Test test) {\n\t\tif (test instanceof TestCase) {\n\t\t\tTestCase tc= (TestCase) test;\n\t\t\treturn Description.createTestDescription(tc.getClass(), tc.getName());\n\t\t} else if (test instanceof TestSuite) {\n\t\t\tTestSuite ts= (TestSuite) test;\n\t\t\tString name= ts.getName() == null ? createSuiteDescription(ts) : ts.getName();\n\t\t\tDescription description= Description.createSuiteDescription(name);\n\t\t\tint n= ts.testCount();\n\t\t\tfor (int i= 0; i < n; i++)\n\t\t\t\tdescription.addChild(makeDescription(ts.testAt(i)));\n\t\t\treturn description;\n\t\t} else if (test instanceof Describable) {\n\t\t\tDescribable adapter= (Describable) test;\n\t\t\treturn adapter.getDescription();\n\t\t} else if (test instanceof TestDecorator) {\n\t\t\tTestDecorator decorator= (TestDecorator) test;\n\t\t\treturn makeDescription(decorator.getTest());\n\t\t} else {\n\t\t\t// This is the best we can do in this case\n\t\t\treturn Description.createSuiteDescription(test.getClass());\n\t\t}\n\t}\n\n\tprivate static String createSuiteDescription(TestSuite ts) {\n\t\tint count= ts.countTestCases();\n\t\tString example = count == 0 ? \"\" : String.format(\" [example: %s]\", ts.testAt(0));\n\t\treturn String.format(\"TestSuite with %s tests%s\", count, example);\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tif (getTest() instanceof Filterable) {\n\t\t\tFilterable adapter= (Filterable) getTest();\n\t\t\tadapter.filter(filter);\n\t\t} else if (getTest() instanceof TestSuite) {\n\t\t\tTestSuite suite= (TestSuite) getTest();\n\t\t\tTestSuite filtered= new TestSuite(suite.getName());\n\t\t\tint n= suite.testCount();\n\t\t\tfor (int i= 0; i < n; i++) {\n\t\t\t\tTest test= suite.testAt(i);\n\t\t\t\tif (filter.shouldRun(makeDescription(test)))\n\t\t\t\t\tfiltered.addTest(test);\n\t\t\t}\n\t\t\tsetTest(filtered);\n\t\t}\n\t}\n\n\tpublic void sort(Sorter sorter) {\n\t\tif (getTest() instanceof Sortable) {\n\t\t\tSortable adapter= (Sortable) getTest();\n\t\t\tadapter.sort(sorter);\n\t\t}\n\t}\n\n\tprivate void setTest(Test test) {\n\t\tfTest = test;\n\t}\n\n\tprivate Test getTest() {\n\t\treturn fTest;\n\t}\n}\n","Method after Refactoring":"package org.junit.internal.runners;\n\nimport java.util.List;\n\nimport junit.extensions.TestDecorator;\nimport junit.framework.AssertionFailedError;\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestListener;\nimport junit.framework.TestResult;\nimport junit.framework.TestSuite;\nimport org.junit.runner.Describable;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit38ClassRunner extends Runner implements Filterable, Sortable {\n\tprivate final class OldTestClassAdaptingListener implements\n\t\t\tTestListener {\n\t\tprivate final RunNotifier fNotifier;\n\n\t\tprivate OldTestClassAdaptingListener(RunNotifier notifier) {\n\t\t\tfNotifier= notifier;\n\t\t}\n\n\t\tpublic void endTest(Test test) {\n\t\t\tfNotifier.fireTestFinished(asDescription(test));\n\t\t}\n\n\t\tpublic void startTest(Test test) {\n\t\t\tfNotifier.fireTestStarted(asDescription(test));\n\t\t}\n\n\t\t// Implement junit.framework.TestListener\n\t\tpublic void addError(Test test, Throwable t) {\n\t\t\tFailure failure= new Failure(asDescription(test), t);\n\t\t\tfNotifier.fireTestFailure(failure);\n\t\t}\n\n\t\tprivate Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(getEffectiveClass(test), getName(test));\n\t\t}\n\n\t\tprivate Class<? extends Test> getEffectiveClass(Test test) {\n\t\t\t// TODO (Feb 23, 2009 11:45:54 PM): Think hard about this.\n\t\t\tif (\"warning\".equals(getName(test)))\n\t\t\t\ttry {\n\t\t\t\t\treturn (Class<? extends Test>) Class.forName(fTest.toString());\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\treturn test.getClass();\n\t\t\t\t}\n\t\t\treturn test.getClass();\n\t\t}\n\n\t\tprivate String getName(Test test) {\n\t\t\tif (test instanceof TestCase)\n\t\t\t\treturn ((TestCase) test).getName();\n\t\t\telse\n\t\t\t\treturn test.toString();\n\t\t}\n\n\t\tpublic void addFailure(Test test, AssertionFailedError t) {\n\t\t\taddError(test, t);\n\t\t}\n\t}\n\n\tprivate Test fTest;\n\t\n\tpublic JUnit38ClassRunner(Class<?> klass) {\n\t\tthis(new TestSuite(klass.asSubclass(TestCase.class)));\n\t}\n\n\tpublic JUnit38ClassRunner(Test test) {\n\t\tsuper();\n\t\tsetTest(test);\n\t}\n\n\t@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tTestResult result= new TestResult();\n\t\tresult.addListener(createAdaptingListener(notifier));\n\t\tgetTest().run(result);\n\t}\n\n\tpublic TestListener createAdaptingListener(final RunNotifier notifier) {\n\t\treturn new OldTestClassAdaptingListener(notifier);\n\t}\n\t\n\t@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(getTest());\n\t}\n\n\t// TODO (Feb 23, 2009 10:57:14 PM): V\n\tpublic static Description makeDescription(Test test) {\n\t\tif (test instanceof TestCase) {\n\t\t\tTestCase tc= (TestCase) test;\n\t\t\treturn Description.createTestDescription(tc.getClass(), tc.getName());\n\t\t} else if (test instanceof TestSuite) {\n\t\t\tTestSuite ts= (TestSuite) test;\n\t\t\tString name= ts.getName() == null ? createSuiteDescription(ts) : ts.getName();\n\t\t\tDescription description= Description.createSuiteDescription(name);\n\t\t\tint n= ts.testCount();\n\t\t\tfor (int i= 0; i < n; i++) {\n\t\t\t\tDescription made= makeDescription(ts.testAt(i));\n\t\t\t\t// TODO (Feb 23, 2009 11:25:23 PM): this is doing Max's work for it.  Max should get rid of these when sorting i\n\t\t\t\tif (!made.toString().startsWith(\"warning(\"))\t\t\t\n\t\t\t\t\tdescription.addChild(made);\n\t\t\t}\n\t\t\treturn description;\n\t\t} else if (test instanceof Describable) {\n\t\t\tDescribable adapter= (Describable) test;\n\t\t\treturn adapter.getDescription();\n\t\t} else if (test instanceof TestDecorator) {\n\t\t\tTestDecorator decorator= (TestDecorator) test;\n\t\t\treturn makeDescription(decorator.getTest());\n\t\t} else {\n\t\t\t// This is the best we can do in this case\n\t\t\treturn Description.createSuiteDescription(test.getClass());\n\t\t}\n\t}\n\n\tprivate static String createSuiteDescription(TestSuite ts) {\n\t\tint count= ts.countTestCases();\n\t\tString example = count == 0 ? \"\" : String.format(\" [example: %s]\", ts.testAt(0));\n\t\treturn String.format(\"TestSuite with %s tests%s\", count, example);\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tif (getTest() instanceof Filterable) {\n\t\t\tFilterable adapter= (Filterable) getTest();\n\t\t\tadapter.filter(filter);\n\t\t} else if (getTest() instanceof TestSuite) {\n\t\t\tTestSuite suite= (TestSuite) getTest();\n\t\t\tTestSuite filtered= new TestSuite(suite.getName());\n\t\t\tint n= suite.testCount();\n\t\t\tfor (int i= 0; i < n; i++) {\n\t\t\t\tTest test= suite.testAt(i);\n\t\t\t\tif (filter.shouldRun(makeDescription(test)))\n\t\t\t\t\tfiltered.addTest(test);\n\t\t\t}\n\t\t\tsetTest(filtered);\n\t\t}\n\t}\n\n\tpublic void sort(Sorter sorter) {\n\t\tif (getTest() instanceof Sortable) {\n\t\t\tSortable adapter= (Sortable) getTest();\n\t\t\tadapter.sort(sorter);\n\t\t}\n\t}\n\n\tprivate void setTest(Test test) {\n\t\tfTest = test;\n\t}\n\n\t// TODO (Feb 23, 2009 10:57:26 PM): V\n\tpublic Test getTest() {\n\t\treturn fTest;\n\t}\n}\n","lineNo":115}
{"Smelly Sample":"package org.junit.experimental.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.internal.requests.SortingRequest;\nimport org.junit.internal.runners.ErrorReportingRunner;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\n\n// TODO (Nov 18, 2008 1:40:42 PM): Is this doing too much?\npublic class MaxCore implements Serializable {\n\tprivate static final long serialVersionUID= 1L;\n\n\tpublic static MaxCore forFolder(String folder) throws CouldNotReadCoreException {\n\t\tif (new File(folder + \".ser\").exists())\n\t\t\treturn readCore(folder);\n\t\treturn new MaxCore(folder);\n\t}\n\n\tprivate static MaxCore readCore(String folder) throws CouldNotReadCoreException {\n\t\t// TODO: rule of three\n\t\t// TODO: Really?\n\t\tObjectInputStream stream;\n\t\ttry {\n\t\t\tstream= new ObjectInputStream(new FileInputStream(folder + \".ser\"));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t}\n\t\ttry {\n\t\t\treturn (MaxCore) stream.readObject();\n\t\t} catch (Exception e) {\n\t\t\tthrow new CouldNotReadCoreException(e); //TODO think about what we can do better here\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static MaxCore createFresh() {\n\t\treturn new MaxCore();\n\t}\n\n\tprotected Map<String, Long> fDurations= new HashMap<String, Long>();\n\tprotected Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();\n\tprivate final String fFolder;\n\t\n\tprivate MaxCore(String folder) {\n\t\tfFolder= folder;\n\t}\n\n\tprivate MaxCore() {\n\t\t// TODO: ensure fresh\n\t\tthis(\"MaxCore\");\n\t}\n\n\tpublic Result run(Request request) {\n\t\treturn run(request, new JUnitCore());\n\t}\n\n\tpublic Result run(Request request, JUnitCore core) {\n\t\tcore.addListener(new RememberingListener());\n\t\ttry { \n\t\t\treturn core.run(sortRequest(request).getRunner());\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tsave();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic String getFolder() {\n\t\treturn fFolder;\n\t}\n\n\tpublic void forget() {\n\t\tnew File(fFolder).delete();\n\t}\n\n\tprivate Request sortRequest(Request request) {\n\t\tif (request instanceof SortingRequest) // We'll pay big karma points for this\n\t\t\treturn request;\n\t\tList<Description> leaves= findLeaves(request);\n\t\tCollections.sort(leaves, new TestComparator());\n\t\treturn constructLeafRequest(leaves);\n\t}\n\n\tprivate Request constructLeafRequest(List<Description> leaves) {\n\t\tfinal List<Runner> runners = new ArrayList<Runner>();\n\t\tfor (Description each : leaves)\n\t\t\trunners.add(buildRunner(each));\n\t\treturn new Request() {\n\t\t\t@Override\n\t\t\tpublic Runner getRunner() {\n\t\t\t\ttry {\n\t\t\t\t\treturn new Suite((Class<?>)null, runners) {};\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\treturn new ErrorReportingRunner(null, e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate Runner buildRunner(Description each) {\n\t\tif (each.toString().equals(\"TestSuite with 0 tests\"))\n\t\t\ttry {\n\t\t\t\t// TODO (Nov 18, 2008 2:18:28 PM): move to Suite\n\t\t\t\treturn new Suite(null, new Class<?>[0]);\n\t\t\t} catch (InitializationError e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\tClass<?> type= each.getTestClass();\n\t\tif (type == null)\n\t\t\t// TODO (Nov 18, 2008 2:04:09 PM): add a check if building a runner is possible\n\t\t\tthrow new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");\n\t\treturn Request.method(type, each.getMethodName()).getRunner();\n\t}\n\n\tprivate void save() throws FileNotFoundException, IOException {\n\t\tObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(fFolder + \".ser\"));\n\t\tstream.writeObject(this);\n\t\tstream.close();\n\t}\n\n\tpublic List<Description> sortedLeavesForTest(Request request) {\n\t\treturn findLeaves(sortRequest(request));\n\t}\n\n\tprivate final class RememberingListener extends RunListener {\n\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t@Override\n\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\tlong end= System.nanoTime();\n\t\t\tlong start= starts.get(description);\n\t\t\tputTestDuration(description, end - start);\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t}\n\t}\n\n\tprivate class TestComparator implements Comparator<Description> {\n\t\tpublic int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\t\n\t\tprivate Long getFailure(Description key) {\n\t\t\tLong result= getFailureTimestamp(key);\n\t\t\tif (result == null) \n\t\t\t\treturn 0L; // 0 = \"never failed (that I know about)\"\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\tprivate List<Description> findLeaves(Request request) {\n\t\tList<Description> results= new ArrayList<Description>();\n\t\tfindLeaves(request.getRunner().getDescription(), results);\n\t\treturn results;\n\t}\n\t\n\tprivate void findLeaves(Description description, List<Description> results) {\n\t\tif (description.getChildren().isEmpty())\n\t\t\tresults.add(description);\n\t\telse\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tfindLeaves(each, results);\n\t}\n\t\n\tprivate Long getFailureTimestamp(Description key) {\n\t\treturn fFailureTimestamps.get(key.toString());\n\t}\n\n\tprivate void putTestFailureTimestamp(Description key, long end) {\n\t\tfFailureTimestamps.put(key.toString(), end);\n\t}\n\n\tprivate boolean isNewTest(Description key) {\n\t\treturn ! fDurations.containsKey(key.toString());\n\t}\n\t\n\tprivate Long getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}\n\t\n\tprivate void putTestDuration(Description description, long duration) {\n\t\tfDurations.put(description.toString(), duration);\n\t}\n}\n\n","Method after Refactoring":"package org.junit.experimental.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.internal.requests.SortingRequest;\nimport org.junit.internal.runners.ErrorReportingRunner;\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.InitializationError;\n\n// TODO (Nov 18, 2008 1:40:42 PM): Is this doing too much?\npublic class MaxCore implements Serializable {\n\tprivate static final long serialVersionUID= 1L;\n\n\tpublic static MaxCore forFolder(String folder) throws CouldNotReadCoreException {\n\t\tif (new File(folder + \".ser\").exists())\n\t\t\treturn readCore(folder);\n\t\treturn new MaxCore(folder);\n\t}\n\n\tprivate static MaxCore readCore(String folder) throws CouldNotReadCoreException {\n\t\t// TODO: rule of three\n\t\t// TODO: Really?\n\t\tObjectInputStream stream;\n\t\ttry {\n\t\t\tstream= new ObjectInputStream(new FileInputStream(folder + \".ser\"));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t}\n\t\ttry {\n\t\t\treturn (MaxCore) stream.readObject();\n\t\t} catch (Exception e) {\n\t\t\tthrow new CouldNotReadCoreException(e); //TODO think about what we can do better here\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new CouldNotReadCoreException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static MaxCore createFresh() {\n\t\treturn new MaxCore();\n\t}\n\n\tprotected Map<String, Long> fDurations= new HashMap<String, Long>();\n\tprotected Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();\n\tprivate final String fFolder;\n\t\n\tprivate MaxCore(String folder) {\n\t\tfFolder= folder;\n\t}\n\n\tprivate MaxCore() {\n\t\t// TODO: ensure fresh\n\t\tthis(\"MaxCore\");\n\t}\n\n\tpublic Result run(Request request) {\n\t\treturn run(request, new JUnitCore());\n\t}\n\n\tpublic Result run(Request request, JUnitCore core) {\n\t\tcore.addListener(new RememberingListener());\n\t\ttry { \n\t\t\treturn core.run(sortRequest(request).getRunner());\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tsave();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic String getFolder() {\n\t\treturn fFolder;\n\t}\n\n\tpublic void forget() {\n\t\tnew File(fFolder).delete();\n\t}\n\n\t// TODO (Feb 23, 2009 10:14:05 PM): publicized for squeeze\n\tpublic Request sortRequest(Request request) {\n\t\tif (request instanceof SortingRequest) // We'll pay big karma points for this\n\t\t\treturn request;\n\t\tList<Description> leaves= findLeaves(request);\n\t\tCollections.sort(leaves, testComparator());\n\t\treturn constructLeafRequest(leaves);\n\t}\n\n\t// TODO (Feb 23, 2009 10:41:36 PM): V\n\tpublic Comparator<Description> testComparator() {\n\t\treturn new TestComparator();\n\t}\n\n\t// TODO (Feb 23, 2009 10:42:05 PM): V\n\tpublic Request constructLeafRequest(List<Description> leaves) {\n\t\tfinal List<Runner> runners = new ArrayList<Runner>();\n\t\tfor (Description each : leaves)\n\t\t\trunners.add(buildRunner(each));\n\t\treturn new Request() {\n\t\t\t@Override\n\t\t\tpublic Runner getRunner() {\n\t\t\t\ttry {\n\t\t\t\t\treturn new Suite((Class<?>)null, runners) {};\n\t\t\t\t} catch (InitializationError e) {\n\t\t\t\t\treturn new ErrorReportingRunner(null, e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// TODO (Feb 23, 2009 11:17:01 PM): V\n\tpublic Runner buildRunner(Description each) {\n\t\tif (each.toString().equals(\"TestSuite with 0 tests\"))\n\t\t\ttry {\n\t\t\t\t// TODO (Nov 18, 2008 2:18:28 PM): move to Suite\n\t\t\t\treturn new Suite(null, new Class<?>[0]);\n\t\t\t} catch (InitializationError e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\tClass<?> type= each.getTestClass();\n\t\tif (type == null)\n\t\t\t// TODO (Nov 18, 2008 2:04:09 PM): add a check if building a runner is possible\n\t\t\tthrow new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");\n\t\tString methodName= each.getMethodName();\n\t\tif (methodName == null)\n\t\t\treturn Request.aClass(type).getRunner();\n\t\treturn Request.method(type, methodName).getRunner();\n\t}\n\n\tprivate void save() throws FileNotFoundException, IOException {\n\t\tObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(fFolder + \".ser\"));\n\t\tstream.writeObject(this);\n\t\tstream.close();\n\t}\n\n\tpublic List<Description> sortedLeavesForTest(Request request) {\n\t\treturn findLeaves(sortRequest(request));\n\t}\n\n\tprivate final class RememberingListener extends RunListener {\n\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t@Override\n\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\tlong end= System.nanoTime();\n\t\t\tlong start= starts.get(description);\n\t\t\tputTestDuration(description, end - start);\n\t\t}\n\n\t\t@Override\n\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t}\n\t}\n\n\tprivate class TestComparator implements Comparator<Description> {\n\t\tpublic int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\t\n\t\tprivate Long getFailure(Description key) {\n\t\t\tLong result= getFailureTimestamp(key);\n\t\t\tif (result == null) \n\t\t\t\treturn 0L; // 0 = \"never failed (that I know about)\"\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\t// TODO (Feb 23, 2009 10:40:23 PM): V\n\tpublic List<Description> findLeaves(Request request) {\n\t\tList<Description> results= new ArrayList<Description>();\n\t\tfindLeaves(request.getRunner().getDescription(), results);\n\t\treturn results;\n\t}\n\t\n\t// TODO (Feb 23, 2009 10:50:48 PM): V\n\tpublic void findLeaves(Description description, List<Description> results) {\n\t\tif (description.getChildren().isEmpty())\n\t\t\tresults.add(description);\n\t\telse\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tfindLeaves(each, results);\n\t}\n\n\tprivate Long getFailureTimestamp(Description key) {\n\t\treturn fFailureTimestamps.get(key.toString());\n\t}\n\n\tprivate void putTestFailureTimestamp(Description key, long end) {\n\t\tfFailureTimestamps.put(key.toString(), end);\n\t}\n\n\tprivate boolean isNewTest(Description key) {\n\t\treturn ! fDurations.containsKey(key.toString());\n\t}\n\t\n\tprivate Long getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}\n\t\n\tprivate void putTestDuration(Description description, long duration) {\n\t\tfDurations.put(description.toString(), duration);\n\t}\n}\n\n","lineNo":153}
{"Smelly Sample":"package org.junit.internal.runners;\n\nimport junit.extensions.TestDecorator;\nimport junit.framework.AssertionFailedError;\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestListener;\nimport junit.framework.TestResult;\nimport junit.framework.TestSuite;\nimport org.junit.runner.Describable;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit38ClassRunner extends Runner implements Filterable, Sortable {\n\tprivate static final class OldTestClassAdaptingListener implements\n\t\t\tTestListener {\n\t\tprivate final RunNotifier fNotifier;\n\n\t\tprivate OldTestClassAdaptingListener(RunNotifier notifier) {\n\t\t\tfNotifier= notifier;\n\t\t}\n\n\t\tpublic void endTest(Test test) {\n\t\t\tfNotifier.fireTestFinished(asDescription(test));\n\t\t}\n\n\t\tpublic void startTest(Test test) {\n\t\t\tfNotifier.fireTestStarted(asDescription(test));\n\t\t}\n\n\t\t// Implement junit.framework.TestListener\n\t\tpublic void addError(Test test, Throwable t) {\n\t\t\tFailure failure= new Failure(asDescription(test), t);\n\t\t\tfNotifier.fireTestFailure(failure);\n\t\t}\n\n\t\tprivate Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(test.getClass(), getName(test));\n\t\t}\n\n\t\tprivate String getName(Test test) {\n\t\t\tif (test instanceof TestCase)\n\t\t\t\treturn ((TestCase) test).getName();\n\t\t\telse\n\t\t\t\treturn test.toString();\n\t\t}\n\n\t\tpublic void addFailure(Test test, AssertionFailedError t) {\n\t\t\taddError(test, t);\n\t\t}\n\t}\n\n\tprivate Test fTest;\n\t\n\tpublic JUnit38ClassRunner(Class<?> klass) {\n\t\tthis(new TestSuite(klass.asSubclass(TestCase.class)));\n\t}\n\n\tpublic JUnit38ClassRunner(Test test) {\n\t\tsuper();\n\t\tsetTest(test);\n\t}\n\n\t@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tTestResult result= new TestResult();\n\t\tresult.addListener(createAdaptingListener(notifier));\n\t\tgetTest().run(result);\n\t}\n\n\tpublic static TestListener createAdaptingListener(final RunNotifier notifier) {\n\t\treturn new OldTestClassAdaptingListener(notifier);\n\t}\n\t\n\t@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(getTest());\n\t}\n\n\tprivate static Description makeDescription(Test test) {\n\t\tif (test instanceof TestCase) {\n\t\t\tTestCase tc= (TestCase) test;\n\t\t\treturn Description.createTestDescription(tc.getClass(), tc.getName());\n\t\t} else if (test instanceof TestSuite) {\n\t\t\tTestSuite ts= (TestSuite) test;\n\t\t\tString name= ts.getName() == null ? createSuiteDescription(ts) : ts.getName();\n\t\t\tDescription description= Description.createSuiteDescription(name);\n\t\t\tint n= ts.testCount();\n\t\t\tfor (int i= 0; i < n; i++)\n\t\t\t\tdescription.addChild(makeDescription(ts.testAt(i)));\n\t\t\treturn description;\n\t\t} else if (test instanceof Describable) {\n\t\t\tDescribable adapter= (Describable) test;\n\t\t\treturn adapter.getDescription();\n\t\t} else if (test instanceof TestDecorator) {\n\t\t\tTestDecorator decorator= (TestDecorator) test;\n\t\t\treturn makeDescription(decorator.getTest());\n\t\t} else {\n\t\t\t// This is the best we can do in this case\n\t\t\treturn Description.createSuiteDescription(test.getClass());\n\t\t}\n\t}\n\n\tprivate static String createSuiteDescription(TestSuite ts) {\n\t\tint count= ts.countTestCases();\n\t\tString example = count == 0 ? \"\" : String.format(\" [example: %s]\", ts.testAt(0));\n\t\treturn String.format(\"TestSuite with %s tests%s\", count, example);\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tif (getTest() instanceof Filterable) {\n\t\t\tFilterable adapter= (Filterable) getTest();\n\t\t\tadapter.filter(filter);\n\t\t} else if (getTest() instanceof TestSuite) {\n\t\t\tTestSuite suite= (TestSuite) getTest();\n\t\t\tTestSuite filtered= new TestSuite(suite.getName());\n\t\t\tint n= suite.testCount();\n\t\t\tfor (int i= 0; i < n; i++) {\n\t\t\t\tTest test= suite.testAt(i);\n\t\t\t\tif (filter.shouldRun(makeDescription(test)))\n\t\t\t\t\tfiltered.addTest(test);\n\t\t\t}\n\t\t\tsetTest(filtered);\n\t\t}\n\t}\n\n\tpublic void sort(Sorter sorter) {\n\t\tif (getTest() instanceof Sortable) {\n\t\t\tSortable adapter= (Sortable) getTest();\n\t\t\tadapter.sort(sorter);\n\t\t}\n\t}\n\n\tprivate void setTest(Test test) {\n\t\tfTest = test;\n\t}\n\n\tprivate Test getTest() {\n\t\treturn fTest;\n\t}\n}\n","Method after Refactoring":"package org.junit.internal.runners;\n\nimport java.util.List;\n\nimport junit.extensions.TestDecorator;\nimport junit.framework.AssertionFailedError;\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestListener;\nimport junit.framework.TestResult;\nimport junit.framework.TestSuite;\nimport org.junit.runner.Describable;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit38ClassRunner extends Runner implements Filterable, Sortable {\n\tprivate final class OldTestClassAdaptingListener implements\n\t\t\tTestListener {\n\t\tprivate final RunNotifier fNotifier;\n\n\t\tprivate OldTestClassAdaptingListener(RunNotifier notifier) {\n\t\t\tfNotifier= notifier;\n\t\t}\n\n\t\tpublic void endTest(Test test) {\n\t\t\tfNotifier.fireTestFinished(asDescription(test));\n\t\t}\n\n\t\tpublic void startTest(Test test) {\n\t\t\tfNotifier.fireTestStarted(asDescription(test));\n\t\t}\n\n\t\t// Implement junit.framework.TestListener\n\t\tpublic void addError(Test test, Throwable t) {\n\t\t\tFailure failure= new Failure(asDescription(test), t);\n\t\t\tfNotifier.fireTestFailure(failure);\n\t\t}\n\n\t\tprivate Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(getEffectiveClass(test), getName(test));\n\t\t}\n\n\t\tprivate Class<? extends Test> getEffectiveClass(Test test) {\n\t\t\t// TODO (Feb 23, 2009 11:45:54 PM): Think hard about this.\n\t\t\tif (\"warning\".equals(getName(test)))\n\t\t\t\ttry {\n\t\t\t\t\treturn (Class<? extends Test>) Class.forName(fTest.toString());\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\treturn test.getClass();\n\t\t\t\t}\n\t\t\treturn test.getClass();\n\t\t}\n\n\t\tprivate String getName(Test test) {\n\t\t\tif (test instanceof TestCase)\n\t\t\t\treturn ((TestCase) test).getName();\n\t\t\telse\n\t\t\t\treturn test.toString();\n\t\t}\n\n\t\tpublic void addFailure(Test test, AssertionFailedError t) {\n\t\t\taddError(test, t);\n\t\t}\n\t}\n\n\tprivate Test fTest;\n\t\n\tpublic JUnit38ClassRunner(Class<?> klass) {\n\t\tthis(new TestSuite(klass.asSubclass(TestCase.class)));\n\t}\n\n\tpublic JUnit38ClassRunner(Test test) {\n\t\tsuper();\n\t\tsetTest(test);\n\t}\n\n\t@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tTestResult result= new TestResult();\n\t\tresult.addListener(createAdaptingListener(notifier));\n\t\tgetTest().run(result);\n\t}\n\n\tpublic TestListener createAdaptingListener(final RunNotifier notifier) {\n\t\treturn new OldTestClassAdaptingListener(notifier);\n\t}\n\t\n\t@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(getTest());\n\t}\n\n\t// TODO (Feb 23, 2009 10:57:14 PM): V\n\tpublic static Description makeDescription(Test test) {\n\t\tif (test instanceof TestCase) {\n\t\t\tTestCase tc= (TestCase) test;\n\t\t\treturn Description.createTestDescription(tc.getClass(), tc.getName());\n\t\t} else if (test instanceof TestSuite) {\n\t\t\tTestSuite ts= (TestSuite) test;\n\t\t\tString name= ts.getName() == null ? createSuiteDescription(ts) : ts.getName();\n\t\t\tDescription description= Description.createSuiteDescription(name);\n\t\t\tint n= ts.testCount();\n\t\t\tfor (int i= 0; i < n; i++) {\n\t\t\t\tDescription made= makeDescription(ts.testAt(i));\n\t\t\t\t// TODO (Feb 23, 2009 11:25:23 PM): this is doing Max's work for it.  Max should get rid of these when sorting i\n\t\t\t\tif (!made.toString().startsWith(\"warning(\"))\t\t\t\n\t\t\t\t\tdescription.addChild(made);\n\t\t\t}\n\t\t\treturn description;\n\t\t} else if (test instanceof Describable) {\n\t\t\tDescribable adapter= (Describable) test;\n\t\t\treturn adapter.getDescription();\n\t\t} else if (test instanceof TestDecorator) {\n\t\t\tTestDecorator decorator= (TestDecorator) test;\n\t\t\treturn makeDescription(decorator.getTest());\n\t\t} else {\n\t\t\t// This is the best we can do in this case\n\t\t\treturn Description.createSuiteDescription(test.getClass());\n\t\t}\n\t}\n\n\tprivate static String createSuiteDescription(TestSuite ts) {\n\t\tint count= ts.countTestCases();\n\t\tString example = count == 0 ? \"\" : String.format(\" [example: %s]\", ts.testAt(0));\n\t\treturn String.format(\"TestSuite with %s tests%s\", count, example);\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tif (getTest() instanceof Filterable) {\n\t\t\tFilterable adapter= (Filterable) getTest();\n\t\t\tadapter.filter(filter);\n\t\t} else if (getTest() instanceof TestSuite) {\n\t\t\tTestSuite suite= (TestSuite) getTest();\n\t\t\tTestSuite filtered= new TestSuite(suite.getName());\n\t\t\tint n= suite.testCount();\n\t\t\tfor (int i= 0; i < n; i++) {\n\t\t\t\tTest test= suite.testAt(i);\n\t\t\t\tif (filter.shouldRun(makeDescription(test)))\n\t\t\t\t\tfiltered.addTest(test);\n\t\t\t}\n\t\t\tsetTest(filtered);\n\t\t}\n\t}\n\n\tpublic void sort(Sorter sorter) {\n\t\tif (getTest() instanceof Sortable) {\n\t\t\tSortable adapter= (Sortable) getTest();\n\t\t\tadapter.sort(sorter);\n\t\t}\n\t}\n\n\tprivate void setTest(Test test) {\n\t\tfTest = test;\n\t}\n\n\t// TODO (Feb 23, 2009 10:57:26 PM): V\n\tpublic Test getTest() {\n\t\treturn fTest;\n\t}\n}\n","lineNo":115}
{"Smelly Sample":"package org.junit.tests;\n\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.Test;\nimport org.junit.experimental.max.CouldNotReadCoreException;\nimport org.junit.experimental.max.MaxCore;\nimport org.junit.internal.RealSystem;\nimport org.junit.internal.TextListener;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\nimport org.junit.runners.Suite.SuiteClasses;\nimport org.junit.tests.assertion.AssertionTest;\nimport org.junit.tests.assertion.BothTest;\nimport org.junit.tests.assertion.EachTest;\nimport org.junit.tests.deprecated.JUnit4ClassRunnerTest;\nimport org.junit.tests.description.AnnotatedDescriptionTest;\nimport org.junit.tests.description.SuiteDescriptionTest;\nimport org.junit.tests.description.TestDescriptionTest;\nimport org.junit.tests.experimental.AssumptionTest;\nimport org.junit.tests.experimental.AssumptionViolatedExceptionTest;\nimport org.junit.tests.experimental.ExperimentalTests;\nimport org.junit.tests.experimental.MatcherTest;\nimport org.junit.tests.experimental.max.MaxStarterTest;\nimport org.junit.tests.experimental.theories.AllMembersSupplierTest;\nimport org.junit.tests.experimental.theories.runner.TheoriesPerformanceTest;\nimport org.junit.tests.junit3compatibility.AllTestsTest;\nimport org.junit.tests.junit3compatibility.ClassRequestTest;\nimport org.junit.tests.junit3compatibility.ForwardCompatibilityTest;\nimport org.junit.tests.junit3compatibility.InitializationErrorForwardCompatibilityTest;\nimport org.junit.tests.junit3compatibility.JUnit38ClassRunnerTest;\nimport org.junit.tests.junit3compatibility.OldTestClassAdaptingListenerTest;\nimport org.junit.tests.junit3compatibility.OldTests;\nimport org.junit.tests.junit3compatibility.SuiteMethodTest;\nimport org.junit.tests.listening.ListenerTest;\nimport org.junit.tests.listening.RunnerTest;\nimport org.junit.tests.listening.TestListenerTest;\nimport org.junit.tests.listening.TextListenerTest;\nimport org.junit.tests.listening.UserStopTest;\nimport org.junit.tests.manipulation.FilterableTest;\nimport org.junit.tests.manipulation.SingleMethodTest;\nimport org.junit.tests.manipulation.SortableTest;\nimport org.junit.tests.running.classes.EnclosedTest;\nimport org.junit.tests.running.classes.IgnoreClassTest;\nimport org.junit.tests.running.classes.ParameterizedTestTest;\nimport org.junit.tests.running.classes.RunWithTest;\nimport org.junit.tests.running.classes.SuiteTest;\nimport org.junit.tests.running.classes.TestClassTest;\nimport org.junit.tests.running.classes.UseSuiteAsASuperclassTest;\nimport org.junit.tests.running.core.CommandLineTest;\nimport org.junit.tests.running.core.JUnitCoreReturnsCorrectExitCodeTest;\nimport org.junit.tests.running.core.SystemExitTest;\nimport org.junit.tests.running.methods.AnnotationTest;\nimport org.junit.tests.running.methods.ExpectedTest;\nimport org.junit.tests.running.methods.InheritedTestTest;\nimport org.junit.tests.running.methods.ParameterizedTestMethodTest;\nimport org.junit.tests.running.methods.TestMethodTest;\nimport org.junit.tests.running.methods.TimeoutTest;\nimport org.junit.tests.validation.BadlyFormedClassesTest;\nimport org.junit.tests.validation.FailedConstructionTest;\nimport org.junit.tests.validation.InaccessibleBaseClassTest;\nimport org.junit.tests.validation.ValidationTest;\n\n// These test files need to be cleaned.  See\n// https://sourceforge.net/pm/task.php?func=detailtask&project_task_id=136507&group_id=15278&group_project_id=51407\n\n@SuppressWarnings(\"deprecation\")\n@RunWith(Suite.class)\n@SuiteClasses({\n\tAssumptionTest.class,\n\tClassRequestTest.class,\n\tListenerTest.class,\n\tFailedConstructionTest.class,\n\tTestDescriptionTest.class,\n\tSuiteDescriptionTest.class,\n\tAllTestsTest.class,\n\tAnnotationTest.class,\n\tAssertionTest.class,\n\tCommandLineTest.class,\n\tExpectedTest.class,\n\tForwardCompatibilityTest.class,\n\tOldTests.class,\n\tParameterizedTestTest.class,\n\tRunWithTest.class,\n\tRunnerTest.class,\n\tSuiteTest.class,\n\tTestListenerTest.class,\n\tTestMethodTest.class,\n\tTextListenerTest.class,\n\tTimeoutTest.class,\n\tEnclosedTest.class,\n\tParameterizedTestMethodTest.class,\n\tInitializationErrorForwardCompatibilityTest.class,\n\tSingleMethodTest.class,\n\tValidationTest.class,\n\tUserStopTest.class,\n\tSortableTest.class,\n\tJUnit38ClassRunnerTest.class,\n\tSystemExitTest.class,\n\tJUnitCoreReturnsCorrectExitCodeTest.class,\n\tInaccessibleBaseClassTest.class,\n\tSuiteMethodTest.class,\n\tBadlyFormedClassesTest.class,\n\tIgnoreClassTest.class,\n\tOldTestClassAdaptingListenerTest.class,\n\tAnnotatedDescriptionTest.class,\n\tBothTest.class,\n\tAssumptionViolatedExceptionTest.class,\n\tEachTest.class,\n\tExperimentalTests.class,\n\tInheritedTestTest.class,\n\tTestClassTest.class,\n\tAllMembersSupplierTest.class,\n\tMatcherTest.class,\n\tObjectContractTest.class,\n\tTheoriesPerformanceTest.class,\n\tJUnit4ClassRunnerTest.class,\n\tUseSuiteAsASuperclassTest.class,\n\tFilterableTest.class,\n\tMaxStarterTest.class\n})\npublic class AllTests {\n\tpublic static Test suite() {\n\t\treturn new JUnit4TestAdapter(AllTests.class);\n\t}\n\tpublic static void main(String[] args) throws CouldNotReadCoreException {\n\t\tMaxCore max= MaxCore.forFolder(\"AllTests\");\n\t\tJUnitCore core= new JUnitCore();\n\t\tcore.addListener(new TextListener(new RealSystem()));\n\t\tmax.run(Request.aClass(AllTests.class), core);\n\t\t// TODO: not always 0\n\t\tSystem.exit(0);\n\t}\n}\n","Method after Refactoring":"package org.junit.tests;\n\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.Test;\nimport org.junit.experimental.max.CouldNotReadCoreException;\nimport org.junit.experimental.max.MaxCore;\nimport org.junit.internal.RealSystem;\nimport org.junit.internal.TextListener;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\nimport org.junit.runners.Suite.SuiteClasses;\nimport org.junit.tests.assertion.AssertionTest;\nimport org.junit.tests.assertion.BothTest;\nimport org.junit.tests.assertion.EachTest;\nimport org.junit.tests.deprecated.JUnit4ClassRunnerTest;\nimport org.junit.tests.description.AnnotatedDescriptionTest;\nimport org.junit.tests.description.SuiteDescriptionTest;\nimport org.junit.tests.description.TestDescriptionTest;\nimport org.junit.tests.experimental.AssumptionTest;\nimport org.junit.tests.experimental.AssumptionViolatedExceptionTest;\nimport org.junit.tests.experimental.ExperimentalTests;\nimport org.junit.tests.experimental.MatcherTest;\nimport org.junit.tests.experimental.max.MaxStarterTest;\nimport org.junit.tests.experimental.theories.AllMembersSupplierTest;\nimport org.junit.tests.experimental.theories.runner.TheoriesPerformanceTest;\nimport org.junit.tests.junit3compatibility.AllTestsTest;\nimport org.junit.tests.junit3compatibility.ClassRequestTest;\nimport org.junit.tests.junit3compatibility.ForwardCompatibilityTest;\nimport org.junit.tests.junit3compatibility.InitializationErrorForwardCompatibilityTest;\nimport org.junit.tests.junit3compatibility.JUnit38ClassRunnerTest;\nimport org.junit.tests.junit3compatibility.OldTestClassAdaptingListenerTest;\nimport org.junit.tests.junit3compatibility.OldTests;\nimport org.junit.tests.junit3compatibility.SuiteMethodTest;\nimport org.junit.tests.listening.ListenerTest;\nimport org.junit.tests.listening.RunnerTest;\nimport org.junit.tests.listening.TestListenerTest;\nimport org.junit.tests.listening.TextListenerTest;\nimport org.junit.tests.listening.UserStopTest;\nimport org.junit.tests.manipulation.FilterableTest;\nimport org.junit.tests.manipulation.SingleMethodTest;\nimport org.junit.tests.manipulation.SortableTest;\nimport org.junit.tests.running.classes.EnclosedTest;\nimport org.junit.tests.running.classes.IgnoreClassTest;\nimport org.junit.tests.running.classes.ParameterizedTestTest;\nimport org.junit.tests.running.classes.RunWithTest;\nimport org.junit.tests.running.classes.SuiteTest;\nimport org.junit.tests.running.classes.TestClassTest;\nimport org.junit.tests.running.classes.UseSuiteAsASuperclassTest;\nimport org.junit.tests.running.core.CommandLineTest;\nimport org.junit.tests.running.core.JUnitCoreReturnsCorrectExitCodeTest;\nimport org.junit.tests.running.core.SystemExitTest;\nimport org.junit.tests.running.methods.AnnotationTest;\nimport org.junit.tests.running.methods.ExpectedTest;\nimport org.junit.tests.running.methods.InheritedTestTest;\nimport org.junit.tests.running.methods.ParameterizedTestMethodTest;\nimport org.junit.tests.running.methods.TestMethodTest;\nimport org.junit.tests.running.methods.TimeoutTest;\nimport org.junit.tests.validation.BadlyFormedClassesTest;\nimport org.junit.tests.validation.FailedConstructionTest;\nimport org.junit.tests.validation.InaccessibleBaseClassTest;\nimport org.junit.tests.validation.ValidationTest;\n\n// These test files need to be cleaned.  See\n// https://sourceforge.net/pm/task.php?func=detailtask&project_task_id=136507&group_id=15278&group_project_id=51407\n\n@SuppressWarnings(\"deprecation\")\n@RunWith(Suite.class)\n@SuiteClasses({\n\tAssumptionTest.class,\n\tClassRequestTest.class,\n\tListenerTest.class,\n\tFailedConstructionTest.class,\n\tTestDescriptionTest.class,\n\tSuiteDescriptionTest.class,\n\tAllTestsTest.class,\n\tAnnotationTest.class,\n\tAssertionTest.class,\n\tCommandLineTest.class,\n\tExpectedTest.class,\n\tForwardCompatibilityTest.class,\n\tOldTests.class,\n\tParameterizedTestTest.class,\n\tRunWithTest.class,\n\tRunnerTest.class,\n\tSuiteTest.class,\n\tTestListenerTest.class,\n\tTestMethodTest.class,\n\tTextListenerTest.class,\n\tTimeoutTest.class,\n\tEnclosedTest.class,\n\tParameterizedTestMethodTest.class,\n\tInitializationErrorForwardCompatibilityTest.class,\n\tSingleMethodTest.class,\n\tValidationTest.class,\n\tUserStopTest.class,\n\tSortableTest.class,\n\tJUnit38ClassRunnerTest.class,\n\tSystemExitTest.class,\n\tJUnitCoreReturnsCorrectExitCodeTest.class,\n\tInaccessibleBaseClassTest.class,\n\tSuiteMethodTest.class,\n\tBadlyFormedClassesTest.class,\n\tIgnoreClassTest.class,\n\tOldTestClassAdaptingListenerTest.class,\n\tAnnotatedDescriptionTest.class,\n\tBothTest.class,\n\tAssumptionViolatedExceptionTest.class,\n\tEachTest.class,\n\tExperimentalTests.class,\n\tInheritedTestTest.class,\n\tTestClassTest.class,\n\tAllMembersSupplierTest.class,\n\tMatcherTest.class,\n\tObjectContractTest.class,\n\tTheoriesPerformanceTest.class,\n\tJUnit4ClassRunnerTest.class,\n\tUseSuiteAsASuperclassTest.class,\n\tFilterableTest.class,\n\tMaxStarterTest.class\n})\npublic class AllTests {\n\tpublic static Test suite() {\n\t\treturn new JUnit4TestAdapter(AllTests.class);\n\t}\n\tpublic static void main(String[] args) throws CouldNotReadCoreException {\n\t\tMaxCore max= MaxCore.forFolder(\"AllTests\");\n\t\tJUnitCore core= new JUnitCore();\n\t\tcore.addListener(new TextListener(new RealSystem()));\n\t\tRequest request= Request.aClass(AllTests.class);\n\t\tmax.run(request, core);\n\t\t// TODO: not always 0\n\t\tSystem.exit(0);\n\t}\n}\n","lineNo":131}
{"Smelly Sample":"package org.junit.internal.runners;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.internal.runners.links.Statement;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class ErrorReportingRunner extends ParentRunner<Throwable> {\n\tprivate final Throwable fCause;\n\n\tpublic ErrorReportingRunner(Class<?> type, Throwable cause) {\n\t\tsuper(type);\n\t\tfCause= cause;\n\t}\n\n\t@Override\n\tprotected Description describeChild(Throwable child) {\n\t\treturn Description.createTestDescription(getTestClass().getJavaClass(), \"initializationError\");\n\t}\n\t\n\t@Override\n\tprotected Statement classBlock(RunNotifier notifier) {\n\t\t// no before or after class\n\t\treturn runChildren(notifier);\n\t}\n\n\t@Override\n\tprotected List<Throwable> getChildren() {\n\t\treturn getCauses(fCause);\n\t}\n\n\t@Override\n\tprotected void runChild(Throwable child, RunNotifier notifier) {\n\t\tnotifier.testAborted(describeChild(child), child);\n\t}\n\t\n\tprivate List<Throwable> getCauses(Throwable cause) {\n\t\tif (cause instanceof InvocationTargetException)\n\t\t\treturn getCauses(cause.getCause());\n\t\tif (cause instanceof InitializationError)\n\t\t\treturn ((InitializationError) cause).getCauses();\n\t\treturn Arrays.asList(cause);\t\n\t}\n}\n","Method after Refactoring":"package org.junit.internal.runners;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.internal.runners.links.Statement;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class ErrorReportingRunner extends ParentRunner<Throwable> {\n\tprivate final Throwable fCause;\n\n\tpublic ErrorReportingRunner(Class<?> type, Throwable cause) {\n\t\tsuper(type);\n\t\tfCause= cause;\n\t}\n\n\t@Override\n\tprotected Description describeChild(Throwable child) {\n\t\treturn Description.createTestDescription(getTestClass().getJavaClass(), \"initializationError\");\n\t}\n\t\n\t@Override\n\tprotected Statement classBlock(RunNotifier notifier) {\n\t\t// no before or after class\n\t\treturn runChildren(notifier);\n\t}\n\n\t@Override\n\tprotected List<Throwable> getChildren() {\n\t\treturn getCauses(fCause);\n\t}\n\n\t@Override\n\tprotected void runChild(Throwable child, RunNotifier notifier) {\n\t\tDescription description= describeChild(child);\n\t\tnotifier.fireTestStarted(description);\n\t\tnotifier.fireTestFailure(new Failure(description, child));\n\t\tnotifier.fireTestFinished(description);\n\t}\n\t\n\tprivate List<Throwable> getCauses(Throwable cause) {\n\t\tif (cause instanceof InvocationTargetException)\n\t\t\treturn getCauses(cause.getCause());\n\t\tif (cause instanceof InitializationError)\n\t\t\treturn ((InitializationError) cause).getCauses();\n\t\treturn Arrays.asList(cause);\t\n\t}\n}\n","lineNo":38}
{"Smelly Sample":"package org.junit.internal;\n\nimport java.io.PrintStream;\nimport java.text.NumberFormat;\nimport java.util.List;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runner.notification.TestRunEvent;\n\npublic class TextListener extends RunListener {\n\n\tprivate final PrintStream fWriter;\n\n\tpublic TextListener(JUnitSystem system) {\n\t\tthis(system.out());\n\t}\n\n\tpublic TextListener(PrintStream writer) {\n\t\tthis.fWriter= writer;\n\t}\n\n\t@Override\n\tpublic void testRunFinished(Result result) {\n\t\tprintHeader(result.getRunTime());\n\t\tprintFailures(result);\n\t\tprintFailedAssumptions(result);\n\t\tprintIgnorances(result);\n\t\tprintFooter(result);\n\t}\n\n\t@Override\n\tpublic void testStarted(Description description) {\n\t\tfWriter.append('.');\n\t}\n\n\t@Override\n\tpublic void testFailure(Failure failure) {\n\t\tfWriter.append('E');\n\t}\n\t\n\t@Override\n\tpublic void testIgnored(Description description) {\n\t\tfWriter.append('I');\n\t}\n\t\n\t/*\n\t * Internal methods\n\t */\n\n\tprivate PrintStream getWriter() {\n\t\treturn fWriter;\n\t}\n\n\tprotected void printHeader(long runTime) {\n\t\tgetWriter().println();\n\t\tgetWriter().println(\"Time: \" + elapsedTimeAsString(runTime));\n\t}\n\n\tprotected void printFailures(Result result) {\n\t\tprintEvents(\"failure\", \"\", result.getFailures());\n\t}\n\t\n\tprivate void printFailedAssumptions(Result result) {\n\t\tprintEvents(\"invalid assumption\", \"INVALID ASSUMPTION \", result.getInvalidAssumptions());\n\t}\n\t\n\tprivate void printIgnorances(Result result) {\n\t\tprintEvents(\"ignored test\", \"IGNORED TEST \", result.getIgnorances());\n\t}\n\n\tprivate void printEvents(String exceptionTypeName, String listPrefix,\n\t\t\tList<? extends TestRunEvent> exceptions) {\n\t\tif (exceptions.size() == 0)\n\t\t\treturn;\n\t\tif (exceptions.size() == 1)\n\t\t\tgetWriter().println(\"There was \" + exceptions.size() + \" \" + exceptionTypeName + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + exceptions.size() + \" \" + exceptionTypeName + \"s:\");\n\t\tint i= 1;\n\t\tfor (TestRunEvent each : exceptions)\n\t\t\tprintFailure(each, listPrefix + i++);\n\t}\n\n\tprotected void printFailure(TestRunEvent each, String prefix) {\n\t\tgetWriter().println(prefix + \") \" + each.getTestHeader());\n\t\tgetWriter().print(each.getTrace());\n\t}\n\n\tprotected void printFooter(Result result) {\n\t\tif (result.wasSuccessful()) {\n\t\t\tgetWriter().println();\n\t\t\tgetWriter().print(\"OK\");\n\t\t\tgetWriter().println(\" (\" + result.getRunCount() + \" test\" + (result.getRunCount() == 1 ? \"\" : \"s\") + \")\");\n\n\t\t} else {\n\t\t\tgetWriter().println();\n\t\t\tgetWriter().println(\"FAILURES!!!\");\n\t\t\tgetWriter().println(\"Tests run: \" + result.getRunCount() + \",  Failures: \" + result.getFailureCount());\n\t\t}\n\t\tgetWriter().println();\n\t}\n\n\t/**\n\t * Returns the formatted string of the elapsed time. Duplicated from\n\t * BaseTestRunner. Fix it.\n\t */\n\tprotected String elapsedTimeAsString(long runTime) {\n\t\treturn NumberFormat.getInstance().format((double) runTime / 1000);\n\t}\n}\n","Method after Refactoring":"package org.junit.internal;\n\nimport java.io.PrintStream;\nimport java.text.NumberFormat;\nimport java.util.List;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\n\npublic class TextListener extends RunListener {\n\n\tprivate final PrintStream fWriter;\n\n\tpublic TextListener(JUnitSystem system) {\n\t\tthis(system.out());\n\t}\n\n\tpublic TextListener(PrintStream writer) {\n\t\tthis.fWriter= writer;\n\t}\n\n\t@Override\n\tpublic void testRunFinished(Result result) {\n\t\tprintHeader(result.getRunTime());\n\t\tprintFailures(result);\n\t\tprintFooter(result);\n\t}\n\n\t@Override\n\tpublic void testStarted(Description description) {\n\t\tfWriter.append('.');\n\t}\n\n\t@Override\n\tpublic void testFailure(Failure failure) {\n\t\tfWriter.append('E');\n\t}\n\n\t@Override\n\tpublic void testIgnored(Description description) {\n\t\tfWriter.append('I');\n\t}\n\n\t/*\n\t * Internal methods\n\t */\n\n\tprivate PrintStream getWriter() {\n\t\treturn fWriter;\n\t}\n\n\tprotected void printHeader(long runTime) {\n\t\tgetWriter().println();\n\t\tgetWriter().println(\"Time: \" + elapsedTimeAsString(runTime));\n\t}\n\n\tprotected void printFailures(Result result) {\n\t\tList<Failure> failures= result.getFailures();\n\t\tif (failures.size() == 0)\n\t\t\treturn;\n\t\tif (failures.size() == 1)\n\t\t\tgetWriter().println(\"There was \" + failures.size() + \" failure:\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + failures.size() + \" failures:\");\n\t\tint i= 1;\n\t\tfor (Failure each : failures)\n\t\t\tprintFailure(each, \"\" + i++);\n\t}\n\n\tprotected void printFailure(Failure each, String prefix) {\n\t\tgetWriter().println(prefix + \") \" + each.getTestHeader());\n\t\tgetWriter().print(each.getTrace());\n\t}\n\n\tprotected void printFooter(Result result) {\n\t\tif (result.wasSuccessful()) {\n\t\t\tgetWriter().println();\n\t\t\tgetWriter().print(\"OK\");\n\t\t\tgetWriter().println(\" (\" + result.getRunCount() + \" test\" + (result.getRunCount() == 1 ? \"\" : \"s\") + \")\");\n\n\t\t} else {\n\t\t\tgetWriter().println();\n\t\t\tgetWriter().println(\"FAILURES!!!\");\n\t\t\tgetWriter().println(\"Tests run: \" + result.getRunCount() + \",  Failures: \" + result.getFailureCount());\n\t\t}\n\t\tgetWriter().println();\n\t}\n\n\t/**\n\t * Returns the formatted string of the elapsed time. Duplicated from\n\t * BaseTestRunner. Fix it.\n\t */\n\tprotected String elapsedTimeAsString(long runTime) {\n\t\treturn NumberFormat.getInstance().format((double) runTime / 1000);\n\t}\n}\n","lineNo":60}
{"Smelly Sample":"package org.junit.runners;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.internal.runners.CompositeRunner;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.runner.Request;\nimport org.junit.runner.Runner;\n\n/**\n * Using <code>Suite<\/code> as a runner allows you to manually\n * build a suite containing tests from many classes. It is the JUnit 4 equivalent of the JUnit 3.8.x\n * static {@link junit.framework.Test} <code>suite()<\/code> method. To use it, annotate a class\n * with <code>@RunWith(Suite.class)<\/code> and <code>@SuiteClasses(TestClass1.class, ...)<\/code>.\n * When you run this class, it will run all the tests in all the suite classes.\n */\npublic class Suite extends CompositeRunner {\n\t/**\n\t * The <code>SuiteClasses<\/code> annotation specifies the classes to be run when a class\n\t * annotated with <code>@RunWith(Suite.class)<\/code> is run.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface SuiteClasses {\n\t\tpublic Class<?>[] value();\n\t}\n\n\t/**\n\t * Internal use only.\n\t */\n\tpublic Suite(Class<?> klass) throws InitializationError {\n\t\tthis(klass, getAnnotatedClasses(klass));\n\t}\n\n\t// This won't work correctly in the face of concurrency. For that we need to\n\t// add parameters to getRunner(), which would be much more complicated.\n\tprivate static Set<Class<?>> parents = new HashSet<Class<?>>();\n\t\n\tprotected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n\t\tsuper(klass, klass.getName());\n\t\t\n\t\taddParent(klass);\n\t\tfor (Class<?> each : annotatedClasses) {\n\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\tif (childRunner != null)\n\t\t\t\tadd(childRunner);\n\t\t}\n\t\tremoveParent(klass);\n\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tgetTestClass().validateStaticMethods(errors);\n\t\tassertValid(errors);\n\t}\n\n\tprivate Class<?> addParent(Class<?> parent) throws InitializationError {\n\t\tif (!parents.add(parent))\n\t\t\tthrow new InitializationError(String.format(\"class '%s' (possibly indirectly) contains itself as a SuiteClass\", parent.getName()));\n\t\treturn parent;\n\t}\n\t\n\tprivate void removeParent(Class<?> klass) {\n\t\tparents.remove(klass);\n\t}\n\n\tprivate static Class<?>[] getAnnotatedClasses(Class<?> klass) throws InitializationError {\n\t\tSuiteClasses annotation= klass.getAnnotation(SuiteClasses.class);\n\t\tif (annotation == null)\n\t\t\tthrow new InitializationError(String.format(\"class '%s' must have a SuiteClasses annotation\", klass.getName()));\n\t\treturn annotation.value();\n\t}\n}\n","Method after Refactoring":"package org.junit.runners;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.internal.runners.CompositeRunner;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.runner.Request;\nimport org.junit.runner.Runner;\n\n/**\n * Using <code>Suite<\/code> as a runner allows you to manually\n * build a suite containing tests from many classes. It is the JUnit 4 equivalent of the JUnit 3.8.x\n * static {@link junit.framework.Test} <code>suite()<\/code> method. To use it, annotate a class\n * with <code>@RunWith(Suite.class)<\/code> and <code>@SuiteClasses(TestClass1.class, ...)<\/code>.\n * When you run this class, it will run all the tests in all the suite classes.\n */\npublic class Suite extends CompositeRunner {\n\t/**\n\t * The <code>SuiteClasses<\/code> annotation specifies the classes to be run when a class\n\t * annotated with <code>@RunWith(Suite.class)<\/code> is run.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface SuiteClasses {\n\t\tpublic Class<?>[] value();\n\t}\n\n\t/**\n\t * Internal use only.\n\t */\n\tpublic Suite(Class<?> klass) throws InitializationError {\n\t\tthis(klass, getAnnotatedClasses(klass));\n\t}\n\n\t// To prevent test writers from hanging themselves, we need to shorten the rope we hand them.\n\t// SuiteBuilder builds a Suite one class at a time, making sure that no Suite contains\n\t// itself as a direct or indirect child.  Since Suites are constructed through\n\t// reflective constructor invocations, we have one static builder that is referenced by all.\n\t// This won't work correctly in the face of concurrency. For that we need to\n\t// add parameters to getRunner(), which would be much more complicated.\n\tpublic static SuiteBuilder builder = new SuiteBuilder();\n\t\n\tprivate static class SuiteBuilder {\n\t\tprivate Set<Class<?>> parents = new HashSet<Class<?>>();\n\n\t\tprivate List<Runner> runners(Class<?> klass, Class<?>[] annotatedClasses)\n\t\t\t\tthrows InitializationError {\n\t\t\tArrayList<Runner> runners= new ArrayList<Runner>();\n\t\t\taddParent(klass);\n\t\t\t\n\t\t\t// TODO: (Dec 10, 2007 1:10:20 PM) Does this duplicate code from ClassesRequest?\n\t\t\ttry {\n\t\t\t\tfor (Class<?> each : annotatedClasses) {\n\t\t\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\t\t\tif (childRunner != null)\n\t\t\t\t\t\trunners.add(childRunner);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tremoveParent(klass);\n\t\t\t}\n\t\t\treturn runners;\n\t\t}\n\n\t\tprivate Class<?> addParent(Class<?> parent) throws InitializationError {\n\t\t\tif (!parents.add(parent))\n\t\t\t\tthrow new InitializationError(String.format(\"class '%s' (possibly indirectly) contains itself as a SuiteClass\", parent.getName()));\n\t\t\treturn parent;\n\t\t}\n\t\t\n\t\tprivate void removeParent(Class<?> klass) {\n\t\t\tparents.remove(klass);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn parents.toString();\n\t\t}\n\t}\n\t\n\tprotected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n\t\tsuper(klass, klass.getName());\n\t\t\n\t\t// TODO: (Dec 10, 2007 1:08:21 PM) pass list of runners directly to superclass constructor\n\n\t\tList<Runner> runners= builder.runners(klass, annotatedClasses);\n\t\tfor (Runner runner : runners)\n\t\t\tadd(runner);\n\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tgetTestClass().validateStaticMethods(errors);\n\t\tassertValid(errors);\n\t}\n\n\tprivate static Class<?>[] getAnnotatedClasses(Class<?> klass) throws InitializationError {\n\t\tSuiteClasses annotation= klass.getAnnotation(SuiteClasses.class);\n\t\tif (annotation == null)\n\t\t\tthrow new InitializationError(String.format(\"class '%s' must have a SuiteClasses annotation\", klass.getName()));\n\t\treturn annotation.value();\n\t}\n}\n","lineNo":92}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assume;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.links.Statement;\nimport org.junit.internal.runners.model.FrameworkMethod;\n\n@SuppressWarnings(\"restriction\")\npublic class Theories extends JUnit4ClassRunner {\n\tpublic Theories(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tField[] fields= getTestClass().getJavaClass().getDeclaredFields();\n\t\t\n\t\tfor (Field each : fields)\n\t\t\tif (each.getAnnotation(DataPoint.class) != null && !Modifier.isStatic(each.getModifiers()))\n\t\t\t\terrors.add(new Error(\"DataPoint field \" + each.getName() + \" must be static\"));\n\t}\n\n\t@Override\n\tprotected List<FrameworkMethod> computeTestMethods() {\n\t\t// TODO: (Jul 20, 2007 2:02:44 PM) Only get methods once, even if they\n\t\t// have both @Test and @Theory\n\n\t\tList<FrameworkMethod> testMethods= super.computeTestMethods();\n\t\ttestMethods.addAll(getTestClass().getAnnotatedMethods(Theory.class));\n\t\treturn testMethods;\n\t}\n\n\t@Override\n\tpublic Statement childBlock(final FrameworkMethod method) {\n\t\treturn new TheoryAnchor(method);\n\t}\n\n\tpublic class TheoryAnchor extends Statement {\n\t\tprivate int successes= 0;\n\n\t\tprivate FrameworkMethod fTestMethod;\n\n\t\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\t\tpublic TheoryAnchor(FrameworkMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}\n\n\t\t@Override\n\t\tpublic void evaluate() throws Throwable {\n\t\t\trunWithAssignment(Assignments.allUnassigned(\n\t\t\t\t\tfTestMethod.getMethod(), getTestClass().getJavaClass()));\n\n\t\t\tif (successes == 0)\n\t\t\t\tAssume\n\t\t\t\t\t\t.fail(\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters);\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment)\n\t\t\t\tthrows Throwable {\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tfor (PotentialAssignment source : incomplete\n\t\t\t\t\t.potentialsForNextUnassigned()) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source));\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(final Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\tnew JUnit4ClassRunner(getTestClass().getJavaClass()) {\n\t\t\t\t@Override\n\t\t\t\tprotected void collectInitializationErrors(\n\t\t\t\t\t\tList<Throwable> errors) {\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Statement childBlock(FrameworkMethod method) {\n\t\t\t\t\tfinal Statement statement= super.childBlock(method);\n\t\t\t\t\treturn new Statement() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstatement.evaluate();\n\t\t\t\t\t\t\t\thandleDataPointSuccess();\n\t\t\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\t\t\thandleAssumptionViolation(e);\n\t\t\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t\t\treportParameterizedError(e, complete\n\t\t\t\t\t\t\t\t\t\t.getAllArguments(nullsOk()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected Statement invoke(FrameworkMethod method, Object test) {\n\t\t\t\t\treturn methodCompletesWithParameters(method, complete, test);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object createTest() throws Exception {\n\t\t\t\t\treturn getTestClass().getConstructor().newInstance(\n\t\t\t\t\t\t\tcomplete.getConstructorArguments(nullsOk()));\n\t\t\t\t}\n\t\t\t}.childBlock(fTestMethod).evaluate();\n\t\t}\n\n\t\tprivate Statement methodCompletesWithParameters(\n\t\t\t\tfinal FrameworkMethod method, final Assignments complete, final Object freshInstance) {\n\t\t\treturn new Statement() {\n\t\t\t\t@Override\n\t\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfinal Object[] values= complete.getMethodArguments(\n\t\t\t\t\t\t\t\tnullsOk());\n\t\t\t\t\t\tmethod.invokeExplosively(freshInstance, values);\n\t\t\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getName(),\n\t\t\t\t\tparams);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\n\t\tprotected void handleDataPointSuccess() {\n\t\t\tsuccesses++;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assume;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.links.Statement;\nimport org.junit.internal.runners.model.FrameworkMethod;\n\n@SuppressWarnings(\"restriction\")\npublic class Theories extends JUnit4ClassRunner {\n\tpublic Theories(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tField[] fields= getTestClass().getJavaClass().getDeclaredFields();\n\t\t\n\t\tfor (Field each : fields)\n\t\t\tif (each.getAnnotation(DataPoint.class) != null && !Modifier.isStatic(each.getModifiers()))\n\t\t\t\terrors.add(new Error(\"DataPoint field \" + each.getName() + \" must be static\"));\n\t}\n\n\t@Override\n\tprotected List<FrameworkMethod> computeTestMethods() {\n\t\t// TODO: (Jul 20, 2007 2:02:44 PM) Only get methods once, even if they\n\t\t// have both @Test and @Theory\n\n\t\tList<FrameworkMethod> testMethods= super.computeTestMethods();\n\t\tList<FrameworkMethod> theoryMethods= getTestClass().getAnnotatedMethods(Theory.class);\n\t\ttestMethods.removeAll(theoryMethods);\n\t\ttestMethods.addAll(theoryMethods);\n\t\treturn testMethods;\n\t}\n\n\t@Override\n\tpublic Statement childBlock(final FrameworkMethod method) {\n\t\treturn new TheoryAnchor(method);\n\t}\n\n\tpublic class TheoryAnchor extends Statement {\n\t\tprivate int successes= 0;\n\n\t\tprivate FrameworkMethod fTestMethod;\n\n\t\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\t\tpublic TheoryAnchor(FrameworkMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}\n\n\t\t@Override\n\t\tpublic void evaluate() throws Throwable {\n\t\t\trunWithAssignment(Assignments.allUnassigned(\n\t\t\t\t\tfTestMethod.getMethod(), getTestClass().getJavaClass()));\n\n\t\t\tif (successes == 0)\n\t\t\t\tAssume\n\t\t\t\t\t\t.fail(\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters);\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment)\n\t\t\t\tthrows Throwable {\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tfor (PotentialAssignment source : incomplete\n\t\t\t\t\t.potentialsForNextUnassigned()) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source));\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(final Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\tnew JUnit4ClassRunner(getTestClass().getJavaClass()) {\n\t\t\t\t@Override\n\t\t\t\tprotected void collectInitializationErrors(\n\t\t\t\t\t\tList<Throwable> errors) {\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Statement childBlock(FrameworkMethod method) {\n\t\t\t\t\tfinal Statement statement= super.childBlock(method);\n\t\t\t\t\treturn new Statement() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstatement.evaluate();\n\t\t\t\t\t\t\t\thandleDataPointSuccess();\n\t\t\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\t\t\thandleAssumptionViolation(e);\n\t\t\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t\t\treportParameterizedError(e, complete\n\t\t\t\t\t\t\t\t\t\t.getAllArguments(nullsOk()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected Statement invoke(FrameworkMethod method, Object test) {\n\t\t\t\t\treturn methodCompletesWithParameters(method, complete, test);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object createTest() throws Exception {\n\t\t\t\t\treturn getTestClass().getConstructor().newInstance(\n\t\t\t\t\t\t\tcomplete.getConstructorArguments(nullsOk()));\n\t\t\t\t}\n\t\t\t}.childBlock(fTestMethod).evaluate();\n\t\t}\n\n\t\tprivate Statement methodCompletesWithParameters(\n\t\t\t\tfinal FrameworkMethod method, final Assignments complete, final Object freshInstance) {\n\t\t\treturn new Statement() {\n\t\t\t\t@Override\n\t\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfinal Object[] values= complete.getMethodArguments(\n\t\t\t\t\t\t\t\tnullsOk());\n\t\t\t\t\t\tmethod.invokeExplosively(freshInstance, values);\n\t\t\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getName(),\n\t\t\t\t\tparams);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\n\t\tprotected void handleDataPointSuccess() {\n\t\t\tsuccesses++;\n\t\t}\n\t}\n}\n","lineNo":43}
{"Smelly Sample":"package org.junit.internal.runners;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.internal.runners.links.ExpectException;\nimport org.junit.internal.runners.links.Fail;\nimport org.junit.internal.runners.links.FailOnTimeout;\nimport org.junit.internal.runners.links.IgnoreTestNotifier;\nimport org.junit.internal.runners.links.IgnoreViolatedAssumptions;\nimport org.junit.internal.runners.links.InvokeMethod;\nimport org.junit.internal.runners.links.Notifier;\nimport org.junit.internal.runners.links.RunAfters;\nimport org.junit.internal.runners.links.RunBefores;\nimport org.junit.internal.runners.links.RunTestNotifier;\nimport org.junit.internal.runners.links.Statement;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.model.InitializationError;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.model.TestMethod;\nimport org.junit.runner.Description;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit4ClassRunner extends ParentRunner<TestMethod> implements Filterable, Sortable {\n\tprotected final List<TestMethod> fTestMethods;\n\n\tpublic JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t\tfTestMethods= computeTestMethods();\n\t\tvalidate();\n\t}\n\n\tprotected List<TestMethod> computeTestMethods() {\n\t\treturn fTestClass.getTestMethods();\n\t}\n\n\tprivate void validate() throws InitializationError {\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tcollectInitializationErrors(errors);\n\t\tassertValid(errors);\n\t}\n\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tfTestClass.validateMethodsForDefaultRunner(errors);\n\t}\n\n\t@Override\n\tprotected Statement classBlock(final RunNotifier notifier) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() {\n\t\t\t\tfor (TestMethod method : getChildren())\n\t\t\t\t\trunChild(method, notifier);\n\t\t\t}\n\t\t};\n\t}\n\n\tprotected void runChild(TestMethod method, RunNotifier notifier) {\n\t\tDescription description= describeChild(method);\n\t\tEachTestNotifier eachNotifier= new EachTestNotifier(notifier,\n\t\t\t\tdescription);\n\t\tnotifying(method, childBlock(method)).run(eachNotifier);\n\t}\n\n\tpublic Object createTest() throws Exception {\n\t\treturn fTestClass.getConstructor().newInstance();\n\t}\n\n\t@Override\n\tprotected Description describeChild(TestMethod method) {\n\t\treturn Description.createTestDescription(fTestClass.getJavaClass(),\n\t\t\t\ttestName(method), method.getMethod().getAnnotations());\n\t}\n\n\tprotected String testName(TestMethod method) {\n\t\treturn method.getName();\n\t}\n\n\tpublic Statement childBlock(TestMethod method) {\n\t\tObject test;\n\t\ttry {\n\t\t\t// TODO: (Oct 12, 2007 11:49:18 AM) Can I ditch reflective callable?\n\n\t\t\ttest= new ReflectiveCallable() {\n\t\t\t\t@Override\n\t\t\t\tprotected Object runReflectiveCall() throws Throwable {\n\t\t\t\t\treturn createTest();\n\t\t\t\t}\n\t\t\t}.run();\n\t\t} catch (Throwable e) {\n\t\t\treturn new Fail(e);\n\t\t}\n\n\t\tStatement link= invoke(method, test);\n\t\tlink= possiblyExpectingExceptions(method, link);\n\t\tlink= withPotentialTimeout(method, link);\n\t\tlink= withBefores(method, test, link);\n\t\tlink= ignoreViolatedAssumptions(link);\n\t\tlink= withAfters(method, test, link);\n\t\treturn link;\n\t}\n\n\tprotected Statement invoke(TestMethod method, Object test) {\n\t\treturn new InvokeMethod(method, test);\n\t}\n\n\tprotected Statement ignoreViolatedAssumptions(Statement next) {\n\t\treturn new IgnoreViolatedAssumptions(next);\n\t}\n\n\tprotected Statement possiblyExpectingExceptions(TestMethod method,\n\t\t\tStatement next) {\n\t\treturn method.expectsException() ? new ExpectException(next, method\n\t\t\t\t.getExpectedException()) : next;\n\t}\n\n\tprotected Statement withPotentialTimeout(TestMethod method, Statement next) {\n\t\tlong timeout= method.getTimeout();\n\t\treturn timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n\t}\n\n\tprotected Statement withAfters(TestMethod method, Object target,\n\t\t\tStatement link) {\n\t\t// TODO: (Oct 12, 2007 10:23:59 AM) Check for DUP in callers\n\n\t\treturn new RunAfters(link, method, target);\n\t}\n\n\tprotected Statement withBefores(TestMethod method, Object target,\n\t\t\tStatement link) {\n\t\treturn new RunBefores(link, method, target);\n\t}\n\n\tprotected Notifier notifying(TestMethod method, Statement link) {\n\t\treturn method.isIgnored() ? new IgnoreTestNotifier()\n\t\t\t\t: new RunTestNotifier(link);\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tfor (Iterator<TestMethod> iter= fTestMethods.iterator(); iter.hasNext();) {\n\t\t\tTestMethod method= iter.next();\n\t\t\tif (!filter.shouldRun(describeChild(method)))\n\t\t\t\titer.remove();\n\t\t}\n\t\tif (fTestMethods.isEmpty())\n\t\t\tthrow new NoTestsRemainException();\n\t}\n\n\tpublic void sort(final Sorter sorter) {\n\t\tCollections.sort(fTestMethods, new Comparator<TestMethod>() {\n\t\t\tpublic int compare(TestMethod o1, TestMethod o2) {\n\t\t\t\treturn sorter.compare(describeChild(o1),\n\t\t\t\t\t\tdescribeChild(o2));\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tprotected List<TestMethod> getChildren() {\n\t\treturn fTestMethods;\n\t}\n}\n","Method after Refactoring":"package org.junit.internal.runners;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.internal.runners.links.ExpectException;\nimport org.junit.internal.runners.links.Fail;\nimport org.junit.internal.runners.links.FailOnTimeout;\nimport org.junit.internal.runners.links.IgnoreTestNotifier;\nimport org.junit.internal.runners.links.IgnoreViolatedAssumptions;\nimport org.junit.internal.runners.links.InvokeMethod;\nimport org.junit.internal.runners.links.Notifier;\nimport org.junit.internal.runners.links.RunAfters;\nimport org.junit.internal.runners.links.RunBefores;\nimport org.junit.internal.runners.links.RunTestNotifier;\nimport org.junit.internal.runners.links.Statement;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.model.InitializationError;\nimport org.junit.internal.runners.model.ReflectiveCallable;\nimport org.junit.internal.runners.model.TestAnnotation;\nimport org.junit.internal.runners.model.FrameworkMethod;\nimport org.junit.runner.Description;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit4ClassRunner extends ParentRunner<FrameworkMethod> implements Filterable, Sortable {\n\tprotected final List<FrameworkMethod> fTestMethods;\n\n\tpublic JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t\tfTestMethods= computeTestMethods();\n\t\tvalidate();\n\t}\n\n\tprotected List<FrameworkMethod> computeTestMethods() {\n\t\treturn fTestClass.getTestMethods();\n\t}\n\n\tprivate void validate() throws InitializationError {\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tcollectInitializationErrors(errors);\n\t\tassertValid(errors);\n\t}\n\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tfTestClass.validateMethodsForDefaultRunner(errors);\n\t}\n\n\t@Override\n\tprotected Statement classBlock(final RunNotifier notifier) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() {\n\t\t\t\tfor (FrameworkMethod method : getChildren())\n\t\t\t\t\trunChild(method, notifier);\n\t\t\t}\n\t\t};\n\t}\n\n\tprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tDescription description= describeChild(method);\n\t\tEachTestNotifier eachNotifier= new EachTestNotifier(notifier,\n\t\t\t\tdescription);\n\t\tnotifying(method, childBlock(method)).run(eachNotifier);\n\t}\n\n\tpublic Object createTest() throws Exception {\n\t\treturn fTestClass.getConstructor().newInstance();\n\t}\n\n\t@Override\n\tprotected Description describeChild(FrameworkMethod method) {\n\t\treturn Description.createTestDescription(fTestClass.getJavaClass(),\n\t\t\t\ttestName(method), method.getMethod().getAnnotations());\n\t}\n\n\tprotected String testName(FrameworkMethod method) {\n\t\treturn method.getName();\n\t}\n\n\tpublic Statement childBlock(FrameworkMethod method) {\n\t\tObject test;\n\t\ttry {\n\t\t\t// TODO: (Oct 12, 2007 11:49:18 AM) Can I ditch reflective callable?\n\n\t\t\ttest= new ReflectiveCallable() {\n\t\t\t\t@Override\n\t\t\t\tprotected Object runReflectiveCall() throws Throwable {\n\t\t\t\t\treturn createTest();\n\t\t\t\t}\n\t\t\t}.run();\n\t\t} catch (Throwable e) {\n\t\t\treturn new Fail(e);\n\t\t}\n\n\t\tTestAnnotation annotation= new TestAnnotation(method);\n\t\t\n\t\tStatement link= invoke(method, test);\n\t\tlink= possiblyExpectingExceptions(annotation, link);\n\t\tlink= withPotentialTimeout(annotation, link);\n\t\tlink= withBefores(method, test, link);\n\t\tlink= ignoreViolatedAssumptions(link);\n\t\tlink= withAfters(method, test, link);\n\t\treturn link;\n\t}\n\n\tprotected Statement invoke(FrameworkMethod method, Object test) {\n\t\treturn new InvokeMethod(method, test);\n\t}\n\n\tprotected Statement ignoreViolatedAssumptions(Statement next) {\n\t\treturn new IgnoreViolatedAssumptions(next);\n\t}\n\n\tprivate Statement possiblyExpectingExceptions(TestAnnotation annotation,\n\t\t\tStatement next) {\n\t\treturn annotation.expectsException() ? new ExpectException(next, annotation\n\t\t\t\t.getExpectedException()) : next;\n\t}\n\n\tprotected Statement withPotentialTimeout(TestAnnotation annotation,\n\t\t\tStatement next) {\n\t\tlong timeout= annotation.getTimeout();\n\t\treturn timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n\t}\n\n\tprotected Statement withAfters(FrameworkMethod method, Object target,\n\t\t\tStatement link) {\n\t\t// TODO: (Oct 12, 2007 10:23:59 AM) Check for DUP in callers\n\n\t\treturn new RunAfters(link, new TestMethodElement(getTestClass()), target);\n\t}\n\n\tprotected Statement withBefores(FrameworkMethod method, Object target,\n\t\t\tStatement link) {\n\t\treturn new RunBefores(link, new TestMethodElement(getTestClass()), target);\n\t}\n\n\tprotected Notifier notifying(FrameworkMethod method, Statement link) {\n\t\treturn method.isIgnored() ? new IgnoreTestNotifier()\n\t\t\t\t: new RunTestNotifier(link);\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tfor (Iterator<FrameworkMethod> iter= fTestMethods.iterator(); iter.hasNext();) {\n\t\t\tFrameworkMethod method= iter.next();\n\t\t\tif (!filter.shouldRun(describeChild(method)))\n\t\t\t\titer.remove();\n\t\t}\n\t\tif (fTestMethods.isEmpty())\n\t\t\tthrow new NoTestsRemainException();\n\t}\n\n\tpublic void sort(final Sorter sorter) {\n\t\tCollections.sort(fTestMethods, new Comparator<FrameworkMethod>() {\n\t\t\tpublic int compare(FrameworkMethod o1, FrameworkMethod o2) {\n\t\t\t\treturn sorter.compare(describeChild(o1),\n\t\t\t\t\t\tdescribeChild(o2));\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tprotected List<FrameworkMethod> getChildren() {\n\t\treturn fTestMethods;\n\t}\n}\n","lineNo":103}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.ParametersSuppliedBy;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\n\npublic class Assignments {\n\tprivate List<PotentialAssignment> fAssigned;\n\n\tprivate final List<ParameterSignature> fUnassigned;\n\n\tprivate final Class<?> fClass;\n\n\tpublic Assignments(List<PotentialAssignment> assigned,\n\t\t\tList<ParameterSignature> unassigned, Class<?> type) {\n\t\tfUnassigned= unassigned;\n\t\tfAssigned= assigned;\n\t\tfClass= type;\n\t}\n\n\t// TODO: (Oct 12, 2007 10:27:59 AM) Do I need testClass?\n\n\tpublic static Assignments allUnassigned(Method testMethod,\n\t\t\tClass<?> testClass) {\n\t\tArrayList<ParameterSignature> signatures= ParameterSignature.signatures(testMethod);\n\t\tsignatures.addAll(ParameterSignature.signatures(testClass.getConstructors()[0]));\n\t\treturn new Assignments(new ArrayList<PotentialAssignment>(),\n\t\t\t\tsignatures, testClass);\n\t}\n\n\tpublic boolean isComplete() {\n\t\treturn fUnassigned.size() == 0;\n\t}\n\n\tpublic ParameterSignature nextUnassigned() {\n\t\treturn fUnassigned.get(0);\n\t}\n\n\tpublic Assignments assignNext(PotentialAssignment source) {\n\t\tList<PotentialAssignment> assigned= new ArrayList<PotentialAssignment>(\n\t\t\t\tfAssigned);\n\t\tassigned.add(source);\n\t\treturn new Assignments(assigned, fUnassigned.subList(1, fUnassigned\n\t\t\t\t.size()), fClass);\n\t}\n\n\tpublic Object[] getActualValues(boolean nullsOk, int start, int stop) throws CouldNotGenerateValueException {\n\t\tObject[] values= new Object[stop - start];\n\t\tfor (int i= start; i < stop; i++) {\n\t\t\tvalues[i]= fAssigned.get(i).getValue();\n\t\t\tif (values[i] == null && !nullsOk)\n\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t}\n\t\treturn values;\n\t}\n\n\tpublic List<PotentialAssignment> potentialsForNextUnassigned()\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSignature unassigned= nextUnassigned();\n\t\treturn getSupplier(unassigned).getValueSources(unassigned);\n\t}\n\n\tpublic ParameterSupplier getSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSupplier supplier= getAnnotatedSupplier(unassigned);\n\t\tif (supplier != null)\n\t\t\treturn supplier;\n\n\t\treturn new AllMembersSupplier(fClass);\n\t}\n\n\tpublic ParameterSupplier getAnnotatedSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParametersSuppliedBy annotation= unassigned\n\t\t\t\t.findDeepAnnotation(ParametersSuppliedBy.class);\n\t\tif (annotation == null)\n\t\t\treturn null;\n\t\treturn annotation.value().newInstance();\n\t}\n\n\tpublic Object[] getConstructorArguments(boolean nullsOk) throws CouldNotGenerateValueException {\n\t\t// TODO: (Oct 12, 2007 12:23:10 PM) pass-through\n\t\treturn getActualValues(nullsOk, 0, getOnlyConstructor()\n\t\t\t\t.getParameterTypes().length);\n\t}\n\n\tprivate Constructor<?> getOnlyConstructor() {\n\t\ttry {\n\t\t\treturn fClass.getConstructors()[0];\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic Object[] getMethodArguments(boolean nullsOk, Object target) throws CouldNotGenerateValueException {\n\t\t// TODO: (Oct 12, 2007 12:29:57 PM) DUP\n\n\t\treturn getActualValues(nullsOk, getOnlyConstructor()\n\t\t\t\t.getParameterTypes().length, fAssigned.size());\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.ParametersSuppliedBy;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\n\npublic class Assignments {\n\tprivate List<PotentialAssignment> fAssigned;\n\n\tprivate final List<ParameterSignature> fUnassigned;\n\n\tprivate final Class<?> fClass;\n\n\tpublic Assignments(List<PotentialAssignment> assigned,\n\t\t\tList<ParameterSignature> unassigned, Class<?> type) {\n\t\tfUnassigned= unassigned;\n\t\tfAssigned= assigned;\n\t\tfClass= type;\n\t}\n\n\t// TODO: (Oct 12, 2007 10:27:59 AM) Do I need testClass?\n\n\tpublic static Assignments allUnassigned(Method testMethod,\n\t\t\tClass<?> testClass) {\n\t\tList<ParameterSignature> signatures= ParameterSignature.signatures(testClass.getConstructors()[0]);\n\t\tsignatures.addAll(ParameterSignature.signatures(testMethod));\n\t\treturn new Assignments(new ArrayList<PotentialAssignment>(),\n\t\t\t\tsignatures, testClass);\n\t}\n\n\tpublic boolean isComplete() {\n\t\treturn fUnassigned.size() == 0;\n\t}\n\n\tpublic ParameterSignature nextUnassigned() {\n\t\treturn fUnassigned.get(0);\n\t}\n\n\tpublic Assignments assignNext(PotentialAssignment source) {\n\t\tList<PotentialAssignment> assigned= new ArrayList<PotentialAssignment>(\n\t\t\t\tfAssigned);\n\t\tassigned.add(source);\n\t\treturn new Assignments(assigned, fUnassigned.subList(1, fUnassigned\n\t\t\t\t.size()), fClass);\n\t}\n\n\tpublic Object[] getActualValues(boolean nullsOk, int start, int stop) throws CouldNotGenerateValueException {\n\t\tObject[] values= new Object[stop - start];\n\t\tfor (int i= start; i < stop; i++) {\n\t\t\tObject value= fAssigned.get(i).getValue();\n\t\t\tif (value == null && !nullsOk)\n\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t\tvalues[i - start]= value;\n\t\t}\n\t\treturn values;\n\t}\n\n\tpublic List<PotentialAssignment> potentialsForNextUnassigned()\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSignature unassigned= nextUnassigned();\n\t\treturn getSupplier(unassigned).getValueSources(unassigned);\n\t}\n\n\tpublic ParameterSupplier getSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSupplier supplier= getAnnotatedSupplier(unassigned);\n\t\tif (supplier != null)\n\t\t\treturn supplier;\n\n\t\treturn new AllMembersSupplier(fClass);\n\t}\n\n\tpublic ParameterSupplier getAnnotatedSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParametersSuppliedBy annotation= unassigned\n\t\t\t\t.findDeepAnnotation(ParametersSuppliedBy.class);\n\t\tif (annotation == null)\n\t\t\treturn null;\n\t\treturn annotation.value().newInstance();\n\t}\n\n\tpublic Object[] getConstructorArguments(boolean nullsOk) throws CouldNotGenerateValueException {\n\t\t// TODO: (Oct 12, 2007 12:23:10 PM) pass-through\n\t\treturn getActualValues(nullsOk, 0, getOnlyConstructor()\n\t\t\t\t.getParameterTypes().length);\n\t}\n\n\tprivate Constructor<?> getOnlyConstructor() {\n\t\ttry {\n\t\t\treturn fClass.getConstructors()[0];\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic Object[] getMethodArguments(boolean nullsOk, Object target) throws CouldNotGenerateValueException {\n\t\t// TODO: (Oct 12, 2007 12:29:57 PM) DUP\n\n\t\treturn getActualValues(nullsOk, getOnlyConstructor()\n\t\t\t\t.getParameterTypes().length, fAssigned.size());\n\t}\n\n\tpublic Object[] getAllArguments(boolean nullsOk) throws CouldNotGenerateValueException {\n\t\treturn getActualValues(nullsOk, 0, fAssigned.size());\n\t}\n}\n","lineNo":60}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.ParametersSuppliedBy;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\n\npublic class Assignments {\n\tprivate List<PotentialAssignment> fAssigned;\n\n\tprivate final List<ParameterSignature> fUnassigned;\n\n\tprivate final Class<?> fClass;\n\n\tpublic Assignments(List<PotentialAssignment> assigned,\n\t\t\tList<ParameterSignature> unassigned, Class<?> type) {\n\t\tfUnassigned= unassigned;\n\t\tfAssigned= assigned;\n\t\tfClass= type;\n\t}\n\n\t// TODO: (Oct 12, 2007 10:27:59 AM) Do I need testClass?\n\n\t\n\tpublic static Assignments allUnassigned(Method testMethod,\n\t\t\tClass<?> testClass) {\n\t\treturn new Assignments(new ArrayList<PotentialAssignment>(),\n\t\t\t\tParameterSignature.signatures(testMethod), testClass);\n\t}\n\n\tpublic boolean isComplete() {\n\t\treturn fUnassigned.size() == 0;\n\t}\n\n\tpublic ParameterSignature nextUnassigned() {\n\t\treturn fUnassigned.get(0);\n\t}\n\n\tpublic Assignments assignNext(PotentialAssignment source) {\n\t\tList<PotentialAssignment> assigned= new ArrayList<PotentialAssignment>(\n\t\t\t\tfAssigned);\n\t\tassigned.add(source);\n\t\treturn new Assignments(assigned, fUnassigned.subList(1, fUnassigned\n\t\t\t\t.size()), fClass);\n\t}\n\n\tpublic Object[] getActualValues(boolean nullsOk, Object target)\n\t\t\tthrows CouldNotGenerateValueException {\n\t\tObject[] values= new Object[fAssigned.size()];\n\t\tfor (int i= 0; i < values.length; i++) {\n\t\t\tvalues[i]= fAssigned.get(i).getValue(target);\n\t\t\tif (values[i] == null && !nullsOk)\n\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t}\n\t\treturn values;\n\t}\n\n\tpublic List<PotentialAssignment> potentialsForNextUnassigned()\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSignature unassigned= nextUnassigned();\n\t\treturn getSupplier(unassigned).getValueSources(unassigned);\n\t}\n\n\tpublic ParameterSupplier getSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSupplier supplier= getAnnotatedSupplier(unassigned);\n\t\tif (supplier != null)\n\t\t\treturn supplier;\n\n\t\treturn new AllMembersSupplier(fClass);\n\t}\n\n\tpublic ParameterSupplier getAnnotatedSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParametersSuppliedBy annotation= unassigned\n\t\t\t\t.findDeepAnnotation(ParametersSuppliedBy.class);\n\t\tif (annotation == null)\n\t\t\treturn null;\n\t\treturn annotation.value().newInstance();\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.ParametersSuppliedBy;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\n\npublic class Assignments {\n\tprivate List<PotentialAssignment> fAssigned;\n\n\tprivate final List<ParameterSignature> fUnassigned;\n\n\tprivate final Class<?> fClass;\n\n\tpublic Assignments(List<PotentialAssignment> assigned,\n\t\t\tList<ParameterSignature> unassigned, Class<?> type) {\n\t\tfUnassigned= unassigned;\n\t\tfAssigned= assigned;\n\t\tfClass= type;\n\t}\n\n\t// TODO: (Oct 12, 2007 10:27:59 AM) Do I need testClass?\n\n\tpublic static Assignments allUnassigned(Method testMethod,\n\t\t\tClass<?> testClass) {\n\t\tArrayList<ParameterSignature> signatures= ParameterSignature.signatures(testMethod);\n\t\tsignatures.addAll(ParameterSignature.signatures(testClass.getConstructors()[0]));\n\t\treturn new Assignments(new ArrayList<PotentialAssignment>(),\n\t\t\t\tsignatures, testClass);\n\t}\n\n\tpublic boolean isComplete() {\n\t\treturn fUnassigned.size() == 0;\n\t}\n\n\tpublic ParameterSignature nextUnassigned() {\n\t\treturn fUnassigned.get(0);\n\t}\n\n\tpublic Assignments assignNext(PotentialAssignment source) {\n\t\tList<PotentialAssignment> assigned= new ArrayList<PotentialAssignment>(\n\t\t\t\tfAssigned);\n\t\tassigned.add(source);\n\t\treturn new Assignments(assigned, fUnassigned.subList(1, fUnassigned\n\t\t\t\t.size()), fClass);\n\t}\n\n\tpublic Object[] getActualValues(boolean nullsOk, int start, int stop) throws CouldNotGenerateValueException {\n\t\tObject[] values= new Object[stop - start];\n\t\tfor (int i= start; i < stop; i++) {\n\t\t\tvalues[i]= fAssigned.get(i).getValue();\n\t\t\tif (values[i] == null && !nullsOk)\n\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t}\n\t\treturn values;\n\t}\n\n\tpublic List<PotentialAssignment> potentialsForNextUnassigned()\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSignature unassigned= nextUnassigned();\n\t\treturn getSupplier(unassigned).getValueSources(unassigned);\n\t}\n\n\tpublic ParameterSupplier getSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSupplier supplier= getAnnotatedSupplier(unassigned);\n\t\tif (supplier != null)\n\t\t\treturn supplier;\n\n\t\treturn new AllMembersSupplier(fClass);\n\t}\n\n\tpublic ParameterSupplier getAnnotatedSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParametersSuppliedBy annotation= unassigned\n\t\t\t\t.findDeepAnnotation(ParametersSuppliedBy.class);\n\t\tif (annotation == null)\n\t\t\treturn null;\n\t\treturn annotation.value().newInstance();\n\t}\n\n\tpublic Object[] getConstructorArguments(boolean nullsOk) throws CouldNotGenerateValueException {\n\t\t// TODO: (Oct 12, 2007 12:23:10 PM) pass-through\n\t\treturn getActualValues(nullsOk, 0, getOnlyConstructor()\n\t\t\t\t.getParameterTypes().length);\n\t}\n\n\tprivate Constructor<?> getOnlyConstructor() {\n\t\ttry {\n\t\t\treturn fClass.getConstructors()[0];\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic Object[] getMethodArguments(boolean nullsOk, Object target) throws CouldNotGenerateValueException {\n\t\t// TODO: (Oct 12, 2007 12:29:57 PM) DUP\n\n\t\treturn getActualValues(nullsOk, getOnlyConstructor()\n\t\t\t\t.getParameterTypes().length, fAssigned.size());\n\t}\n}\n","lineNo":35}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\npublic class ParameterSignature {\n\tpublic static ArrayList<ParameterSignature> signatures(Method method) {\n\t\tArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();\n\t\tfor (int i= 0; i < method.getParameterTypes().length; i++) {\n\t\t\tsigs.add(new ParameterSignature(method.getParameterTypes()[i],\n\t\t\t\t\tmethod.getParameterAnnotations()[i]));\n\t\t}\n\t\treturn sigs;\n\t}\n\n\tfinal Class<?> type;\n\n\tprivate final Annotation[] annotations;\n\n\tprivate ParameterSignature(Class<?> type, Annotation[] annotations) {\n\t\tthis.type= type;\n\t\tthis.annotations= annotations;\n\t}\n\n\tpublic boolean canAcceptType(Class<?> candidate) {\n\t\treturn type.isAssignableFrom(candidate);\n\t}\n\n\tpublic Class<?> getType() {\n\t\treturn type;\n\t}\n\n\tpublic List<Annotation> getAnnotations() {\n\t\treturn Arrays.asList(annotations);\n\t}\n\n\tpublic boolean canAcceptArrayType(Class<?> type) {\n\t\treturn type.isArray() && canAcceptType(type.getComponentType());\n\t}\n\n\tpublic boolean hasAnnotation(Class<? extends Annotation> type) {\n\t\treturn getAnnotation(type) != null;\n\t}\n\n\tpublic <T extends Annotation> T findDeepAnnotation(\n\t\t\tClass<T> annotationType) {\n\t\treturn findDeepAnnotation(annotations, annotationType, 3);\n\t}\n\n\tprivate <T extends Annotation> T findDeepAnnotation(Annotation[] annotations,\n\t\t\tClass<T> annotationType, int remainingDepth) {\n\t\tif (remainingDepth == 0)\n\t\t\treturn null;\n\t\t\n\t\tfor (Annotation each : annotations) {\n\t\t\tif (annotationType.isInstance(each))\n\t\t\t\treturn annotationType.cast(each);\n\t\t\tAnnotation candidate = findDeepAnnotation(each.annotationType().getAnnotations(), annotationType, remainingDepth - 1);\n\t\t\tif (candidate != null)\n\t\t\t\treturn annotationType.cast(candidate);\n\t\t}\n\t\n\t\treturn null;\n\t}\n\n\tpublic <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n\t\tfor (Annotation each : getAnnotations())\n\t\t\tif (annotationType.isInstance(each))\n\t\t\t\treturn annotationType.cast(each);\n\t\treturn null;\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\npublic class ParameterSignature {\n\tpublic static ArrayList<ParameterSignature> signatures(Method method) {\n\t\tArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();\n\t\tfor (int i= 0; i < method.getParameterTypes().length; i++) {\n\t\t\tsigs.add(new ParameterSignature(method.getParameterTypes()[i],\n\t\t\t\t\tmethod.getParameterAnnotations()[i]));\n\t\t}\n\t\treturn sigs;\n\t}\n\n\tfinal Class<?> type;\n\n\tprivate final Annotation[] annotations;\n\n\tprivate ParameterSignature(Class<?> type, Annotation[] annotations) {\n\t\tthis.type= type;\n\t\tthis.annotations= annotations;\n\t}\n\n\tpublic boolean canAcceptType(Class<?> candidate) {\n\t\treturn type.isAssignableFrom(candidate);\n\t}\n\n\tpublic Class<?> getType() {\n\t\treturn type;\n\t}\n\n\tpublic List<Annotation> getAnnotations() {\n\t\treturn Arrays.asList(annotations);\n\t}\n\n\tpublic boolean canAcceptArrayType(Class<?> type) {\n\t\treturn type.isArray() && canAcceptType(type.getComponentType());\n\t}\n\n\tpublic boolean hasAnnotation(Class<? extends Annotation> type) {\n\t\treturn getAnnotation(type) != null;\n\t}\n\n\tpublic <T extends Annotation> T findDeepAnnotation(\n\t\t\tClass<T> annotationType) {\n\t\tAnnotation[] annotations2= annotations;\n\t\treturn findDeepAnnotation(annotations2, annotationType);\n\t}\n\n\tprivate <T extends Annotation> T findDeepAnnotation(Annotation[] annotations,\n\t\t\tClass<T> annotationType) {\n\t\tfor (Annotation each : annotations) {\n\t\t\tif (annotationType.isInstance(each))\n\t\t\t\treturn annotationType.cast(each);\n\t\t\tAnnotation candidate = findDeepAnnotation(each.annotationType().getAnnotations(), annotationType);\n\t\t\tif (candidate != null)\n\t\t\t\treturn annotationType.cast(candidate);\n\t\t}\n\t\n\t\treturn null;\n\t}\n\n\tpublic <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n\t\tfor (Annotation each : getAnnotations())\n\t\t\tif (annotationType.isInstance(each))\n\t\t\t\treturn annotationType.cast(each);\n\t\treturn null;\n\t}\n}\n","lineNo":54}
{"Smelly Sample":"package org.junit.internal.runners.model;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class TestClass extends TestElement {\n\tprivate final Class<?> fClass;\n\t\n\tpublic TestClass(Class<?> klass) {\n\t\tfClass= klass;\n\t}\n\n\tpublic List<TestMethod> getTestMethods() {\n\t\treturn getAnnotatedMethods(Test.class);\n\t}\n\n\t@Override\n\tpublic List<TestMethod> getBefores() {\n\t\treturn getAnnotatedMethods(BeforeClass.class);\n\t}\n\n\t@Override\n\tpublic List<TestMethod> getAfters() {\n\t\treturn getAnnotatedMethods(AfterClass.class);\n\t}\n\t\n\tpublic List<TestMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n\t\tList<TestMethod> results= new ArrayList<TestMethod>();\n\t\tfor (Class<?> eachClass : getSuperClasses(fClass)) {\n\t\t\tMethod[] methods= eachClass.getDeclaredMethods();\n\t\t\tfor (Method eachMethod : methods) {\n\t\t\t\tAnnotation annotation= eachMethod.getAnnotation(annotationClass);\n\t\t\t\tTestMethod testMethod= new TestMethod(eachMethod, this);\n\t\t\t\tif (annotation != null && ! testMethod.isShadowedBy(results))\n\t\t\t\t\tresults.add(testMethod);\n\t\t\t}\n\t\t}\n\t\tif (runsTopToBottom(annotationClass))\n\t\t\tCollections.reverse(results);\n\t\treturn results;\n\t}\n\n\tprivate boolean runsTopToBottom(Class< ? extends Annotation> annotation) {\n\t\treturn annotation.equals(Before.class) || annotation.equals(BeforeClass.class);\n\t}\n\t\n\tprivate List<Class<?>> getSuperClasses(Class< ?> testClass) {\n\t\tArrayList<Class<?>> results= new ArrayList<Class<?>>();\n\t\tClass<?> current= testClass;\n\t\twhile (current != null) {\n\t\t\tresults.add(current);\n\t\t\tcurrent= current.getSuperclass();\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic Constructor<?> getConstructor() throws SecurityException, NoSuchMethodException {\n\t\treturn fClass.getConstructor();\n\t}\n\n\tpublic Class<?> getJavaClass() {\n\t\treturn fClass;\n\t}\n\n\tpublic String getName() {\n\t\treturn fClass.getName();\n\t}\n\n\tpublic void runProtected(RunNotifier notifier, Description description, Runnable runnable) {\n\t\t// TODO: (Oct 8, 2007 1:02:02 PM) instead of this, have a runChildren overridable method in JUnit4ClassRunner\n\t\trunProtected(new EachTestNotifier(notifier, description), runnable, null);\n\t}\n\n\tpublic void validateMethods(Class<? extends Annotation> annotation, boolean isStatic, List<Throwable> errors) {\n\t\tList<TestMethod> methods= getAnnotatedMethods(annotation);\n\t\t\n\t\tfor (TestMethod eachTestMethod : methods) {\n\t\t\teachTestMethod.validate(isStatic, errors);\n\t\t}\n\t}\n\n\tpublic void validateStaticMethods(List<Throwable> errors) {\n\t\tvalidateMethods(BeforeClass.class, true, errors);\n\t\tvalidateMethods(AfterClass.class, true, errors);\n\t}\n\n\tpublic void validateNoArgConstructor(List<Throwable> errors) {\n\t\ttry {\n\t\t\tgetConstructor();\n\t\t} catch (Exception e) {\n\t\t\terrors.add(new Exception(\"Test class should have public zero-argument constructor\", e));\n\t\t}\n\t}\n\n\tpublic void validateInstanceMethods(List<Throwable> errors) {\n\t\tvalidateMethods(After.class, false, errors);\n\t\tvalidateMethods(Before.class, false, errors);\n\t\tvalidateMethods(Test.class, false, errors);\n\t\t\n\t\tList<TestMethod> methods= getAnnotatedMethods(Test.class);\n\t\tif (methods.size() == 0)\n\t\t\terrors.add(new Exception(\"No runnable methods\"));\n\t}\n\n\tpublic void validateMethodsForDefaultRunner(List<Throwable> errors) {\n\t\tvalidateNoArgConstructor(errors);\n\t\tvalidateStaticMethods(errors);\n\t\tvalidateInstanceMethods(errors);\n\t}\n}\n","Method after Refactoring":"package org.junit.internal.runners.model;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.StoppedByUserException;\n\npublic class TestClass extends TestElement {\n\tprivate final Class<?> fClass;\n\t\n\tpublic TestClass(Class<?> klass) {\n\t\tfClass= klass;\n\t}\n\n\tpublic List<TestMethod> getTestMethods() {\n\t\treturn getAnnotatedMethods(Test.class);\n\t}\n\n\t@Override\n\tpublic List<TestMethod> getBefores() {\n\t\treturn getAnnotatedMethods(BeforeClass.class);\n\t}\n\n\t@Override\n\tpublic List<TestMethod> getAfters() {\n\t\treturn getAnnotatedMethods(AfterClass.class);\n\t}\n\t\n\tpublic List<TestMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n\t\tList<TestMethod> results= new ArrayList<TestMethod>();\n\t\tfor (Class<?> eachClass : getSuperClasses(fClass)) {\n\t\t\tMethod[] methods= eachClass.getDeclaredMethods();\n\t\t\tfor (Method eachMethod : methods) {\n\t\t\t\tAnnotation annotation= eachMethod.getAnnotation(annotationClass);\n\t\t\t\tTestMethod testMethod= new TestMethod(eachMethod, this);\n\t\t\t\tif (annotation != null && ! testMethod.isShadowedBy(results))\n\t\t\t\t\tresults.add(testMethod);\n\t\t\t}\n\t\t}\n\t\tif (runsTopToBottom(annotationClass))\n\t\t\tCollections.reverse(results);\n\t\treturn results;\n\t}\n\n\tprivate boolean runsTopToBottom(Class< ? extends Annotation> annotation) {\n\t\treturn annotation.equals(Before.class) || annotation.equals(BeforeClass.class);\n\t}\n\t\n\tprivate List<Class<?>> getSuperClasses(Class< ?> testClass) {\n\t\tArrayList<Class<?>> results= new ArrayList<Class<?>>();\n\t\tClass<?> current= testClass;\n\t\twhile (current != null) {\n\t\t\tresults.add(current);\n\t\t\tcurrent= current.getSuperclass();\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic Constructor<?> getConstructor() throws SecurityException, NoSuchMethodException {\n\t\treturn fClass.getConstructor();\n\t}\n\n\tpublic Class<?> getJavaClass() {\n\t\treturn fClass;\n\t}\n\n\tpublic String getName() {\n\t\treturn fClass.getName();\n\t}\n\n\tpublic void runProtected(RunNotifier notifier, Description description, Runnable runnable) {\n\t\t// TODO: (Oct 8, 2007 1:02:02 PM) instead of this, have a runChildren overridable method in JUnit4ClassRunner\n\t\tEachTestNotifier testNotifier= new EachTestNotifier(notifier, description);\n\t\ttry {\n\t\t\trunProtected(testNotifier, runnable, null);\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\t// TODO: (Oct 12, 2007 10:21:33 AM) DUP with other ignorings\n\t\t} catch (StoppedByUserException e) {\n\t\t\t// TODO: (Oct 12, 2007 10:26:35 AM) DUP\n\n\t\t\tthrow e;\n\t\t} catch (Throwable e) {\n\t\t\ttestNotifier.addFailure(e);\n\t\t}\n\t}\n\n\tpublic void validateMethods(Class<? extends Annotation> annotation, boolean isStatic, List<Throwable> errors) {\n\t\tList<TestMethod> methods= getAnnotatedMethods(annotation);\n\t\t\n\t\tfor (TestMethod eachTestMethod : methods) {\n\t\t\teachTestMethod.validate(isStatic, errors);\n\t\t}\n\t}\n\n\tpublic void validateStaticMethods(List<Throwable> errors) {\n\t\tvalidateMethods(BeforeClass.class, true, errors);\n\t\tvalidateMethods(AfterClass.class, true, errors);\n\t}\n\n\tpublic void validateNoArgConstructor(List<Throwable> errors) {\n\t\ttry {\n\t\t\tgetConstructor();\n\t\t} catch (Exception e) {\n\t\t\terrors.add(new Exception(\"Test class should have public zero-argument constructor\", e));\n\t\t}\n\t}\n\n\tpublic void validateInstanceMethods(List<Throwable> errors) {\n\t\tvalidateMethods(After.class, false, errors);\n\t\tvalidateMethods(Before.class, false, errors);\n\t\tvalidateMethods(Test.class, false, errors);\n\t\t\n\t\tList<TestMethod> methods= getAnnotatedMethods(Test.class);\n\t\tif (methods.size() == 0)\n\t\t\terrors.add(new Exception(\"No runnable methods\"));\n\t}\n\n\tpublic void validateMethodsForDefaultRunner(List<Throwable> errors) {\n\t\tvalidateNoArgConstructor(errors);\n\t\tvalidateStaticMethods(errors);\n\t\tvalidateInstanceMethods(errors);\n\t}\n}\n","lineNo":85}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.links.Link;\nimport org.junit.internal.runners.links.WithBeforeAndAfter;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.model.InitializationError;\nimport org.junit.internal.runners.model.TestMethod;\n\n@SuppressWarnings(\"restriction\")\npublic class Theories extends JUnit4ClassRunner {\n\tpublic Theories(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t}\n\n\t@Override\n\tprotected List<TestMethod> getTestMethods() {\n\t\t// TODO: (Jul 20, 2007 2:02:44 PM) Only get methods once, even if they have both @Test and @Theory\n\n\t\tList<TestMethod> testMethods= super.getTestMethods();\n\t\ttestMethods.addAll(getTestClass().getAnnotatedMethods(Theory.class));\n\t\treturn testMethods;\n\t}\n\n\t@Override\n\tprotected Link chain(final TestMethod method, Object test) {\n\t\tLink next= invoke(method, test);\n\t\tnext= ignoreViolatedAssumptions(next);\n\t\tnext= possiblyExpectingExceptions(method, next);\n\t\treturn notifying(method, next);\n\t}\n\n\t@Override\n\tprotected TheoryAnchor invoke(TestMethod method, Object test) {\n\t\treturn new TheoryAnchor(method);\n\t}\n\n\tpublic class TheoryAnchor extends Link {\n\t\tprivate int successes = 0;\n\t\tprivate TestMethod fTestMethod;\n\t\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\t\tpublic TheoryAnchor(TestMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run(EachTestNotifier context) throws Throwable {\n\t\t\trunWithAssignment(Assignments.allUnassigned(fTestMethod\n\t\t\t\t\t.getMethod(), fTestMethod.getTestClass().getJavaClass()), context);\n\t\t\t\n\t\t\tif (successes  == 0)\n\t\t\t\tAssert\n\t\t\t\t\t\t.fail(\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters);\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment, EachTestNotifier notifier)\n\t\t\t\tthrows Throwable {\n\t\t\t// TODO: (Oct 9, 2007 8:56:54 PM) Should this be moved to Assignments?\n\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment, notifier);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment, notifier);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete, EachTestNotifier notifier)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tfor (PotentialAssignment source : incomplete\n\t\t\t\t\t.potentialsForNextUnassigned()) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source), notifier);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(final Assignments complete, EachTestNotifier notifier)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\ttry {\n\t\t\t\tfinal Object freshInstance= createTest();\n\t\t\t\tnew WithBeforeAndAfter(new Link() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run(EachTestNotifier context) throws Throwable {\n\t\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, complete);\n\t\t\t\t\t}\n\t\t\t\t}, fTestMethod, freshInstance).run(notifier); \n\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t}\n\n\t\tprivate void invokeWithActualParameters(Object target, Assignments complete)\n\t\t\t\tthrows Throwable {\n\t\t\tfinal Object[] values= complete.getActualValues(nullsOk(), target);\n\t\t\ttry {\n\t\t\t\tfTestMethod.invokeExplosively(target, values);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\thandleAssumptionViolation(e);\n\t\t\t} catch (Throwable e) {\n\t\t\t\treportParameterizedError(e, values);\n\t\t\t}\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getName(),\n\t\t\t\t\tparams);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.links.Link;\nimport org.junit.internal.runners.links.WithBeforeAndAfter;\nimport org.junit.internal.runners.model.EachTestNotifier;\nimport org.junit.internal.runners.model.InitializationError;\nimport org.junit.internal.runners.model.TestMethod;\n\n@SuppressWarnings(\"restriction\")\npublic class Theories extends JUnit4ClassRunner {\n\tpublic Theories(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t}\n\n\t@Override\n\tprotected List<TestMethod> getTestMethods() {\n\t\t// TODO: (Jul 20, 2007 2:02:44 PM) Only get methods once, even if they have both @Test and @Theory\n\n\t\tList<TestMethod> testMethods= super.getTestMethods();\n\t\ttestMethods.addAll(getTestClass().getAnnotatedMethods(Theory.class));\n\t\treturn testMethods;\n\t}\n\n\t@Override\n\tprotected Link chain(final TestMethod method, Object test, EachTestNotifier notifier) {\n\t\tLink next= invoke(method, test);\n\t\tnext= ignoreViolatedAssumptions(next);\n\t\tnext= possiblyExpectingExceptions(method, next);\n\t\treturn notifying(method, next, notifier);\n\t}\n\n\t@Override\n\tprotected TheoryAnchor invoke(TestMethod method, Object test) {\n\t\treturn new TheoryAnchor(method);\n\t}\n\n\tpublic class TheoryAnchor extends Link {\n\t\tprivate int successes = 0;\n\t\tprivate TestMethod fTestMethod;\n\t\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\t\tpublic TheoryAnchor(TestMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run(FailureListener listener) {\n\t\t\ttry {\n\t\t\t\trunWithAssignment(Assignments.allUnassigned(fTestMethod\n\t\t\t\t\t\t.getMethod(), fTestMethod.getTestClass().getJavaClass()), listener);\n\t\t\t} catch (Throwable e) {\n\t\t\t\tlistener.addFailure(e);\n\t\t\t}\n\t\t\t\n\t\t\tif (!listener.failureSeen() && successes == 0)\n\t\t\t\tlistener.addFailure(new AssertionError(\n\t\t\t\t\t\t\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters));\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment, FailureListener listener)\n\t\t\t\tthrows Throwable {\n\t\t\t// TODO: (Oct 9, 2007 8:56:54 PM) Should this be moved to Assignments?\n\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment, listener);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment, listener);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete, FailureListener listener)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tList<PotentialAssignment> potentialsForNextUnassigned= incomplete\n\t\t\t\t\t\t\t.potentialsForNextUnassigned();\n\t\t\tfor (PotentialAssignment source : potentialsForNextUnassigned) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source), listener);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(final Assignments complete, final FailureListener listener)\n\t\t\t\tthrows Throwable {\n\t\t\tfinal Object freshInstance= createTest();\n\t\t\tnew WithBeforeAndAfter(new Link() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run(FailureListener listener) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, complete);\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlistener.addFailure(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, fTestMethod, freshInstance).run(new FailureListener() {\n\t\t\t\t@Override\n\t\t\t\tprotected void handleFailure(Throwable error) {\n\t\t\t\t\tif (!(error instanceof CouldNotGenerateValueException))\n\t\t\t\t\t\tlistener.addFailure(error);\n\t\t\t\t}\n\t\t\t}); \n\t\t}\n\n\t\tprivate void invokeWithActualParameters(Object target, Assignments complete)\n\t\t\t\tthrows Throwable {\n\t\t\tfinal Object[] values= complete.getActualValues(nullsOk(), target);\n\t\t\ttry {\n\t\t\t\tfTestMethod.invokeExplosively(target, values);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\thandleAssumptionViolation(e);\n\t\t\t} catch (Throwable e) {\n\t\t\t\treportParameterizedError(e, values);\n\t\t\t}\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getName(),\n\t\t\t\t\tparams);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\t}\n}\n","lineNo":90}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.internal.runners.model.EachTestNotifier;\n\npublic class Assignments {\n\tprivate final EachTestNotifier fContext;\n\n\tprivate List<PotentialAssignment> fAssigned;\n\n\tprivate final List<ParameterSignature> fUnassigned;\n\n\tprivate Object fTarget;\n\n\tpublic Assignments(EachTestNotifier context,\n\t\t\tList<ParameterSignature> unassigned, Object target) {\n\t\tthis(context, new ArrayList<PotentialAssignment>(), unassigned, target);\n\t}\n\n\tpublic Assignments(EachTestNotifier context,\n\t\t\tList<PotentialAssignment> assigned,\n\t\t\tList<ParameterSignature> unassigned, Object target) {\n\t\tfContext= context;\n\t\tfUnassigned= unassigned;\n\t\tfAssigned= assigned;\n\t\tfTarget= target;\n\t}\n\n\tpublic static Assignments allUnassigned(EachTestNotifier context,\n\t\t\tMethod testMethod, Object target) {\n\t\treturn new Assignments(context, ParameterSignature\n\t\t\t\t.signatures(testMethod), target);\n\t}\n\n\tpublic boolean isComplete() {\n\t\treturn fUnassigned.size() == 0;\n\t}\n\n\tpublic ParameterSignature nextUnassigned() {\n\t\treturn fUnassigned.get(0);\n\t}\n\n\tpublic Assignments assignNext(PotentialAssignment source) {\n\t\tList<PotentialAssignment> assigned= new ArrayList<PotentialAssignment>(\n\t\t\t\tfAssigned);\n\t\tassigned.add(source);\n\t\treturn new Assignments(fContext, assigned, fUnassigned.subList(\n\t\t\t\t1, fUnassigned.size()), fTarget);\n\t}\n\n\tpublic Object getTarget() {\n\t\treturn fTarget;\n\t}\n\n\tpublic EachTestNotifier getContext() {\n\t\treturn fContext;\n\t}\n\n\tpublic Object[] getActualValues(boolean nullsOk)\n\t\t\tthrows CouldNotGenerateValueException {\n\t\tObject[] values= new Object[fAssigned.size()];\n\t\tfor (int i= 0; i < values.length; i++) {\n\t\t\tvalues[i]= fAssigned.get(i).getValue(getTarget());\n\t\t\tif (values[i] == null && !nullsOk)\n\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t}\n\t\treturn values;\n\t}\n\n\tpublic List<PotentialAssignment> potentialsForNextUnassigned()\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\treturn new AssignmentRequest(getTarget(), nextUnassigned())\n\t\t\t\t.getPotentialAssignments();\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.experimental.theories.ParameterSignature;\nimport org.junit.experimental.theories.ParameterSupplier;\nimport org.junit.experimental.theories.ParametersSuppliedBy;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\n\npublic class Assignments {\n\tprivate List<PotentialAssignment> fAssigned;\n\n\tprivate final List<ParameterSignature> fUnassigned;\n\n\tprivate final Class<?> fClass;\n\n\tpublic Assignments(List<ParameterSignature> unassigned, Class<?> testClass) {\n\t\tthis(new ArrayList<PotentialAssignment>(), unassigned, testClass);\n\t}\n\n\tpublic Assignments(List<PotentialAssignment> assigned,\n\t\t\tList<ParameterSignature> unassigned, Class<?> type) {\n\t\tfUnassigned= unassigned;\n\t\tfAssigned= assigned;\n\t\tfClass= type;\n\t}\n\n\t// TODO: (Oct 9, 2007 8:30:53 PM) Do I need all these constructors?\n\n\tpublic static Assignments allUnassigned(Method testMethod,\n\t\t\tClass<?> testClass) {\n\t\treturn new Assignments(ParameterSignature.signatures(testMethod),\n\t\t\t\ttestClass);\n\t}\n\n\tpublic boolean isComplete() {\n\t\treturn fUnassigned.size() == 0;\n\t}\n\n\tpublic ParameterSignature nextUnassigned() {\n\t\treturn fUnassigned.get(0);\n\t}\n\n\tpublic Assignments assignNext(PotentialAssignment source) {\n\t\tList<PotentialAssignment> assigned= new ArrayList<PotentialAssignment>(\n\t\t\t\tfAssigned);\n\t\tassigned.add(source);\n\t\treturn new Assignments(assigned, fUnassigned.subList(1, fUnassigned\n\t\t\t\t.size()), fClass);\n\t}\n\n\tpublic Object[] getActualValues(boolean nullsOk, Object target)\n\t\t\tthrows CouldNotGenerateValueException {\n\t\tObject[] values= new Object[fAssigned.size()];\n\t\tfor (int i= 0; i < values.length; i++) {\n\t\t\tvalues[i]= fAssigned.get(i).getValue(target);\n\t\t\tif (values[i] == null && !nullsOk)\n\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t}\n\t\treturn values;\n\t}\n\n\tpublic List<PotentialAssignment> potentialsForNextUnassigned()\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSignature unassigned= nextUnassigned();\n\t\treturn getSupplier(unassigned).getValueSources(unassigned);\n\t}\n\n\tpublic ParameterSupplier getSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParameterSupplier supplier= getAnnotatedSupplier(unassigned);\n\t\tif (supplier != null)\n\t\t\treturn supplier;\n\n\t\treturn new AllMembersSupplier(fClass);\n\t}\n\n\tpublic ParameterSupplier getAnnotatedSupplier(ParameterSignature unassigned)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\t\tParametersSuppliedBy annotation= unassigned\n\t\t\t\t.findDeepAnnotation(ParametersSuppliedBy.class);\n\t\tif (annotation == null)\n\t\t\treturn null;\n\t\treturn annotation.value().newInstance();\n\t}\n}\n","lineNo":71}
{"Smelly Sample":"package org.junit.tests.running.methods;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.TestResult;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.MethodValidator;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.model.TestClass;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\n\npublic class TestMethodTest {\n\n\t@SuppressWarnings(\"all\")  \n\tpublic static class EverythingWrong {\n\t\tprivate EverythingWrong() {}\n\t\t@BeforeClass public void notStaticBC() {}\n\t\t@BeforeClass static void notPublicBC() {}\n\t\t@BeforeClass public static int nonVoidBC() { return 0; }\n\t\t@BeforeClass public static void argumentsBC(int i) {}\n\t\t@BeforeClass public static void fineBC() {}\n\t\t@AfterClass public void notStaticAC() {}\n\t\t@AfterClass static void notPublicAC() {}\n\t\t@AfterClass public static int nonVoidAC() { return 0; }\n\t\t@AfterClass public static void argumentsAC(int i) {}\n\t\t@AfterClass public static void fineAC() {}\n\t\t@After public static void staticA() {}\n\t\t@After void notPublicA() {}\n\t\t@After public int nonVoidA() { return 0; }\n\t\t@After public void argumentsA(int i) {}\n\t\t@After public void fineA() {}\n\t\t@Before public static void staticB() {}\n\t\t@Before void notPublicB() {}\n\t\t@Before public int nonVoidB() { return 0; }\n\t\t@Before public void argumentsB(int i) {}\n\t\t@Before public void fineB() {}\n\t\t@Test public static void staticT() {}\n\t\t@Test void notPublicT() {}\n\t\t@Test public int nonVoidT() { return 0; }\n\t\t@Test public void argumentsT(int i) {}\n\t\t@Test public void fineT() {}\n\t}\n\t\n\t@Test public void testFailures() throws Exception {\n\t\tList<Throwable> problems= validateAllMethods(EverythingWrong.class);\n\t\tint errorCount= 1 + 4 * 5; // missing constructor plus four invalid methods for each annotation */\n\t\tassertEquals(errorCount, problems.size());\n\t}\n\n\tstatic public class SuperWrong {\n\t\t@Test void notPublic() {\n\t\t}\n\t}\n\n\tstatic public class SubWrong extends SuperWrong {\n\t\t@Test public void justFine() {\n\t\t}\n\t}\n\n\t@Test public void validateInheritedMethods() throws Exception {\n\t\tList<Throwable> problems= validateAllMethods(SubWrong.class);\n\t\tassertEquals(1, problems.size());\n\t}\n\n\tstatic public class SubShadows extends SuperWrong {\n\t\t@Override\n\t\t@Test public void notPublic() {\n\t\t}\n\t}\n\n\t@Test public void dontValidateShadowedMethods() throws Exception {\n\t\tList<Throwable> problems= validateAllMethods(SubShadows.class);\n\t\tassertTrue(problems.isEmpty());\n\t}\n\n\tprivate List<Throwable> validateAllMethods(Class<?> clazz) {\n\t\ttry {\n\t\t\tnew JUnit4ClassRunner(clazz);\n\t\t} catch (InitializationError e) {\n\t\t\treturn e.getCauses();\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\tstatic public class IgnoredTest {\n\t\t@Test public void valid() {}\n\t\t@Ignore @Test public void ignored() {}\n\t\t@Ignore(\"For testing purposes\") @Test public void withReason() {}\n\t}\n\n\t@Test public void ignoreRunner() {\n\t\tJUnitCore runner= new JUnitCore();\n\t\tResult result= runner.run(IgnoredTest.class);\n\t\tassertEquals(2, result.getIgnoreCount());\n\t}\n\n\t@Test public void compatibility() {\n\t\tTestResult result= new TestResult();\n\t\tnew JUnit4TestAdapter(IgnoredTest.class).run(result);\n\t\tassertEquals(1, result.runCount());\n\t}\n\t\n\tpublic static class Confused {\n\t\t@Test public void a(Object b) {\n\t\t}\n\t\t\n\t\t@Test public void a() {\n\t\t}\n\t}\n\t\n\t@Test public void overloaded() {\n\t\tMethodValidator validator= new MethodValidator(new TestClass(Confused.class));\n\t\tvalidator.fTestClass.validateMethodsForDefaultRunner(validator.fErrors);\n\t\tList<Throwable> errors= validator.fErrors;\n\t\tassertEquals(1, errors.size());\n\t}\n\t\n\tpublic static class OnlyTestIsIgnored {\n\t\t@Ignore @Test public void ignored() {}\n\t}\n\t\n\t@Test public void onlyIgnoredMethodsIsStillFineTestClass() {\n\t\tResult result= JUnitCore.runClasses(OnlyTestIsIgnored.class);\n\t\tassertEquals(0, result.getFailureCount());\n\t\tassertEquals(1, result.getIgnoreCount());\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.running.methods;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.TestResult;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.model.ErrorList;\nimport org.junit.internal.runners.model.InitializationError;\nimport org.junit.internal.runners.model.TestClass;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Result;\n\npublic class TestMethodTest {\n\n\t@SuppressWarnings(\"all\")  \n\tpublic static class EverythingWrong {\n\t\tprivate EverythingWrong() {}\n\t\t@BeforeClass public void notStaticBC() {}\n\t\t@BeforeClass static void notPublicBC() {}\n\t\t@BeforeClass public static int nonVoidBC() { return 0; }\n\t\t@BeforeClass public static void argumentsBC(int i) {}\n\t\t@BeforeClass public static void fineBC() {}\n\t\t@AfterClass public void notStaticAC() {}\n\t\t@AfterClass static void notPublicAC() {}\n\t\t@AfterClass public static int nonVoidAC() { return 0; }\n\t\t@AfterClass public static void argumentsAC(int i) {}\n\t\t@AfterClass public static void fineAC() {}\n\t\t@After public static void staticA() {}\n\t\t@After void notPublicA() {}\n\t\t@After public int nonVoidA() { return 0; }\n\t\t@After public void argumentsA(int i) {}\n\t\t@After public void fineA() {}\n\t\t@Before public static void staticB() {}\n\t\t@Before void notPublicB() {}\n\t\t@Before public int nonVoidB() { return 0; }\n\t\t@Before public void argumentsB(int i) {}\n\t\t@Before public void fineB() {}\n\t\t@Test public static void staticT() {}\n\t\t@Test void notPublicT() {}\n\t\t@Test public int nonVoidT() { return 0; }\n\t\t@Test public void argumentsT(int i) {}\n\t\t@Test public void fineT() {}\n\t}\n\t\n\t@Test public void testFailures() throws Exception {\n\t\tList<Throwable> problems= validateAllMethods(EverythingWrong.class);\n\t\tint errorCount= 1 + 4 * 5; // missing constructor plus four invalid methods for each annotation */\n\t\tassertEquals(errorCount, problems.size());\n\t}\n\n\tstatic public class SuperWrong {\n\t\t@Test void notPublic() {\n\t\t}\n\t}\n\n\tstatic public class SubWrong extends SuperWrong {\n\t\t@Test public void justFine() {\n\t\t}\n\t}\n\n\t@Test public void validateInheritedMethods() throws Exception {\n\t\tList<Throwable> problems= validateAllMethods(SubWrong.class);\n\t\tassertEquals(1, problems.size());\n\t}\n\n\tstatic public class SubShadows extends SuperWrong {\n\t\t@Override\n\t\t@Test public void notPublic() {\n\t\t}\n\t}\n\n\t@Test public void dontValidateShadowedMethods() throws Exception {\n\t\tList<Throwable> problems= validateAllMethods(SubShadows.class);\n\t\tassertTrue(problems.isEmpty());\n\t}\n\n\tprivate List<Throwable> validateAllMethods(Class<?> clazz) {\n\t\ttry {\n\t\t\tnew JUnit4ClassRunner(clazz);\n\t\t} catch (InitializationError e) {\n\t\t\treturn e.getCauses();\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\tstatic public class IgnoredTest {\n\t\t@Test public void valid() {}\n\t\t@Ignore @Test public void ignored() {}\n\t\t@Ignore(\"For testing purposes\") @Test public void withReason() {}\n\t}\n\n\t@Test public void ignoreRunner() {\n\t\tJUnitCore runner= new JUnitCore();\n\t\tResult result= runner.run(IgnoredTest.class);\n\t\tassertEquals(2, result.getIgnoreCount());\n\t}\n\n\t@Test public void compatibility() {\n\t\tTestResult result= new TestResult();\n\t\tnew JUnit4TestAdapter(IgnoredTest.class).run(result);\n\t\tassertEquals(1, result.runCount());\n\t}\n\t\n\tpublic static class Confused {\n\t\t@Test public void a(Object b) {\n\t\t}\n\t\t\n\t\t@Test public void a() {\n\t\t}\n\t}\n\t\n\t@Test public void overloaded() {\n\t\tTestClass testClass= new TestClass(Confused.class);\n\t\tErrorList errors= new ErrorList();\n\t\ttestClass.validateMethodsForDefaultRunner(errors);\n\t\tassertFalse(errors.isEmpty());\n\t}\n\t\n\tpublic static class OnlyTestIsIgnored {\n\t\t@Ignore @Test public void ignored() {}\n\t}\n\t\n\t@Test public void onlyIgnoredMethodsIsStillFineTestClass() {\n\t\tResult result= JUnitCore.runClasses(OnlyTestIsIgnored.class);\n\t\tassertEquals(0, result.getFailureCount());\n\t\tassertEquals(1, result.getIgnoreCount());\n\t}\n}\n","lineNo":125}
{"Smelly Sample":"package org.junit.tests.validation;\n\nimport org.junit.Test;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.MethodValidator;\nimport org.junit.internal.runners.model.TestClass;\nimport org.junit.tests.validation.anotherpackage.Sub;\n\npublic class InaccessibleBaseClassTest {\t\n\t@Test(expected=InitializationError.class)\n\tpublic void inaccessibleBaseClassIsCaughtAtValidation() throws InitializationError {\n\t\tMethodValidator methodValidator= new MethodValidator(new TestClass(Sub.class));\n\t\tmethodValidator.fTestClass.validateMethodsForDefaultRunner(methodValidator.fErrors);\n\t\tmethodValidator.assertValid();\n\t}\n}\n","Method after Refactoring":"package org.junit.tests.validation;\n\nimport static org.junit.Assert.assertFalse;\nimport org.junit.Test;\nimport org.junit.internal.runners.model.ErrorList;\nimport org.junit.internal.runners.model.TestClass;\nimport org.junit.tests.validation.anotherpackage.Sub;\n\npublic class InaccessibleBaseClassTest {\t\n\t@Test\n\tpublic void inaccessibleBaseClassIsCaughtAtValidation() {\n\t\tTestClass testClass= new TestClass(Sub.class);\n\t\tErrorList errors= new ErrorList();\n\t\ttestClass.validateMethodsForDefaultRunner(errors);\n\t\tassertFalse(errors.isEmpty());\n\t}\n}\n","lineNo":12}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.links.WithBeforeAndAfter;\nimport org.junit.internal.runners.links.Link;\nimport org.junit.internal.runners.model.Roadie;\nimport org.junit.internal.runners.model.TestMethod;\n\n@SuppressWarnings(\"restriction\")\npublic class Theories extends JUnit4ClassRunner {\n\tpublic Theories(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t}\n\n\t@Override\n\tprotected List<TestMethod> getTestMethods() {\n\t\t// TODO: (Jul 20, 2007 2:02:44 PM) Only get methods once\n\n\t\tList<TestMethod> testMethods= super.getTestMethods();\n\t\ttestMethods.addAll(getTestClass().getAnnotatedMethods(Theory.class));\n\t\treturn testMethods;\n\t}\n\n\t@Override\n\tprotected Link chain(final TestMethod method) {\n\t\treturn notifying(method, new Link() {\n\t\t\t@Override\n\t\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\t\tpossiblyExpectingExceptions(method, invoke(method)).run(context);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tprotected TheoryAnchor invoke(TestMethod method) {\n\t\treturn new TheoryAnchor(method);\n\t}\n\n\tpublic static class TheoryAnchor extends Link {\n\t\tprivate int successes = 0;\n\t\tprivate TestMethod fTestMethod;\n\t\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\t\tpublic TheoryAnchor(TestMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\trunWithAssignment(Assignments.allUnassigned(context, fTestMethod.getMethod()));\n\t\t\t\n\t\t\tif (successes  == 0)\n\t\t\t\tAssert\n\t\t\t\t\t\t.fail(\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters);\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment)\n\t\t\t\tthrows Throwable {\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tfor (PotentialAssignment source : incomplete\n\t\t\t\t\t.potentialsForNextUnassigned()) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source));\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(final Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\ttry {\n\t\t\t\tfinal Object freshInstance= complete.getTarget().getClass()\n\t\t\t\t\t\t.getConstructor().newInstance();\n\t\t\t\tfinal Roadie thisContext= complete.getContext()\n\t\t\t\t\t\t.withNewInstance(freshInstance);\n\t\t\t\tnew WithBeforeAndAfter(new Link() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, complete);\n\t\t\t\t\t}\n\t\t\t\t}, fTestMethod).run(thisContext); \n\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t}\n\n\t\tprivate void invokeWithActualParameters(Object target, Assignments complete)\n\t\t\t\tthrows Throwable {\n\t\t\tfinal Object[] values= complete.getActualValues(nullsOk());\n\t\t\ttry {\n\t\t\t\tfTestMethod.invokeExplosively(target, values);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\thandleAssumptionViolation(e);\n\t\t\t} catch (Throwable e) {\n\t\t\t\treportParameterizedError(e, values);\n\t\t\t}\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getName(),\n\t\t\t\t\tparams);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.experimental.theories.internal.Assignments;\nimport org.junit.experimental.theories.internal.ParameterizedAssertionError;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.internal.runners.links.WithBeforeAndAfter;\nimport org.junit.internal.runners.links.Link;\nimport org.junit.internal.runners.model.Roadie;\nimport org.junit.internal.runners.model.TestMethod;\n\n@SuppressWarnings(\"restriction\")\npublic class Theories extends JUnit4ClassRunner {\n\tpublic Theories(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t}\n\n\t@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t}\n\n\t@Override\n\tprotected List<TestMethod> getTestMethods() {\n\t\t// TODO: (Jul 20, 2007 2:02:44 PM) Only get methods once\n\n\t\tList<TestMethod> testMethods= super.getTestMethods();\n\t\ttestMethods.addAll(getTestClass().getAnnotatedMethods(Theory.class));\n\t\treturn testMethods;\n\t}\n\n\t@Override\n\tprotected Link chain(final TestMethod method) {\n\t\tLink next= invoke(method);\n\t\tnext= ignoreViolatedAssumptions(next);\n\t\tnext= possiblyExpectingExceptions(method, next);\n\t\treturn notifying(method, next);\n\t}\n\n\t@Override\n\tprotected TheoryAnchor invoke(TestMethod method) {\n\t\treturn new TheoryAnchor(method);\n\t}\n\n\tpublic static class TheoryAnchor extends Link {\n\t\tprivate int successes = 0;\n\t\tprivate TestMethod fTestMethod;\n\t\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\t\tpublic TheoryAnchor(TestMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\trunWithAssignment(Assignments.allUnassigned(context, fTestMethod.getMethod()));\n\t\t\t\n\t\t\tif (successes  == 0)\n\t\t\t\tAssert\n\t\t\t\t\t\t.fail(\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters);\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment)\n\t\t\t\tthrows Throwable {\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tfor (PotentialAssignment source : incomplete\n\t\t\t\t\t.potentialsForNextUnassigned()) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source));\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(final Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\ttry {\n\t\t\t\tfinal Object freshInstance= complete.getTarget().getClass()\n\t\t\t\t\t\t.getConstructor().newInstance();\n\t\t\t\tfinal Roadie thisContext= complete.getContext()\n\t\t\t\t\t\t.withNewInstance(freshInstance);\n\t\t\t\tnew WithBeforeAndAfter(new Link() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, complete);\n\t\t\t\t\t}\n\t\t\t\t}, fTestMethod).run(thisContext); \n\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t}\n\n\t\tprivate void invokeWithActualParameters(Object target, Assignments complete)\n\t\t\t\tthrows Throwable {\n\t\t\tfinal Object[] values= complete.getActualValues(nullsOk());\n\t\t\ttry {\n\t\t\t\tfTestMethod.invokeExplosively(target, values);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\thandleAssumptionViolation(e);\n\t\t\t} catch (Throwable e) {\n\t\t\t\treportParameterizedError(e, values);\n\t\t\t}\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getName(),\n\t\t\t\t\tparams);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\t}\n}\n","lineNo":43}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.Theory;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.internal.runners.ExplosiveMethod;\nimport org.junit.internal.runners.Roadie;\nimport org.junit.internal.runners.TestClass;\nimport org.junit.internal.runners.JUnit4MethodRunner;\n\npublic class TheoryMethodRunner extends JUnit4MethodRunner {\n\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\tprivate int successes= 0;\n\n\tprotected Throwable thrown= null;\n\n\tpublic TheoryMethodRunner(Method method, TestClass testClass) {\n\t\tsuper(method, testClass);\n\t}\n\n\t@Override\n\tprotected Link chain() {\n\t\treturn new Notifier(new Link() {\n\t\t\n\t\t\t@Override\n\t\t\tpublic void run(Roadie context) {\n\t\t\t\t// TODO: (Oct 5, 2007 11:23:04 AM) handle more gracefully\n\n\t\t\t\ttry {\n\t\t\t\t\thandleExceptions(anchor()).run(context);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t// TODO: (Oct 5, 2007 11:23:47 AM) Don't make addFailure be public\n\t\t\t\t\tcontext.addFailure(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t});\n\t}\n\n\t@Override\n\tprotected TheoryAnchor anchor() {\n\t\treturn new TheoryAnchor();\n\t}\n\n\tpublic class TheoryAnchor extends Anchor {\n\t\t@Override\n\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\trunWithAssignment(Assignments.allUnassigned(context, fTestMethod\n\t\t\t\t\t.getMethod()));\n\n\t\t\tif (successes == 0)\n\t\t\t\tAssert\n\t\t\t\t\t\t.fail(\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters);\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment)\n\t\t\t\tthrows Throwable {\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tfor (PotentialAssignment source : incomplete\n\t\t\t\t\t.potentialsForNextUnassigned()) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source));\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\ttry {\n\t\t\t\tfinal Object[] values= complete.getActualValues(nullsOk());\n\t\t\t\tfinal Object freshInstance= complete.getTarget().getClass()\n\t\t\t\t\t\t.getConstructor().newInstance();\n\t\t\t\tfinal Roadie thisContext= complete.getContext()\n\t\t\t\t\t\t.withNewInstance(freshInstance);\n\t\t\t\tnew BeforeAndAfter(new Anchor() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, values);\n\t\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t\tthrown= e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}).run(thisContext); \n\t\t\t\tif (thrown != null)\n\t\t\t\t\tthrow thrown;\n\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t}\n\n\t\tprivate void invokeWithActualParameters(Object target, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\ttry {\n\t\t\t\tExplosiveMethod.from(fTestMethod.getMethod()).invoke(target,\n\t\t\t\t\t\tparams);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\thandleAssumptionViolation(e);\n\t\t\t} catch (Throwable e) {\n\t\t\t\treportParameterizedError(e, params);\n\t\t\t}\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getMethod()\n\t\t\t\t\t.getName(), params);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.experimental.theories.internal;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.Assume.AssumptionViolatedException;\nimport org.junit.experimental.theories.PotentialAssignment;\nimport org.junit.experimental.theories.Theory;\nimport org.junit.experimental.theories.PotentialAssignment.CouldNotGenerateValueException;\nimport org.junit.internal.runners.ExplosiveMethod;\nimport org.junit.internal.runners.Roadie;\nimport org.junit.internal.runners.TestClass;\nimport org.junit.internal.runners.JUnit4MethodRunner;\n\npublic class TheoryMethodRunner extends JUnit4MethodRunner {\n\tprivate List<AssumptionViolatedException> fInvalidParameters= new ArrayList<AssumptionViolatedException>();\n\n\tprivate int successes= 0;\n\n\tprotected Throwable thrown= null;\n\n\tpublic TheoryMethodRunner(Method method, TestClass testClass) {\n\t\tsuper(method, testClass);\n\t}\n\n\t@Override\n\tprotected Link chain() {\n\t\tLink link= new Link() {\n\t\t\n\t\t\t@Override\n\t\t\tpublic void run(Roadie context) {\n\t\t\t\t// TODO: (Oct 5, 2007 11:23:04 AM) handle more gracefully\n\n\t\t\t\ttry {\n\t\t\t\t\thandleExceptions(anchor()).run(context);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t// TODO: (Oct 5, 2007 11:23:47 AM) Don't make addFailure be public\n\t\t\t\t\tcontext.addFailure(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t};\n\t\tlink= new Notifier(link);\n\t\treturn new Ignored(link);\n\t}\n\n\t@Override\n\tprotected TheoryAnchor anchor() {\n\t\treturn new TheoryAnchor();\n\t}\n\n\tpublic class TheoryAnchor extends Link {\n\t\t@Override\n\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\trunWithAssignment(Assignments.allUnassigned(context, fTestMethod\n\t\t\t\t\t.getMethod()));\n\n\t\t\tif (successes == 0)\n\t\t\t\tAssert\n\t\t\t\t\t\t.fail(\"Never found parameters that satisfied method.  Violated assumptions: \"\n\t\t\t\t\t\t\t\t+ fInvalidParameters);\n\t\t}\n\n\t\tprotected void runWithAssignment(Assignments parameterAssignment)\n\t\t\t\tthrows Throwable {\n\t\t\tif (!parameterAssignment.isComplete()) {\n\t\t\t\trunWithIncompleteAssignment(parameterAssignment);\n\t\t\t} else {\n\t\t\t\trunWithCompleteAssignment(parameterAssignment);\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithIncompleteAssignment(Assignments incomplete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tThrowable {\n\t\t\tfor (PotentialAssignment source : incomplete\n\t\t\t\t\t.potentialsForNextUnassigned()) {\n\t\t\t\trunWithAssignment(incomplete.assignNext(source));\n\t\t\t}\n\t\t}\n\n\t\tprotected void runWithCompleteAssignment(Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\ttry {\n\t\t\t\tfinal Object[] values= complete.getActualValues(nullsOk());\n\t\t\t\tfinal Object freshInstance= complete.getTarget().getClass()\n\t\t\t\t\t\t.getConstructor().newInstance();\n\t\t\t\tfinal Roadie thisContext= complete.getContext()\n\t\t\t\t\t\t.withNewInstance(freshInstance);\n\t\t\t\tnew BeforeAndAfter(new Link() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run(Roadie context) throws Throwable {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, values);\n\t\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t\tthrown= e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}).run(thisContext); \n\t\t\t\tif (thrown != null)\n\t\t\t\t\tthrow thrown;\n\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t}\n\n\t\tprivate void invokeWithActualParameters(Object target, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\ttry {\n\t\t\t\tExplosiveMethod.from(fTestMethod.getMethod()).invoke(target,\n\t\t\t\t\t\tparams);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\thandleAssumptionViolation(e);\n\t\t\t} catch (Throwable e) {\n\t\t\t\treportParameterizedError(e, params);\n\t\t\t}\n\t\t}\n\n\t\tprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t}\n\n\t\tprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\t\tthrows Throwable {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fTestMethod.getMethod()\n\t\t\t\t\t.getName(), params);\n\t\t}\n\n\t\tprivate boolean nullsOk() {\n\t\t\tTheory annotation= fTestMethod.getMethod().getAnnotation(\n\t\t\t\t\tTheory.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\treturn annotation.nullsAccepted();\n\t\t}\n\t}\n\n}\n","lineNo":34}
{"Smelly Sample":"package org.junit.internal.runners;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit4ClassRunner extends Runner implements Filterable, Sortable {\n\tprivate final List<Method> fTestMethods;\n\tprivate TestClass fTestClass;\n\n\tpublic JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tfTestClass= new TestClass(klass);\n\t\tfTestMethods= fTestClass.getTestMethods();\n\t\tvalidate();\n\t}\n\t\n\tprotected void validate() throws InitializationError {\n\t\tMethodValidator methodValidator= new MethodValidator(fTestClass);\n\t\tmethodValidator.validateMethodsForDefaultRunner();\n\t\tmethodValidator.assertValid();\n\t}\n\n\t@Override\n\tpublic void run(final RunNotifier notifier) {\n\t\tnew ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\trunMethods(notifier);\n\t\t\t}\n\t\t}).runProtected();\n\t}\n\n\tprotected void runMethods(final RunNotifier notifier) {\n\t\tfor (Method method : fTestMethods)\n\t\t\tinvokeTestMethod(method, notifier);\n\t}\n\n\t@Override\n\tpublic Description getDescription() {\n\t\tDescription spec= Description.createSuiteDescription(getName(), classAnnotations());\n\t\tList<Method> testMethods= fTestMethods;\n\t\tfor (Method method : testMethods)\n\t\t\tspec.addChild(methodDescription(method));\n\t\treturn spec;\n\t}\n\n\tprotected Annotation[] classAnnotations() {\n\t\treturn fTestClass.getJavaClass().getAnnotations();\n\t}\n\n\tprotected String getName() {\n\t\treturn getTestClass().getName();\n\t}\n\t\n\tprotected Object createTest() throws Exception {\n\t\treturn getTestClass().getConstructor().newInstance();\n\t}\n\n\tprotected void invokeTestMethod(Method method, RunNotifier notifier) {\n\t\tObject test;\n\t\ttry {\n\t\t\ttest= createTest();\n\t\t} catch (InvocationTargetException e) {\n\t\t\tnotifier.testAborted(methodDescription(method), e.getCause());\n\t\t\treturn;\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tnotifier.testAborted(methodDescription(method), e);\n\t\t\treturn;\n\t\t}\n\t\tcreateMethodRunner(test, method, notifier).run();\n\t}\n\n\tprotected MethodRoadie createMethodRunner(Object test, Method method, RunNotifier notifier) {\n\t\treturn new MethodRoadie(test, method, notifier, methodDescription(method), fTestClass);\n\t}\n\n\tprotected String testName(Method method) {\n\t\treturn method.getName();\n\t}\n\n\tprotected Description methodDescription(Method method) {\n\t\tDescription result= Description.createTestDescription(getTestClass().getJavaClass(), testName(method), testAnnotations(method));\n\t\treturn result;\n\t}\n\n\tprotected Annotation[] testAnnotations(Method method) {\n\t\treturn method.getAnnotations();\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tfor (Iterator<Method> iter= fTestMethods.iterator(); iter.hasNext();) {\n\t\t\tMethod method= iter.next();\n\t\t\tif (!filter.shouldRun(methodDescription(method)))\n\t\t\t\titer.remove();\n\t\t}\n\t\tif (fTestMethods.isEmpty())\n\t\t\tthrow new NoTestsRemainException();\n\t}\n\n\tpublic void sort(final Sorter sorter) {\n\t\tCollections.sort(fTestMethods, new Comparator<Method>() {\n\t\t\tpublic int compare(Method o1, Method o2) {\n\t\t\t\treturn sorter.compare(methodDescription(o1), methodDescription(o2));\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected TestClass getTestClass() {\n\t\treturn fTestClass;\n\t}\n}\n","Method after Refactoring":"package org.junit.internal.runners;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.Filterable;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.manipulation.Sortable;\nimport org.junit.runner.manipulation.Sorter;\nimport org.junit.runner.notification.RunNotifier;\n\npublic class JUnit4ClassRunner extends Runner implements Filterable, Sortable {\n\tprivate final List<Method> fTestMethods;\n\tprivate TestClass fTestClass;\n\n\tpublic JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tfTestClass= new TestClass(klass);\n\t\tfTestMethods= getTestMethods();\n\t\tvalidate();\n\t}\n\t\n\tprotected List<Method> getTestMethods() {\n\t\treturn fTestClass.getTestMethods();\n\t}\n\t\n\tprotected void validate() throws InitializationError {\n\t\tMethodValidator methodValidator= new MethodValidator(fTestClass);\n\t\tmethodValidator.validateMethodsForDefaultRunner();\n\t\tmethodValidator.assertValid();\n\t}\n\n\t@Override\n\tpublic void run(final RunNotifier notifier) {\n\t\tnew ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\trunMethods(notifier);\n\t\t\t}\n\t\t}).runProtected();\n\t}\n\n\tprotected void runMethods(final RunNotifier notifier) {\n\t\tfor (Method method : fTestMethods)\n\t\t\tinvokeTestMethod(method, notifier);\n\t}\n\n\t@Override\n\tpublic Description getDescription() {\n\t\tDescription spec= Description.createSuiteDescription(getName(), classAnnotations());\n\t\tList<Method> testMethods= fTestMethods;\n\t\tfor (Method method : testMethods)\n\t\t\tspec.addChild(methodDescription(method));\n\t\treturn spec;\n\t}\n\n\tprotected Annotation[] classAnnotations() {\n\t\treturn fTestClass.getJavaClass().getAnnotations();\n\t}\n\n\tprotected String getName() {\n\t\treturn getTestClass().getName();\n\t}\n\t\n\tprotected Object createTest() throws Exception {\n\t\treturn getTestClass().getConstructor().newInstance();\n\t}\n\n\tprotected void invokeTestMethod(Method method, RunNotifier notifier) {\n\t\tDescription description= methodDescription(method);\n\t\tObject test;\n\t\ttry {\n\t\t\ttest= createTest();\n\t\t} catch (InvocationTargetException e) {\n\t\t\tnotifier.testAborted(description, e.getCause());\n\t\t\treturn;\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tnotifier.testAborted(description, e);\n\t\t\treturn;\n\t\t}\n\t\tTestMethod testMethod= wrapMethod(method);\n\t\tnew MethodRoadie(test, testMethod, notifier, description).run();\n\t}\n\n\tprotected TestMethod wrapMethod(Method method) {\n\t\treturn new TestMethod(method, fTestClass);\n\t}\n\n\tprotected String testName(Method method) {\n\t\treturn method.getName();\n\t}\n\n\tprotected Description methodDescription(Method method) {\n\t\treturn Description.createTestDescription(getTestClass().getJavaClass(), testName(method), testAnnotations(method));\n\t}\n\n\tprotected Annotation[] testAnnotations(Method method) {\n\t\treturn method.getAnnotations();\n\t}\n\n\tpublic void filter(Filter filter) throws NoTestsRemainException {\n\t\tfor (Iterator<Method> iter= fTestMethods.iterator(); iter.hasNext();) {\n\t\t\tMethod method= iter.next();\n\t\t\tif (!filter.shouldRun(methodDescription(method)))\n\t\t\t\titer.remove();\n\t\t}\n\t\tif (fTestMethods.isEmpty())\n\t\t\tthrow new NoTestsRemainException();\n\t}\n\n\tpublic void sort(final Sorter sorter) {\n\t\tCollections.sort(fTestMethods, new Comparator<Method>() {\n\t\t\tpublic int compare(Method o1, Method o2) {\n\t\t\t\treturn sorter.compare(methodDescription(o1), methodDescription(o2));\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected TestClass getTestClass() {\n\t\treturn fTestClass;\n\t}\n}\n","lineNo":76}
{"Smelly Sample":"package org.junit;\n\nimport org.junit.internal.ArrayComparisonFailure;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions are recorded.\n * These methods can be used directly: <code>Assert.assertEquals(...)<\/code>, however, they\n * read better if they are referenced through static import:<br>\n * <code>\n *   import static org.junit.Assert.*;<br>\n *   ...<br>\n *   &nbsp;&nbsp;assertEquals(...);<br>\n *   <\/code>\n *   \n *   @see java.lang.AssertionError\n */\npublic class Assert {\n\t/**\n\t * Protect constructor since it is a static only class\n\t */\n\tprotected Assert() {\n\t}\n\t\n\t// TODO: param comments should start with lower case letters\n\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws an\n\t * {@link AssertionError} with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertTrue(String message, boolean condition) {\n\t\tif (!condition)\n\t\t\tfail(message);\n\t}\n\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws an\n\t * {@link AssertionError} without a message.\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertTrue(boolean condition) {\n\t\tassertTrue(null, condition);\n\t}\n\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws an\n\t * {@link AssertionError} with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertFalse(String message, boolean condition) {\n\t\tassertTrue(message, !condition);\n\t}\n\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws an\n\t * {@link AssertionError} without a message.\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertFalse(boolean condition) {\n\t\tassertFalse(null, condition);\n\t}\n\n\t/**\n\t * Fails a test with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @see AssertionError\n\t */\n\tstatic public void fail(String message) {\n\t\tthrow new AssertionError(message == null ? \"\" : message);\n\t}\n\n\t/**\n\t * Fails a test with no message.\n\t */\n\tstatic public void fail() {\n\t\tfail(null);\n\t}\n\t\n\t/**\n\t * Asserts that two objects are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected expected value\n\t * @param actual actual value\n\t */\n\tstatic public void assertEquals(String message, Object expected, Object actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && expected.equals(actual))\n\t\t\treturn;\n\t\tif (expected instanceof String && actual instanceof String)\n\t\t\tthrow new ComparisonFailure(message, (String)expected, (String)actual);\n\t\telse\n\t\t\tfailNotEquals(message, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two objects are equal. If they are not, an\n\t * {@link AssertionError} without a message is thrown.\n\t * @param expected expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t */\n\tstatic public void assertEquals(Object expected, Object actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertEquals(String message, Object[] expecteds, Object[] actuals) {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tif (actuals.length != expecteds.length)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expecteds.length + \" actual.length=\" + actuals.length);\n\n\t\tfor (int i= 0; i < expecteds.length; i++) {\n\t\t\tObject o1= expecteds[i];\n\t\t\tObject o2= actuals[i];\n\t\t\tif (o1.getClass().isArray() && o2.getClass().isArray()) {\n\t\t\t\tObject[] expected= (Object[]) o1;\n\t\t\t\tObject[] actual= (Object[]) o2;\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(o1, o2);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown.\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertEquals(Object[] expecteds, Object[] actuals) {\n\t\tassertEquals(null, expecteds, actuals);\n\t}\n\n\t/**\n\t * Asserts that two doubles are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown with the given message. If the\n\t * expected value is infinity then the delta value is ignored. NaNs are\n\t * considered equal:\n\t * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(String message, double expected, double actual, double delta) {\n\t\tif (Double.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected - actual) <= delta))\n\t\t\tfailNotEquals(message, new Double(expected), new Double(actual));\n\t}\n\n\t/**\n\t * Asserts that two doubles are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown. If the\n\t * expected value is infinity then the delta value is ignored.NaNs are\n\t * considered equal:\n\t * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n\t * @param expected expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(double expected, double actual, double delta) {\n\t\tassertEquals(null, expected, actual, delta);\n\t}\n\n\t/**\n\t * Asserts that two floats are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown with the given message. If the\n\t * expected value is infinity then the delta value is ignored.NaNs are\n\t * considered equal:\n\t * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected the expected float value\n\t * @param actual the float value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(String message, float expected, float actual, float delta) {\n\t\tif (Float.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected - actual) <= delta))\n\t\t\tfailNotEquals(message, new Float(expected), new Float(actual));\n\t}\n\n\t/**\n\t * Asserts that two floats are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown. If the\n\t * expected value is infinity then the delta value is ignored. {@link Float#NaN NaNs} are\n\t * considered equal:\n\t * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n\t * @param expected the expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(float expected, float actual, float delta) {\n\t\tassertEquals(null, expected, actual, delta);\n\t}\n\n\t/**\n\t * Asserts that an object isn't null. If it is an {@link AssertionError} is\n\t * thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNotNull(String message, Object object) {\n\t\tassertTrue(message, object != null);\n\t}\n\n\t/**\n\t * Asserts that an object isn't null. If it is an {@link AssertionError} is\n\t * thrown.\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNotNull(Object object) {\n\t\tassertNotNull(null, object);\n\t}\n\t\n\t/**\n\t * Asserts that an object is null. If it is not, an {@link AssertionError} is\n\t * thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNull(String message, Object object) {\n\t\tassertTrue(message, object == null);\n\t}\n\n\t/**\n\t * Asserts that an object is null. If it isn't an {@link AssertionError} is\n\t * thrown.\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNull(Object object) {\n\t\tassertNull(null, object);\n\t}\n\t\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not, an\n\t * {@link AssertionError} is thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected the expected object\n\t * @param actual the object to compare to <code>expected<\/code>\n\t */\n\tstatic public void assertSame(String message, Object expected, Object actual) {\n\t\tif (expected == actual)\n\t\t\treturn;\n\t\tfailNotSame(message, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not the\n\t * same, an {@link AssertionError} without a message is thrown.\n\t * @param expected the expected object\n\t * @param actual the object to compare to <code>expected<\/code>\n\t */\n\tstatic public void assertSame(Object expected, Object actual) {\n\t\tassertSame(null, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object, an {@link AssertionError} is thrown with the given\n\t * message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param unexpected the object you don't expect\n\t * @param actual the object to compare to <code>unexpected<\/code>\n\t */\n\tstatic public void assertNotSame(String message, Object unexpected, Object actual) {\n\t\tif (unexpected == actual)\n\t\t\tfailSame(message);\n\t}\n\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object, an {@link AssertionError} without a message is thrown.\n\t * @param unexpected the object you don't expect\n\t * @param actual the object to compare to <code>unexpected<\/code>\n\t */\n\tstatic public void assertNotSame(Object unexpected, Object actual) {\n\t\tassertNotSame(null, unexpected, actual);\n\t}\n\n\tstatic private void failSame(String message) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message + \" \";\n\t\tfail(formatted + \"expected not same\");\n\t}\n\n\tstatic private void failNotSame(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message + \" \";\n\t\tfail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual + \">\");\n\t}\n\n\tstatic private void failNotEquals(String message, Object expected, Object actual) {\n\t\tfail(format(message, expected, actual));\n\t}\n\n\tstatic String format(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message + \" \";\n\t\treturn formatted + \"expected:<\" + expected + \"> but was:<\" + actual + \">\";\n\t}\n\n}\n","Method after Refactoring":"package org.junit;\n\nimport org.junit.internal.ArrayComparisonFailure;\n\n/**\n * A set of assertion methods useful for writing tests. Only failed assertions are recorded.\n * These methods can be used directly: <code>Assert.assertEquals(...)<\/code>, however, they\n * read better if they are referenced through static import:<br>\n * <code>\n *   import static org.junit.Assert.*;<br>\n *   ...<br>\n *   &nbsp;&nbsp;assertEquals(...);<br>\n *   <\/code>\n *   \n *   @see java.lang.AssertionError\n */\npublic class Assert {\n\t/**\n\t * Protect constructor since it is a static only class\n\t */\n\tprotected Assert() {\n\t}\n\t\n\t// TODO: param comments should start with lower case letters\n\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws an\n\t * {@link AssertionError} with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertTrue(String message, boolean condition) {\n\t\tif (!condition)\n\t\t\tfail(message);\n\t}\n\n\t/**\n\t * Asserts that a condition is true. If it isn't it throws an\n\t * {@link AssertionError} without a message.\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertTrue(boolean condition) {\n\t\tassertTrue(null, condition);\n\t}\n\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws an\n\t * {@link AssertionError} with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertFalse(String message, boolean condition) {\n\t\tassertTrue(message, !condition);\n\t}\n\n\t/**\n\t * Asserts that a condition is false. If it isn't it throws an\n\t * {@link AssertionError} without a message.\n\t * @param condition condition to be checked\n\t */\n\tstatic public void assertFalse(boolean condition) {\n\t\tassertFalse(null, condition);\n\t}\n\n\t/**\n\t * Fails a test with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @see AssertionError\n\t */\n\tstatic public void fail(String message) {\n\t\tthrow new AssertionError(message == null ? \"\" : message);\n\t}\n\n\t/**\n\t * Fails a test with no message.\n\t */\n\tstatic public void fail() {\n\t\tfail(null);\n\t}\n\t\n\t/**\n\t * Asserts that two objects are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected expected value\n\t * @param actual actual value\n\t */\n\tstatic public void assertEquals(String message, Object expected, Object actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && expected.equals(actual))\n\t\t\treturn;\n\t\tif (expected instanceof String && actual instanceof String) {\n\t\t\tString cleanMessage= message == null ? \"\" : message;\n\t\t\tthrow new ComparisonFailure(cleanMessage, (String)expected, (String)actual);\n\t\t}\n\t\telse\n\t\t\tfailNotEquals(message, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two objects are equal. If they are not, an\n\t * {@link AssertionError} without a message is thrown.\n\t * @param expected expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t */\n\tstatic public void assertEquals(Object expected, Object actual) {\n\t\tassertEquals(null, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertEquals(String message, Object[] expecteds, Object[] actuals) {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tif (actuals.length != expecteds.length)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expecteds.length + \" actual.length=\" + actuals.length);\n\n\t\tfor (int i= 0; i < expecteds.length; i++) {\n\t\t\tObject o1= expecteds[i];\n\t\t\tObject o2= actuals[i];\n\t\t\tif (o1.getClass().isArray() && o2.getClass().isArray()) {\n\t\t\t\tObject[] expected= (Object[]) o1;\n\t\t\t\tObject[] actual= (Object[]) o2;\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(o1, o2);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown.\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertEquals(Object[] expecteds, Object[] actuals) {\n\t\tassertEquals(null, expecteds, actuals);\n\t}\n\n\t/**\n\t * Asserts that two doubles are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown with the given message. If the\n\t * expected value is infinity then the delta value is ignored. NaNs are\n\t * considered equal:\n\t * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(String message, double expected, double actual, double delta) {\n\t\tif (Double.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected - actual) <= delta))\n\t\t\tfailNotEquals(message, new Double(expected), new Double(actual));\n\t}\n\n\t/**\n\t * Asserts that two doubles are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown. If the\n\t * expected value is infinity then the delta value is ignored.NaNs are\n\t * considered equal:\n\t * <code>assertEquals(Double.NaN, Double.NaN, *)<\/code> passes\n\t * @param expected expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(double expected, double actual, double delta) {\n\t\tassertEquals(null, expected, actual, delta);\n\t}\n\n\t/**\n\t * Asserts that two floats are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown with the given message. If the\n\t * expected value is infinity then the delta value is ignored.NaNs are\n\t * considered equal:\n\t * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected the expected float value\n\t * @param actual the float value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(String message, float expected, float actual, float delta) {\n\t\tif (Float.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected - actual) <= delta))\n\t\t\tfailNotEquals(message, new Float(expected), new Float(actual));\n\t}\n\n\t/**\n\t * Asserts that two floats are equal to within a positive delta. If they\n\t * are not, an {@link AssertionError} is thrown. If the\n\t * expected value is infinity then the delta value is ignored. {@link Float#NaN NaNs} are\n\t * considered equal:\n\t * <code>assertEquals(Float.NaN, Float.NaN, *)<\/code> passes\n\t * @param expected the expected value\n\t * @param actual the value to check against <code>expected<\/code>\n\t * @param delta the maximum delta between <code>expected<\/code> and <code>actual<\/code> for which \n\t * both numbers are still considered equal.\n\t */\n\tstatic public void assertEquals(float expected, float actual, float delta) {\n\t\tassertEquals(null, expected, actual, delta);\n\t}\n\n\t/**\n\t * Asserts that an object isn't null. If it is an {@link AssertionError} is\n\t * thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNotNull(String message, Object object) {\n\t\tassertTrue(message, object != null);\n\t}\n\n\t/**\n\t * Asserts that an object isn't null. If it is an {@link AssertionError} is\n\t * thrown.\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNotNull(Object object) {\n\t\tassertNotNull(null, object);\n\t}\n\t\n\t/**\n\t * Asserts that an object is null. If it is not, an {@link AssertionError} is\n\t * thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNull(String message, Object object) {\n\t\tassertTrue(message, object == null);\n\t}\n\n\t/**\n\t * Asserts that an object is null. If it isn't an {@link AssertionError} is\n\t * thrown.\n\t * @param object Object to check or <code>null<\/code>\n\t */\n\tstatic public void assertNull(Object object) {\n\t\tassertNull(null, object);\n\t}\n\t\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not, an\n\t * {@link AssertionError} is thrown with the given message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param expected the expected object\n\t * @param actual the object to compare to <code>expected<\/code>\n\t */\n\tstatic public void assertSame(String message, Object expected, Object actual) {\n\t\tif (expected == actual)\n\t\t\treturn;\n\t\tfailNotSame(message, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two objects refer to the same object. If they are not the\n\t * same, an {@link AssertionError} without a message is thrown.\n\t * @param expected the expected object\n\t * @param actual the object to compare to <code>expected<\/code>\n\t */\n\tstatic public void assertSame(Object expected, Object actual) {\n\t\tassertSame(null, expected, actual);\n\t}\n\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object, an {@link AssertionError} is thrown with the given\n\t * message.\n\t * @param message the identifying message or <code>null<\/code> for the {@link AssertionError}\n\t * @param unexpected the object you don't expect\n\t * @param actual the object to compare to <code>unexpected<\/code>\n\t */\n\tstatic public void assertNotSame(String message, Object unexpected, Object actual) {\n\t\tif (unexpected == actual)\n\t\t\tfailSame(message);\n\t}\n\n\t/**\n\t * Asserts that two objects do not refer to the same object. If they do\n\t * refer to the same object, an {@link AssertionError} without a message is thrown.\n\t * @param unexpected the object you don't expect\n\t * @param actual the object to compare to <code>unexpected<\/code>\n\t */\n\tstatic public void assertNotSame(Object unexpected, Object actual) {\n\t\tassertNotSame(null, unexpected, actual);\n\t}\n\n\tstatic private void failSame(String message) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message + \" \";\n\t\tfail(formatted + \"expected not same\");\n\t}\n\n\tstatic private void failNotSame(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message + \" \";\n\t\tfail(formatted + \"expected same:<\" + expected + \"> was not:<\" + actual + \">\");\n\t}\n\n\tstatic private void failNotEquals(String message, Object expected, Object actual) {\n\t\tfail(format(message, expected, actual));\n\t}\n\n\tstatic String format(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null && ! message.equals(\"\"))\n\t\t\tformatted= message + \" \";\n\t\treturn formatted + \"expected:<\" + expected + \"> but was:<\" + actual + \">\";\n\t}\n\n}\n","lineNo":94}
{"Smelly Sample":"package org.junit.internal.runners;\n\nimport junit.extensions.TestDecorator;\nimport junit.framework.AssertionFailedError;\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.JUnit4TestCaseFacade;\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestListener;\nimport junit.framework.TestResult;\nimport junit.framework.TestSuite;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.Failure;\n\npublic class OldTestClassRunner extends Runner {\n\t\n\tprivate Test fTest;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic OldTestClassRunner(Class<?> klass) {\n\t\tthis(new TestSuite((Class<? extends TestCase>) klass));\n\t}\n\n\tpublic OldTestClassRunner(Test test) {\n\t\tsuper();\n\t\tfTest= test;\n\t}\n\n\t@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tTestResult result= new TestResult();\n\t\tresult.addListener(getListener(notifier));\n\t\tfTest.run(result);\n\t}\n\n\tprivate TestListener getListener(final RunNotifier notifier) {\n\t\treturn new TestListener() {\n\t\t\tpublic void endTest(Test test) {\n\t\t\t\t// TODO: uncovered\n\t\t\t\tnotifier.fireTestFinished(asDescription(test));\n\t\t\t}\n\n\t\t\tpublic void startTest(Test test) {\n\t\t\t\tnotifier.fireTestStarted(asDescription(test));\n\t\t\t}\n\t\t\n\t\t\t// Implement junit.framework.TestListener\n\t\t\t//TODO method not covered\n\t\t\tpublic void addError(Test test, Throwable t) {\n\t\t\t\tFailure failure= new Failure(asDescription(test), t);\n\t\t\t\tnotifier.fireTestFailure(failure);\n\t\t\t}\n\t\t\t\n\t\t\tprivate Description asDescription(Test test) {\n\t\t\t\tif (test instanceof JUnit4TestCaseFacade) {\n\t\t\t\t\tJUnit4TestCaseFacade facade= (JUnit4TestCaseFacade) test;\n\t\t\t\t\treturn facade.getDescription();\n\t\t\t\t}\n\t\t\t\treturn Description.createTestDescription(test.getClass(), getName(test));\n\t\t\t}\n\n\t\t\tprivate String getName(Test test) {\n\t\t\t\tif (test instanceof TestCase)\n\t\t\t\t\treturn ((TestCase) test).getName();\n\t\t\t\telse\n\t\t\t\t\treturn test.toString();\n\t\t\t}\n\n\t\t\t//TODO method not covered\n\t\t\tpublic void addFailure(Test test, AssertionFailedError t) {\n\t\t\t\taddError(test, t);\n\t\t\t}\n\t\t};\n\t}\n\t\n\t@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(fTest);\n\t}\n\n\tprivate Description makeDescription(Test test) {\n\t\tif (test instanceof TestCase) {\n\t\t\tTestCase tc= (TestCase) test;\n\t\t\treturn Description.createTestDescription(tc.getClass(), tc.getName());\n\t\t} else if (test instanceof TestSuite) {\n\t\t\tTestSuite ts= (TestSuite) test;\n\t\t\tDescription description= Description.createSuiteDescription(ts.getName());\n\t\t\tint n= ts.testCount();\n\t\t\tfor (int i= 0; i < n; i++)\n\t\t\t\tdescription.addChild(makeDescription(ts.testAt(i)));\n\t\t\treturn description;\n\t\t} else if (test instanceof JUnit4TestAdapter) {\n\t\t\tJUnit4TestAdapter adapter= (JUnit4TestAdapter) test;\n\t\t\treturn adapter.getDescription();\n\t\t} else if (test instanceof TestDecorator) {\n\t\t\tTestDecorator decorator= (TestDecorator) test;\n\t\t\treturn makeDescription(decorator.getTest());\n\t\t} else {\n\t\t\t// This is the best we can do in this case\n\t\t\treturn Description.createSuiteDescription(test.getClass());\n\t\t}\n\t}\n}\n","Method after Refactoring":"package org.junit.internal.runners;\n\nimport junit.extensions.TestDecorator;\nimport junit.framework.AssertionFailedError;\nimport junit.framework.JUnit4TestAdapter;\nimport junit.framework.JUnit4TestCaseFacade;\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestListener;\nimport junit.framework.TestResult;\nimport junit.framework.TestSuite;\nimport org.junit.runner.Description;\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runner.notification.Failure;\n\npublic class OldTestClassRunner extends Runner {\n\t\n\tprivate Test fTest;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic OldTestClassRunner(Class<?> klass) {\n\t\tthis(new TestSuite((Class<? extends TestCase>) klass));\n\t}\n\n\tpublic OldTestClassRunner(Test test) {\n\t\tsuper();\n\t\tfTest= test;\n\t}\n\n\t@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tTestResult result= new TestResult();\n\t\tresult.addListener(getListener(notifier));\n\t\tfTest.run(result);\n\t}\n\n\tprivate TestListener getListener(final RunNotifier notifier) {\n\t\treturn new TestListener() {\n\t\t\tpublic void endTest(Test test) {\n\t\t\t\t// TODO: uncovered\n\t\t\t\tnotifier.fireTestFinished(asDescription(test));\n\t\t\t}\n\n\t\t\tpublic void startTest(Test test) {\n\t\t\t\tnotifier.fireTestStarted(asDescription(test));\n\t\t\t}\n\t\t\n\t\t\t// Implement junit.framework.TestListener\n\t\t\t//TODO method not covered\n\t\t\tpublic void addError(Test test, Throwable t) {\n\t\t\t\tFailure failure= new Failure(asDescription(test), t);\n\t\t\t\tnotifier.fireTestFailure(failure);\n\t\t\t}\n\t\t\t\n\t\t\tprivate Description asDescription(Test test) {\n\t\t\t\tif (test instanceof JUnit4TestCaseFacade) {\n\t\t\t\t\tJUnit4TestCaseFacade facade= (JUnit4TestCaseFacade) test;\n\t\t\t\t\treturn facade.getDescription();\n\t\t\t\t}\n\t\t\t\treturn Description.createTestDescription(test.getClass(), getName(test));\n\t\t\t}\n\n\t\t\tprivate String getName(Test test) {\n\t\t\t\tif (test instanceof TestCase)\n\t\t\t\t\treturn ((TestCase) test).getName();\n\t\t\t\telse\n\t\t\t\t\treturn test.toString();\n\t\t\t}\n\n\t\t\t//TODO method not covered\n\t\t\tpublic void addFailure(Test test, AssertionFailedError t) {\n\t\t\t\taddError(test, t);\n\t\t\t}\n\t\t};\n\t}\n\t\n\t@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(fTest);\n\t}\n\n\tprivate Description makeDescription(Test test) {\n\t\tif (test instanceof TestCase) {\n\t\t\tTestCase tc= (TestCase) test;\n\t\t\treturn Description.createTestDescription(tc.getClass(), tc.getName());\n\t\t} else if (test instanceof TestSuite) {\n\t\t\tTestSuite ts= (TestSuite) test;\n\t\t\tString name= ts.getName() == null ? \"\" : ts.getName();\n\t\t\tDescription description= Description.createSuiteDescription(name);\n\t\t\tint n= ts.testCount();\n\t\t\tfor (int i= 0; i < n; i++)\n\t\t\t\tdescription.addChild(makeDescription(ts.testAt(i)));\n\t\t\treturn description;\n\t\t} else if (test instanceof JUnit4TestAdapter) {\n\t\t\tJUnit4TestAdapter adapter= (JUnit4TestAdapter) test;\n\t\t\treturn adapter.getDescription();\n\t\t} else if (test instanceof TestDecorator) {\n\t\t\tTestDecorator decorator= (TestDecorator) test;\n\t\t\treturn makeDescription(decorator.getTest());\n\t\t} else {\n\t\t\t// This is the best we can do in this case\n\t\t\treturn Description.createSuiteDescription(test.getClass());\n\t\t}\n\t}\n}\n","lineNo":89}
{"Smelly Sample":"/**\n * \n */\npackage org.junit.internal.requests;\n\nimport org.junit.runner.Request;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.NoTestsRemainException;\n\npublic final class FilterRequest extends Request {\n\tprivate final Request fRequest;\n\n\tprivate final Filter fFilter;\n\n\tpublic FilterRequest(Request classRequest, Filter filter) {\n\t\tfRequest= classRequest;\n\t\tfFilter= filter;\n\t}\n\n\t@Override\n\tpublic Runner getRunner() {\n\t\ttry {\n\t\t\treturn fFilter.apply(fRequest.getRunner());\n\t\t} catch (NoTestsRemainException e) {\n\t\t\treturn Request.errorReport(Filter.class, new Exception(String\n\t\t\t\t\t.format(\"No tests found matching %s from %s\", fFilter\n\t\t\t\t\t\t\t.describe(), fRequest.toString()))).getRunner();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/**\n * \n */\npackage org.junit.internal.requests;\n\nimport org.junit.runner.Request;\nimport org.junit.runner.Runner;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.NoTestsRemainException;\n\npublic final class FilterRequest extends Request {\n\tprivate final Request fRequest;\n\tprivate final Filter fFilter;\n\n\tpublic FilterRequest(Request classRequest, Filter filter) {\n\t\tfRequest= classRequest;\n\t\tfFilter= filter;\n\t}\n\n\t@Override\n\tpublic Runner getRunner() {\n\t\ttry {\n\t\t\tRunner runner= fRequest.getRunner();\n\t\t\tfFilter.apply(runner);\n\t\t\treturn runner;\n\t\t} catch (NoTestsRemainException e) {\n\t\t\treturn Request.errorReport(Filter.class, new Exception(String\n\t\t\t\t\t.format(\"No tests found matching %s from %s\", fFilter\n\t\t\t\t\t\t\t.describe(), fRequest.toString()))).getRunner();\n\t\t}\n\t}\n}\n","lineNo":23}
{"Smelly Sample":"package junit.framework;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\n/**\n * A test case defines the fixture to run multiple tests. To define a test case<br>\n * 1) implement a subclass of TestCase<br>\n * 2) define instance variables that store the state of the fixture<br>\n * 3) initialize the fixture state by overriding <code>setUp<\/code><br>\n * 4) clean-up after a test by overriding <code>tearDown<\/code>.<br>\n * Each test runs in its own fixture so there\n * can be no side effects among test runs.\n * Here is an example:\n * <pre>\n * public class MathTest extends TestCase {\n *     protected double fValue1;\n *     protected double fValue2;\n *\n *    protected void setUp() {\n *         fValue1= 2.0;\n *         fValue2= 3.0;\n *     }\n * }\n * <\/pre>\n *\n * For each test implement a method which interacts\n * with the fixture. Verify the expected results with assertions specified\n * by calling <code>assertTrue<\/code> with a boolean.\n * <pre>\n *    public void testAdd() {\n *        double result= fValue1 + fValue2;\n *        assertTrue(result == 5.0);\n *    }\n * <\/pre>\n * Once the methods are defined you can run them. The framework supports\n * both a static type safe and more dynamic way to run a test.\n * In the static way you override the runTest method and define the method to\n * be invoked. A convenient way to do so is with an anonymous inner class.\n * <pre>\n * TestCase test= new MathTest(\"add\") {\n *        public void runTest() {\n *            testAdd();\n *        }\n * };\n * test.run();\n * <\/pre>\n * The dynamic way uses reflection to implement <code>runTest<\/code>. It dynamically finds\n * and invokes a method.\n * In this case the name of the test case has to correspond to the test method\n * to be run.\n * <pre>\n * TestCase test= new MathTest(\"testAdd\");\n * test.run();\n * <\/pre>\n * The tests to be run can be collected into a TestSuite. JUnit provides\n * different <i>test runners<\/i> which can run a test suite and collect the results.\n * A test runner either expects a static method <code>suite<\/code> as the entry\n * point to get a test to run or it will extract the suite automatically.\n * <pre>\n * public static Test suite() {\n *      suite.addTest(new MathTest(\"testAdd\"));\n *      suite.addTest(new MathTest(\"testDivideByZero\"));\n *      return suite;\n *  }\n * <\/pre>\n * @see TestResult\n * @see TestSuite\n */\n\npublic abstract class TestCase extends Assert implements Test {\n\t/**\n\t * the name of the test case\n\t */\n\tprivate String fName;\n\n\t/**\n\t * No-arg constructor to enable serialization. This method\n\t * is not intended to be used by mere mortals without calling setName().\n\t */\n\tpublic TestCase() {\n\t\tfName= null;\n\t}\n\t/**\n\t * Constructs a test case with the given name.\n\t */\n\tpublic TestCase(String name) {\n\t\tfName= name;\n\t}\n\t/**\n\t * Counts the number of test cases executed by run(TestResult result).\n\t */\n\tpublic int countTestCases() {\n\t\treturn 1;\n\t}\n\t/**\n\t * Creates a default TestResult object\n\t *\n\t * @see TestResult\n\t */\n\tprotected TestResult createResult() {\n\t    return new TestResult();\n\t}\n\t/**\n\t * A convenience method to run this test, collecting the results with a\n\t * default TestResult object.\n\t *\n\t * @see TestResult\n\t */\n\tpublic TestResult run() {\n\t\tTestResult result= createResult();\n\t\trun(result);\n\t\treturn result;\n\t}\n\t/**\n\t * Runs the test case and collects the results in TestResult.\n\t */\n\tpublic void run(TestResult result) {\n\t\tresult.run(this);\n\t}\n\t/**\n\t * Runs the bare test sequence.\n\t * @exception Throwable if any exception is thrown\n\t */\n\tpublic void runBare() throws Throwable {\n\t\tThrowable running= null;\n\t\tsetUp();\n\t\ttry {\n\t\t\trunTest();\n\t\t} catch (Throwable e) {\n\t\t\trunning= e;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\ttearDown();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow (running != null) ? running : e;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Override to run the test and assert its state.\n\t * @exception Throwable if any exception is thrown\n\t */\n\tprotected void runTest() throws Throwable {\n\t\tassertNotNull(fName);\n\t\tMethod runMethod= null;\n\t\ttry {\n\t\t\t// use getMethod to get all public inherited\n\t\t\t// methods. getDeclaredMethods returns all\n\t\t\t// methods of this class but excludes the\n\t\t\t// inherited ones.\n\t\t\trunMethod= getClass().getMethod(fName, null);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tfail(\"Method \\\"\"+fName+\"\\\" not found\");\n\t\t}\n\t\tif (!Modifier.isPublic(runMethod.getModifiers())) {\n\t\t\tfail(\"Method \\\"\"+fName+\"\\\" should be public\");\n\t\t}\n\n\t\ttry {\n\t\t\trunMethod.invoke(this, new Class[0]);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\te.fillInStackTrace();\n\t\t\tthrow e.getTargetException();\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\te.fillInStackTrace();\n\t\t\tthrow e;\n\t\t}\n\t}\n\t/**\n\t * Sets up the fixture, for example, open a network connection.\n\t * This method is called before a test is executed.\n\t */\n\tprotected void setUp() throws Exception {\n\t}\n\t/**\n\t * Tears down the fixture, for example, close a network connection.\n\t * This method is called after a test is executed.\n\t */\n\tprotected void tearDown() throws Exception {\n\t}\n\t/**\n\t * Returns a string representation of the test case\n\t */\n\tpublic String toString() {\n\t    return getName() + \"(\" + getClass().getName() + \")\";\n\t}\n\t/**\n\t * Gets the name of a TestCase\n\t * @return returns a String\n\t */\n\tpublic String getName() {\n\t\treturn fName;\n\t}\n\t/**\n\t * Sets the name of a TestCase\n\t * @param name The name to set\n\t */\n\tpublic void setName(String name) {\n\t\tfName= name;\n\t}\n}\n","Method after Refactoring":"package junit.framework;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\n/**\n * A test case defines the fixture to run multiple tests. To define a test case<br>\n * 1) implement a subclass of TestCase<br>\n * 2) define instance variables that store the state of the fixture<br>\n * 3) initialize the fixture state by overriding <code>setUp<\/code><br>\n * 4) clean-up after a test by overriding <code>tearDown<\/code>.<br>\n * Each test runs in its own fixture so there\n * can be no side effects among test runs.\n * Here is an example:\n * <pre>\n * public class MathTest extends TestCase {\n *     protected double fValue1;\n *     protected double fValue2;\n *\n *    protected void setUp() {\n *         fValue1= 2.0;\n *         fValue2= 3.0;\n *     }\n * }\n * <\/pre>\n *\n * For each test implement a method which interacts\n * with the fixture. Verify the expected results with assertions specified\n * by calling <code>assertTrue<\/code> with a boolean.\n * <pre>\n *    public void testAdd() {\n *        double result= fValue1 + fValue2;\n *        assertTrue(result == 5.0);\n *    }\n * <\/pre>\n * Once the methods are defined you can run them. The framework supports\n * both a static type safe and more dynamic way to run a test.\n * In the static way you override the runTest method and define the method to\n * be invoked. A convenient way to do so is with an anonymous inner class.\n * <pre>\n * TestCase test= new MathTest(\"add\") {\n *        public void runTest() {\n *            testAdd();\n *        }\n * };\n * test.run();\n * <\/pre>\n * The dynamic way uses reflection to implement <code>runTest<\/code>. It dynamically finds\n * and invokes a method.\n * In this case the name of the test case has to correspond to the test method\n * to be run.\n * <pre>\n * TestCase test= new MathTest(\"testAdd\");\n * test.run();\n * <\/pre>\n * The tests to be run can be collected into a TestSuite. JUnit provides\n * different <i>test runners<\/i> which can run a test suite and collect the results.\n * A test runner either expects a static method <code>suite<\/code> as the entry\n * point to get a test to run or it will extract the suite automatically.\n * <pre>\n * public static Test suite() {\n *      suite.addTest(new MathTest(\"testAdd\"));\n *      suite.addTest(new MathTest(\"testDivideByZero\"));\n *      return suite;\n *  }\n * <\/pre>\n * @see TestResult\n * @see TestSuite\n */\n\npublic abstract class TestCase extends Assert implements Test {\n\t/**\n\t * the name of the test case\n\t */\n\tprivate String fName;\n\n\t/**\n\t * No-arg constructor to enable serialization. This method\n\t * is not intended to be used by mere mortals without calling setName().\n\t */\n\tpublic TestCase() {\n\t\tfName= null;\n\t}\n\t/**\n\t * Constructs a test case with the given name.\n\t */\n\tpublic TestCase(String name) {\n\t\tfName= name;\n\t}\n\t/**\n\t * Counts the number of test cases executed by run(TestResult result).\n\t */\n\tpublic int countTestCases() {\n\t\treturn 1;\n\t}\n\t/**\n\t * Creates a default TestResult object\n\t *\n\t * @see TestResult\n\t */\n\tprotected TestResult createResult() {\n\t    return new TestResult();\n\t}\n\t/**\n\t * A convenience method to run this test, collecting the results with a\n\t * default TestResult object.\n\t *\n\t * @see TestResult\n\t */\n\tpublic TestResult run() {\n\t\tTestResult result= createResult();\n\t\trun(result);\n\t\treturn result;\n\t}\n\t/**\n\t * Runs the test case and collects the results in TestResult.\n\t */\n\tpublic void run(TestResult result) {\n\t\tresult.run(this);\n\t}\n\t/**\n\t * Runs the bare test sequence.\n\t * @exception Throwable if any exception is thrown\n\t */\n\tpublic void runBare() throws Throwable {\n\t\tThrowable exception= null;\n\t\tsetUp();\n\t\ttry {\n\t\t\trunTest();\n\t\t} catch (Throwable running) {\n\t\t\texception= running;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\ttearDown();\n\t\t\t} catch (Throwable tearingDown) {\n\t\t\t\tif (exception == null) exception= tearingDown;\n\t\t\t}\n\t\t}\n\t\tif (exception != null) throw exception;\n\t}\n\t/**\n\t * Override to run the test and assert its state.\n\t * @exception Throwable if any exception is thrown\n\t */\n\tprotected void runTest() throws Throwable {\n\t\tassertNotNull(fName); // Some VMs crash when calling getMethod(null,null);\n\t\tMethod runMethod= null;\n\t\ttry {\n\t\t\t// use getMethod to get all public inherited\n\t\t\t// methods. getDeclaredMethods returns all\n\t\t\t// methods of this class but excludes the\n\t\t\t// inherited ones.\n\t\t\trunMethod= getClass().getMethod(fName, null);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tfail(\"Method \\\"\"+fName+\"\\\" not found\");\n\t\t}\n\t\tif (!Modifier.isPublic(runMethod.getModifiers())) {\n\t\t\tfail(\"Method \\\"\"+fName+\"\\\" should be public\");\n\t\t}\n\n\t\ttry {\n\t\t\trunMethod.invoke(this, new Class[0]);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\te.fillInStackTrace();\n\t\t\tthrow e.getTargetException();\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\te.fillInStackTrace();\n\t\t\tthrow e;\n\t\t}\n\t}\n\t/**\n\t * Sets up the fixture, for example, open a network connection.\n\t * This method is called before a test is executed.\n\t */\n\tprotected void setUp() throws Exception {\n\t}\n\t/**\n\t * Tears down the fixture, for example, close a network connection.\n\t * This method is called after a test is executed.\n\t */\n\tprotected void tearDown() throws Exception {\n\t}\n\t/**\n\t * Returns a string representation of the test case\n\t */\n\tpublic String toString() {\n\t    return getName() + \"(\" + getClass().getName() + \")\";\n\t}\n\t/**\n\t * Gets the name of a TestCase\n\t * @return returns a String\n\t */\n\tpublic String getName() {\n\t\treturn fName;\n\t}\n\t/**\n\t * Sets the name of a TestCase\n\t * @param name The name to set\n\t */\n\tpublic void setName(String name) {\n\t\tfName= name;\n\t}\n}\n","lineNo":127}
{"Smelly Sample":"package junit.swingui;\n\nimport junit.framework.*;\nimport junit.runner.*;\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport java.text.NumberFormat;\nimport java.net.URL;\nimport java.io.*;\n\nimport javax.swing.*;\nimport javax.swing.event.*;\nimport javax.swing.text.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\n\n/**\n * A Swing based user interface to run tests.\n * Enter the name of a class which either provides a static\n * suite method or is a subclass of TestCase.\n * <pre>\n * Synopsis: java junit.swingui.TestRunner [-noloading] [TestCase]\n * <\/pre>\n * TestRunner takes as an optional argument the name of the testcase class to be run.\n */\npublic class TestRunner extends BaseTestRunner implements TestRunContext {\n\tprotected JFrame fFrame;\n\tprivate Thread fRunner;\n\tprivate TestResult fTestResult;\n\t\n\tprivate JComboBox fSuiteCombo;\n\tprivate ProgressBar fProgressIndicator;\n\tprivate DefaultListModel fFailures;\n\tprivate JLabel fLogo;\n\tprivate CounterPanel fCounterPanel;\n\tprivate JButton fRun;\n\tprivate JButton fQuitButton;\n\tprivate JButton fRerunButton;\n\tprivate StatusLine fStatusLine;\n\tprivate FailureDetailView fFailureView;\n\tprivate JTabbedPane fTestViewTab;\n\tprivate JCheckBox fUseLoadingRunner;\n\tprivate Vector fTestRunViews= new Vector(); // view associated with tab in tabbed pane\n\tprivate int fNonLoadingRuns= 0;\n\tprivate static Font PLAIN_FONT= StatusLine.PLAIN_FONT;\n\tprivate static Font BOLD_FONT= StatusLine.BOLD_FONT;\n\tprivate static final int GAP= 4;\n\tprivate static final int HISTORY_LENGTH= 5;\n\n\tprivate static final String TESTCOLLECTOR_KEY= \"TestCollectorClass\";\n\tprivate static final String FAILUREDETAILVIEW_KEY= \"FailureViewClass\";\n\t\t\n\tpublic TestRunner() {\n\t} \n\t\n\tpublic static void main(String[] args) {\n\t\tnew TestRunner().start(args);\n\t}\n\t \n\tpublic static void run(Class test) {\n\t\tString args[]= { test.getName() };\n\t\tmain(args);\n\t}\n\t\n\tpublic void addError(final Test test, final Throwable t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setErrorValue(fTestResult.errorCount());\n\t\t\t\t\tappendFailure(\"Error\", test, t);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void addFailure(final Test test, final AssertionFailedError t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setFailureValue(fTestResult.failureCount());\n\t\t\t\t\tappendFailure(\"Failure\", test, t);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t);\n\t}\n\t\n\tpublic void startTest(Test test) {\n\t\tpostInfo(\"Running: \"+test);\n\t}\n\t\n\tpublic void endTest(Test test) {\n\t\tpostEndTest(test);\n\t}\n\n\tprivate void postEndTest(final Test test) {\n\t\tsynchUI();\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (fTestResult != null) {\n\t\t\t\t\t\tfCounterPanel.setRunValue(fTestResult.runCount());\n\t\t\t\t\t\tfProgressIndicator.step(fTestResult.wasSuccessful());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tpublic void setSuite(String suiteName) {\n\t\tfSuiteCombo.getEditor().setItem(suiteName);\n\t}\n\n\tprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\t\n\tprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\t\n\tprivate void appendFailure(String kind, Test test, Throwable t) {\n\t\tfFailures.addElement(new TestFailure(test, t));\n\t\tif (fFailures.size() == 1) \n\t\t\trevealFailure(test);\n\t}\n\t\n\tprivate void revealFailure(Test test) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.revealFailure(test);\n\t\t}\n\t}\n\t\t\n\tpublic void changedUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\n\tprotected void aboutToStart(final Test testSuite) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.aboutToStart(testSuite, fTestResult);\n\t\t}\n\t}\n\t\n\tprotected void runFinished(final Test testSuite) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\t\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\t\t\t\tv.runFinished(testSuite, fTestResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tprotected CounterPanel createCounterPanel() {\n\t\treturn new CounterPanel();\n\t}\n\t\n\tprotected JPanel createFailedPanel() {\n\t\tJPanel failedPanel= new JPanel(new GridLayout(0, 1, 0, 2));\n\t\tfRerunButton= new JButton(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfailedPanel.add(fRerunButton);\n\t\treturn failedPanel;\n\t}\n\t\t\t\n\tprotected FailureDetailView createFailureDetailView() {\n\t\tString className= BaseTestRunner.getPreference(FAILUREDETAILVIEW_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass viewClass= null;\n\t\t\ttry {\n\t\t\t\tviewClass= Class.forName(className);\n\t\t\t\treturn (FailureDetailView)viewClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create Failure DetailView - using default view\");\n\t\t\t}\n\t\t}\n\t\treturn new DefaultFailureDetailView();\n\t}\n\n\t/**\n\t * Creates the JUnit menu. Clients override this\n\t * method to add additional menu items.\n\t */\n\tprotected JMenu createJUnitMenu() {\n\t\tJMenu menu= new JMenu(\"JUnit\");\n\t\tmenu.setMnemonic('J');\n\t\tJMenuItem mi1= new JMenuItem(\"About...\");\n\t\tmi1.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            about();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi1.setMnemonic('A');\n\t\tmenu.add(mi1);\n\t\t\n\t\tmenu.addSeparator();\n\t\tJMenuItem mi2= new JMenuItem(\" Exit \");\n\t\tmi2.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            terminate();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi2.setMnemonic('x');\n\t\tmenu.add(mi2);\n\n\t\treturn menu;\n\t}\n\t\n\tprotected JFrame createFrame(String title) {\n\t\tJFrame frame= new JFrame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\t\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\t\tframe.getContentPane().setLayout(new BorderLayout(0, 0));\n\t\t\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn frame;\n\t}\n\t\n\tprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\t\n\tprotected void createMenus(JMenuBar mb) {\n\t\tmb.add(createJUnitMenu());\n\t}\n\t\t\n\tprotected JCheckBox createUseLoaderCheckBox() {\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tJCheckBox box= new JCheckBox(\"Reload classes every run\", useLoader);\n\t\tbox.setToolTipText(\"Use a custom class loader to reload the classes for every run\");\n\t\treturn box;\n\t}\n\t\n\tprotected JButton createQuitButton() {\n\t\t // spaces required to avoid layout flicker\n\t\t // Exit is shorter than Stop that shows in the same column\n\t\tJButton quit= new JButton(\" Exit \"); \n\t\tquit.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn quit;\n\t}\n\t\n\tprotected JButton createRunButton() {\n\t\tJButton run= new JButton(\"Run\");\n\t\trun.setEnabled(true);\n\t\trun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn run;\n\t}\n\t\n\tprotected Component createBrowseButton() {\n\t\tJButton browse= new JButton(\"...\");\n\t\tbrowse.setToolTipText(\"Select a Test class\");\n\t\tbrowse.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tbrowseTestClasses();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn browse;\t\t\n\t}\n\t\n\tprotected StatusLine createStatusLine() {\n\t\treturn new StatusLine(420);\n\t}\n\t\n\tprotected JComboBox createSuiteCombo() {\n\t\tJComboBox combo= new JComboBox();\n\t\tcombo.setEditable(true);\n\t\tcombo.setLightWeightPopupEnabled(false);\n\t\t\n\t\tcombo.getEditor().getEditorComponent().addKeyListener(\n\t\t\tnew KeyAdapter() {\n\t\t\t\tpublic void keyTyped(KeyEvent e) {\n\t\t\t\t\ttextChanged();\n\t\t\t\t\tif (e.getKeyChar() == KeyEvent.VK_ENTER)\n\t\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\ttry {\n\t\t\tloadHistory(combo);\n\t\t} catch (IOException e) {\n\t\t\t// fails the first time\n\t\t}\n\t\tcombo.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent event) {\n\t\t\t\t\tif (event.getStateChange() == ItemEvent.SELECTED) {\n\t\t\t\t\t\ttextChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn combo;\n\t}\n\t\n\tprotected JTabbedPane createTestRunViews() {\n\t\tJTabbedPane pane= new JTabbedPane(JTabbedPane.BOTTOM);\n\n\t\tFailureRunView lv= new FailureRunView(this);\n\t\tfTestRunViews.addElement(lv);\n\t\tlv.addTab(pane);\n\t\t\n\t\tTestHierarchyRunView tv= new TestHierarchyRunView(this);\n\t\tfTestRunViews.addElement(tv);\n\t\ttv.addTab(pane);\n\t\t\n\t\tpane.addChangeListener(\n\t\t\tnew ChangeListener() {\n\t\t\t\tpublic void stateChanged(ChangeEvent e) {\n\t\t\t\t\ttestViewChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn pane;\n\t}\n\t\n\tpublic void testViewChanged() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tview.activate();\n\t}\n\t\n\tprotected TestResult createTestResult() {\n\t\treturn new TestResult();\n\t}\n\t\n\tprotected JFrame createUI(String suiteName) {\t\n\t\tJFrame frame= createFrame(\"JUnit\");\t\n\t\tJMenuBar mb= new JMenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setJMenuBar(mb);\n\t\n\t\tJLabel suiteLabel= new JLabel(\"Test class name:\");\n\t\tfSuiteCombo= createSuiteCombo();\n\t\tfRun= createRunButton();\n\t\tframe.getRootPane().setDefaultButton(fRun);\n\t\tComponent browseButton= createBrowseButton();\n\t\t\n\t\tfUseLoadingRunner= createUseLoaderCheckBox();\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\t\tfCounterPanel= createCounterPanel();\n\t\t\n\t\tJLabel failureLabel= new JLabel(\"Errors and Failures:\");\n\t\tfFailures= new DefaultListModel();\n\t\t\n\t\tfTestViewTab= createTestRunViews();\t\n\t\tJPanel failedPanel= createFailedPanel();\n\t\t\n\t\tfFailureView= createFailureDetailView();\n\t\tJScrollPane tracePane= new JScrollPane(fFailureView.getComponent(), JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n\t\tfStatusLine= createStatusLine();\n\t\tfQuitButton= createQuitButton();\n\t\tfLogo= createLogo();\n\t\t\t\t\t\n\t\tJPanel panel= new JPanel(new GridBagLayout());\n\t\n\t\taddGrid(panel, suiteLabel,\t0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fSuiteCombo, \t0, 1, 1, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, browseButton, \t1, 1, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, fUseLoadingRunner,  \t0, 2, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, new JSeparator(), \t0, 3, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\n\t\t\n\t\taddGrid(panel, fProgressIndicator, \t0, 4, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t2, 4, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, fCounterPanel,\t 0, 5, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\tJSplitPane splitter= new JSplitPane(JSplitPane.VERTICAL_SPLIT, fTestViewTab, tracePane);\n\t\taddGrid(panel, splitter, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\t\t\t\t\n\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.NORTH/*CENTER*/);\n\t\t\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\t\n\t\tframe.setContentPane(panel);\n\t\tframe.pack();\n\t\tframe.setLocation(200, 200);\n\t\treturn frame;\n\t}\n\n\tprivate void addGrid(JPanel p, Component co, int x, int y, int w, int fill, double wx, int anchor) {\n\t\tGridBagConstraints c= new GridBagConstraints();\n\t\tc.gridx= x; c.gridy= y;\n\t\tc.gridwidth= w;\n\t\tc.anchor= anchor;\n\t\tc.weightx= wx;\n\t\tc.fill= fill;\n\t\tif (fill == GridBagConstraints.BOTH || fill == GridBagConstraints.VERTICAL)\n\t\t\tc.weighty= 1.0;\n\t\tc.insets= new Insets(y == 0 ? GAP : 0, x == 0 ? GAP : 0, GAP, GAP);\n\t\tp.add(co, c);\n\t}\n\n\tprotected String getSuiteText() {\n\t\tif (fSuiteCombo == null)\n\t\t\treturn \"\";\n\t\treturn (String)fSuiteCombo.getEditor().getItem();\n\t}\n\t\n\tpublic ListModel getFailures() {\n\t\treturn fFailures;\n\t}\n\t\n\tpublic void insertUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\t\n\tpublic void browseTestClasses() {\n\t\tTestCollector collector= createTestCollector();\t\t\n\t\tTestSelector selector= new TestSelector(fFrame, collector);\n\t\tif (selector.isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(fFrame, \"No Test Cases found.\\nCheck that the configured \\'TestCollector\\' is supported on this platform.\");\n\t\t\treturn;\n\t\t}\n\t\tselector.show();\n\t\tString className= selector.getSelectedItem();\n\t\tif (className != null)\n\t\t\tsetSuite(className);\n\t}\n\n\tTestCollector createTestCollector() {\n\t\tString className= BaseTestRunner.getPreference(TESTCOLLECTOR_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass collectorClass= null;\n\t\t\ttry {\n\t\t\t\tcollectorClass= Class.forName(className);\n\t\t\t\treturn (TestCollector)collectorClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create TestCollector - using default collector\");\n\t\t\t}\n\t\t}\n\t\treturn new SimpleTestCollector();\n\t}\n\t\n\tprivate Image loadFrameIcon() {\n\t\tImageIcon icon= (ImageIcon)getIconResource(BaseTestRunner.class, \"smalllogo.gif\");\n\t\tif (icon != null)\n\t\t\treturn icon.getImage();\n\t\treturn null;\n\t}\n\t\n\tprivate void loadHistory(JComboBox combo) throws IOException {\n\t\tBufferedReader br= new BufferedReader(new FileReader(getSettingsFile()));\n\t\tint itemCount= 0;\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tcombo.addItem(line);\n\t\t\t\titemCount++;\n\t\t\t}\n\t\t\tif (itemCount > 0)\n\t\t\t\tcombo.setSelectedIndex(0);\n\n\t\t} finally {\n\t\t\tbr.close();\n\t\t}\n\t}\n\t\n\tprivate File getSettingsFile() {\n\t \tString home= System.getProperty(\"user.home\");\n \t\treturn new File(home,\".junitsession\");\n \t}\n\t\n\tprivate void postInfo(final String message) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowInfo(message);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void postStatus(final String status) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowStatus(status);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void removeUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\n\tprivate void rerun() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tTest rerunTest= view.getSelectedTest();\n\t\tif (rerunTest != null)\n\t\t\trerunTest(rerunTest);\n\t}\n\t\n\tprivate void rerunTest(Test test) {\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= getLoader().reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tObject[] args= new Object[]{((TestCase)test).name()};\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\treloadedTest=(Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\t\t\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1) \n\t\t\tshowStatus(message+\" had an error\"); \n\t\telse \n\t\t\tshowStatus(message+\" had a failure\");\n\t}\n\n\tprotected void reset() {\n\t\tfCounterPanel.reset();\n\t\tfProgressIndicator.reset();\n\t\tfRerunButton.setEnabled(false);\n\t\tfFailureView.clear();\n\t\tfFailures.clear();\n\t}\n\t\n\t/**\n\t * runs a suite.\n\t * @deprecated use runSuite() instead\n\t */\n\tpublic void run() {\n\t\trunSuite();\n\t}\n\t\n\tprotected void runFailed(String message) {\n\t\tshowStatus(message);\n\t\tfRun.setText(\"Run\");\n\t\tfRunner= null;\n\t}\n\t\n\tsynchronized public void runSuite() {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\tif (!setUseLoadingRunner())\n\t\t\t\treturn;\n\t\t\treset();\n\t\t\tshowInfo(\"Load Test Case...\");\n\t\t\tfinal String suiteName= getSuiteText();\n\t\t\tfinal Test testSuite= getTest(suiteName);\t\t\n\t\t\tif (testSuite != null) {\n\t\t\t\taddToHistory(suiteName);\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean setUseLoadingRunner() {\n\t\tsetLoading(fUseLoadingRunner.isSelected());\n\t\tif (!fUseLoadingRunner.isSelected())\n\t\t\tfNonLoadingRuns++;\n\t\tif (fNonLoadingRuns > 1) {\n\t\t\tString message= \"You are running the tests more than once with the standard class loader.\\n\"+\n\t\t\t\t\t    \"Code modifications you made since the last run will be ignored.\\n\"+\n\t\t\t\t\t    \"It is recommended to restart the TestRunner.\\nDo you still want to continue?\";\n\t\t\tint returnCode= JOptionPane.showConfirmDialog(fFrame, message, \"Warning\", JOptionPane.YES_NO_OPTION);\n\t\t\treturn returnCode == JOptionPane.YES_OPTION;\n\t\t}\n\t\treturn true;\n\t}\n\n\tsynchronized protected void runTest(final Test testSuite) {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\treset();\t\n\t\t\tif (testSuite != null) {\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void doRunTest(final Test testSuite) {\n\t\tsetButtonLabel(fRun, \"Stop\");\n\t\tfRunner= new Thread(\"TestRunner-Thread\") {\n\t\t\tpublic void run() {\n\t\t\t\tTestRunner.this.start(testSuite); \n\t\t\t\tpostInfo(\"Running...\");\n\t\t\t\t\n\t\t\t\tlong startTime= System.currentTimeMillis();\n\t\t\t\ttestSuite.run(fTestResult);\n\t\t\t\t\t\n\t\t\t\tif (fTestResult.shouldStop()) {\n\t\t\t\t\tpostStatus(\"Stopped\");\n\t\t\t\t} else {\n\t\t\t\t\tlong endTime= System.currentTimeMillis();\n\t\t\t\t\tlong runTime= endTime-startTime;\n\t\t\t\t\tpostInfo(\"Finished: \" + elapsedTimeAsString(runTime) + \" seconds\");\n\t\t\t\t}\n\t\t\t\trunFinished(testSuite);\n\t\t\t\tsetButtonLabel(fRun, \"Run\");\n\t\t\t\tfRunner= null;\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t};\n\t\t// make sure that the test result is created before we start the\n\t\t// test runner thread so that listeners can register for it.\n\t\tfTestResult= createTestResult();\n\t\tfTestResult.addListener(TestRunner.this);\n\t\taboutToStart(testSuite);\n\n\t\tfRunner.start();\n\t}\n\n\tprivate void saveHistory() throws IOException {\n\t\tBufferedWriter bw= new BufferedWriter(new FileWriter(getSettingsFile()));\n\t\ttry {\n\t\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\t\tString testsuite= fSuiteCombo.getItemAt(i).toString();\n\t\t\t\tbw.write(testsuite, 0, testsuite.length());\n\t\t\t\tbw.newLine();\n\t\t\t}\n\t\t} finally {\n\t\t\tbw.close();\n\t\t}\n\t}\n\t\n\tprivate void setButtonLabel(final JButton button, final String label) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbutton.setText(label);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void setLabelValue(final JTextField label, final int value) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tlabel.setText(Integer.toString(value));\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\t\n\tpublic void handleTestSelected(Test test) {\n\t\tfRerunButton.setEnabled(test != null && (test instanceof TestCase));\n\t\tshowFailureDetail(test);\n\t}\n\n\tprivate void showFailureDetail(Test test) {\n\t\tif (test != null) {\n\t\t\tListModel failures= getFailures();\n\t\t\tfor (int i= 0; i < failures.getSize(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure)failures.getElementAt(i);\n\t\t\t\tif (failure.failedTest() == test) {\n\t\t\t\t\tfFailureView.showFailure(failure);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfFailureView.clear();\n\t}\n\t\t\n\tprivate void showInfo(String message) {\n\t\tfStatusLine.showInfo(message);\n\t}\n\t\n\tprivate void showStatus(String status) {\n\t\tfStatusLine.showError(status);\n\t}\n\t\n\t/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\t\t\n\t\tString suiteName= processArguments(args);\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.pack(); \n\t\tfFrame.setVisible(true);\n\n\t\tif (suiteName != null) {\n\t\t\tsetSuite(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}\n\t\t\n\tprivate void start(final Test test) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfProgressIndicator.start(test.countTestCases());\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\t/**\n\t * Wait until all the events are processed in the event thread\n\t */\n\tprivate void synchUI() {\n\t\ttry {\n\t\t\tSwingUtilities.invokeAndWait(\n\t\t\t\tnew Runnable() {\n\t\t\t\t\tpublic void run() {}\n\t\t\t\t}\t\t\n\t\t\t);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t}\n\t\n\t/**\n\t * Terminates the TestRunner\n\t */\n\tpublic void terminate() {\n\t\tfFrame.dispose();\n\t\ttry {\n\t\t\tsaveHistory();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Couldn't save test run history\");\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tpublic void textChanged() {\n\t\tfRun.setEnabled(getSuiteText().length() > 0);\n\t\tclearStatus();\n\t}\n\t\n\tprotected void clearStatus() {\n\t\tfStatusLine.clear();\n\t}\n\t\n\tpublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}\n\t\n\tprivate void about() {\n\t\tAboutDialog about= new AboutDialog(fFrame); \n\t\tabout.show();\n\t}\n\t\n\n}\n","Method after Refactoring":"package junit.swingui;\n\nimport junit.framework.*;\nimport junit.runner.*;\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport java.text.NumberFormat;\nimport java.net.URL;\nimport java.io.*;\n\nimport javax.swing.*;\nimport javax.swing.event.*;\nimport javax.swing.text.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\n\n/**\n * A Swing based user interface to run tests.\n * Enter the name of a class which either provides a static\n * suite method or is a subclass of TestCase.\n * <pre>\n * Synopsis: java junit.swingui.TestRunner [-noloading] [TestCase]\n * <\/pre>\n * TestRunner takes as an optional argument the name of the testcase class to be run.\n */\npublic class TestRunner extends BaseTestRunner implements TestRunContext {\n\tprotected JFrame fFrame;\n\tprivate Thread fRunner;\n\tprivate TestResult fTestResult;\n\t\n\tprivate JComboBox fSuiteCombo;\n\tprivate ProgressBar fProgressIndicator;\n\tprivate DefaultListModel fFailures;\n\tprivate JLabel fLogo;\n\tprivate CounterPanel fCounterPanel;\n\tprivate JButton fRun;\n\tprivate JButton fQuitButton;\n\tprivate JButton fRerunButton;\n\tprivate StatusLine fStatusLine;\n\tprivate FailureDetailView fFailureView;\n\tprivate JTabbedPane fTestViewTab;\n\tprivate JCheckBox fUseLoadingRunner;\n\tprivate Vector fTestRunViews= new Vector(); // view associated with tab in tabbed pane\n\tprivate static Font PLAIN_FONT= StatusLine.PLAIN_FONT;\n\tprivate static Font BOLD_FONT= StatusLine.BOLD_FONT;\n\tprivate static final int GAP= 4;\n\tprivate static final int HISTORY_LENGTH= 5;\n\n\tprivate static final String TESTCOLLECTOR_KEY= \"TestCollectorClass\";\n\tprivate static final String FAILUREDETAILVIEW_KEY= \"FailureViewClass\";\n\t\t\n\tpublic TestRunner() {\n\t} \n\t\n\tpublic static void main(String[] args) {\n\t\tnew TestRunner().start(args);\n\t}\n\t \n\tpublic static void run(Class test) {\n\t\tString args[]= { test.getName() };\n\t\tmain(args);\n\t}\n\t\n\tpublic void addError(final Test test, final Throwable t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setErrorValue(fTestResult.errorCount());\n\t\t\t\t\tappendFailure(\"Error\", test, t);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void addFailure(final Test test, final AssertionFailedError t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setFailureValue(fTestResult.failureCount());\n\t\t\t\t\tappendFailure(\"Failure\", test, t);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t);\n\t}\n\t\n\tpublic void startTest(Test test) {\n\t\tpostInfo(\"Running: \"+test);\n\t}\n\t\n\tpublic void endTest(Test test) {\n\t\tpostEndTest(test);\n\t}\n\n\tprivate void postEndTest(final Test test) {\n\t\tsynchUI();\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (fTestResult != null) {\n\t\t\t\t\t\tfCounterPanel.setRunValue(fTestResult.runCount());\n\t\t\t\t\t\tfProgressIndicator.step(fTestResult.wasSuccessful());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tpublic void setSuite(String suiteName) {\n\t\tfSuiteCombo.getEditor().setItem(suiteName);\n\t}\n\n\tprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\t\n\tprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\t\n\tprivate void appendFailure(String kind, Test test, Throwable t) {\n\t\tfFailures.addElement(new TestFailure(test, t));\n\t\tif (fFailures.size() == 1) \n\t\t\trevealFailure(test);\n\t}\n\t\n\tprivate void revealFailure(Test test) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.revealFailure(test);\n\t\t}\n\t}\n\t\t\n\tprotected void aboutToStart(final Test testSuite) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.aboutToStart(testSuite, fTestResult);\n\t\t}\n\t}\n\t\n\tprotected void runFinished(final Test testSuite) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\t\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\t\t\t\tv.runFinished(testSuite, fTestResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tprotected CounterPanel createCounterPanel() {\n\t\treturn new CounterPanel();\n\t}\n\t\n\tprotected JPanel createFailedPanel() {\n\t\tJPanel failedPanel= new JPanel(new GridLayout(0, 1, 0, 2));\n\t\tfRerunButton= new JButton(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfailedPanel.add(fRerunButton);\n\t\treturn failedPanel;\n\t}\n\t\t\t\n\tprotected FailureDetailView createFailureDetailView() {\n\t\tString className= BaseTestRunner.getPreference(FAILUREDETAILVIEW_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass viewClass= null;\n\t\t\ttry {\n\t\t\t\tviewClass= Class.forName(className);\n\t\t\t\treturn (FailureDetailView)viewClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create Failure DetailView - using default view\");\n\t\t\t}\n\t\t}\n\t\treturn new DefaultFailureDetailView();\n\t}\n\n\t/**\n\t * Creates the JUnit menu. Clients override this\n\t * method to add additional menu items.\n\t */\n\tprotected JMenu createJUnitMenu() {\n\t\tJMenu menu= new JMenu(\"JUnit\");\n\t\tmenu.setMnemonic('J');\n\t\tJMenuItem mi1= new JMenuItem(\"About...\");\n\t\tmi1.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            about();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi1.setMnemonic('A');\n\t\tmenu.add(mi1);\n\t\t\n\t\tmenu.addSeparator();\n\t\tJMenuItem mi2= new JMenuItem(\" Exit \");\n\t\tmi2.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            terminate();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi2.setMnemonic('x');\n\t\tmenu.add(mi2);\n\n\t\treturn menu;\n\t}\n\t\n\tprotected JFrame createFrame(String title) {\n\t\tJFrame frame= new JFrame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\t\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\t\tframe.getContentPane().setLayout(new BorderLayout(0, 0));\n\t\t\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn frame;\n\t}\n\t\n\tprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\t\n\tprotected void createMenus(JMenuBar mb) {\n\t\tmb.add(createJUnitMenu());\n\t}\n\t\t\n\tprotected JCheckBox createUseLoaderCheckBox() {\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tJCheckBox box= new JCheckBox(\"Reload classes every run\", useLoader);\n\t\tbox.setToolTipText(\"Use a custom class loader to reload the classes for every run\");\n\t\tif (inVAJava())\n\t\t\tbox.setVisible(false);\n\t\treturn box;\n\t}\n\t\n\tprotected JButton createQuitButton() {\n\t\t // spaces required to avoid layout flicker\n\t\t // Exit is shorter than Stop that shows in the same column\n\t\tJButton quit= new JButton(\" Exit \"); \n\t\tquit.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn quit;\n\t}\n\t\n\tprotected JButton createRunButton() {\n\t\tJButton run= new JButton(\"Run\");\n\t\trun.setEnabled(true);\n\t\trun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn run;\n\t}\n\t\n\tprotected Component createBrowseButton() {\n\t\tJButton browse= new JButton(\"...\");\n\t\tbrowse.setToolTipText(\"Select a Test class\");\n\t\tbrowse.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tbrowseTestClasses();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn browse;\t\t\n\t}\n\t\n\tprotected StatusLine createStatusLine() {\n\t\treturn new StatusLine(420);\n\t}\n\t\n\tprotected JComboBox createSuiteCombo() {\n\t\tJComboBox combo= new JComboBox();\n\t\tcombo.setEditable(true);\n\t\tcombo.setLightWeightPopupEnabled(false);\n\t\t\n\t\tcombo.getEditor().getEditorComponent().addKeyListener(\n\t\t\tnew KeyAdapter() {\n\t\t\t\tpublic void keyTyped(KeyEvent e) {\n\t\t\t\t\ttextChanged();\n\t\t\t\t\tif (e.getKeyChar() == KeyEvent.VK_ENTER)\n\t\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\ttry {\n\t\t\tloadHistory(combo);\n\t\t} catch (IOException e) {\n\t\t\t// fails the first time\n\t\t}\n\t\tcombo.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent event) {\n\t\t\t\t\tif (event.getStateChange() == ItemEvent.SELECTED) {\n\t\t\t\t\t\ttextChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn combo;\n\t}\n\t\n\tprotected JTabbedPane createTestRunViews() {\n\t\tJTabbedPane pane= new JTabbedPane(JTabbedPane.BOTTOM);\n\n\t\tFailureRunView lv= new FailureRunView(this);\n\t\tfTestRunViews.addElement(lv);\n\t\tlv.addTab(pane);\n\t\t\n\t\tTestHierarchyRunView tv= new TestHierarchyRunView(this);\n\t\tfTestRunViews.addElement(tv);\n\t\ttv.addTab(pane);\n\t\t\n\t\tpane.addChangeListener(\n\t\t\tnew ChangeListener() {\n\t\t\t\tpublic void stateChanged(ChangeEvent e) {\n\t\t\t\t\ttestViewChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn pane;\n\t}\n\t\n\tpublic void testViewChanged() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tview.activate();\n\t}\n\t\n\tprotected TestResult createTestResult() {\n\t\treturn new TestResult();\n\t}\n\t\n\tprotected JFrame createUI(String suiteName) {\t\n\t\tJFrame frame= createFrame(\"JUnit\");\t\n\t\tJMenuBar mb= new JMenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setJMenuBar(mb);\n\t\n\t\tJLabel suiteLabel= new JLabel(\"Test class name:\");\n\t\tfSuiteCombo= createSuiteCombo();\n\t\tfRun= createRunButton();\n\t\tframe.getRootPane().setDefaultButton(fRun);\n\t\tComponent browseButton= createBrowseButton();\n\t\t\n\t\tfUseLoadingRunner= createUseLoaderCheckBox();\n\t\tfProgressIndicator= new ProgressBar();\n\t\tfCounterPanel= createCounterPanel();\n\t\t\n\t\tJLabel failureLabel= new JLabel(\"Errors and Failures:\");\n\t\tfFailures= new DefaultListModel();\n\t\t\n\t\tfTestViewTab= createTestRunViews();\t\n\t\tJPanel failedPanel= createFailedPanel();\n\t\t\n\t\tfFailureView= createFailureDetailView();\n\t\tJScrollPane tracePane= new JScrollPane(fFailureView.getComponent(), JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n\t\tfStatusLine= createStatusLine();\n\t\tfQuitButton= createQuitButton();\n\t\tfLogo= createLogo();\n\t\t\t\t\t\n\t\tJPanel panel= new JPanel(new GridBagLayout());\n\t\n\t\taddGrid(panel, suiteLabel,\t0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fSuiteCombo, \t0, 1, 1, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, browseButton, \t1, 1, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, fUseLoadingRunner,  \t0, 2, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, new JSeparator(), \t0, 3, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\n\t\t\n\t\taddGrid(panel, fProgressIndicator, \t0, 4, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t2, 4, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, fCounterPanel,\t 0, 5, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\tJSplitPane splitter= new JSplitPane(JSplitPane.VERTICAL_SPLIT, fTestViewTab, tracePane);\n\t\taddGrid(panel, splitter, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\t\t\t\t\n\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.NORTH/*CENTER*/);\n\t\t\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\t\n\t\tframe.setContentPane(panel);\n\t\tframe.pack();\n\t\tframe.setLocation(200, 200);\n\t\treturn frame;\n\t}\n\n\tprivate void addGrid(JPanel p, Component co, int x, int y, int w, int fill, double wx, int anchor) {\n\t\tGridBagConstraints c= new GridBagConstraints();\n\t\tc.gridx= x; c.gridy= y;\n\t\tc.gridwidth= w;\n\t\tc.anchor= anchor;\n\t\tc.weightx= wx;\n\t\tc.fill= fill;\n\t\tif (fill == GridBagConstraints.BOTH || fill == GridBagConstraints.VERTICAL)\n\t\t\tc.weighty= 1.0;\n\t\tc.insets= new Insets(y == 0 ? GAP : 0, x == 0 ? GAP : 0, GAP, GAP);\n\t\tp.add(co, c);\n\t}\n\n\tprotected String getSuiteText() {\n\t\tif (fSuiteCombo == null)\n\t\t\treturn \"\";\n\t\treturn (String)fSuiteCombo.getEditor().getItem();\n\t}\n\t\n\tpublic ListModel getFailures() {\n\t\treturn fFailures;\n\t}\n\t\n\tpublic void insertUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\t\n\tpublic void browseTestClasses() {\n\t\tTestCollector collector= createTestCollector();\t\t\n\t\tTestSelector selector= new TestSelector(fFrame, collector);\n\t\tif (selector.isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(fFrame, \"No Test Cases found.\\nCheck that the configured \\'TestCollector\\' is supported on this platform.\");\n\t\t\treturn;\n\t\t}\n\t\tselector.show();\n\t\tString className= selector.getSelectedItem();\n\t\tif (className != null)\n\t\t\tsetSuite(className);\n\t}\n\n\tTestCollector createTestCollector() {\n\t\tString className= BaseTestRunner.getPreference(TESTCOLLECTOR_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass collectorClass= null;\n\t\t\ttry {\n\t\t\t\tcollectorClass= Class.forName(className);\n\t\t\t\treturn (TestCollector)collectorClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create TestCollector - using default collector\");\n\t\t\t}\n\t\t}\n\t\treturn new SimpleTestCollector();\n\t}\n\t\n\tprivate Image loadFrameIcon() {\n\t\tImageIcon icon= (ImageIcon)getIconResource(BaseTestRunner.class, \"smalllogo.gif\");\n\t\tif (icon != null)\n\t\t\treturn icon.getImage();\n\t\treturn null;\n\t}\n\t\n\tprivate void loadHistory(JComboBox combo) throws IOException {\n\t\tBufferedReader br= new BufferedReader(new FileReader(getSettingsFile()));\n\t\tint itemCount= 0;\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tcombo.addItem(line);\n\t\t\t\titemCount++;\n\t\t\t}\n\t\t\tif (itemCount > 0)\n\t\t\t\tcombo.setSelectedIndex(0);\n\n\t\t} finally {\n\t\t\tbr.close();\n\t\t}\n\t}\n\t\n\tprivate File getSettingsFile() {\n\t \tString home= System.getProperty(\"user.home\");\n \t\treturn new File(home,\".junitsession\");\n \t}\n\t\n\tprivate void postInfo(final String message) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowInfo(message);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void postStatus(final String status) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowStatus(status);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void removeUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\n\tprivate void rerun() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tTest rerunTest= view.getSelectedTest();\n\t\tif (rerunTest != null)\n\t\t\trerunTest(rerunTest);\n\t}\n\t\n\tprivate void rerunTest(Test test) {\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= getLoader().reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tObject[] args= new Object[]{((TestCase)test).getName()};\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\treloadedTest=(Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\t\t\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1) \n\t\t\tshowStatus(message+\" had an error\"); \n\t\telse \n\t\t\tshowStatus(message+\" had a failure\");\n\t}\n\n\tprotected void reset() {\n\t\tfCounterPanel.reset();\n\t\tfProgressIndicator.reset();\n\t\tfRerunButton.setEnabled(false);\n\t\tfFailureView.clear();\n\t\tfFailures.clear();\n\t}\n\t\n\t/**\n\t * runs a suite.\n\t * @deprecated use runSuite() instead\n\t */\n\tpublic void run() {\n\t\trunSuite();\n\t}\n\t\n\tprotected void runFailed(String message) {\n\t\tshowStatus(message);\n\t\tfRun.setText(\"Run\");\n\t\tfRunner= null;\n\t}\n\t\n\tsynchronized public void runSuite() {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\tsetLoading(shouldReload());\n\t\t\treset();\n\t\t\tshowInfo(\"Load Test Case...\");\n\t\t\tfinal String suiteName= getSuiteText();\n\t\t\tfinal Test testSuite= getTest(suiteName);\t\t\n\t\t\tif (testSuite != null) {\n\t\t\t\taddToHistory(suiteName);\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean shouldReload() {\n\t\treturn !inVAJava() && fUseLoadingRunner.isSelected();\n\t}\n\t\n\n\tsynchronized protected void runTest(final Test testSuite) {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\treset();\t\n\t\t\tif (testSuite != null) {\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void doRunTest(final Test testSuite) {\n\t\tsetButtonLabel(fRun, \"Stop\");\n\t\tfRunner= new Thread(\"TestRunner-Thread\") {\n\t\t\tpublic void run() {\n\t\t\t\tTestRunner.this.start(testSuite); \n\t\t\t\tpostInfo(\"Running...\");\n\t\t\t\t\n\t\t\t\tlong startTime= System.currentTimeMillis();\n\t\t\t\ttestSuite.run(fTestResult);\n\t\t\t\t\t\n\t\t\t\tif (fTestResult.shouldStop()) {\n\t\t\t\t\tpostStatus(\"Stopped\");\n\t\t\t\t} else {\n\t\t\t\t\tlong endTime= System.currentTimeMillis();\n\t\t\t\t\tlong runTime= endTime-startTime;\n\t\t\t\t\tpostInfo(\"Finished: \" + elapsedTimeAsString(runTime) + \" seconds\");\n\t\t\t\t}\n\t\t\t\trunFinished(testSuite);\n\t\t\t\tsetButtonLabel(fRun, \"Run\");\n\t\t\t\tfRunner= null;\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t};\n\t\t// make sure that the test result is created before we start the\n\t\t// test runner thread so that listeners can register for it.\n\t\tfTestResult= createTestResult();\n\t\tfTestResult.addListener(TestRunner.this);\n\t\taboutToStart(testSuite);\n\n\t\tfRunner.start();\n\t}\n\n\tprivate void saveHistory() throws IOException {\n\t\tBufferedWriter bw= new BufferedWriter(new FileWriter(getSettingsFile()));\n\t\ttry {\n\t\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\t\tString testsuite= fSuiteCombo.getItemAt(i).toString();\n\t\t\t\tbw.write(testsuite, 0, testsuite.length());\n\t\t\t\tbw.newLine();\n\t\t\t}\n\t\t} finally {\n\t\t\tbw.close();\n\t\t}\n\t}\n\t\n\tprivate void setButtonLabel(final JButton button, final String label) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbutton.setText(label);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void setLabelValue(final JTextField label, final int value) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tlabel.setText(Integer.toString(value));\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\t\n\tpublic void handleTestSelected(Test test) {\n\t\tfRerunButton.setEnabled(test != null && (test instanceof TestCase));\n\t\tshowFailureDetail(test);\n\t}\n\n\tprivate void showFailureDetail(Test test) {\n\t\tif (test != null) {\n\t\t\tListModel failures= getFailures();\n\t\t\tfor (int i= 0; i < failures.getSize(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure)failures.getElementAt(i);\n\t\t\t\tif (failure.failedTest() == test) {\n\t\t\t\t\tfFailureView.showFailure(failure);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfFailureView.clear();\n\t}\n\t\t\n\tprivate void showInfo(String message) {\n\t\tfStatusLine.showInfo(message);\n\t}\n\t\n\tprivate void showStatus(String status) {\n\t\tfStatusLine.showError(status);\n\t}\n\t\n\t/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\t\t\n\t\tString suiteName= processArguments(args);\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.pack(); \n\t\tfFrame.setVisible(true);\n\n\t\tif (suiteName != null) {\n\t\t\tsetSuite(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}\n\t\t\n\tprivate void start(final Test test) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tint total= test.countTestCases();\n\t\t\t\t\tfProgressIndicator.start(total);\n\t\t\t\t\tfCounterPanel.setTotal(total);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\t/**\n\t * Wait until all the events are processed in the event thread\n\t */\n\tprivate void synchUI() {\n\t\ttry {\n\t\t\tSwingUtilities.invokeAndWait(\n\t\t\t\tnew Runnable() {\n\t\t\t\t\tpublic void run() {}\n\t\t\t\t}\t\t\n\t\t\t);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t}\n\t\n\t/**\n\t * Terminates the TestRunner\n\t */\n\tpublic void terminate() {\n\t\tfFrame.dispose();\n\t\ttry {\n\t\t\tsaveHistory();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Couldn't save test run history\");\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tpublic void textChanged() {\n\t\tfRun.setEnabled(getSuiteText().length() > 0);\n\t\tclearStatus();\n\t}\n\t\n\tprotected void clearStatus() {\n\t\tfStatusLine.clear();\n\t}\n\t\n\tpublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}\n\t\n\tprivate void about() {\n\t\tAboutDialog about= new AboutDialog(fFrame); \n\t\tabout.show();\n\t}\n\t\n\n}\n","lineNo":747}
{"Smelly Sample":"package junit.swingui;\n\nimport junit.framework.*;\nimport junit.runner.*;\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport java.text.NumberFormat;\nimport java.net.URL;\nimport java.io.*;\n\nimport javax.swing.*;\nimport javax.swing.event.*;\nimport javax.swing.text.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\n\n/**\n * A Swing based user interface to run tests.\n * Enter the name of a class which either provides a static\n * suite method or is a subclass of TestCase.\n * <pre>\n * Synopsis: java junit.swingui.TestRunner [-noloading] [TestCase]\n * <\/pre>\n * TestRunner takes as an optional argument the name of the testcase class to be run.\n */\npublic class TestRunner extends BaseTestRunner implements TestRunContext {\n\tprotected JFrame fFrame;\n\tprivate Thread fRunner;\n\tprivate TestResult fTestResult;\n\t\n\tprivate JComboBox fSuiteCombo;\n\tprivate ProgressBar fProgressIndicator;\n\tprivate DefaultListModel fFailures;\n\tprivate JLabel fLogo;\n\tprivate CounterPanel fCounterPanel;\n\tprivate JButton fRun;\n\tprivate JButton fQuitButton;\n\tprivate JButton fRerunButton;\n\tprivate StatusLine fStatusLine;\n\tprivate FailureDetailView fFailureView;\n\tprivate JTabbedPane fTestViewTab;\n\tprivate JCheckBox fUseLoadingRunner;\n\tprivate Vector fTestRunViews= new Vector(); // view associated with tab in tabbed pane\n\tprivate int fNonLoadingRuns= 0;\n\tprivate static Font PLAIN_FONT= StatusLine.PLAIN_FONT;\n\tprivate static Font BOLD_FONT= StatusLine.BOLD_FONT;\n\tprivate static final int GAP= 4;\n\tprivate static final int HISTORY_LENGTH= 5;\n\n\tprivate static final String TESTCOLLECTOR_KEY= \"TestCollectorClass\";\n\tprivate static final String FAILUREDETAILVIEW_KEY= \"FailureViewClass\";\n\t\t\n\tpublic TestRunner() {\n\t} \n\t\n\tpublic static void main(String[] args) {\n\t\tnew TestRunner().start(args);\n\t}\n\t \n\tpublic static void run(Class test) {\n\t\tString args[]= { test.getName() };\n\t\tmain(args);\n\t}\n\t\n\tpublic void addError(final Test test, final Throwable t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setErrorValue(fTestResult.errorCount());\n\t\t\t\t\tappendFailure(\"Error\", test, t);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void addFailure(final Test test, final AssertionFailedError t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setFailureValue(fTestResult.failureCount());\n\t\t\t\t\tappendFailure(\"Failure\", test, t);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t);\n\t}\n\t\n\tpublic void startTest(Test test) {\n\t\tpostInfo(\"Running: \"+test);\n\t}\n\t\n\tpublic void endTest(Test test) {\n\t\tpostEndTest(test);\n\t}\n\n\tprivate void postEndTest(final Test test) {\n\t\tsynchUI();\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (fTestResult != null) {\n\t\t\t\t\t\tfCounterPanel.setRunValue(fTestResult.runCount());\n\t\t\t\t\t\tfProgressIndicator.step(fTestResult.wasSuccessful());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tpublic void setSuite(String suiteName) {\n\t\tfSuiteCombo.getEditor().setItem(suiteName);\n\t}\n\n\tprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\t\n\tprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\t\n\tprivate void appendFailure(String kind, Test test, Throwable t) {\n\t\tfFailures.addElement(new TestFailure(test, t));\n\t\tif (fFailures.size() == 1) \n\t\t\trevealFailure(test);\n\t}\n\t\n\tprivate void revealFailure(Test test) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.revealFailure(test);\n\t\t}\n\t}\n\t\t\n\tpublic void changedUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\n\tprotected void aboutToStart(final Test testSuite) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.aboutToStart(testSuite, fTestResult);\n\t\t}\n\t}\n\t\n\tprotected void runFinished(final Test testSuite) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\t\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\t\t\t\tv.runFinished(testSuite, fTestResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tprotected CounterPanel createCounterPanel() {\n\t\treturn new CounterPanel();\n\t}\n\t\n\tprotected JPanel createFailedPanel() {\n\t\tJPanel failedPanel= new JPanel(new GridLayout(0, 1, 0, 2));\n\t\tfRerunButton= new JButton(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfailedPanel.add(fRerunButton);\n\t\treturn failedPanel;\n\t}\n\t\t\t\n\tprotected FailureDetailView createFailureDetailView() {\n\t\tString className= BaseTestRunner.getPreference(FAILUREDETAILVIEW_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass viewClass= null;\n\t\t\ttry {\n\t\t\t\tviewClass= Class.forName(className);\n\t\t\t\treturn (FailureDetailView)viewClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create Failure DetailView - using default view\");\n\t\t\t}\n\t\t}\n\t\treturn new DefaultFailureDetailView();\n\t}\n\n\t/**\n\t * Creates the JUnit menu. Clients override this\n\t * method to add additional menu items.\n\t */\n\tprotected JMenu createJUnitMenu() {\n\t\tJMenu menu= new JMenu(\"JUnit\");\n\t\tmenu.setMnemonic('J');\n\t\tJMenuItem mi1= new JMenuItem(\"About...\");\n\t\tmi1.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            about();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi1.setMnemonic('A');\n\t\tmenu.add(mi1);\n\t\t\n\t\tmenu.addSeparator();\n\t\tJMenuItem mi2= new JMenuItem(\"Exit\");\n\t\tmi2.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            terminate();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi2.setMnemonic('x');\n\t\tmenu.add(mi2);\n\n\t\treturn menu;\n\t}\n\t\n\tprotected JFrame createFrame(String title) {\n\t\tJFrame frame= new JFrame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\t\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\t\tframe.getContentPane().setLayout(new BorderLayout(0, 0));\n\t\t\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn frame;\n\t}\n\t\n\tprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\t\n\tprotected void createMenus(JMenuBar mb) {\n\t\tmb.add(createJUnitMenu());\n\t}\n\t\t\n\tprotected JCheckBox createUseLoaderCheckBox() {\n\t\tboolean useLoader= useReoadingTestSuiteLoader();\n\t\treturn new JCheckBox(\"Use custom class loader for loading tests\", useLoader);\n\t}\n\t\n\tprotected JButton createQuitButton() {\n\t\tJButton quit= new JButton(\" Exit \"); \n\t\tquit.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn quit;\n\t}\n\t\n\tprotected JButton createRunButton() {\n\t\tJButton run= new JButton(\"Run\");\n\t\trun.setEnabled(true);\n\t\trun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn run;\n\t}\n\t\n\tprotected Component createBrowseButton() {\n\t\tJButton browse= new JButton(\"...\");\n\t\tbrowse.setToolTipText(\"Select a Test class\");\n\t\tbrowse.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tbrowseTestClasses();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn browse;\t\t\n\t}\n\t\n\tprotected StatusLine createStatusLine() {\n\t\treturn new StatusLine(420);\n\t}\n\t\n\tprotected JComboBox createSuiteCombo() {\n\t\tJComboBox combo= new JComboBox();\n\t\tcombo.setEditable(true);\n\t\tcombo.setLightWeightPopupEnabled(false);\n\t\t\n\t\tcombo.getEditor().getEditorComponent().addKeyListener(\n\t\t\tnew KeyAdapter() {\n\t\t\t\tpublic void keyTyped(KeyEvent e) {\n\t\t\t\t\ttextChanged();\n\t\t\t\t\tif (e.getKeyChar() == KeyEvent.VK_ENTER)\n\t\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\ttry {\n\t\t\tloadHistory(combo);\n\t\t} catch (IOException e) {\n\t\t\t// fails the first time\n\t\t}\n\t\tcombo.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent event) {\n\t\t\t\t\tif (event.getStateChange() == ItemEvent.SELECTED) {\n\t\t\t\t\t\ttextChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn combo;\n\t}\n\t\n\tprotected JTabbedPane createTestRunViews() {\n\t\tJTabbedPane pane= new JTabbedPane(JTabbedPane.BOTTOM);\n\n\t\tFailureRunView lv= new FailureRunView(this);\n\t\tfTestRunViews.addElement(lv);\n\t\tlv.addTab(pane);\n\t\t\n\t\tTestHierarchyRunView tv= new TestHierarchyRunView(this);\n\t\tfTestRunViews.addElement(tv);\n\t\ttv.addTab(pane);\n\t\t\n\t\tpane.addChangeListener(\n\t\t\tnew ChangeListener() {\n\t\t\t\tpublic void stateChanged(ChangeEvent e) {\n\t\t\t\t\ttestViewChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn pane;\n\t}\n\t\n\tpublic void testViewChanged() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tview.activate();\n\t}\n\t\n\tprotected TestResult createTestResult() {\n\t\treturn new TestResult();\n\t}\n\t\n\tprotected JFrame createUI(String suiteName) {\t\n\t\tJFrame frame= createFrame(\"JUnit\");\t\n\t\tJMenuBar mb= new JMenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setJMenuBar(mb);\n\t\n\t\tJLabel suiteLabel= new JLabel(\"Test:\");\n\t\tfSuiteCombo= createSuiteCombo();\n\t\tfRun= createRunButton();\n\t\tframe.getRootPane().setDefaultButton(fRun);\n\t\tComponent browseButton= createBrowseButton();\n\t\t\n\t\tfUseLoadingRunner= createUseLoaderCheckBox();\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\t\tfCounterPanel= createCounterPanel();\n\t\t\n\t\tJLabel failureLabel= new JLabel(\"Errors and Failures:\");\n\t\tfFailures= new DefaultListModel();\n\t\t\n\t\tfTestViewTab= createTestRunViews();\t\n\t\tJPanel failedPanel= createFailedPanel();\n\t\t\n\t\tfFailureView= createFailureDetailView();\n\t\tJScrollPane tracePane= new JScrollPane(fFailureView.getComponent(), JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n\t\tfStatusLine= createStatusLine();\n\t\tfQuitButton= createQuitButton();\n\t\tfLogo= createLogo();\n\t\t\t\t\t\n\t\tJPanel panel= new JPanel(new GridBagLayout());\n\t\n\t\taddGrid(panel, suiteLabel,\t0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fSuiteCombo, \t0, 1, 1, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, browseButton, \t1, 1, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, fUseLoadingRunner,  \t0, 2, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, new JSeparator(), \t0, 3, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\n\t\t\n\t\taddGrid(panel, fProgressIndicator, \t0, 4, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t2, 4, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, fCounterPanel,\t 0, 5, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, fTestViewTab, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, tracePane, \t 0, 7, 2, GridBagConstraints.BOTH, \t        1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\t\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\t\n\t\tframe.setContentPane(panel);\n\t\tframe.pack();\n\t\tframe.setLocation(200, 200);\n\t\treturn frame;\n\t}\n\n\tprivate void addGrid(JPanel p, Component co, int x, int y, int w, int fill, double wx, int anchor) {\n\t\tGridBagConstraints c= new GridBagConstraints();\n\t\tc.gridx= x; c.gridy= y;\n\t\tc.gridwidth= w;\n\t\tc.anchor= anchor;\n\t\tc.weightx= wx;\n\t\tc.fill= fill;\n\t\tif (fill == GridBagConstraints.BOTH || fill == GridBagConstraints.VERTICAL)\n\t\t\tc.weighty= 1.0;\n\t\tc.insets= new Insets(y == 0 ? GAP : 0, x == 0 ? GAP : 0, GAP, GAP);\n\t\tp.add(co, c);\n\t}\n\n\tprotected String getSuiteText() {\n\t\tif (fSuiteCombo == null)\n\t\t\treturn \"\";\n\t\treturn (String)fSuiteCombo.getEditor().getItem();\n\t}\n\t\n\tpublic ListModel getFailures() {\n\t\treturn fFailures;\n\t}\n\t\n\tpublic void insertUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\t\n\tpublic void browseTestClasses() {\n\t\tTestCollector collector= createTestCollector();\t\t\n\t\tTestSelector selector= new TestSelector(fFrame, collector);\n\t\tif (selector.isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(fFrame, \"No Test Cases found.\\nCheck that the configured \\'TestCollector\\' is supported on this platform.\");\n\t\t\treturn;\n\t\t}\n\t\tselector.show();\n\t\tString className= selector.getSelectedItem();\n\t\tif (className != null)\n\t\t\tsetSuite(className);\n\t}\n\n\tTestCollector createTestCollector() {\n\t\tString className= BaseTestRunner.getPreference(TESTCOLLECTOR_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass collectorClass= null;\n\t\t\ttry {\n\t\t\t\tcollectorClass= Class.forName(className);\n\t\t\t\treturn (TestCollector)collectorClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create TestCollector - using default collector\");\n\t\t\t}\n\t\t}\n\t\treturn new SimpleTestCollector();\n\t}\n\t\n\tprivate Image loadFrameIcon() {\n\t\tImageIcon icon= (ImageIcon)getIconResource(BaseTestRunner.class, \"smalllogo.gif\");\n\t\tif (icon != null)\n\t\t\treturn icon.getImage();\n\t\treturn null;\n\t}\n\t\n\tprivate void loadHistory(JComboBox combo) throws IOException {\n\t\tBufferedReader br= new BufferedReader(new FileReader(getSettingsFile()));\n\t\tint itemCount= 0;\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tcombo.addItem(line);\n\t\t\t\titemCount++;\n\t\t\t}\n\t\t\tif (itemCount > 0)\n\t\t\t\tcombo.setSelectedIndex(0);\n\n\t\t} finally {\n\t\t\tbr.close();\n\t\t}\n\t}\n\t\n\tprivate File getSettingsFile() {\n\t \tString home= System.getProperty(\"user.home\");\n \t\treturn new File(home,\".junitsession\");\n \t}\n\t\n\tprivate void postInfo(final String message) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowInfo(message);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void postStatus(final String status) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowStatus(status);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void removeUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\n\tprivate void rerun() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tTest rerunTest= view.getSelectedTest();\n\t\tif (rerunTest != null)\n\t\t\trerunTest(rerunTest);\n\t}\n\t\n\tprivate void rerunTest(Test test) {\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= getLoader().reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tObject[] args= new Object[]{((TestCase)test).name()};\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\treloadedTest=(Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\t\t\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1) \n\t\t\tshowStatus(message+\" had an error\"); \n\t\telse \n\t\t\tshowStatus(message+\" had a failure\");\n\t}\n\n\tprotected void reset() {\n\t\tfCounterPanel.reset();\n\t\tfProgressIndicator.reset();\n\t\tfRerunButton.setEnabled(false);\n\t\tfFailureView.clear();\n\t\tfFailures.clear();\n\t}\n\t\n\t/**\n\t * runs a suite.\n\t * @deprecated use runSuite() instead\n\t */\n\tpublic void run() {\n\t\trunSuite();\n\t}\n\t\n\tprotected void runFailed(String message) {\n\t\tshowStatus(message);\n\t\tfRun.setText(\"Run\");\n\t\tfRunner= null;\n\t}\n\t\n\tsynchronized public void runSuite() {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\tif (!setUseLoadingRunner())\n\t\t\t\treturn;\n\t\t\treset();\n\t\t\tshowInfo(\"Load Test Case...\");\n\t\t\tfinal String suiteName= getSuiteText();\n\t\t\tfinal Test testSuite= getTest(suiteName);\t\t\n\t\t\tif (testSuite != null) {\n\t\t\t\taddToHistory(suiteName);\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean setUseLoadingRunner() {\n\t\tsetLoading(fUseLoadingRunner.isSelected());\n\t\tif (!fUseLoadingRunner.isSelected())\n\t\t\tfNonLoadingRuns++;\n\t\tif (fNonLoadingRuns > 1) {\n\t\t\tString message= \"You are running the tests more than once with the standard class loader.\\n\"+\n\t\t\t\t\t    \"Code modifications you made since the last run will be ignored.\\n\"+\n\t\t\t\t\t    \"It is recommended to restart the TestRunner.\\nDo you still want to continue?\";\n\t\t\tint returnCode= JOptionPane.showConfirmDialog(fFrame, message, \"Warning\", JOptionPane.YES_NO_OPTION);\n\t\t\treturn returnCode == JOptionPane.YES_OPTION;\n\t\t}\n\t\treturn true;\n\t}\n\n\tsynchronized protected void runTest(final Test testSuite) {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\treset();\t\n\t\t\tif (testSuite != null) {\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void doRunTest(final Test testSuite) {\n\t\tsetButtonLabel(fRun, \"Stop\");\n\t\tfRunner= new Thread(\"TestRunner-Thread\") {\n\t\t\tpublic void run() {\n\t\t\t\tTestRunner.this.start(testSuite); \n\t\t\t\tpostInfo(\"Running...\");\n\t\t\t\t\n\t\t\t\tlong startTime= System.currentTimeMillis();\n\t\t\t\ttestSuite.run(fTestResult);\n\t\t\t\t\t\n\t\t\t\tif (fTestResult.shouldStop()) {\n\t\t\t\t\tpostStatus(\"Stopped\");\n\t\t\t\t} else {\n\t\t\t\t\tlong endTime= System.currentTimeMillis();\n\t\t\t\t\tlong runTime= endTime-startTime;\n\t\t\t\t\tpostInfo(\"Finished: \" + elapsedTimeAsString(runTime) + \" seconds\");\n\t\t\t\t}\n\t\t\t\trunFinished(testSuite);\n\t\t\t\tsetButtonLabel(fRun, \"Run\");\n\t\t\t\tfRunner= null;\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t};\n\t\t// make sure that the test result is created before we start the\n\t\t// test runner thread so that listeners can register for it.\n\t\tfTestResult= createTestResult();\n\t\tfTestResult.addListener(TestRunner.this);\n\t\taboutToStart(testSuite);\n\n\t\tfRunner.start();\n\t}\n\n\tprivate void saveHistory() throws IOException {\n\t\tBufferedWriter bw= new BufferedWriter(new FileWriter(getSettingsFile()));\n\t\ttry {\n\t\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\t\tString testsuite= fSuiteCombo.getItemAt(i).toString();\n\t\t\t\tbw.write(testsuite, 0, testsuite.length());\n\t\t\t\tbw.newLine();\n\t\t\t}\n\t\t} finally {\n\t\t\tbw.close();\n\t\t}\n\t}\n\t\n\tprivate void setButtonLabel(final JButton button, final String label) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbutton.setText(label);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void setLabelValue(final JTextField label, final int value) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tlabel.setText(Integer.toString(value));\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\t\n\tpublic void handleTestSelected(Test test) {\n\t\tfRerunButton.setEnabled(test != null && (test instanceof TestCase));\n\t\tshowFailureDetail(test);\n\t}\n\n\tprivate void showFailureDetail(Test test) {\n\t\tif (test != null) {\n\t\t\tListModel failures= getFailures();\n\t\t\tfor (int i= 0; i < failures.getSize(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure)failures.getElementAt(i);\n\t\t\t\tif (failure.failedTest() == test) {\n\t\t\t\t\tfFailureView.showFailure(failure);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfFailureView.clear();\n\t}\n\t\t\n\tprivate void showInfo(String message) {\n\t\tfStatusLine.showInfo(message);\n\t}\n\t\n\tprivate void showStatus(String status) {\n\t\tfStatusLine.showError(status);\n\t}\n\t\n\t/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\t\t\n\t\tString suiteName= processArguments(args);\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.pack(); \n\t\tfFrame.setVisible(true);\n\n\t\tif (suiteName != null) {\n\t\t\tsetSuite(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}\n\t\t\n\tprivate void start(final Test test) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfProgressIndicator.start(test.countTestCases());\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\t/**\n\t * Wait until all the events are processed in the event thread\n\t */\n\tprivate void synchUI() {\n\t\ttry {\n\t\t\tSwingUtilities.invokeAndWait(\n\t\t\t\tnew Runnable() {\n\t\t\t\t\tpublic void run() {}\n\t\t\t\t}\t\t\n\t\t\t);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t}\n\t\n\t/**\n\t * Terminates the TestRunner\n\t */\n\tpublic void terminate() {\n\t\tfFrame.dispose();\n\t\ttry {\n\t\t\tsaveHistory();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Couldn't save test run history\");\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tpublic void textChanged() {\n\t\tfRun.setEnabled(getSuiteText().length() > 0);\n\t\tclearStatus();\n\t}\n\t\n\tprotected void clearStatus() {\n\t\tfStatusLine.clear();\n\t}\n\t\n\tpublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}\n\t\n\tprivate void about() {\n\t\tAboutDialog about= new AboutDialog(fFrame); \n\t\tabout.show();\n\t}\n\t\n\n}\n","Method after Refactoring":"package junit.swingui;\n\nimport junit.framework.*;\nimport junit.runner.*;\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport java.text.NumberFormat;\nimport java.net.URL;\nimport java.io.*;\n\nimport javax.swing.*;\nimport javax.swing.event.*;\nimport javax.swing.text.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\n\n/**\n * A Swing based user interface to run tests.\n * Enter the name of a class which either provides a static\n * suite method or is a subclass of TestCase.\n * <pre>\n * Synopsis: java junit.swingui.TestRunner [-noloading] [TestCase]\n * <\/pre>\n * TestRunner takes as an optional argument the name of the testcase class to be run.\n */\npublic class TestRunner extends BaseTestRunner implements TestRunContext {\n\tprotected JFrame fFrame;\n\tprivate Thread fRunner;\n\tprivate TestResult fTestResult;\n\t\n\tprivate JComboBox fSuiteCombo;\n\tprivate ProgressBar fProgressIndicator;\n\tprivate DefaultListModel fFailures;\n\tprivate JLabel fLogo;\n\tprivate CounterPanel fCounterPanel;\n\tprivate JButton fRun;\n\tprivate JButton fQuitButton;\n\tprivate JButton fRerunButton;\n\tprivate StatusLine fStatusLine;\n\tprivate FailureDetailView fFailureView;\n\tprivate JTabbedPane fTestViewTab;\n\tprivate JCheckBox fUseLoadingRunner;\n\tprivate Vector fTestRunViews= new Vector(); // view associated with tab in tabbed pane\n\tprivate int fNonLoadingRuns= 0;\n\tprivate static Font PLAIN_FONT= StatusLine.PLAIN_FONT;\n\tprivate static Font BOLD_FONT= StatusLine.BOLD_FONT;\n\tprivate static final int GAP= 4;\n\tprivate static final int HISTORY_LENGTH= 5;\n\n\tprivate static final String TESTCOLLECTOR_KEY= \"TestCollectorClass\";\n\tprivate static final String FAILUREDETAILVIEW_KEY= \"FailureViewClass\";\n\t\t\n\tpublic TestRunner() {\n\t} \n\t\n\tpublic static void main(String[] args) {\n\t\tnew TestRunner().start(args);\n\t}\n\t \n\tpublic static void run(Class test) {\n\t\tString args[]= { test.getName() };\n\t\tmain(args);\n\t}\n\t\n\tpublic void addError(final Test test, final Throwable t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setErrorValue(fTestResult.errorCount());\n\t\t\t\t\tappendFailure(\"Error\", test, t);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void addFailure(final Test test, final AssertionFailedError t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setFailureValue(fTestResult.failureCount());\n\t\t\t\t\tappendFailure(\"Failure\", test, t);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t);\n\t}\n\t\n\tpublic void startTest(Test test) {\n\t\tpostInfo(\"Running: \"+test);\n\t}\n\t\n\tpublic void endTest(Test test) {\n\t\tpostEndTest(test);\n\t}\n\n\tprivate void postEndTest(final Test test) {\n\t\tsynchUI();\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (fTestResult != null) {\n\t\t\t\t\t\tfCounterPanel.setRunValue(fTestResult.runCount());\n\t\t\t\t\t\tfProgressIndicator.step(fTestResult.wasSuccessful());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tpublic void setSuite(String suiteName) {\n\t\tfSuiteCombo.getEditor().setItem(suiteName);\n\t}\n\n\tprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\t\n\tprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\t\n\tprivate void appendFailure(String kind, Test test, Throwable t) {\n\t\tfFailures.addElement(new TestFailure(test, t));\n\t\tif (fFailures.size() == 1) \n\t\t\trevealFailure(test);\n\t}\n\t\n\tprivate void revealFailure(Test test) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.revealFailure(test);\n\t\t}\n\t}\n\t\t\n\tpublic void changedUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\n\tprotected void aboutToStart(final Test testSuite) {\n\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\tv.aboutToStart(testSuite, fTestResult);\n\t\t}\n\t}\n\t\n\tprotected void runFinished(final Test testSuite) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor (Enumeration e= fTestRunViews.elements(); e.hasMoreElements(); ) {\n\t\t\t\t\t\tTestRunView v= (TestRunView) e.nextElement();\n\t\t\t\t\t\tv.runFinished(testSuite, fTestResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tprotected CounterPanel createCounterPanel() {\n\t\treturn new CounterPanel();\n\t}\n\t\n\tprotected JPanel createFailedPanel() {\n\t\tJPanel failedPanel= new JPanel(new GridLayout(0, 1, 0, 2));\n\t\tfRerunButton= new JButton(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfailedPanel.add(fRerunButton);\n\t\treturn failedPanel;\n\t}\n\t\t\t\n\tprotected FailureDetailView createFailureDetailView() {\n\t\tString className= BaseTestRunner.getPreference(FAILUREDETAILVIEW_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass viewClass= null;\n\t\t\ttry {\n\t\t\t\tviewClass= Class.forName(className);\n\t\t\t\treturn (FailureDetailView)viewClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create Failure DetailView - using default view\");\n\t\t\t}\n\t\t}\n\t\treturn new DefaultFailureDetailView();\n\t}\n\n\t/**\n\t * Creates the JUnit menu. Clients override this\n\t * method to add additional menu items.\n\t */\n\tprotected JMenu createJUnitMenu() {\n\t\tJMenu menu= new JMenu(\"JUnit\");\n\t\tmenu.setMnemonic('J');\n\t\tJMenuItem mi1= new JMenuItem(\"About...\");\n\t\tmi1.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            about();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi1.setMnemonic('A');\n\t\tmenu.add(mi1);\n\t\t\n\t\tmenu.addSeparator();\n\t\tJMenuItem mi2= new JMenuItem(\" Exit \");\n\t\tmi2.addActionListener(\n\t\t    new ActionListener() {\n\t\t        public void actionPerformed(ActionEvent event) {\n\t\t            terminate();\n\t\t        }\n\t\t    }\n\t\t);\n\t\tmi2.setMnemonic('x');\n\t\tmenu.add(mi2);\n\n\t\treturn menu;\n\t}\n\t\n\tprotected JFrame createFrame(String title) {\n\t\tJFrame frame= new JFrame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\t\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\t\tframe.getContentPane().setLayout(new BorderLayout(0, 0));\n\t\t\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn frame;\n\t}\n\t\n\tprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\t\n\tprotected void createMenus(JMenuBar mb) {\n\t\tmb.add(createJUnitMenu());\n\t}\n\t\t\n\tprotected JCheckBox createUseLoaderCheckBox() {\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tJCheckBox box= new JCheckBox(\"Reload classes every run\", useLoader);\n\t\tbox.setToolTipText(\"Use a custom class loader to reload the classes for every run\");\n\t\treturn box;\n\t}\n\t\n\tprotected JButton createQuitButton() {\n\t\t // spaces required to avoid layout flicker\n\t\t // Exit is shorter than Stop that shows in the same column\n\t\tJButton quit= new JButton(\" Exit \"); \n\t\tquit.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn quit;\n\t}\n\t\n\tprotected JButton createRunButton() {\n\t\tJButton run= new JButton(\"Run\");\n\t\trun.setEnabled(true);\n\t\trun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn run;\n\t}\n\t\n\tprotected Component createBrowseButton() {\n\t\tJButton browse= new JButton(\"...\");\n\t\tbrowse.setToolTipText(\"Select a Test class\");\n\t\tbrowse.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tbrowseTestClasses();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn browse;\t\t\n\t}\n\t\n\tprotected StatusLine createStatusLine() {\n\t\treturn new StatusLine(420);\n\t}\n\t\n\tprotected JComboBox createSuiteCombo() {\n\t\tJComboBox combo= new JComboBox();\n\t\tcombo.setEditable(true);\n\t\tcombo.setLightWeightPopupEnabled(false);\n\t\t\n\t\tcombo.getEditor().getEditorComponent().addKeyListener(\n\t\t\tnew KeyAdapter() {\n\t\t\t\tpublic void keyTyped(KeyEvent e) {\n\t\t\t\t\ttextChanged();\n\t\t\t\t\tif (e.getKeyChar() == KeyEvent.VK_ENTER)\n\t\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\ttry {\n\t\t\tloadHistory(combo);\n\t\t} catch (IOException e) {\n\t\t\t// fails the first time\n\t\t}\n\t\tcombo.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent event) {\n\t\t\t\t\tif (event.getStateChange() == ItemEvent.SELECTED) {\n\t\t\t\t\t\ttextChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn combo;\n\t}\n\t\n\tprotected JTabbedPane createTestRunViews() {\n\t\tJTabbedPane pane= new JTabbedPane(JTabbedPane.BOTTOM);\n\n\t\tFailureRunView lv= new FailureRunView(this);\n\t\tfTestRunViews.addElement(lv);\n\t\tlv.addTab(pane);\n\t\t\n\t\tTestHierarchyRunView tv= new TestHierarchyRunView(this);\n\t\tfTestRunViews.addElement(tv);\n\t\ttv.addTab(pane);\n\t\t\n\t\tpane.addChangeListener(\n\t\t\tnew ChangeListener() {\n\t\t\t\tpublic void stateChanged(ChangeEvent e) {\n\t\t\t\t\ttestViewChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn pane;\n\t}\n\t\n\tpublic void testViewChanged() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tview.activate();\n\t}\n\t\n\tprotected TestResult createTestResult() {\n\t\treturn new TestResult();\n\t}\n\t\n\tprotected JFrame createUI(String suiteName) {\t\n\t\tJFrame frame= createFrame(\"JUnit\");\t\n\t\tJMenuBar mb= new JMenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setJMenuBar(mb);\n\t\n\t\tJLabel suiteLabel= new JLabel(\"Test class name:\");\n\t\tfSuiteCombo= createSuiteCombo();\n\t\tfRun= createRunButton();\n\t\tframe.getRootPane().setDefaultButton(fRun);\n\t\tComponent browseButton= createBrowseButton();\n\t\t\n\t\tfUseLoadingRunner= createUseLoaderCheckBox();\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\t\tfCounterPanel= createCounterPanel();\n\t\t\n\t\tJLabel failureLabel= new JLabel(\"Errors and Failures:\");\n\t\tfFailures= new DefaultListModel();\n\t\t\n\t\tfTestViewTab= createTestRunViews();\t\n\t\tJPanel failedPanel= createFailedPanel();\n\t\t\n\t\tfFailureView= createFailureDetailView();\n\t\tJScrollPane tracePane= new JScrollPane(fFailureView.getComponent(), JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n\t\tfStatusLine= createStatusLine();\n\t\tfQuitButton= createQuitButton();\n\t\tfLogo= createLogo();\n\t\t\t\t\t\n\t\tJPanel panel= new JPanel(new GridBagLayout());\n\t\n\t\taddGrid(panel, suiteLabel,\t0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fSuiteCombo, \t0, 1, 1, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, browseButton, \t1, 1, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, fUseLoadingRunner,  \t0, 2, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, new JSeparator(), \t0, 3, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n\n\t\t\n\t\taddGrid(panel, fProgressIndicator, \t0, 4, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t2, 4, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, fCounterPanel,\t 0, 5, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\tJSplitPane splitter= new JSplitPane(JSplitPane.VERTICAL_SPLIT, fTestViewTab, tracePane);\n\t\taddGrid(panel, splitter, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\t\t\t\t\n\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.NORTH/*CENTER*/);\n\t\t\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\t\n\t\tframe.setContentPane(panel);\n\t\tframe.pack();\n\t\tframe.setLocation(200, 200);\n\t\treturn frame;\n\t}\n\n\tprivate void addGrid(JPanel p, Component co, int x, int y, int w, int fill, double wx, int anchor) {\n\t\tGridBagConstraints c= new GridBagConstraints();\n\t\tc.gridx= x; c.gridy= y;\n\t\tc.gridwidth= w;\n\t\tc.anchor= anchor;\n\t\tc.weightx= wx;\n\t\tc.fill= fill;\n\t\tif (fill == GridBagConstraints.BOTH || fill == GridBagConstraints.VERTICAL)\n\t\t\tc.weighty= 1.0;\n\t\tc.insets= new Insets(y == 0 ? GAP : 0, x == 0 ? GAP : 0, GAP, GAP);\n\t\tp.add(co, c);\n\t}\n\n\tprotected String getSuiteText() {\n\t\tif (fSuiteCombo == null)\n\t\t\treturn \"\";\n\t\treturn (String)fSuiteCombo.getEditor().getItem();\n\t}\n\t\n\tpublic ListModel getFailures() {\n\t\treturn fFailures;\n\t}\n\t\n\tpublic void insertUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\t\n\tpublic void browseTestClasses() {\n\t\tTestCollector collector= createTestCollector();\t\t\n\t\tTestSelector selector= new TestSelector(fFrame, collector);\n\t\tif (selector.isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(fFrame, \"No Test Cases found.\\nCheck that the configured \\'TestCollector\\' is supported on this platform.\");\n\t\t\treturn;\n\t\t}\n\t\tselector.show();\n\t\tString className= selector.getSelectedItem();\n\t\tif (className != null)\n\t\t\tsetSuite(className);\n\t}\n\n\tTestCollector createTestCollector() {\n\t\tString className= BaseTestRunner.getPreference(TESTCOLLECTOR_KEY);\n\t\tif (className != null) {\t\t\t\n\t\t\tClass collectorClass= null;\n\t\t\ttry {\n\t\t\t\tcollectorClass= Class.forName(className);\n\t\t\t\treturn (TestCollector)collectorClass.newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\tJOptionPane.showMessageDialog(fFrame, \"Could not create TestCollector - using default collector\");\n\t\t\t}\n\t\t}\n\t\treturn new SimpleTestCollector();\n\t}\n\t\n\tprivate Image loadFrameIcon() {\n\t\tImageIcon icon= (ImageIcon)getIconResource(BaseTestRunner.class, \"smalllogo.gif\");\n\t\tif (icon != null)\n\t\t\treturn icon.getImage();\n\t\treturn null;\n\t}\n\t\n\tprivate void loadHistory(JComboBox combo) throws IOException {\n\t\tBufferedReader br= new BufferedReader(new FileReader(getSettingsFile()));\n\t\tint itemCount= 0;\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tcombo.addItem(line);\n\t\t\t\titemCount++;\n\t\t\t}\n\t\t\tif (itemCount > 0)\n\t\t\t\tcombo.setSelectedIndex(0);\n\n\t\t} finally {\n\t\t\tbr.close();\n\t\t}\n\t}\n\t\n\tprivate File getSettingsFile() {\n\t \tString home= System.getProperty(\"user.home\");\n \t\treturn new File(home,\".junitsession\");\n \t}\n\t\n\tprivate void postInfo(final String message) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowInfo(message);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void postStatus(final String status) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tshowStatus(status);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void removeUpdate(DocumentEvent event) {\n\t\ttextChanged();\n\t}\n\t\n\tprivate void rerun() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tTest rerunTest= view.getSelectedTest();\n\t\tif (rerunTest != null)\n\t\t\trerunTest(rerunTest);\n\t}\n\t\n\tprivate void rerunTest(Test test) {\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= getLoader().reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tObject[] args= new Object[]{((TestCase)test).name()};\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\treloadedTest=(Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\t\t\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1) \n\t\t\tshowStatus(message+\" had an error\"); \n\t\telse \n\t\t\tshowStatus(message+\" had a failure\");\n\t}\n\n\tprotected void reset() {\n\t\tfCounterPanel.reset();\n\t\tfProgressIndicator.reset();\n\t\tfRerunButton.setEnabled(false);\n\t\tfFailureView.clear();\n\t\tfFailures.clear();\n\t}\n\t\n\t/**\n\t * runs a suite.\n\t * @deprecated use runSuite() instead\n\t */\n\tpublic void run() {\n\t\trunSuite();\n\t}\n\t\n\tprotected void runFailed(String message) {\n\t\tshowStatus(message);\n\t\tfRun.setText(\"Run\");\n\t\tfRunner= null;\n\t}\n\t\n\tsynchronized public void runSuite() {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\tif (!setUseLoadingRunner())\n\t\t\t\treturn;\n\t\t\treset();\n\t\t\tshowInfo(\"Load Test Case...\");\n\t\t\tfinal String suiteName= getSuiteText();\n\t\t\tfinal Test testSuite= getTest(suiteName);\t\t\n\t\t\tif (testSuite != null) {\n\t\t\t\taddToHistory(suiteName);\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean setUseLoadingRunner() {\n\t\tsetLoading(fUseLoadingRunner.isSelected());\n\t\tif (!fUseLoadingRunner.isSelected())\n\t\t\tfNonLoadingRuns++;\n\t\tif (fNonLoadingRuns > 1) {\n\t\t\tString message= \"You are running the tests more than once with the standard class loader.\\n\"+\n\t\t\t\t\t    \"Code modifications you made since the last run will be ignored.\\n\"+\n\t\t\t\t\t    \"It is recommended to restart the TestRunner.\\nDo you still want to continue?\";\n\t\t\tint returnCode= JOptionPane.showConfirmDialog(fFrame, message, \"Warning\", JOptionPane.YES_NO_OPTION);\n\t\t\treturn returnCode == JOptionPane.YES_OPTION;\n\t\t}\n\t\treturn true;\n\t}\n\n\tsynchronized protected void runTest(final Test testSuite) {\n\t\tif (fRunner != null) {\n\t\t\tfTestResult.stop();\n\t\t} else {\n\t\t\treset();\t\n\t\t\tif (testSuite != null) {\n\t\t\t\tdoRunTest(testSuite);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void doRunTest(final Test testSuite) {\n\t\tsetButtonLabel(fRun, \"Stop\");\n\t\tfRunner= new Thread(\"TestRunner-Thread\") {\n\t\t\tpublic void run() {\n\t\t\t\tTestRunner.this.start(testSuite); \n\t\t\t\tpostInfo(\"Running...\");\n\t\t\t\t\n\t\t\t\tlong startTime= System.currentTimeMillis();\n\t\t\t\ttestSuite.run(fTestResult);\n\t\t\t\t\t\n\t\t\t\tif (fTestResult.shouldStop()) {\n\t\t\t\t\tpostStatus(\"Stopped\");\n\t\t\t\t} else {\n\t\t\t\t\tlong endTime= System.currentTimeMillis();\n\t\t\t\t\tlong runTime= endTime-startTime;\n\t\t\t\t\tpostInfo(\"Finished: \" + elapsedTimeAsString(runTime) + \" seconds\");\n\t\t\t\t}\n\t\t\t\trunFinished(testSuite);\n\t\t\t\tsetButtonLabel(fRun, \"Run\");\n\t\t\t\tfRunner= null;\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t};\n\t\t// make sure that the test result is created before we start the\n\t\t// test runner thread so that listeners can register for it.\n\t\tfTestResult= createTestResult();\n\t\tfTestResult.addListener(TestRunner.this);\n\t\taboutToStart(testSuite);\n\n\t\tfRunner.start();\n\t}\n\n\tprivate void saveHistory() throws IOException {\n\t\tBufferedWriter bw= new BufferedWriter(new FileWriter(getSettingsFile()));\n\t\ttry {\n\t\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\t\tString testsuite= fSuiteCombo.getItemAt(i).toString();\n\t\t\t\tbw.write(testsuite, 0, testsuite.length());\n\t\t\t\tbw.newLine();\n\t\t\t}\n\t\t} finally {\n\t\t\tbw.close();\n\t\t}\n\t}\n\t\n\tprivate void setButtonLabel(final JButton button, final String label) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbutton.setText(label);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate void setLabelValue(final JTextField label, final int value) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tlabel.setText(Integer.toString(value));\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\t\n\tpublic void handleTestSelected(Test test) {\n\t\tfRerunButton.setEnabled(test != null && (test instanceof TestCase));\n\t\tshowFailureDetail(test);\n\t}\n\n\tprivate void showFailureDetail(Test test) {\n\t\tif (test != null) {\n\t\t\tListModel failures= getFailures();\n\t\t\tfor (int i= 0; i < failures.getSize(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure)failures.getElementAt(i);\n\t\t\t\tif (failure.failedTest() == test) {\n\t\t\t\t\tfFailureView.showFailure(failure);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfFailureView.clear();\n\t}\n\t\t\n\tprivate void showInfo(String message) {\n\t\tfStatusLine.showInfo(message);\n\t}\n\t\n\tprivate void showStatus(String status) {\n\t\tfStatusLine.showError(status);\n\t}\n\t\n\t/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\t\t\n\t\tString suiteName= processArguments(args);\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.pack(); \n\t\tfFrame.setVisible(true);\n\n\t\tif (suiteName != null) {\n\t\t\tsetSuite(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}\n\t\t\n\tprivate void start(final Test test) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfProgressIndicator.start(test.countTestCases());\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\t/**\n\t * Wait until all the events are processed in the event thread\n\t */\n\tprivate void synchUI() {\n\t\ttry {\n\t\t\tSwingUtilities.invokeAndWait(\n\t\t\t\tnew Runnable() {\n\t\t\t\t\tpublic void run() {}\n\t\t\t\t}\t\t\n\t\t\t);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t}\n\t\n\t/**\n\t * Terminates the TestRunner\n\t */\n\tpublic void terminate() {\n\t\tfFrame.dispose();\n\t\ttry {\n\t\t\tsaveHistory();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Couldn't save test run history\");\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tpublic void textChanged() {\n\t\tfRun.setEnabled(getSuiteText().length() > 0);\n\t\tclearStatus();\n\t}\n\t\n\tprotected void clearStatus() {\n\t\tfStatusLine.clear();\n\t}\n\t\n\tpublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}\n\t\n\tprivate void about() {\n\t\tAboutDialog about= new AboutDialog(fFrame); \n\t\tabout.show();\n\t}\n\t\n\n}\n","lineNo":430}
{"Smelly Sample":"package junit.runner;\n\nimport junit.framework.*;\nimport java.lang.reflect.*;\nimport java.text.NumberFormat;\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Base class for all test runners.\n * This class was born live on stage in Sardinia during XP2000.\n */\npublic abstract class BaseTestRunner implements TestListener {\n\tpublic static final String SUITE_METHODNAME= \"suite\";\n\t\n\tstatic Properties fPreferences;\n\tstatic int fgMaxMessageLength= 200;\n\tstatic boolean fgFilterStack= true;\n\tboolean fLoading= true;\n\t\n\t/**\n\t * Returns the Test corresponding to the given suite. This is\n\t * a template method, subclasses override runFailed(), clearStatus().\n\t */\n\tpublic Test getTest(String suiteClassName) {\n\t\tif (suiteClassName.length() <= 0) {\n\t\t\tclearStatus();\n\t\t\treturn null;\n\t\t}\n\t\tClass testClass= null;\n\t\ttry {\n\t\t\ttestClass= loadSuiteClass(suiteClassName);\n\t\t} catch (NoClassDefFoundError e) {\n\t\t\trunFailed(\"Class definition \\\"\"+suiteClassName+\"\\\" not found\");\n\t\t\treturn null;\n\t\t} catch(Exception e) {\n\t\t\trunFailed(\"Class \\\"\"+suiteClassName+\"\\\" not found\");\n\t\t\treturn null;\n\t\t}\n\t\tMethod suiteMethod= null;\n\t\ttry {\n\t\t\tsuiteMethod= testClass.getMethod(SUITE_METHODNAME, new Class[0]);\n\t \t} catch(Exception e) {\n\t \t\t// try to extract a test suite automatically\n\t\t\tclearStatus();\t\t\t\n\t\t\treturn new TestSuite(testClass);\n\t\t}\n\t\tTest test= null;\n\t\ttry {\n\t\t\ttest= (Test)suiteMethod.invoke(null, new Class[0]); // static method\n\t\t\tif (test == null)\n\t\t\t\treturn test;\n\t\t} catch(Exception e) {\n\t\t\trunFailed(\"Could not invoke the suite() method\");\n\t\t\treturn null;\n\t\t}\n\t\tclearStatus();\n\t\treturn test;\n\t}\n\t\n\t/**\n\t * Returns the formatted string of the elapsed time.\n\t */\n\tpublic String elapsedTimeAsString(long runTime) {\n\t\treturn NumberFormat.getInstance().format((double)runTime/1000);\n\t}\n\t\n\t/**\n\t * Processes the command line arguments and\n\t * returns the name of the suite class to run or null\n\t */\n\tprotected String processArguments(String[] args) {\n\t\tString suiteName= null;\n\t\tfor (int i= 0; i < args.length; i++) {\n\t\t\tif (args[i].equals(\"-noloading\")) {\n\t\t\t\tsetLoading(false);\n\t\t\t} else if (args[i].equals(\"-nofilterstack\")) {\n\t\t\t\tfgFilterStack= false;\n\t\t\t} else if (args[i].equals(\"-c\")) {\n\t\t\t\tif (args.length > i+1)\n\t\t\t\t\tsuiteName= extractClassName(args[i+1]);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"Missing Test class name\");\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tsuiteName= args[i];\n\t\t\t}\n\t\t}\n\t\treturn suiteName;\t\t\n\t}\n\n\t/**\n\t * Sets the loading behaviour of the test runner\n\t */\n\tprotected void setLoading(boolean enable) {\n\t\tfLoading= enable;\n\t}\n\t/**\n\t * Extract the class name from a String in VA/Java style\n\t */\n\tpublic String extractClassName(String className) {\n\t\tif(className.startsWith(\"Default package for\")) \n\t\t\treturn className.substring(className.lastIndexOf(\".\")+1);\n\t\treturn className;\n\t}\n\t\n\t/**\n\t * Truncates a String to the maximum length.\n\t */\n\tpublic static String truncate(String s) {\n\t\tif (fgMaxMessageLength != -1 && s.length() > fgMaxMessageLength)\n\t\t\ts= s.substring(0, fgMaxMessageLength)+\"...\";\n\t\treturn s;\n\t}\n\t\n\t/**\n\t * Override to define how to handle a failed loading of\n\t * a test suite.\n\t */\n\tprotected abstract void runFailed(String message);\n\t\n\t/**\n\t * Returns the loaded Class for a suite name. \n\t */\n\tprotected Class loadSuiteClass(String suiteClassName) throws ClassNotFoundException {\n\t\treturn getLoader().load(suiteClassName);\n\t}\n\t\n\t/**\n\t * Clears the status message.\n\t */\n\tprotected void clearStatus() { // Belongs in the GUI TestRunner class\n\t}\n\t\n\t/**\n\t * Returns the loader to be used.\n\t */\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading)\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}\n\t\n\tprivate static File getPreferencesFile() {\n\t \tString home= System.getProperty(\"user.home\");\n \t\treturn new File(home, \"junit.properties\");\n \t}\n \t\n \tprivate static void readPreferences() {\n \t\tInputStream is= null;\n \t\ttry {\n \t\t\tis= new FileInputStream(getPreferencesFile());\n \t\t\tfPreferences= new Properties(fPreferences);\n\t\t\tfPreferences.load(is);\n\t\t} catch (IOException e) {\n\t\t\ttry {\n\t\t\t\tif (is != null)\n\t\t\t\t\tis.close();\n\t\t\t} catch (IOException e1) {\n\t\t\t}\n\t\t}\n \t}\n \t\n \tpublic static String getPreference(String key) {\n \t\treturn fPreferences.getProperty(key);\n \t}\n \t\n \tpublic static int getPreference(String key, int dflt) {\n \t\tString value= getPreference(key);\n \t\tint intValue= dflt;\n \t\tif (value == null)\n \t\t\treturn intValue;\n \t\ttry {\n \t\t\tintValue= Integer.parseInt(value);\n \t \t} catch (NumberFormatException ne) {\n \t\t}\n \t\treturn intValue;\n \t}\n\n \tpublic static boolean inVAJava() {\n\t\ttry {\n\t\t\tClass.forName(\"com.ibm.uvm.tools.DebugSupport\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Filters stack frames from internal JUnit classes\n\t */\n\tpublic static String filterStack(String stack) {\n\t\tif (!getPreference(\"filterstack\").equals(\"true\") || fgFilterStack == false)\n\t\t\treturn stack;\n\t\t\t\n\t\tStringWriter sw= new StringWriter();\n\t\tPrintWriter pw= new PrintWriter(sw);\n\t\tStringReader sr= new StringReader(stack);\n\t\tBufferedReader br= new BufferedReader(sr);\n\t\t\n\t\tString line;\n\t\ttry {\t\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tif (!filterLine(line))\n\t\t\t\t\tpw.println(line);\n\t\t\t}\n\t\t} catch (Exception IOException) {\n\t\t\treturn stack; // return the stack unfiltered\n\t\t}\n\t\treturn sw.toString();\n\t}\n\t\n\tstatic boolean filterLine(String line) {\n\t\tString[] patterns= new String[] {\n\t\t\t\"junit.framework.TestCase\",\n\t\t\t\"junit.framework.TestResult\",\n\t\t\t\"junit.framework.TestSuite\",\n\t\t\t\"junit.framework.Assert.\", // don't filter AssertionFailure\n\t\t\t\"junit.swingui.TestRunner\",\n\t\t\t\"junit.awtui.TestRunner\",\n\t\t\t\"junit.textui.TestRunner\",\n\t\t\t\"java.lang.reflect.Method.invoke(\"\n\t\t};\n\t\tfor (int i= 0; i < patterns.length; i++) {\n\t\t\tif (line.indexOf(patterns[i]) > 0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n \t{\n \t\tfPreferences= new Properties();\n \t\t//JDK 1.2 feature\n \t\t//fPreferences.setProperty(\"loading\", \"true\");\n \t\tfPreferences.put(\"loading\", \"true\");\n \t\tfPreferences.put(\"filterstack\", \"true\");\n  \t\treadPreferences();\n \t\tfgMaxMessageLength= getPreference(\"maxmessage\", fgMaxMessageLength);\n \t}\n \t\n}\n","Method after Refactoring":"package junit.runner;\n\nimport junit.framework.*;\nimport java.lang.reflect.*;\nimport java.text.NumberFormat;\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Base class for all test runners.\n * This class was born live on stage in Sardinia during XP2000.\n */\npublic abstract class BaseTestRunner implements TestListener {\n\tpublic static final String SUITE_METHODNAME= \"suite\";\n\t\n\tstatic Properties fPreferences;\n\tstatic int fgMaxMessageLength= 200;\n\tstatic boolean fgFilterStack= true;\n\tboolean fLoading= true;\n\t\n\t/**\n\t * Returns the Test corresponding to the given suite. This is\n\t * a template method, subclasses override runFailed(), clearStatus().\n\t */\n\tpublic Test getTest(String suiteClassName) {\n\t\tif (suiteClassName.length() <= 0) {\n\t\t\tclearStatus();\n\t\t\treturn null;\n\t\t}\n\t\tClass testClass= null;\n\t\ttry {\n\t\t\ttestClass= loadSuiteClass(suiteClassName);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tString clazz= e.getMessage();\n\t\t\tif (clazz == null) \n\t\t\t\tclazz= suiteClassName;\n\t\t\trunFailed(\"Class not found \\\"\"+clazz+\"\\\"\");\n\t\t\treturn null;\n\t\t} catch(Exception e) {\n\t\t\trunFailed(\"Error: \"+e.toString());\n\t\t\treturn null;\n\t\t}\n\t\tMethod suiteMethod= null;\n\t\ttry {\n\t\t\tsuiteMethod= testClass.getMethod(SUITE_METHODNAME, new Class[0]);\n\t \t} catch(Exception e) {\n\t \t\t// try to extract a test suite automatically\n\t\t\tclearStatus();\t\t\t\n\t\t\treturn new TestSuite(testClass);\n\t\t}\n\t\tTest test= null;\n\t\ttry {\n\t\t\ttest= (Test)suiteMethod.invoke(null, new Class[0]); // static method\n\t\t\tif (test == null)\n\t\t\t\treturn test;\n\t\t} catch(Exception e) {\n\t\t\trunFailed(\"Could not invoke the suite() method\");\n\t\t\treturn null;\n\t\t}\n\t\tclearStatus();\n\t\treturn test;\n\t}\n\t\n\t/**\n\t * Returns the formatted string of the elapsed time.\n\t */\n\tpublic String elapsedTimeAsString(long runTime) {\n\t\treturn NumberFormat.getInstance().format((double)runTime/1000);\n\t}\n\t\n\t/**\n\t * Processes the command line arguments and\n\t * returns the name of the suite class to run or null\n\t */\n\tprotected String processArguments(String[] args) {\n\t\tString suiteName= null;\n\t\tfor (int i= 0; i < args.length; i++) {\n\t\t\tif (args[i].equals(\"-noloading\")) {\n\t\t\t\tsetLoading(false);\n\t\t\t} else if (args[i].equals(\"-nofilterstack\")) {\n\t\t\t\tfgFilterStack= false;\n\t\t\t} else if (args[i].equals(\"-c\")) {\n\t\t\t\tif (args.length > i+1)\n\t\t\t\t\tsuiteName= extractClassName(args[i+1]);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"Missing Test class name\");\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tsuiteName= args[i];\n\t\t\t}\n\t\t}\n\t\treturn suiteName;\t\t\n\t}\n\n\t/**\n\t * Sets the loading behaviour of the test runner\n\t */\n\tprotected void setLoading(boolean enable) {\n\t\tfLoading= enable;\n\t}\n\t/**\n\t * Extract the class name from a String in VA/Java style\n\t */\n\tpublic String extractClassName(String className) {\n\t\tif(className.startsWith(\"Default package for\")) \n\t\t\treturn className.substring(className.lastIndexOf(\".\")+1);\n\t\treturn className;\n\t}\n\t\n\t/**\n\t * Truncates a String to the maximum length.\n\t */\n\tpublic static String truncate(String s) {\n\t\tif (fgMaxMessageLength != -1 && s.length() > fgMaxMessageLength)\n\t\t\ts= s.substring(0, fgMaxMessageLength)+\"...\";\n\t\treturn s;\n\t}\n\t\n\t/**\n\t * Override to define how to handle a failed loading of\n\t * a test suite.\n\t */\n\tprotected abstract void runFailed(String message);\n\t\n\t/**\n\t * Returns the loaded Class for a suite name. \n\t */\n\tprotected Class loadSuiteClass(String suiteClassName) throws ClassNotFoundException {\n\t\treturn getLoader().load(suiteClassName);\n\t}\n\t\n\t/**\n\t * Clears the status message.\n\t */\n\tprotected void clearStatus() { // Belongs in the GUI TestRunner class\n\t}\n\t\n\t/**\n\t * Returns the loader to be used.\n\t */\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (useReoadingTestSuiteLoader())\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}\n\t\n\tprotected boolean useReoadingTestSuiteLoader() {\n\t\treturn getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading;\n\t}\n\t\n\tprivate static File getPreferencesFile() {\n\t \tString home= System.getProperty(\"user.home\");\n \t\treturn new File(home, \"junit.properties\");\n \t}\n \t\n \tprivate static void readPreferences() {\n \t\tInputStream is= null;\n \t\ttry {\n \t\t\tis= new FileInputStream(getPreferencesFile());\n \t\t\tfPreferences= new Properties(fPreferences);\n\t\t\tfPreferences.load(is);\n\t\t} catch (IOException e) {\n\t\t\ttry {\n\t\t\t\tif (is != null)\n\t\t\t\t\tis.close();\n\t\t\t} catch (IOException e1) {\n\t\t\t}\n\t\t}\n \t}\n \t\n \tpublic static String getPreference(String key) {\n \t\treturn fPreferences.getProperty(key);\n \t}\n \t\n \tpublic static int getPreference(String key, int dflt) {\n \t\tString value= getPreference(key);\n \t\tint intValue= dflt;\n \t\tif (value == null)\n \t\t\treturn intValue;\n \t\ttry {\n \t\t\tintValue= Integer.parseInt(value);\n \t \t} catch (NumberFormatException ne) {\n \t\t}\n \t\treturn intValue;\n \t}\n\n \tpublic static boolean inVAJava() {\n\t\ttry {\n\t\t\tClass.forName(\"com.ibm.uvm.tools.DebugSupport\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Returns a filtered stack trace\n\t */\n\tpublic static String getFilteredTrace(Throwable t) { \n\t\tStringWriter stringWriter= new StringWriter();\n\t\tPrintWriter writer= new PrintWriter(stringWriter);\n\t\tt.printStackTrace(writer);\n\t\tStringBuffer buffer= stringWriter.getBuffer();\n\t\tString trace= buffer.toString();\n\t\treturn BaseTestRunner.filterStack(trace);\n\t}\n\n\t/**\n\t * Filters stack frames from internal JUnit classes\n\t */\n\tpublic static String filterStack(String stack) {\n\t\tif (!getPreference(\"filterstack\").equals(\"true\") || fgFilterStack == false)\n\t\t\treturn stack;\n\t\t\t\n\t\tStringWriter sw= new StringWriter();\n\t\tPrintWriter pw= new PrintWriter(sw);\n\t\tStringReader sr= new StringReader(stack);\n\t\tBufferedReader br= new BufferedReader(sr);\n\t\t\n\t\tString line;\n\t\ttry {\t\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tif (!filterLine(line))\n\t\t\t\t\tpw.println(line);\n\t\t\t}\n\t\t} catch (Exception IOException) {\n\t\t\treturn stack; // return the stack unfiltered\n\t\t}\n\t\treturn sw.toString();\n\t}\n\t\n\tstatic boolean filterLine(String line) {\n\t\tString[] patterns= new String[] {\n\t\t\t\"junit.framework.TestCase\",\n\t\t\t\"junit.framework.TestResult\",\n\t\t\t\"junit.framework.TestSuite\",\n\t\t\t\"junit.framework.Assert.\", // don't filter AssertionFailure\n\t\t\t\"junit.swingui.TestRunner\",\n\t\t\t\"junit.awtui.TestRunner\",\n\t\t\t\"junit.textui.TestRunner\",\n\t\t\t\"java.lang.reflect.Method.invoke(\"\n\t\t};\n\t\tfor (int i= 0; i < patterns.length; i++) {\n\t\t\tif (line.indexOf(patterns[i]) > 0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n \t{\n \t\tfPreferences= new Properties();\n \t\t//JDK 1.2 feature\n \t\t//fPreferences.setProperty(\"loading\", \"true\");\n \t\tfPreferences.put(\"loading\", \"true\");\n \t\tfPreferences.put(\"filterstack\", \"true\");\n  \t\treadPreferences();\n \t\tfgMaxMessageLength= getPreference(\"maxmessage\", fgMaxMessageLength);\n \t}\n \t\n}\n","lineNo":34}
{"Smelly Sample":"package junit.runner;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * An implementation of a TestCollector that consults the\n * class path. It considers all classes on the class path\n * excluding classes in JARs. It leaves it up to subclasses\n * to decide whether a class is runnable Test.\n *\n * @see TestCollector\n */\npublic abstract class ClassPathTestCollector implements TestCollector {\n\t\n\tstatic final int SUFFIX_LENGTH= \".class\".length();\n\t\n\tpublic ClassPathTestCollector() {\n\t}\n\t\n\tpublic Enumeration collectTests() {\n\t\tString classPath= System.getProperty(\"java.class.path\");\n\t\tString separator= System.getProperty(\"path.separator\");\n\t\tVector result= new Vector(100);\n\t\tcollectFilesInRoots(splitClassPath(classPath, separator), result);\n\t\treturn result.elements();\n\t}\n\t\n\tvoid collectFilesInRoots(Vector roots, Vector result) {\n\t\tEnumeration e= roots.elements();\n\t\twhile (e.hasMoreElements()) \n\t\t\tgatherFiles(new File((String)e.nextElement()), \"\", result);\n\t}\n\n\tvoid gatherFiles(File classRoot, String classFileName, Vector result) {\n\t\tFile thisRoot= new File(classRoot, classFileName);\n\t\tif (thisRoot.isFile()) {\n\t\t\tif (isTestClass(classFileName)) \n\t\t\t\tresult.addElement(classNameFromFile(classFileName));\n\t\t\treturn;\n\t\t}\t\t\n\t\tString[] contents= thisRoot.list(); \n\t\tfor (int i= 0; i < contents.length; i++) \n\t\t\tgatherFiles(classRoot, classFileName+File.separatorChar+contents[i], result);\t\t\n\t}\n\t\n\tVector splitClassPath(String classPath, String separator) {\n\t\tVector result= new Vector();\n\t\tStringTokenizer tokenizer= new StringTokenizer(classPath, separator);\n\t\twhile (tokenizer.hasMoreTokens()) \n\t\t\tresult.addElement(tokenizer.nextToken());\n\t\treturn result;\n\t}\n\t\n\tprotected boolean isTestClass(String classFileName) {\n\t\treturn \n\t\t\tclassFileName.endsWith(\".class\") && \n\t\t\tclassFileName.indexOf('$') < 0 &&\n\t\t\tclassFileName.indexOf(\"Test\") > 0;\n\t}\n\t\n\tprotected String classNameFromFile(String classFileName) {\n\t\t// convert /a/b.class to a.b\n\t\tString s= classFileName.substring(0, classFileName.length()-SUFFIX_LENGTH);\n\t\tString s2= s.replace(File.separatorChar, '.');\n\t\tif (s2.startsWith(\".\"))\n\t\t\treturn s2.substring(1);\n\t\treturn s2;\n\t}\t\n}\n","Method after Refactoring":"package junit.runner;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * An implementation of a TestCollector that consults the\n * class path. It considers all classes on the class path\n * excluding classes in JARs. It leaves it up to subclasses\n * to decide whether a class is a runnable Test.\n *\n * @see TestCollector\n */\npublic abstract class ClassPathTestCollector implements TestCollector {\n\t\n\tstatic final int SUFFIX_LENGTH= \".class\".length();\n\t\n\tpublic ClassPathTestCollector() {\n\t}\n\t\n\tpublic Enumeration collectTests() {\n\t\tString classPath= System.getProperty(\"java.class.path\");\n\t\tString separator= System.getProperty(\"path.separator\");\n\t\tHashtable result= new Hashtable(100);\n\t\tcollectFilesInRoots(splitClassPath(classPath, separator), result);\n\t\treturn result.elements();\n\t}\n\t\n\tvoid collectFilesInRoots(Vector roots, Hashtable result) {\n\t\tEnumeration e= roots.elements();\n\t\twhile (e.hasMoreElements()) \n\t\t\tgatherFiles(new File((String)e.nextElement()), \"\", result);\n\t}\n\n\tvoid gatherFiles(File classRoot, String classFileName, Hashtable result) {\n\t\tFile thisRoot= new File(classRoot, classFileName);\n\t\tif (thisRoot.isFile()) {\n\t\t\tif (isTestClass(classFileName)) {\n\t\t\t\tString className= classNameFromFile(classFileName);\n\t\t\t\tresult.put(className, className);\n\t\t\t}\n\t\t\treturn;\n\t\t}\t\t\n\t\tString[] contents= thisRoot.list();\n\t\tif (contents != null) { \n\t\t\tfor (int i= 0; i < contents.length; i++) \n\t\t\t\tgatherFiles(classRoot, classFileName+File.separatorChar+contents[i], result);\t\t\n\t\t}\n\t}\n\t\n\tVector splitClassPath(String classPath, String separator) {\n\t\tVector result= new Vector();\n\t\tStringTokenizer tokenizer= new StringTokenizer(classPath, separator);\n\t\twhile (tokenizer.hasMoreTokens()) \n\t\t\tresult.addElement(tokenizer.nextToken());\n\t\treturn result;\n\t}\n\t\n\tprotected boolean isTestClass(String classFileName) {\n\t\treturn \n\t\t\tclassFileName.endsWith(\".class\") && \n\t\t\tclassFileName.indexOf('$') < 0 &&\n\t\t\tclassFileName.indexOf(\"Test\") > 0;\n\t}\n\t\n\tprotected String classNameFromFile(String classFileName) {\n\t\t// convert /a/b.class to a.b\n\t\tString s= classFileName.substring(0, classFileName.length()-SUFFIX_LENGTH);\n\t\tString s2= s.replace(File.separatorChar, '.');\n\t\tif (s2.startsWith(\".\"))\n\t\t\treturn s2.substring(1);\n\t\treturn s2;\n\t}\t\n}\n","lineNo":39}
