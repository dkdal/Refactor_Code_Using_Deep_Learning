{"Smelly Sample":"package com.ichi2.anki;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.Typeface;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.ichi2.libanki.Utils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class AnkiFont {\n    private String mName;\n    private String mFamily;\n    private List<String> mAttributes;\n    private String mPath;\n    private static final String fAssetPathPrefix = \"/android_asset/fonts/\";\n    private static Set<String> corruptFonts = new HashSet<String>();\n\n    private AnkiFont(String name, String family, List<String> attributes, String path) {\n        mName = name;\n        mFamily = family;\n        mAttributes = attributes;\n        mPath = path;\n    }\n    \n    /**\n     * Factory for AnkiFont creation.\n     * Creates a typeface wrapper from a font file representing.\n     * @param ctx Activity context, needed to access assets\n     * @param path Path to typeface file, needed when this is a custom font.\n     * @param fromAssets True if the font is to be found in assets of application\n     * @return A new AnkiFont object or null if the file can't be interpreted as typeface.\n     */\n    public static AnkiFont createAnkiFont(Context ctx, String path, boolean fromAssets) {\n        File fontfile = new File(path);\n        String name = Utils.removeExtension(fontfile.getName());\n        String family = name;\n        List<String> attributes = new ArrayList<String>();\n\n        if (fromAssets) {\n            path = fAssetPathPrefix.concat(fontfile.getName());\n        }\n        Typeface tf = getTypeface(ctx, path);\n        if (tf == null) {\n            // unable to create typeface\n            return null;\n        }\n        if (tf.isBold() || name.toLowerCase().contains(\"bold\")) {\n            attributes.add(\"font-weight: bolder;\");\n            family = family.replaceFirst(\"(?i)-?Bold\", \"\");\n        } else if (name.toLowerCase().contains(\"light\")) {\n            attributes.add(\"font-weight: lighter;\");\n            family = family.replaceFirst(\"(?i)-?Light\", \"\");\n        } else {\n            attributes.add(\"font-weight: normal;\");\n        }\n        if (tf.isItalic() || name.toLowerCase().contains(\"italic\")) {\n            attributes.add(\"font-style: italic;\");\n            family = family.replaceFirst(\"(?i)-?Italic\", \"\");\n        } else if (name.toLowerCase().contains(\"oblique\")) {\n            attributes.add(\"font-style: oblique;\");\n            family = family.replaceFirst(\"(?i)-?Oblique\", \"\");\n        } else {\n            attributes.add(\"font-style: normal;\");\n        }\n        if (name.toLowerCase().contains(\"condensed\") || name.toLowerCase().contains(\"narrow\")) {\n            attributes.add(\"font-stretch: condensed;\");\n            family = family.replaceFirst(\"(?i)-?Condensed\", \"\");\n            family = family.replaceFirst(\"(?i)-?Narrow(er)?\", \"\");\n        } else if (name.toLowerCase().contains(\"expanded\") || name.toLowerCase().contains(\"wide\")) {\n            attributes.add(\"font-stretch: expanded;\");\n            family = family.replaceFirst(\"(?i)-?Expanded\", \"\");\n            family = family.replaceFirst(\"(?i)-?Wide(r)?\", \"\");\n        } else {\n            attributes.add(\"font-stretch: normal;\");\n        }\n        family = family.replaceFirst(\"(?i)-?Regular\", \"\");\n        return new AnkiFont(name, family, attributes, path);\n    }\n    \n    public String getDeclaration() {\n        StringBuilder sb = new StringBuilder(\"@font-face {\");\n        sb.append(getCSS()).append(\" src: url(\\\"file://\").append(mPath).append(\"\\\");}\");\n        return sb.toString();\n    }\n    public String getCSS() {\n        StringBuilder sb = new StringBuilder(\"font-family: \\\"\").append(mFamily).append(\"\\\" !important;\");\n        for (String attr : mAttributes) {\n            sb.append(\" \").append(attr);\n        }\n        return sb.toString();\n    }\n    public String getName() {\n        return mName;\n    }\n    public String getPath() {\n        return mPath;\n    }\n    public static Typeface getTypeface(Context ctx, String path) {\n        try {\n            if (path.startsWith(fAssetPathPrefix)) {\n                return Typeface.createFromAsset(ctx.getAssets(), path.replaceFirst(\"/android_asset/\", \"\"));\n            } else {\n                return Typeface.createFromFile(path);\n            }\n        } catch (RuntimeException e) {\n            Log.w(AnkiDroidApp.TAG, \"AnkiFont.getTypeface: \" + e.getMessage() + \" - File: \" + path);\n            if (!corruptFonts.contains(path)) {\n                // Show warning toast\n                String name = new File(path).getName();\n                Resources res = AnkiDroidApp.getAppResources();\n                Toast toast = Toast.makeText(ctx, res.getString(R.string.corrupt_font, name), Toast.LENGTH_LONG);\n                toast.show();\n                // Don't warn again in this session\n                corruptFonts.add(path);\n            }\n            return null;\n        }\n    }\n}\n","Method after Refactoring":"package com.ichi2.anki;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.res.Resources;\nimport android.graphics.Typeface;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.ichi2.libanki.Utils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class AnkiFont {\n    private String mName;\n    private String mFamily;\n    private List<String> mAttributes;\n    private String mPath;\n    private Boolean mIsDefault;\n    private Boolean mIsOverride;\n    private static final String fAssetPathPrefix = \"/android_asset/fonts/\";\n    private static Set<String> corruptFonts = new HashSet<String>();\n\n    private AnkiFont(String name, String family, List<String> attributes, String path) {\n        mName = name;\n        mFamily = family;\n        mAttributes = attributes;\n        mPath = path;\n        mIsDefault = false;\n        mIsOverride = false;\n    } \n    \n    \n    /**\n     * Factory for AnkiFont creation.\n     * Creates a typeface wrapper from a font file representing.\n     * @param ctx Activity context, needed to access assets\n     * @param path Path to typeface file, needed when this is a custom font.\n     * @param fromAssets True if the font is to be found in assets of application\n     * @return A new AnkiFont object or null if the file can't be interpreted as typeface.\n     */\n    public static AnkiFont createAnkiFont(Context ctx, String path, boolean fromAssets) {\n        File fontfile = new File(path);\n        String name = Utils.removeExtension(fontfile.getName());\n        String family = name;\n        List<String> attributes = new ArrayList<String>();\n\n        if (fromAssets) {\n            path = fAssetPathPrefix.concat(fontfile.getName());\n        }\n        Typeface tf = getTypeface(ctx, path);\n        if (tf == null) {\n            // unable to create typeface\n            return null;\n        }\n\n        if (tf.isBold() || name.toLowerCase().contains(\"bold\")) {\n            attributes.add(\"font-weight: bolder;\");\n            family = family.replaceFirst(\"(?i)-?Bold\", \"\");\n        } else if (name.toLowerCase().contains(\"light\")) {\n            attributes.add(\"font-weight: lighter;\");\n            family = family.replaceFirst(\"(?i)-?Light\", \"\");\n        } else {\n            attributes.add(\"font-weight: normal;\");\n        }\n        if (tf.isItalic() || name.toLowerCase().contains(\"italic\")) {\n            attributes.add(\"font-style: italic;\");\n            family = family.replaceFirst(\"(?i)-?Italic\", \"\");\n        } else if (name.toLowerCase().contains(\"oblique\")) {\n            attributes.add(\"font-style: oblique;\");\n            family = family.replaceFirst(\"(?i)-?Oblique\", \"\");\n        } else {\n            attributes.add(\"font-style: normal;\");\n        }\n        if (name.toLowerCase().contains(\"condensed\") || name.toLowerCase().contains(\"narrow\")) {\n            attributes.add(\"font-stretch: condensed;\");\n            family = family.replaceFirst(\"(?i)-?Condensed\", \"\");\n            family = family.replaceFirst(\"(?i)-?Narrow(er)?\", \"\");\n        } else if (name.toLowerCase().contains(\"expanded\") || name.toLowerCase().contains(\"wide\")) {\n            attributes.add(\"font-stretch: expanded;\");\n            family = family.replaceFirst(\"(?i)-?Expanded\", \"\");\n            family = family.replaceFirst(\"(?i)-?Wide(r)?\", \"\");\n        }\n        \n        AnkiFont createdFont = new AnkiFont(name, family, attributes, path);\n        \n        // determine if override font or default font\n        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(ctx);\n        String overrideFont = preferences.getString(\"overrideFont\", \"\");        \n        if (overrideFont.equalsIgnoreCase(name)) {\n            createdFont.setAsOverride();\n        } else {\n            String defaultFont = preferences.getString(\"defaultFont\", \"\");\n            if (defaultFont.equalsIgnoreCase(name)) {\n                createdFont.setAsDefault();\n            }\n        }\n        return createdFont;\n    }\n    \n    public String getDeclaration() {\n        StringBuilder sb = new StringBuilder(\"@font-face {\");\n        sb.append(getCSS()).append(\" src: url(\\\"file://\").append(mPath).append(\"\\\");}\");\n        return sb.toString();\n    }\n    public String getCSS() {        \n        StringBuilder sb = new StringBuilder(\"font-family: \\\"\").append(mFamily);\n        if (mIsOverride) {\n            sb.append(\"\\\" !important;\");\n        } else {\n            sb.append(\"\\\";\");\n        }\n        for (String attr : mAttributes) {\n            sb.append(\" \").append(attr);\n            if (mIsOverride) {\n                if (sb.charAt(sb.length() - 1) == ';') {\n                    sb.deleteCharAt(sb.length() - 1);\n                    sb.append(\" !important;\");\n                } else {\n                    Log.d(AnkiDroidApp.TAG, \"AnkiFont.getCSS() - unable to set a font attribute important while override is set.\");\n                }\n            }\n        }\n        return sb.toString();\n    }\n    public String getName() {\n        return mName;\n    }\n    public String getPath() {\n        return mPath;\n    }\n    public static Typeface getTypeface(Context ctx, String path) {\n        try {\n            if (path.startsWith(fAssetPathPrefix)) {\n                return Typeface.createFromAsset(ctx.getAssets(), path.replaceFirst(\"/android_asset/\", \"\"));\n            } else {\n                return Typeface.createFromFile(path);\n            }\n        } catch (RuntimeException e) {\n            Log.w(AnkiDroidApp.TAG, \"AnkiFont.getTypeface: \" + e.getMessage() + \" - File: \" + path);\n            if (!corruptFonts.contains(path)) {\n                // Show warning toast\n                String name = new File(path).getName();\n                Resources res = AnkiDroidApp.getAppResources();\n                Toast toast = Toast.makeText(ctx, res.getString(R.string.corrupt_font, name), Toast.LENGTH_LONG);\n                toast.show();\n                // Don't warn again in this session\n                corruptFonts.add(path);\n            }\n            return null;\n        }\n    }\n    private void setAsDefault() {\n        mIsDefault = true;\n        mIsOverride = false;\n    }\n    private void setAsOverride() {\n        mIsOverride = true;\n        mIsDefault = false;\n    }    \n}\n","lineNo":111}
{"Smelly Sample":"/****************************************************************************************\n * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *\n * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.libanki;\n\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.util.Log;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.Pair;\nimport com.ichi2.upgrade.Upgrade;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Finder {\n\n    public static Pattern allPattern = Pattern\n            .compile(\"(-)?\\\\'(([^\\\\'\\\\\\\\]|\\\\\\\\.)*)\\\\'|(-)?\\\"(([^\\\"\\\\\\\\]|\\\\\\\\.)*)\\\"|(-)?([^ ]+)|([ ]+)\");\n    private static final Pattern fPropPattern = Pattern.compile(\"(^.+?)(<=|>=|!=|=|<|>)(.+?$)\");\n    private static final Pattern fNidsPattern = Pattern.compile(\"[^0-9,]\");\n    private static final Pattern fMidPattern = Pattern.compile(\"[^0-9]\");\n\n    private static final List<String> fValidEases = Arrays.asList(new String[] { \"1\", \"2\", \"3\", \"4\" });\n    private static final List<String> fValidProps = Arrays\n            .asList(new String[] { \"due\", \"ivl\", \"reps\", \"lapses\", \"ease\" });\n\n    private Collection mCol;\n\n\n    public Finder(Collection col) {\n        mCol = col;\n    }\n\n\n    /** Return a list of card ids for QUERY */\n    public List<Long> findCards(String query, String _order) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, false);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    /** Return a list of card ids for QUERY */\n    public ArrayList<HashMap<String, String>> findCardsForCardBrowser(String query, String _order, HashMap<String, String> deckNames) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        ArrayList<HashMap<String, String>> res = new ArrayList<HashMap<String, String>>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, true);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                HashMap<String, String> map = new HashMap<String, String>();\n                map.put(\"id\", cur.getString(0));\n                map.put(\"sfld\", cur.getString(1));\n                map.put(\"deck\", deckNames.get(cur.getString(2)));\n                int queue = cur.getInt(3);\n                String tags = cur.getString(4);\n                map.put(\"flags\", Integer.toString((queue == -1 ? 1 : 0) + (tags.matches(\".*[Mm]arked.*\") ? 2 : 0)));\n                map.put(\"tags\", tags);\n                res.add(map);\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            Log.e(AnkiDroidApp.TAG, \"Invalid grouping, sql: \" + sql);\n            return new ArrayList<HashMap<String, String>>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    public List<Long> findNotes(String query) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        if (preds.equals(\"\")) {\n            preds = \"1\";\n        } else {\n            preds = \"(\" + preds + \")\";\n        }\n        String sql = \"select distinct(n.id) from cards c, notes n where c.nid=n.id and \" + preds;\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return res;\n    }\n\n\n    // Tokenizing\n    // ///////////\n    public String[] _tokenize(String query) {\n        char inQuote = 0;\n        List<String> tokens = new ArrayList<String>();\n        String token = \"\";\n        for (int i = 0; i < query.length(); ++i) {\n            // quoted text\n            char c = query.charAt(i);\n            if (c == '\\'' || c == '\"') {\n                if (inQuote != 0) {\n                    if (c == inQuote) {\n                        inQuote = 0;\n                    } else {\n                        token += c;\n                    }\n                } else if (token.length() != 0) {\n                    // quotes are allowed to start directly after a :\n                    if (token.endsWith(\":\")) {\n                        inQuote = c;\n                    } else {\n                        token += c;\n                    }\n                } else {\n                    inQuote = c;\n                }\n                // separator\n            } else if (c == ' ') {\n                if (inQuote != 0) {\n                    token += c;\n                } else if (token.length() != 0) {\n                    // space marks token finished\n                    tokens.add(token);\n                    token = \"\";\n                }\n                // nesting\n            } else if (c == '(' || c == ')') {\n                if (inQuote != 0) {\n                    token += c;\n                } else {\n                    if (c == ')' && token.length() != 0) {\n                        tokens.add(token);\n                        token = \"\";\n                    }\n                    tokens.add(String.valueOf(c));\n                }\n                // negation\n            } else if (c == '-') {\n                if (token.length() != 0) {\n                    token += c;\n                } else if (tokens.size() == 0 || !tokens.get(tokens.size() - 1).equals(\"-\")) {\n                    tokens.add(\"-\");\n                }\n                // normal character\n            } else {\n                token += c;\n            }\n        }\n        // if we finished in a token, add it\n        if (token.length() != 0) {\n            tokens.add(token);\n        }\n        return tokens.toArray(new String[] {});\n    }\n\n    // Query building\n    // ///////////////\n    public class SearchState {\n        public boolean isnot;\n        public boolean isor;\n        public boolean join;\n        public String q;\n        public boolean bad;\n\n\n        public SearchState() {\n            isnot = false;\n            isor = false;\n            join = false;\n            q = \"\";\n            bad = false;\n        }\n    }\n\n\n    public Pair<String, String[]> _where(String[] tokens) {\n        // state and query\n        SearchState s = new SearchState();\n        List<String> args = new ArrayList<String>();\n        for (String token : tokens) {\n            if (s.bad) {\n                return new Pair<String, String[]>(null, null);\n            }\n            // special tokens\n            if (token.equals(\"-\")) {\n                s.isnot = true;\n            } else if (token.toLowerCase().equals(\"or\")) {\n                s.isor = true;\n            } else if (token.equals(\"(\")) {\n                addPred(s, token, false);\n                s.join = false;\n            } else if (token.equals(\")\")) {\n                s.q += \")\";\n                // commands\n            } else if (token.contains(\":\")) {\n                String[] spl = token.split(\":\", 2);\n                String cmd = spl[0].toLowerCase();\n                String val = spl[1];\n                if (cmd.equals(\"tag\")) {\n                    addPred(s, _findTag(val, args));\n                } else if (cmd.equals(\"is\")) {\n                    addPred(s, _findCardState(val));\n                } else if (cmd.equals(\"nid\")) {\n                    addPred(s, _findNids(val));\n                } else if (cmd.equals(\"card\")) {\n                    addPred(s, _findTemplate(val));\n                } else if (cmd.equals(\"note\")) {\n                    addPred(s, _findModel(val));\n                } else if (cmd.equals(\"mid\")) {\n                    addPred(s, _findMid(val));\n                } else if (cmd.equals(\"deck\")) {\n                    addPred(s, _findDeck(val));\n                } else if (cmd.equals(\"prop\")) {\n                    addPred(s, _findProp(val));\n                } else if (cmd.equals(\"rated\")) {\n                    addPred(s, _findRated(val));\n                } else if (cmd.equals(\"added\")) {\n                    addPred(s, _findAdded(val));\n                } else {\n                    addPred(s, _findField(cmd, val));\n                }\n                // normal text search\n            } else {\n                addPred(s, _findText(token, args));\n            }\n        }\n        if (s.bad) {\n            return new Pair<String, String[]>(null, null);\n        }\n        return new Pair<String, String[]>(s.q, args.toArray(new String[] {}));\n    }\n\n\n    private void addPred(SearchState s, String txt) {\n        addPred(s, txt, true);\n    }\n\n\n    private void addPred(SearchState s, String txt, boolean wrap) {\n        // failed command\n        if (txt == null || txt.length() == 0) {\n            // if it was to be negated then we can just ignore it\n            if (s.isnot) {\n                s.isnot = false;\n                return;\n            } else {\n                s.bad = true;\n                return;\n            }\n        } else if (txt.equals(\"skip\")) {\n            return;\n        }\n        // do we need a conjunction\n        if (s.join) {\n            if (s.isor) {\n                s.q += \" or \";\n                s.isor = false;\n            } else {\n                s.q += \" and \";\n            }\n        }\n        if (s.isnot) {\n            s.q += \" not \";\n            s.isnot = false;\n        }\n        if (wrap) {\n            txt = \"(\" + txt + \")\";\n        }\n        s.q += txt;\n        s.join = true;\n    }\n\n\n    private String _query(String preds, String order, boolean forCardBrowser) {\n        // can we skip the note table?\n        String sql;\n        if (forCardBrowser) {\n            sql = \"select c.id, n.sfld, c.did, c.queue, n.tags from cards c, notes n where c.nid=n.id and \";\n        } else {\n            if (!preds.contains(\"n.\") && !order.contains(\"n.\")) {\n                sql = \"select c.id from cards c where \";\n            } else {\n                sql = \"select c.id from cards c, notes n where c.nid=n.id and \";\n            }\n        }\n        // combine with preds\n        if (preds.length() != 0) {\n            sql += \"(\" + preds + \")\";\n        } else {\n            sql += \"1\";\n        }\n        // order\n        if (order != null && order.length() != 0) {\n            sql += \" \" + order;\n        }\n        return sql;\n    }\n\n\n    // Ordering\n    // /////////\n\n    private Pair<String, Boolean> _order(String order) {\n        if (order == null || order.length() == 0) {\n            return new Pair<String, Boolean>(\"\", false);\n        } else if (!order.equalsIgnoreCase(\"true\")) {\n            // custom order string provided\n            return new Pair<String, Boolean>(\" order by \" + order, false);\n        }\n        // use deck default\n        String type;\n        try {\n            type = mCol.getConf().getString(\"sortType\");\n            String sort = null;\n            if (type.startsWith(\"note\")) {\n                if (type.startsWith(\"noteCrt\")) {\n                    sort = \"n.id, c.ord\";\n                } else if (type.startsWith(\"noteMod\")) {\n                    sort = \"n.mod, c.ord\";\n                } else if (type.startsWith(\"noteFld\")) {\n                    sort = \"n.sfld COLLATE NOCASE, c.ord\";\n                }\n            } else if (type.startsWith(\"card\")) {\n                if (type.startsWith(\"cardMod\")) {\n                    sort = \"c.mod\";\n                } else if (type.startsWith(\"cardReps\")) {\n                    sort = \"c.reps\";\n                } else if (type.startsWith(\"cardDue\")) {\n                    sort = \"c.type, c.due\";\n                } else if (type.startsWith(\"cardEase\")) {\n                    sort = \"c.factor\";\n                } else if (type.startsWith(\"cardLapses\")) {\n                    sort = \"c.lapses\";\n                } else if (type.startsWith(\"cardIvl\")) {\n                    sort = \"c.ivl\";\n                }\n            }\n            if (sort == null) {\n            \t// deck has invalid sort order; revert to noteCrt\n            \tsort = \"n.id, c.ord\";\n            }\n            boolean sortBackwards = Upgrade.upgradeJSONIfNecessary(mCol, mCol.getConf(), \"sortBackwards\", false);\n            return new Pair<String, Boolean>(\" ORDER BY \" + sort, sortBackwards);\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    // Commands\n    // /////////\n\n    private String _findTag(String val, List<String> args) {\n        if (val.equals(\"none\")) {\n            return \"n.tags = \\\"\\\"\";\n        }\n        val = val.replace(\"*\", \"%\");\n        if (!val.startsWith(\"%\")) {\n            val = \"% \" + val;\n        }\n        if (!val.endsWith(\"%\")) {\n            val += \" %\";\n        }\n        args.add(val);\n        return \"n.tags like ?\";\n    }\n\n\n    private String _findCardState(String val) {\n        int n;\n        if (val.equals(\"review\") || val.equals(\"new\") || val.equals(\"learn\")) {\n            if (val.equals(\"review\")) {\n                n = 2;\n            } else if (val.equals(\"new\")) {\n                n = 0;\n            } else {\n                return \"queue IN (1, 3)\";\n            }\n            return \"type = \" + n;\n        } else if (val.equals(\"suspended\")) {\n            return \"c.queue = -1\";\n        } else if (val.equals(\"buried\")) {\n            return \"c.queue = -2\";\n        } else if (val.equals(\"due\")) {\n            return \"(c.queue in (2,3) and c.due <= \" + mCol.getSched().getToday() +\n                    \") or (c.queue = 1 and c.due <= \" + mCol.getSched().getDayCutoff() + \")\";\n        } else {\n            return null;\n        }\n    }\n\n\n    private String _findRated(String val) {\n        // days(:optional_ease)\n        String[] r = val.split(\":\");\n        int days;\n        try {\n            days = Integer.parseInt(r[0]);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        days = Math.min(days, 31);\n        // ease\n        String ease = \"\";\n        if (r.length > 1) {\n            if (!fValidEases.contains(r[1])) {\n                return \"\";\n            }\n            ease = \"and ease=\" + r[1];\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id in (select cid from revlog where id>\" + cutoff + \" \" + ease + \")\";\n    }\n\n\n    private String _findAdded(String val) {\n        int days;\n        try {\n            days = Integer.parseInt(val);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id > \" + cutoff;\n    }\n\n\n    private String _findProp(String _val) {\n        // extract\n        Matcher m = fPropPattern.matcher(_val);\n        if (!m.matches()) {\n            return \"\";\n        }\n        String prop = m.group(1).toLowerCase();\n        String cmp = m.group(2);\n        String sval = m.group(3);\n        int val;\n        // is val valid?\n        try {\n            if (prop.equals(\"ease\")) {\n                // This multiplying and convert to int happens later in libanki, moved it here for efficiency\n                val = (int) (Double.parseDouble(sval) * 1000);\n            } else {\n                val = Integer.parseInt(sval);\n            }\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        // is prop valid?\n        if (!fValidProps.contains(prop)) {\n            return \"\";\n        }\n        // query\n        String q = \"\";\n        if (prop.equals(\"due\")) {\n            val += mCol.getSched().getToday();\n            // only valid for review/daily learning\n            q = \"(c.queue in (2,3)) and \";\n        } else if (prop.equals(\"ease\")) {\n            prop = \"factor\";\n            // already done: val = int(val*1000)\n        }\n        q += \"(\" + prop + \" \" + cmp + \" \" + val + \")\";\n        return q;\n    }\n\n\n    private String _findText(String val, List<String> args) {\n        val = val.replace(\"*\", \"%\");\n        args.add(\"%\" + val + \"%\");\n        args.add(\"%\" + val + \"%\");\n        return \"(n.sfld like ? escape '\\\\' or n.flds like ? escape '\\\\')\";\n    }\n\n\n    private String _findNids(String val) {\n        if (fNidsPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.id in (\" + val + \")\";\n    }\n\n    private String _findMid(String val) {\n        if (fMidPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.mid = \" + val;\n    }\n\n    private String _findModel(String val) {\n        LinkedList<Long> ids = new LinkedList<Long>();\n        val = val.toLowerCase();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                if (m.getString(\"name\").toLowerCase().equals(val)) {\n                    ids.add(m.getLong(\"id\"));\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return \"n.mid in \" + Utils.ids2str(ids);\n    }\n\n\n    private List<Long> dids(long did) {\n        if (did == 0) {\n            return null;\n        }\n        TreeMap<String, Long> children = mCol.getDecks().children(did);\n\n        List<Long> res = new ArrayList<Long>();\n        res.add(did);\n        res.addAll(children.values());\n        return res;\n    }\n\n\n    public String _findDeck(String val) {\n        // if searching for all decks, skip\n        if (val.equals(\"*\")) {\n            return \"skip\";\n            // deck types\n        } else if (val.equals(\"filtered\")) {\n            return \"c.odid\";\n        }\n\n        List<Long> ids = null;\n        // current deck?\n        try {\n            if (val.toLowerCase().equals(\"current\")) {\n                ids = dids(mCol.getDecks().current().getLong(\"id\"));\n            } else if (!val.contains(\"*\")) {\n                // single deck\n                ids = dids(mCol.getDecks().id(val, false));\n            } else {\n                // widlcard\n                ids = new ArrayList<Long>();\n                val = val.replace(\"*\", \".*\");\n                for (JSONObject d : mCol.getDecks().all()) {\n                    if (d.getString(\"name\").matches(\"(?i)\" + val)) {\n                        for (long id : dids(d.getLong(\"id\"))) {\n                            ids.add(id);\n                        }\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (ids == null || ids.size() == 0) {\n            return \"\";\n        }\n        String sids = Utils.ids2str(ids);\n        return \"c.did in \" + sids + \" or c.odid in \" + sids;\n    }\n\n\n    private String _findTemplate(String val) {\n        // were we given an ordinal number?\n        Integer num = null;\n        try {\n            num = Integer.parseInt(val) - 1;\n        } catch (NumberFormatException e) {\n            num = null;\n        }\n        if (num != null) {\n            return \"c.ord = \" + num;\n        }\n        // search for template names\n        List<String> lims = new ArrayList<String>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray tmpls = m.getJSONArray(\"tmpls\");\n                for (int ti = 0; ti < tmpls.length(); ++ti) {\n                    JSONObject t = tmpls.getJSONObject(ti);\n                    if (t.getString(\"name\").equalsIgnoreCase(val)) {\n                        if (m.getInt(\"type\") == Sched.MODEL_CLOZE) {\n                            // if the user has asked for a cloze card, we want\n                            // to give all ordinals, so we just limit to the\n                            // model instead\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \")\");\n                        } else {\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \" and c.ord = \" +\n                                    t.getInt(\"ord\") + \")\");\n                        }\n                    }\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return Utils.join(\" or \", lims.toArray(new String[] {}));\n    }\n\n\n    private String _findField(String field, String val) {\n        val = val.replace(\"*\", \"%\");\n        // find models that have that field\n        Map<Long, Object[]> mods = new HashMap<Long, Object[]>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (f.getString(\"name\").equalsIgnoreCase(field)) {\n                        mods.put(m.getLong(\"id\"), new Object[] { m, f.getInt(\"ord\") });\n                    }\n\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (mods.isEmpty()) {\n            // nothing has that field\n            return \"\";\n        }\n        // gather nids\n        // Pattern.quote escapes the meta characters with \\Q \\E\n        String regex = Pattern.quote(val).replace(\"\\\\Q_\\\\E\", \".\").replace(\"\\\\Q%\\\\E\", \".*\");\n        LinkedList<Long> nids = new LinkedList<Long>();\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(\n                    \"select id, mid, flds from notes where mid in \" +\n                    Utils.ids2str(new LinkedList<Long>(mods.keySet())) +\n                    \" and flds like ? escape '\\\\'\", new String[] { \"%\" + val + \"%\" });\n            while (cur.moveToNext()) {\n                String[] flds = Utils.splitFields(cur.getString(2));\n                int ord = (Integer) mods.get(cur.getLong(1))[1];\n                String strg = flds[ord];\n                if (Pattern.compile(regex, Pattern.CASE_INSENSITIVE).matcher(strg).matches()) {\n                    nids.add(cur.getLong(0));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (nids.isEmpty()) {\n            return \"\";\n        }\n        return \"n.id in \" + Utils.ids2str(nids);\n    }\n\n\n    // Find and Replace\n    // /////////////////\n    /**\n     * Find and replace fields in a note\n     * \n     * @param col The collection to search into.\n     * @param nids The cards to be searched for.\n     * @param src The original text to find.\n     * @param dst The text to change to.\n     * @param regex If true, the src is treated as a regex. Default = false.\n     * @param field Limit the search to specific field. If null, it searches all fields.\n     * @param fold If true the search is case-insensitive. Default = true.\n     * @return\n     */\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst) {\n        return findReplace(col, nids, src, dst, false, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean regex) {\n        return findReplace(col, nids, src, dst, regex, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, String field) {\n        return findReplace(col, nids, src, dst, false, field, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean isRegex,\n            String field, boolean fold) {\n        Map<Long, Integer> mmap = new HashMap<Long, Integer>();\n        if (field != null) {\n            try {\n                for (JSONObject m : col.getModels().all()) {\n                    JSONArray flds = m.getJSONArray(\"flds\");\n                    for (int fi = 0; fi < flds.length(); ++fi) {\n                        JSONObject f = flds.getJSONObject(fi);\n                        if (f.getString(\"name\").equals(field)) {\n                            mmap.put(m.getLong(\"id\"), f.getInt(\"ord\"));\n                        }\n                    }\n                }\n            } catch (JSONException e) {\n                throw new RuntimeException(e);\n            }\n            if (mmap.isEmpty()) {\n                return 0;\n            }\n        }\n        // find and gather replacements\n        if (!isRegex) {\n            src = Pattern.quote(src);\n        }\n        if (fold) {\n            src = \"(?i)\" + src;\n        }\n        Pattern regex = Pattern.compile(src);\n\n        ArrayList<Object[]> d = new ArrayList<Object[]>();\n        String sql = \"select id, mid, flds from notes where id in \" + Utils.ids2str(nids.toArray(new Long[] {}));\n        nids = new ArrayList<Long>();\n\n        Cursor cur = null;\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                String flds = cur.getString(2);\n                String origFlds = flds;\n                // does it match?\n                String[] sflds = Utils.splitFields(flds);\n                if (field != null) {\n                    long mid = cur.getLong(1);\n                    if (!mmap.containsKey(mid)) {\n                        continue;\n                    }\n                    int ord = mmap.get(mid);\n                    sflds[ord] = regex.matcher(sflds[ord]).replaceAll(dst);\n                } else {\n                    for (int i = 0; i < sflds.length; ++i) {\n                        sflds[i] = regex.matcher(sflds[i]).replaceAll(dst);\n                    }\n                }\n                flds = Utils.joinFields(sflds);\n                if (!flds.equals(origFlds)) {\n                    long nid = cur.getLong(0);\n                    nids.add(nid);\n                    d.add(new Object[] { flds, Utils.intNow(), col.usn(), nid });\n                }\n\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (d.isEmpty()) {\n            return 0;\n        }\n        // replace\n        col.getDb().executeMany(\"update notes set flds=?,mod=?,usn=? where id=?\", d);\n        long[] pnids = Utils.toPrimitive(nids);\n        col.updateFieldCache(pnids);\n        col.genCards(pnids);\n        return d.size();\n    }\n\n\n    public List<String> fieldNames(Collection col, boolean downcase) {\n        Set<String> fields = new HashSet<String>();\n        List<String> names = new ArrayList<String>();\n        try {\n            for (JSONObject m : col.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (!fields.contains(f.getString(\"name\").toLowerCase())) {\n                        names.add(f.getString(\"name\"));\n                        fields.add(f.getString(\"name\").toLowerCase());\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (downcase) {\n            return new ArrayList<String>(fields);\n        }\n        return names;\n    }\n\n\n    // Find Duplicates\n    // ////////////////\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName) {\n        return findDupes(col, fieldName, \"\");\n    }\n\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName, String search) {\n        // limit search to notes with applicable field name\n    \tif (search != null && search.length() > 0) {\n            search = \"(\" + search + \") \";\n    \t}\n        search += \"'\" + fieldName + \":*'\";\n        // go through notes\n\n        String sql = \"select id, mid, flds from notes where id in \"\n                + Utils.ids2str(col.findNotes(search).toArray(new Long[] {}));\n        Cursor cur = null;\n        Map<Long, Integer> fields = new HashMap<Long, Integer>();\n        Map<String, List<Long>> vals = new HashMap<String, List<Long>>();\n        List<Pair<String, List<Long>>> dupes = new ArrayList<Pair<String, List<Long>>>();\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                long nid = cur.getLong(0);\n                long mid = cur.getLong(1);\n                String[] flds = Utils.splitFields(cur.getString(2));\n                // inlined ordForMid(mid)\n                if (!fields.containsKey(mid)) {\n                    JSONObject model = col.getModels().get(mid);\n                    fields.put(mid, col.getModels().fieldMap(model).get(fieldName).first);\n                }\n                String val = flds[fields.get(mid)];\n                // empty does not count as duplicate\n                if (val.equals(\"\")) {\n                    continue;\n                }\n                if (!vals.containsKey(val)) {\n                    vals.put(val, new ArrayList<Long>());\n                }\n                vals.get(val).add(nid);\n                if (vals.get(val).size() == 2) {\n                    dupes.add(new Pair<String, List<Long>>(val, vals.get(val)));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return dupes;\n    }\n}\n","Method after Refactoring":"/****************************************************************************************\n * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *\n * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.libanki;\n\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.util.Log;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.Pair;\nimport com.ichi2.upgrade.Upgrade;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Finder {\n\n    public static Pattern allPattern = Pattern\n            .compile(\"(-)?\\\\'(([^\\\\'\\\\\\\\]|\\\\\\\\.)*)\\\\'|(-)?\\\"(([^\\\"\\\\\\\\]|\\\\\\\\.)*)\\\"|(-)?([^ ]+)|([ ]+)\");\n    private static final Pattern fPropPattern = Pattern.compile(\"(^.+?)(<=|>=|!=|=|<|>)(.+?$)\");\n    private static final Pattern fNidsPattern = Pattern.compile(\"[^0-9,]\");\n    private static final Pattern fMidPattern = Pattern.compile(\"[^0-9]\");\n\n    private static final List<String> fValidEases = Arrays.asList(new String[] { \"1\", \"2\", \"3\", \"4\" });\n    private static final List<String> fValidProps = Arrays\n            .asList(new String[] { \"due\", \"ivl\", \"reps\", \"lapses\", \"ease\" });\n\n    private Collection mCol;\n\n\n    public Finder(Collection col) {\n        mCol = col;\n    }\n\n\n    /** Return a list of card ids for QUERY */\n    public List<Long> findCards(String query, String _order) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, false);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    /** Return a list of card ids for QUERY */\n    public ArrayList<HashMap<String, String>> findCardsForCardBrowser(String query, String _order, HashMap<String, String> deckNames) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        ArrayList<HashMap<String, String>> res = new ArrayList<HashMap<String, String>>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, true);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                HashMap<String, String> map = new HashMap<String, String>();\n                map.put(\"id\", cur.getString(0));\n                map.put(\"sfld\", cur.getString(1));\n                map.put(\"deck\", deckNames.get(cur.getString(2)));\n                int queue = cur.getInt(3);\n                String tags = cur.getString(4);\n                map.put(\"flags\", Integer.toString((queue == -1 ? 1 : 0) + (tags.matches(\".*[Mm]arked.*\") ? 2 : 0)));\n                map.put(\"tags\", tags);\n                res.add(map);\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            Log.e(AnkiDroidApp.TAG, \"Invalid grouping, sql: \" + sql);\n            return new ArrayList<HashMap<String, String>>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    public List<Long> findNotes(String query) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        if (preds.equals(\"\")) {\n            preds = \"1\";\n        } else {\n            preds = \"(\" + preds + \")\";\n        }\n        String sql = \"select distinct(n.id) from cards c, notes n where c.nid=n.id and \" + preds;\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return res;\n    }\n\n\n    // Tokenizing\n    // ///////////\n    public String[] _tokenize(String query) {\n        char inQuote = 0;\n        List<String> tokens = new ArrayList<String>();\n        String token = \"\";\n        for (int i = 0; i < query.length(); ++i) {\n            // quoted text\n            char c = query.charAt(i);\n            if (c == '\\'' || c == '\"') {\n                if (inQuote != 0) {\n                    if (c == inQuote) {\n                        inQuote = 0;\n                    } else {\n                        token += c;\n                    }\n                } else if (token.length() != 0) {\n                    // quotes are allowed to start directly after a :\n                    if (token.endsWith(\":\")) {\n                        inQuote = c;\n                    } else {\n                        token += c;\n                    }\n                } else {\n                    inQuote = c;\n                }\n                // separator\n            } else if (c == ' ') {\n                if (inQuote != 0) {\n                    token += c;\n                } else if (token.length() != 0) {\n                    // space marks token finished\n                    tokens.add(token);\n                    token = \"\";\n                }\n                // nesting\n            } else if (c == '(' || c == ')') {\n                if (inQuote != 0) {\n                    token += c;\n                } else {\n                    if (c == ')' && token.length() != 0) {\n                        tokens.add(token);\n                        token = \"\";\n                    }\n                    tokens.add(String.valueOf(c));\n                }\n                // negation\n            } else if (c == '-') {\n                if (token.length() != 0) {\n                    token += c;\n                } else if (tokens.size() == 0 || !tokens.get(tokens.size() - 1).equals(\"-\")) {\n                    tokens.add(\"-\");\n                }\n                // normal character\n            } else {\n                token += c;\n            }\n        }\n        // if we finished in a token, add it\n        if (token.length() != 0) {\n            tokens.add(token);\n        }\n        return tokens.toArray(new String[] {});\n    }\n\n    // Query building\n    // ///////////////\n    public class SearchState {\n        public boolean isnot;\n        public boolean isor;\n        public boolean join;\n        public String q;\n        public boolean bad;\n\n\n        public SearchState() {\n            isnot = false;\n            isor = false;\n            join = false;\n            q = \"\";\n            bad = false;\n        }\n    }\n\n\n    public Pair<String, String[]> _where(String[] tokens) {\n        // state and query\n        SearchState s = new SearchState();\n        List<String> args = new ArrayList<String>();\n        for (String token : tokens) {\n            if (s.bad) {\n                return new Pair<String, String[]>(null, null);\n            }\n            // special tokens\n            if (token.equals(\"-\")) {\n                s.isnot = true;\n            } else if (token.toLowerCase().equals(\"or\")) {\n                s.isor = true;\n            } else if (token.equals(\"(\")) {\n                addPred(s, token, false);\n                s.join = false;\n            } else if (token.equals(\")\")) {\n                s.q += \")\";\n                // commands\n            } else if (token.contains(\":\")) {\n                String[] spl = token.split(\":\", 2);\n                String cmd = spl[0].toLowerCase();\n                String val = spl[1];\n                if (cmd.equals(\"tag\")) {\n                    addPred(s, _findTag(val, args));\n                } else if (cmd.equals(\"is\")) {\n                    addPred(s, _findCardState(val));\n                } else if (cmd.equals(\"nid\")) {\n                    addPred(s, _findNids(val));\n                } else if (cmd.equals(\"card\")) {\n                    addPred(s, _findTemplate(val));\n                } else if (cmd.equals(\"note\")) {\n                    addPred(s, _findModel(val));\n                } else if (cmd.equals(\"mid\")) {\n                    addPred(s, _findMid(val));\n                } else if (cmd.equals(\"deck\")) {\n                    addPred(s, _findDeck(val));\n                } else if (cmd.equals(\"prop\")) {\n                    addPred(s, _findProp(val));\n                } else if (cmd.equals(\"rated\")) {\n                    addPred(s, _findRated(val));\n                } else if (cmd.equals(\"added\")) {\n                    addPred(s, _findAdded(val));\n                } else {\n                    addPred(s, _findField(cmd, val));\n                }\n                // normal text search\n            } else {\n                addPred(s, _findText(token, args));\n            }\n        }\n        if (s.bad) {\n            return new Pair<String, String[]>(null, null);\n        }\n        return new Pair<String, String[]>(s.q, args.toArray(new String[] {}));\n    }\n\n\n    private void addPred(SearchState s, String txt) {\n        addPred(s, txt, true);\n    }\n\n\n    private void addPred(SearchState s, String txt, boolean wrap) {\n        // failed command\n        if (txt == null || txt.length() == 0) {\n            // if it was to be negated then we can just ignore it\n            if (s.isnot) {\n                s.isnot = false;\n                return;\n            } else {\n                s.bad = true;\n                return;\n            }\n        } else if (txt.equals(\"skip\")) {\n            return;\n        }\n        // do we need a conjunction\n        if (s.join) {\n            if (s.isor) {\n                s.q += \" or \";\n                s.isor = false;\n            } else {\n                s.q += \" and \";\n            }\n        }\n        if (s.isnot) {\n            s.q += \" not \";\n            s.isnot = false;\n        }\n        if (wrap) {\n            txt = \"(\" + txt + \")\";\n        }\n        s.q += txt;\n        s.join = true;\n    }\n\n\n    private String _query(String preds, String order, boolean forCardBrowser) {\n        // can we skip the note table?\n        String sql;\n        if (forCardBrowser) {\n            sql = \"select c.id, n.sfld, c.did, c.queue, n.tags from cards c, notes n where c.nid=n.id and \";\n        } else {\n            if (!preds.contains(\"n.\") && !order.contains(\"n.\")) {\n                sql = \"select c.id from cards c where \";\n            } else {\n                sql = \"select c.id from cards c, notes n where c.nid=n.id and \";\n            }\n        }\n        // combine with preds\n        if (preds.length() != 0) {\n            sql += \"(\" + preds + \")\";\n        } else {\n            sql += \"1\";\n        }\n        // order\n        if (order != null && order.length() != 0) {\n            sql += \" \" + order;\n        }\n        return sql;\n    }\n\n\n    // Ordering\n    // /////////\n\n    private Pair<String, Boolean> _order(String order) {\n        if (order == null || order.length() == 0) {\n            return new Pair<String, Boolean>(\"\", false);\n        } else if (!order.equalsIgnoreCase(\"true\")) {\n            // custom order string provided\n            return new Pair<String, Boolean>(\" order by \" + order, false);\n        }\n        // use deck default\n        String type;\n        try {\n            type = mCol.getConf().getString(\"sortType\");\n            String sort = null;\n            if (type.startsWith(\"note\")) {\n                if (type.startsWith(\"noteCrt\")) {\n                    sort = \"n.id, c.ord\";\n                } else if (type.startsWith(\"noteMod\")) {\n                    sort = \"n.mod, c.ord\";\n                } else if (type.startsWith(\"noteFld\")) {\n                    sort = \"n.sfld COLLATE NOCASE, c.ord\";\n                }\n            } else if (type.startsWith(\"card\")) {\n                if (type.startsWith(\"cardMod\")) {\n                    sort = \"c.mod\";\n                } else if (type.startsWith(\"cardReps\")) {\n                    sort = \"c.reps\";\n                } else if (type.startsWith(\"cardDue\")) {\n                    sort = \"c.type, c.due\";\n                } else if (type.startsWith(\"cardEase\")) {\n                    sort = \"c.factor\";\n                } else if (type.startsWith(\"cardLapses\")) {\n                    sort = \"c.lapses\";\n                } else if (type.startsWith(\"cardIvl\")) {\n                    sort = \"c.ivl\";\n                }\n            }\n            if (sort == null) {\n            \t// deck has invalid sort order; revert to noteCrt\n            \tsort = \"n.id, c.ord\";\n            }\n            boolean sortBackwards = Upgrade.upgradeJSONIfNecessary(mCol, mCol.getConf(), \"sortBackwards\", false);\n            return new Pair<String, Boolean>(\" ORDER BY \" + sort, sortBackwards);\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    // Commands\n    // /////////\n\n    private String _findTag(String val, List<String> args) {\n        if (val.equals(\"none\")) {\n            return \"n.tags = \\\"\\\"\";\n        }\n        val = val.replace(\"*\", \"%\");\n        if (!val.startsWith(\"%\")) {\n            val = \"% \" + val;\n        }\n        if (!val.endsWith(\"%\")) {\n            val += \" %\";\n        }\n        args.add(val);\n        return \"n.tags like ?\";\n    }\n\n\n    private String _findCardState(String val) {\n        int n;\n        if (val.equals(\"review\") || val.equals(\"new\") || val.equals(\"learn\")) {\n            if (val.equals(\"review\")) {\n                n = 2;\n            } else if (val.equals(\"new\")) {\n                n = 0;\n            } else {\n                return \"queue IN (1, 3)\";\n            }\n            return \"type = \" + n;\n        } else if (val.equals(\"suspended\")) {\n            return \"c.queue = -1\";\n        } else if (val.equals(\"buried\")) {\n            return \"c.queue = -2\";\n        } else if (val.equals(\"due\")) {\n            return \"(c.queue in (2,3) and c.due <= \" + mCol.getSched().getToday() +\n                    \") or (c.queue = 1 and c.due <= \" + mCol.getSched().getDayCutoff() + \")\";\n        } else {\n            return null;\n        }\n    }\n\n\n    private String _findRated(String val) {\n        // days(:optional_ease)\n        String[] r = val.split(\":\");\n        int days;\n        try {\n            days = Integer.parseInt(r[0]);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        days = Math.min(days, 31);\n        // ease\n        String ease = \"\";\n        if (r.length > 1) {\n            if (!fValidEases.contains(r[1])) {\n                return \"\";\n            }\n            ease = \"and ease=\" + r[1];\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id in (select cid from revlog where id>\" + cutoff + \" \" + ease + \")\";\n    }\n\n\n    private String _findAdded(String val) {\n        int days;\n        try {\n            days = Integer.parseInt(val);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id > \" + cutoff;\n    }\n\n\n    private String _findProp(String _val) {\n        // extract\n        Matcher m = fPropPattern.matcher(_val);\n        if (!m.matches()) {\n            return \"\";\n        }\n        String prop = m.group(1).toLowerCase();\n        String cmp = m.group(2);\n        String sval = m.group(3);\n        int val;\n        // is val valid?\n        try {\n            if (prop.equals(\"ease\")) {\n                // This multiplying and convert to int happens later in libanki, moved it here for efficiency\n                val = (int) (Double.parseDouble(sval) * 1000);\n            } else {\n                val = Integer.parseInt(sval);\n            }\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        // is prop valid?\n        if (!fValidProps.contains(prop)) {\n            return \"\";\n        }\n        // query\n        String q = \"\";\n        if (prop.equals(\"due\")) {\n            val += mCol.getSched().getToday();\n            // only valid for review/daily learning\n            q = \"(c.queue in (2,3)) and \";\n        } else if (prop.equals(\"ease\")) {\n            prop = \"factor\";\n            // already done: val = int(val*1000)\n        }\n        q += \"(\" + prop + \" \" + cmp + \" \" + val + \")\";\n        return q;\n    }\n\n\n    private String _findText(String val, List<String> args) {\n        val = val.replace(\"*\", \"%\");\n        args.add(\"%\" + val + \"%\");\n        args.add(\"%\" + val + \"%\");\n        return \"(n.sfld like ? escape '\\\\' or n.flds like ? escape '\\\\')\";\n    }\n\n\n    private String _findNids(String val) {\n        if (fNidsPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.id in (\" + val + \")\";\n    }\n\n    private String _findMid(String val) {\n        if (fMidPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.mid = \" + val;\n    }\n\n    private String _findModel(String val) {\n        LinkedList<Long> ids = new LinkedList<Long>();\n        val = val.toLowerCase();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                if (m.getString(\"name\").toLowerCase().equals(val)) {\n                    ids.add(m.getLong(\"id\"));\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return \"n.mid in \" + Utils.ids2str(ids);\n    }\n\n\n    private List<Long> dids(long did) {\n        if (did == 0) {\n            return null;\n        }\n        TreeMap<String, Long> children = mCol.getDecks().children(did);\n\n        List<Long> res = new ArrayList<Long>();\n        res.add(did);\n        res.addAll(children.values());\n        return res;\n    }\n\n\n    public String _findDeck(String val) {\n        // if searching for all decks, skip\n        if (val.equals(\"*\")) {\n            return \"skip\";\n            // deck types\n        } else if (val.equals(\"filtered\")) {\n            return \"c.odid\";\n        }\n\n        List<Long> ids = null;\n        // current deck?\n        try {\n            if (val.toLowerCase().equals(\"current\")) {\n                ids = dids(mCol.getDecks().current().getLong(\"id\"));\n            } else if (!val.contains(\"*\")) {\n                // single deck\n                ids = dids(mCol.getDecks().id(val, false));\n            } else {\n                // widlcard\n                ids = new ArrayList<Long>();\n                val = val.replace(\"*\", \".*\");\n                for (JSONObject d : mCol.getDecks().all()) {\n                    if (d.getString(\"name\").matches(\"(?i)\" + val)) {\n                        for (long id : dids(d.getLong(\"id\"))) {\n                            ids.add(id);\n                        }\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (ids == null || ids.size() == 0) {\n            return \"\";\n        }\n        String sids = Utils.ids2str(ids);\n        return \"c.did in \" + sids + \" or c.odid in \" + sids;\n    }\n\n\n    private String _findTemplate(String val) {\n        // were we given an ordinal number?\n        Integer num = null;\n        try {\n            num = Integer.parseInt(val) - 1;\n        } catch (NumberFormatException e) {\n            num = null;\n        }\n        if (num != null) {\n            return \"c.ord = \" + num;\n        }\n        // search for template names\n        List<String> lims = new ArrayList<String>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray tmpls = m.getJSONArray(\"tmpls\");\n                for (int ti = 0; ti < tmpls.length(); ++ti) {\n                    JSONObject t = tmpls.getJSONObject(ti);\n                    if (t.getString(\"name\").equalsIgnoreCase(val)) {\n                        if (m.getInt(\"type\") == Sched.MODEL_CLOZE) {\n                            // if the user has asked for a cloze card, we want\n                            // to give all ordinals, so we just limit to the\n                            // model instead\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \")\");\n                        } else {\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \" and c.ord = \" +\n                                    t.getInt(\"ord\") + \")\");\n                        }\n                    }\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return Utils.join(\" or \", lims.toArray(new String[] {}));\n    }\n\n\n    private String _findField(String field, String val) {\n        /*\n         * We need two expressions to query the cards: One that will use JAVA REGEX syntax and another\n         * that should use SQLITE LIKE clause syntax.\n         */\n        String sqlVal = val\n                .replace(\"%\",\"\\\\%\") // For SQLITE, we escape all % signs\n                .replace(\"*\",\"%\"); // And then convert the * into non-escaped % signs\n\n        /*\n         * The following three lines make sure that only _ and * are valid wildcards. \n         * Any other characters are enclosed inside the \\Q \\E markers, which force  \n         * all meta-characters in between them to lose their special meaning \n         */\n        String javaVal = val\n                    .replace(\"_\",\"\\\\E.\\\\Q\") \n                    .replace(\"*\",\"\\\\E.*\\\\Q\");\n        /*\n         * For the pattern, we use the javaVal expression that uses JAVA REGEX syntax\n         */\n        Pattern pattern = Pattern.compile(\"\\\\Q\" + javaVal + \"\\\\E\", Pattern.CASE_INSENSITIVE);\n\n        // find models that have that field\n        Map<Long, Object[]> mods = new HashMap<Long, Object[]>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (f.getString(\"name\").equalsIgnoreCase(field)) {\n                        mods.put(m.getLong(\"id\"), new Object[] { m, f.getInt(\"ord\") });\n                    }\n\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (mods.isEmpty()) {\n            // nothing has that field\n            return \"\";\n        }\n        LinkedList<Long> nids = new LinkedList<Long>();\n        Cursor cur = null;\n        try {\n            /*\n             * Here we use the sqlVal expression, that is required for LIKE syntax in sqllite.\n             * There is no problem with special characters, because only % and _ are special\n             * characters in this syntax.\n             */\n            cur = mCol.getDb().getDatabase().rawQuery(\n                    \"select id, mid, flds from notes where mid in \" +\n                            Utils.ids2str(new LinkedList<Long>(mods.keySet())) +\n                            \" and flds like ? escape '\\\\'\", new String[] { \"%\" + sqlVal + \"%\" });\n\n            while (cur.moveToNext()) {\n                String[] flds = Utils.splitFields(cur.getString(2));\n                int ord = (Integer) mods.get(cur.getLong(1))[1];\n                String strg = flds[ord];\n                if (pattern.matcher(strg).matches()) {\n                    nids.add(cur.getLong(0));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (nids.isEmpty()) {\n            return \"\";\n        }\n        return \"n.id in \" + Utils.ids2str(nids);\n    }\n\n\n    // Find and Replace\n    // /////////////////\n    /**\n     * Find and replace fields in a note\n     * \n     * @param col The collection to search into.\n     * @param nids The cards to be searched for.\n     * @param src The original text to find.\n     * @param dst The text to change to.\n     * @param regex If true, the src is treated as a regex. Default = false.\n     * @param field Limit the search to specific field. If null, it searches all fields.\n     * @param fold If true the search is case-insensitive. Default = true.\n     * @return\n     */\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst) {\n        return findReplace(col, nids, src, dst, false, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean regex) {\n        return findReplace(col, nids, src, dst, regex, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, String field) {\n        return findReplace(col, nids, src, dst, false, field, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean isRegex,\n            String field, boolean fold) {\n        Map<Long, Integer> mmap = new HashMap<Long, Integer>();\n        if (field != null) {\n            try {\n                for (JSONObject m : col.getModels().all()) {\n                    JSONArray flds = m.getJSONArray(\"flds\");\n                    for (int fi = 0; fi < flds.length(); ++fi) {\n                        JSONObject f = flds.getJSONObject(fi);\n                        if (f.getString(\"name\").equals(field)) {\n                            mmap.put(m.getLong(\"id\"), f.getInt(\"ord\"));\n                        }\n                    }\n                }\n            } catch (JSONException e) {\n                throw new RuntimeException(e);\n            }\n            if (mmap.isEmpty()) {\n                return 0;\n            }\n        }\n        // find and gather replacements\n        if (!isRegex) {\n            src = Pattern.quote(src);\n        }\n        if (fold) {\n            src = \"(?i)\" + src;\n        }\n        Pattern regex = Pattern.compile(src);\n\n        ArrayList<Object[]> d = new ArrayList<Object[]>();\n        String sql = \"select id, mid, flds from notes where id in \" + Utils.ids2str(nids.toArray(new Long[] {}));\n        nids = new ArrayList<Long>();\n\n        Cursor cur = null;\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                String flds = cur.getString(2);\n                String origFlds = flds;\n                // does it match?\n                String[] sflds = Utils.splitFields(flds);\n                if (field != null) {\n                    long mid = cur.getLong(1);\n                    if (!mmap.containsKey(mid)) {\n                        continue;\n                    }\n                    int ord = mmap.get(mid);\n                    sflds[ord] = regex.matcher(sflds[ord]).replaceAll(dst);\n                } else {\n                    for (int i = 0; i < sflds.length; ++i) {\n                        sflds[i] = regex.matcher(sflds[i]).replaceAll(dst);\n                    }\n                }\n                flds = Utils.joinFields(sflds);\n                if (!flds.equals(origFlds)) {\n                    long nid = cur.getLong(0);\n                    nids.add(nid);\n                    d.add(new Object[] { flds, Utils.intNow(), col.usn(), nid });\n                }\n\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (d.isEmpty()) {\n            return 0;\n        }\n        // replace\n        col.getDb().executeMany(\"update notes set flds=?,mod=?,usn=? where id=?\", d);\n        long[] pnids = Utils.toPrimitive(nids);\n        col.updateFieldCache(pnids);\n        col.genCards(pnids);\n        return d.size();\n    }\n\n\n    public List<String> fieldNames(Collection col, boolean downcase) {\n        Set<String> fields = new HashSet<String>();\n        List<String> names = new ArrayList<String>();\n        try {\n            for (JSONObject m : col.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (!fields.contains(f.getString(\"name\").toLowerCase())) {\n                        names.add(f.getString(\"name\"));\n                        fields.add(f.getString(\"name\").toLowerCase());\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (downcase) {\n            return new ArrayList<String>(fields);\n        }\n        return names;\n    }\n\n\n    // Find Duplicates\n    // ////////////////\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName) {\n        return findDupes(col, fieldName, \"\");\n    }\n\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName, String search) {\n        // limit search to notes with applicable field name\n    \tif (search != null && search.length() > 0) {\n            search = \"(\" + search + \") \";\n    \t}\n        search += \"'\" + fieldName + \":*'\";\n        // go through notes\n\n        String sql = \"select id, mid, flds from notes where id in \"\n                + Utils.ids2str(col.findNotes(search).toArray(new Long[] {}));\n        Cursor cur = null;\n        Map<Long, Integer> fields = new HashMap<Long, Integer>();\n        Map<String, List<Long>> vals = new HashMap<String, List<Long>>();\n        List<Pair<String, List<Long>>> dupes = new ArrayList<Pair<String, List<Long>>>();\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                long nid = cur.getLong(0);\n                long mid = cur.getLong(1);\n                String[] flds = Utils.splitFields(cur.getString(2));\n                // inlined ordForMid(mid)\n                if (!fields.containsKey(mid)) {\n                    JSONObject model = col.getModels().get(mid);\n                    fields.put(mid, col.getModels().fieldMap(model).get(fieldName).first);\n                }\n                String val = flds[fields.get(mid)];\n                // empty does not count as duplicate\n                if (val.equals(\"\")) {\n                    continue;\n                }\n                if (!vals.containsKey(val)) {\n                    vals.put(val, new ArrayList<Long>());\n                }\n                vals.get(val).add(nid);\n                if (vals.get(val).size() == 2) {\n                    dupes.add(new Pair<String, List<Long>>(val, vals.get(val)));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return dupes;\n    }\n}\n","lineNo":688}
{"Smelly Sample":"/****************************************************************************************\n * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *\n * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.libanki;\n\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.util.Log;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.Pair;\nimport com.ichi2.upgrade.Upgrade;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Finder {\n\n    public static Pattern allPattern = Pattern\n            .compile(\"(-)?\\\\'(([^\\\\'\\\\\\\\]|\\\\\\\\.)*)\\\\'|(-)?\\\"(([^\\\"\\\\\\\\]|\\\\\\\\.)*)\\\"|(-)?([^ ]+)|([ ]+)\");\n    private static final Pattern fPropPattern = Pattern.compile(\"(^.+?)(<=|>=|!=|=|<|>)(.+?$)\");\n    private static final Pattern fNidsPattern = Pattern.compile(\"[^0-9,]\");\n    private static final Pattern fMidPattern = Pattern.compile(\"[^0-9]\");\n\n    private static final List<String> fValidEases = Arrays.asList(new String[] { \"1\", \"2\", \"3\", \"4\" });\n    private static final List<String> fValidProps = Arrays\n            .asList(new String[] { \"due\", \"ivl\", \"reps\", \"lapses\", \"ease\" });\n\n    private Collection mCol;\n\n\n    public Finder(Collection col) {\n        mCol = col;\n    }\n\n\n    /** Return a list of card ids for QUERY */\n    public List<Long> findCards(String query, String _order) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, false);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    /** Return a list of card ids for QUERY */\n    public ArrayList<HashMap<String, String>> findCardsForCardBrowser(String query, String _order, HashMap<String, String> deckNames) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        ArrayList<HashMap<String, String>> res = new ArrayList<HashMap<String, String>>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, true);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                HashMap<String, String> map = new HashMap<String, String>();\n                map.put(\"id\", cur.getString(0));\n                map.put(\"sfld\", cur.getString(1));\n                map.put(\"deck\", deckNames.get(cur.getString(2)));\n                int queue = cur.getInt(3);\n                String tags = cur.getString(4);\n                map.put(\"flags\", Integer.toString((queue == -1 ? 1 : 0) + (tags.matches(\".*[Mm]arked.*\") ? 2 : 0)));\n                map.put(\"tags\", tags);\n                res.add(map);\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            Log.e(AnkiDroidApp.TAG, \"Invalid grouping, sql: \" + sql);\n            return new ArrayList<HashMap<String, String>>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    public List<Long> findNotes(String query) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        if (preds.equals(\"\")) {\n            preds = \"1\";\n        } else {\n            preds = \"(\" + preds + \")\";\n        }\n        String sql = \"select distinct(n.id) from cards c, notes n where c.nid=n.id and \" + preds;\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return res;\n    }\n\n\n    // Tokenizing\n    // ///////////\n    public String[] _tokenize(String query) {\n        char inQuote = 0;\n        List<String> tokens = new ArrayList<String>();\n        String token = \"\";\n        for (int i = 0; i < query.length(); ++i) {\n            // quoted text\n            char c = query.charAt(i);\n            if (c == '\\'' || c == '\"') {\n                if (inQuote != 0) {\n                    if (c == inQuote) {\n                        inQuote = 0;\n                    } else {\n                        token += c;\n                    }\n                } else if (token.length() != 0) {\n                    // quotes are allowed to start directly after a :\n                    if (token.endsWith(\":\")) {\n                        inQuote = c;\n                    } else {\n                        token += c;\n                    }\n                } else {\n                    inQuote = c;\n                }\n                // separator\n            } else if (c == ' ') {\n                if (inQuote != 0) {\n                    token += c;\n                } else if (token.length() != 0) {\n                    // space marks token finished\n                    tokens.add(token);\n                    token = \"\";\n                }\n                // nesting\n            } else if (c == '(' || c == ')') {\n                if (inQuote != 0) {\n                    token += c;\n                } else {\n                    if (c == ')' && token.length() != 0) {\n                        tokens.add(token);\n                        token = \"\";\n                    }\n                    tokens.add(String.valueOf(c));\n                }\n                // negation\n            } else if (c == '-') {\n                if (token.length() != 0) {\n                    token += c;\n                } else if (tokens.size() == 0 || !tokens.get(tokens.size() - 1).equals(\"-\")) {\n                    tokens.add(\"-\");\n                }\n                // normal character\n            } else {\n                token += c;\n            }\n        }\n        // if we finished in a token, add it\n        if (token.length() != 0) {\n            tokens.add(token);\n        }\n        return tokens.toArray(new String[] {});\n    }\n\n    // Query building\n    // ///////////////\n    public class SearchState {\n        public boolean isnot;\n        public boolean isor;\n        public boolean join;\n        public String q;\n        public boolean bad;\n\n\n        public SearchState() {\n            isnot = false;\n            isor = false;\n            join = false;\n            q = \"\";\n            bad = false;\n        }\n    }\n\n\n    public Pair<String, String[]> _where(String[] tokens) {\n        // state and query\n        SearchState s = new SearchState();\n        List<String> args = new ArrayList<String>();\n        for (String token : tokens) {\n            if (s.bad) {\n                return new Pair<String, String[]>(null, null);\n            }\n            // special tokens\n            if (token.equals(\"-\")) {\n                s.isnot = true;\n            } else if (token.toLowerCase().equals(\"or\")) {\n                s.isor = true;\n            } else if (token.equals(\"(\")) {\n                addPred(s, token, false);\n                s.join = false;\n            } else if (token.equals(\")\")) {\n                s.q += \")\";\n                // commands\n            } else if (token.contains(\":\")) {\n                String[] spl = token.split(\":\", 2);\n                String cmd = spl[0].toLowerCase();\n                String val = spl[1];\n                if (cmd.equals(\"tag\")) {\n                    addPred(s, _findTag(val, args));\n                } else if (cmd.equals(\"is\")) {\n                    addPred(s, _findCardState(val));\n                } else if (cmd.equals(\"nid\")) {\n                    addPred(s, _findNids(val));\n                } else if (cmd.equals(\"card\")) {\n                    addPred(s, _findTemplate(val));\n                } else if (cmd.equals(\"note\")) {\n                    addPred(s, _findModel(val));\n                } else if (cmd.equals(\"mid\")) {\n                    addPred(s, _findMid(val));\n                } else if (cmd.equals(\"deck\")) {\n                    addPred(s, _findDeck(val));\n                } else if (cmd.equals(\"prop\")) {\n                    addPred(s, _findProp(val));\n                } else if (cmd.equals(\"rated\")) {\n                    addPred(s, _findRated(val));\n                } else if (cmd.equals(\"added\")) {\n                    addPred(s, _findAdded(val));\n                } else {\n                    addPred(s, _findField(cmd, val));\n                }\n                // normal text search\n            } else {\n                addPred(s, _findText(token, args));\n            }\n        }\n        if (s.bad) {\n            return new Pair<String, String[]>(null, null);\n        }\n        return new Pair<String, String[]>(s.q, args.toArray(new String[] {}));\n    }\n\n\n    private void addPred(SearchState s, String txt) {\n        addPred(s, txt, true);\n    }\n\n\n    private void addPred(SearchState s, String txt, boolean wrap) {\n        // failed command\n        if (txt == null || txt.length() == 0) {\n            // if it was to be negated then we can just ignore it\n            if (s.isnot) {\n                s.isnot = false;\n                return;\n            } else {\n                s.bad = true;\n                return;\n            }\n        } else if (txt.equals(\"skip\")) {\n            return;\n        }\n        // do we need a conjunction\n        if (s.join) {\n            if (s.isor) {\n                s.q += \" or \";\n                s.isor = false;\n            } else {\n                s.q += \" and \";\n            }\n        }\n        if (s.isnot) {\n            s.q += \" not \";\n            s.isnot = false;\n        }\n        if (wrap) {\n            txt = \"(\" + txt + \")\";\n        }\n        s.q += txt;\n        s.join = true;\n    }\n\n\n    private String _query(String preds, String order, boolean forCardBrowser) {\n        // can we skip the note table?\n        String sql;\n        if (forCardBrowser) {\n            sql = \"select c.id, n.sfld, c.did, c.queue, n.tags from cards c, notes n where c.nid=n.id and \";\n        } else {\n            if (!preds.contains(\"n.\") && !order.contains(\"n.\")) {\n                sql = \"select c.id from cards c where \";\n            } else {\n                sql = \"select c.id from cards c, notes n where c.nid=n.id and \";\n            }\n        }\n        // combine with preds\n        if (preds.length() != 0) {\n            sql += \"(\" + preds + \")\";\n        } else {\n            sql += \"1\";\n        }\n        // order\n        if (order != null && order.length() != 0) {\n            sql += \" \" + order;\n        }\n        return sql;\n    }\n\n\n    // Ordering\n    // /////////\n\n    private Pair<String, Boolean> _order(String order) {\n        if (order == null || order.length() == 0) {\n            return new Pair<String, Boolean>(\"\", false);\n        } else if (!order.equalsIgnoreCase(\"true\")) {\n            // custom order string provided\n            return new Pair<String, Boolean>(\" order by \" + order, false);\n        }\n        // use deck default\n        String type;\n        try {\n            type = mCol.getConf().getString(\"sortType\");\n            String sort = null;\n            if (type.startsWith(\"note\")) {\n                if (type.startsWith(\"noteCrt\")) {\n                    sort = \"n.id, c.ord\";\n                } else if (type.startsWith(\"noteMod\")) {\n                    sort = \"n.mod, c.ord\";\n                } else if (type.startsWith(\"noteFld\")) {\n                    sort = \"n.sfld COLLATE NOCASE, c.ord\";\n                }\n            } else if (type.startsWith(\"card\")) {\n                if (type.startsWith(\"cardMod\")) {\n                    sort = \"c.mod\";\n                } else if (type.startsWith(\"cardReps\")) {\n                    sort = \"c.reps\";\n                } else if (type.startsWith(\"cardDue\")) {\n                    sort = \"c.type, c.due\";\n                } else if (type.startsWith(\"cardEase\")) {\n                    sort = \"c.factor\";\n                } else if (type.startsWith(\"cardLapses\")) {\n                    sort = \"c.lapses\";\n                } else if (type.startsWith(\"cardIvl\")) {\n                    sort = \"c.ivl\";\n                }\n            }\n            if (sort == null) {\n            \t// deck has invalid sort order; revert to noteCrt\n            \tsort = \"n.id, c.ord\";\n            }\n            boolean sortBackwards = Upgrade.upgradeJSONIfNecessary(mCol, mCol.getConf(), \"sortBackwards\", false);\n            return new Pair<String, Boolean>(\" ORDER BY \" + sort, sortBackwards);\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    // Commands\n    // /////////\n\n    private String _findTag(String val, List<String> args) {\n        if (val.equals(\"none\")) {\n            return \"n.tags = \\\"\\\"\";\n        }\n        val = val.replace(\"*\", \"%\");\n        if (!val.startsWith(\"%\")) {\n            val = \"% \" + val;\n        }\n        if (!val.endsWith(\"%\")) {\n            val += \" %\";\n        }\n        args.add(val);\n        return \"n.tags like ?\";\n    }\n\n\n    private String _findCardState(String val) {\n        int n;\n        if (val.equals(\"review\") || val.equals(\"new\") || val.equals(\"learn\")) {\n            if (val.equals(\"review\")) {\n                n = 2;\n            } else if (val.equals(\"new\")) {\n                n = 0;\n            } else {\n                return \"queue IN (1, 3)\";\n            }\n            return \"type = \" + n;\n        } else if (val.equals(\"suspended\")) {\n            return \"c.queue = -1\";\n        } else if (val.equals(\"buried\")) {\n            return \"c.queue = -2\";\n        } else if (val.equals(\"due\")) {\n            return \"(c.queue in (2,3) and c.due <= \" + mCol.getSched().getToday() +\n                    \") or (c.queue = 1 and c.due <= \" + mCol.getSched().getDayCutoff() + \")\";\n        } else {\n            return null;\n        }\n    }\n\n\n    private String _findRated(String val) {\n        // days(:optional_ease)\n        String[] r = val.split(\":\");\n        int days;\n        try {\n            days = Integer.parseInt(r[0]);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        days = Math.min(days, 31);\n        // ease\n        String ease = \"\";\n        if (r.length > 1) {\n            if (!fValidEases.contains(r[1])) {\n                return \"\";\n            }\n            ease = \"and ease=\" + r[1];\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id in (select cid from revlog where id>\" + cutoff + \" \" + ease + \")\";\n    }\n\n\n    private String _findAdded(String val) {\n        int days;\n        try {\n            days = Integer.parseInt(val);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id > \" + cutoff;\n    }\n\n\n    private String _findProp(String _val) {\n        // extract\n        Matcher m = fPropPattern.matcher(_val);\n        if (!m.matches()) {\n            return \"\";\n        }\n        String prop = m.group(1).toLowerCase();\n        String cmp = m.group(2);\n        String sval = m.group(3);\n        int val;\n        // is val valid?\n        try {\n            if (prop.equals(\"ease\")) {\n                // This multiplying and convert to int happens later in libanki, moved it here for efficiency\n                val = (int) (Double.parseDouble(sval) * 1000);\n            } else {\n                val = Integer.parseInt(sval);\n            }\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        // is prop valid?\n        if (!fValidProps.contains(prop)) {\n            return \"\";\n        }\n        // query\n        String q = \"\";\n        if (prop.equals(\"due\")) {\n            val += mCol.getSched().getToday();\n            // only valid for review/daily learning\n            q = \"(c.queue in (2,3)) and \";\n        } else if (prop.equals(\"ease\")) {\n            prop = \"factor\";\n            // already done: val = int(val*1000)\n        }\n        q += \"(\" + prop + \" \" + cmp + \" \" + val + \")\";\n        return q;\n    }\n\n\n    private String _findText(String val, List<String> args) {\n        val = val.replace(\"*\", \"%\");\n        args.add(\"%\" + val + \"%\");\n        args.add(\"%\" + val + \"%\");\n        return \"(n.sfld like ? escape '\\\\' or n.flds like ? escape '\\\\')\";\n    }\n\n\n    private String _findNids(String val) {\n        if (fNidsPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.id in (\" + val + \")\";\n    }\n\n    private String _findMid(String val) {\n        if (fMidPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.mid = \" + val;\n    }\n\n    private String _findModel(String val) {\n        LinkedList<Long> ids = new LinkedList<Long>();\n        val = val.toLowerCase();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                if (m.getString(\"name\").toLowerCase().equals(val)) {\n                    ids.add(m.getLong(\"id\"));\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return \"n.mid in \" + Utils.ids2str(ids);\n    }\n\n\n    private List<Long> dids(long did) {\n        if (did == 0) {\n            return null;\n        }\n        TreeMap<String, Long> children = mCol.getDecks().children(did);\n\n        List<Long> res = new ArrayList<Long>();\n        res.add(did);\n        res.addAll(children.values());\n        return res;\n    }\n\n\n    public String _findDeck(String val) {\n        // if searching for all decks, skip\n        if (val.equals(\"*\")) {\n            return \"skip\";\n            // deck types\n        } else if (val.equals(\"filtered\")) {\n            return \"c.odid\";\n        }\n\n        List<Long> ids = null;\n        // current deck?\n        try {\n            if (val.toLowerCase().equals(\"current\")) {\n                ids = dids(mCol.getDecks().current().getLong(\"id\"));\n            } else if (!val.contains(\"*\")) {\n                // single deck\n                ids = dids(mCol.getDecks().id(val, false));\n            } else {\n                // widlcard\n                ids = new ArrayList<Long>();\n                val = val.replace(\"*\", \".*\");\n                for (JSONObject d : mCol.getDecks().all()) {\n                    if (d.getString(\"name\").matches(\"(?i)\" + val)) {\n                        for (long id : dids(d.getLong(\"id\"))) {\n                            ids.add(id);\n                        }\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (ids == null || ids.size() == 0) {\n            return \"\";\n        }\n        String sids = Utils.ids2str(ids);\n        return \"c.did in \" + sids + \" or c.odid in \" + sids;\n    }\n\n\n    private String _findTemplate(String val) {\n        // were we given an ordinal number?\n        Integer num = null;\n        try {\n            num = Integer.parseInt(val) - 1;\n        } catch (NumberFormatException e) {\n            num = null;\n        }\n        if (num != null) {\n            return \"c.ord = \" + num;\n        }\n        // search for template names\n        List<String> lims = new ArrayList<String>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray tmpls = m.getJSONArray(\"tmpls\");\n                for (int ti = 0; ti < tmpls.length(); ++ti) {\n                    JSONObject t = tmpls.getJSONObject(ti);\n                    if (t.getString(\"name\").equalsIgnoreCase(val)) {\n                        if (m.getInt(\"type\") == Sched.MODEL_CLOZE) {\n                            // if the user has asked for a cloze card, we want\n                            // to give all ordinals, so we just limit to the\n                            // model instead\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \")\");\n                        } else {\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \" and c.ord = \" +\n                                    t.getInt(\"ord\") + \")\");\n                        }\n                    }\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return Utils.join(\" or \", lims.toArray(new String[] {}));\n    }\n\n\n    private String _findField(String field, String val) {\n        val = val.replace(\"*\", \"%\");\n        // find models that have that field\n        Map<Long, Object[]> mods = new HashMap<Long, Object[]>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (f.getString(\"name\").equalsIgnoreCase(field)) {\n                        mods.put(m.getLong(\"id\"), new Object[] { m, f.getInt(\"ord\") });\n                    }\n\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (mods.isEmpty()) {\n            // nothing has that field\n            return \"\";\n        }\n        // gather nids\n        // Pattern.quote escapes the meta characters with \\Q \\E\n        String regex = Pattern.quote(val).replace(\"\\\\Q_\\\\E\", \".\").replace(\"\\\\Q%\\\\E\", \".*\");\n        LinkedList<Long> nids = new LinkedList<Long>();\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(\n                    \"select id, mid, flds from notes where mid in \" +\n                    Utils.ids2str(new LinkedList<Long>(mods.keySet())) +\n                    \" and flds like ? escape '\\\\'\", new String[] { \"%\" + val + \"%\" });\n            while (cur.moveToNext()) {\n                String[] flds = Utils.splitFields(cur.getString(2));\n                int ord = (Integer) mods.get(cur.getLong(1))[1];\n                String strg = flds[ord];\n                if (Pattern.compile(regex, Pattern.CASE_INSENSITIVE).matcher(strg).matches()) {\n                    nids.add(cur.getLong(0));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (nids.isEmpty()) {\n            return \"\";\n        }\n        return \"n.id in \" + Utils.ids2str(nids);\n    }\n\n\n    // Find and Replace\n    // /////////////////\n    /**\n     * Find and replace fields in a note\n     * \n     * @param col The collection to search into.\n     * @param nids The cards to be searched for.\n     * @param src The original text to find.\n     * @param dst The text to change to.\n     * @param regex If true, the src is treated as a regex. Default = false.\n     * @param field Limit the search to specific field. If null, it searches all fields.\n     * @param fold If true the search is case-insensitive. Default = true.\n     * @return\n     */\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst) {\n        return findReplace(col, nids, src, dst, false, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean regex) {\n        return findReplace(col, nids, src, dst, regex, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, String field) {\n        return findReplace(col, nids, src, dst, false, field, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean isRegex,\n            String field, boolean fold) {\n        Map<Long, Integer> mmap = new HashMap<Long, Integer>();\n        if (field != null) {\n            try {\n                for (JSONObject m : col.getModels().all()) {\n                    JSONArray flds = m.getJSONArray(\"flds\");\n                    for (int fi = 0; fi < flds.length(); ++fi) {\n                        JSONObject f = flds.getJSONObject(fi);\n                        if (f.getString(\"name\").equals(field)) {\n                            mmap.put(m.getLong(\"id\"), f.getInt(\"ord\"));\n                        }\n                    }\n                }\n            } catch (JSONException e) {\n                throw new RuntimeException(e);\n            }\n            if (mmap.isEmpty()) {\n                return 0;\n            }\n        }\n        // find and gather replacements\n        if (!isRegex) {\n            src = Pattern.quote(src);\n        }\n        if (fold) {\n            src = \"(?i)\" + src;\n        }\n        Pattern regex = Pattern.compile(src);\n\n        ArrayList<Object[]> d = new ArrayList<Object[]>();\n        String sql = \"select id, mid, flds from notes where id in \" + Utils.ids2str(nids.toArray(new Long[] {}));\n        nids = new ArrayList<Long>();\n\n        Cursor cur = null;\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                String flds = cur.getString(2);\n                String origFlds = flds;\n                // does it match?\n                String[] sflds = Utils.splitFields(flds);\n                if (field != null) {\n                    long mid = cur.getLong(1);\n                    if (!mmap.containsKey(mid)) {\n                        continue;\n                    }\n                    int ord = mmap.get(mid);\n                    sflds[ord] = regex.matcher(sflds[ord]).replaceAll(dst);\n                } else {\n                    for (int i = 0; i < sflds.length; ++i) {\n                        sflds[i] = regex.matcher(sflds[i]).replaceAll(dst);\n                    }\n                }\n                flds = Utils.joinFields(sflds);\n                if (!flds.equals(origFlds)) {\n                    long nid = cur.getLong(0);\n                    nids.add(nid);\n                    d.add(new Object[] { flds, Utils.intNow(), col.usn(), nid });\n                }\n\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (d.isEmpty()) {\n            return 0;\n        }\n        // replace\n        col.getDb().executeMany(\"update notes set flds=?,mod=?,usn=? where id=?\", d);\n        long[] pnids = Utils.toPrimitive(nids);\n        col.updateFieldCache(pnids);\n        col.genCards(pnids);\n        return d.size();\n    }\n\n\n    public List<String> fieldNames(Collection col, boolean downcase) {\n        Set<String> fields = new HashSet<String>();\n        List<String> names = new ArrayList<String>();\n        try {\n            for (JSONObject m : col.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (!fields.contains(f.getString(\"name\").toLowerCase())) {\n                        names.add(f.getString(\"name\"));\n                        fields.add(f.getString(\"name\").toLowerCase());\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (downcase) {\n            return new ArrayList<String>(fields);\n        }\n        return names;\n    }\n\n\n    // Find Duplicates\n    // ////////////////\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName) {\n        return findDupes(col, fieldName, \"\");\n    }\n\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName, String search) {\n        // limit search to notes with applicable field name\n    \tif (search != null && search.length() > 0) {\n            search = \"(\" + search + \") \";\n    \t}\n        search += \"'\" + fieldName + \":*'\";\n        // go through notes\n\n        String sql = \"select id, mid, flds from notes where id in \"\n                + Utils.ids2str(col.findNotes(search).toArray(new Long[] {}));\n        Cursor cur = null;\n        Map<Long, Integer> fields = new HashMap<Long, Integer>();\n        Map<String, List<Long>> vals = new HashMap<String, List<Long>>();\n        List<Pair<String, List<Long>>> dupes = new ArrayList<Pair<String, List<Long>>>();\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                long nid = cur.getLong(0);\n                long mid = cur.getLong(1);\n                String[] flds = Utils.splitFields(cur.getString(2));\n                // inlined ordForMid(mid)\n                if (!fields.containsKey(mid)) {\n                    JSONObject model = col.getModels().get(mid);\n                    fields.put(mid, col.getModels().fieldMap(model).get(fieldName).first);\n                }\n                String val = flds[fields.get(mid)];\n                // empty does not count as duplicate\n                if (val.equals(\"\")) {\n                    continue;\n                }\n                if (!vals.containsKey(val)) {\n                    vals.put(val, new ArrayList<Long>());\n                }\n                vals.get(val).add(nid);\n                if (vals.get(val).size() == 2) {\n                    dupes.add(new Pair<String, List<Long>>(val, vals.get(val)));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return dupes;\n    }\n}\n","Method after Refactoring":"/****************************************************************************************\n * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *\n * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.libanki;\n\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.util.Log;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.Pair;\nimport com.ichi2.upgrade.Upgrade;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Finder {\n\n    public static Pattern allPattern = Pattern\n            .compile(\"(-)?\\\\'(([^\\\\'\\\\\\\\]|\\\\\\\\.)*)\\\\'|(-)?\\\"(([^\\\"\\\\\\\\]|\\\\\\\\.)*)\\\"|(-)?([^ ]+)|([ ]+)\");\n    private static final Pattern fPropPattern = Pattern.compile(\"(^.+?)(<=|>=|!=|=|<|>)(.+?$)\");\n    private static final Pattern fNidsPattern = Pattern.compile(\"[^0-9,]\");\n    private static final Pattern fMidPattern = Pattern.compile(\"[^0-9]\");\n\n    private static final List<String> fValidEases = Arrays.asList(new String[] { \"1\", \"2\", \"3\", \"4\" });\n    private static final List<String> fValidProps = Arrays\n            .asList(new String[] { \"due\", \"ivl\", \"reps\", \"lapses\", \"ease\" });\n\n    private Collection mCol;\n\n\n    public Finder(Collection col) {\n        mCol = col;\n    }\n\n\n    /** Return a list of card ids for QUERY */\n    public List<Long> findCards(String query, String _order) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, false);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    /** Return a list of card ids for QUERY */\n    public ArrayList<HashMap<String, String>> findCardsForCardBrowser(String query, String _order, HashMap<String, String> deckNames) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        ArrayList<HashMap<String, String>> res = new ArrayList<HashMap<String, String>>();\n        if (preds == null) {\n            return res;\n        }\n        Pair<String, Boolean> res2 = _order(_order);\n        String order = res2.first;\n        boolean rev = res2.second;\n        String sql = _query(preds, order, true);\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                HashMap<String, String> map = new HashMap<String, String>();\n                map.put(\"id\", cur.getString(0));\n                map.put(\"sfld\", cur.getString(1));\n                map.put(\"deck\", deckNames.get(cur.getString(2)));\n                int queue = cur.getInt(3);\n                String tags = cur.getString(4);\n                map.put(\"flags\", Integer.toString((queue == -1 ? 1 : 0) + (tags.matches(\".*[Mm]arked.*\") ? 2 : 0)));\n                map.put(\"tags\", tags);\n                res.add(map);\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            Log.e(AnkiDroidApp.TAG, \"Invalid grouping, sql: \" + sql);\n            return new ArrayList<HashMap<String, String>>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (rev) {\n            Collections.reverse(res);\n        }\n        return res;\n    }\n\n    public List<Long> findNotes(String query) {\n        String[] tokens = _tokenize(query);\n        Pair<String, String[]> res1 = _where(tokens);\n        String preds = res1.first;\n        String[] args = res1.second;\n        List<Long> res = new ArrayList<Long>();\n        if (preds == null) {\n            return res;\n        }\n        if (preds.equals(\"\")) {\n            preds = \"1\";\n        } else {\n            preds = \"(\" + preds + \")\";\n        }\n        String sql = \"select distinct(n.id) from cards c, notes n where c.nid=n.id and \" + preds;\n        Cursor cur = null;\n        try {\n            cur = mCol.getDb().getDatabase().rawQuery(sql, args);\n            while (cur.moveToNext()) {\n                res.add(cur.getLong(0));\n            }\n        } catch (SQLException e) {\n            // invalid grouping\n            return new ArrayList<Long>();\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return res;\n    }\n\n\n    // Tokenizing\n    // ///////////\n    public String[] _tokenize(String query) {\n        char inQuote = 0;\n        List<String> tokens = new ArrayList<String>();\n        String token = \"\";\n        for (int i = 0; i < query.length(); ++i) {\n            // quoted text\n            char c = query.charAt(i);\n            if (c == '\\'' || c == '\"') {\n                if (inQuote != 0) {\n                    if (c == inQuote) {\n                        inQuote = 0;\n                    } else {\n                        token += c;\n                    }\n                } else if (token.length() != 0) {\n                    // quotes are allowed to start directly after a :\n                    if (token.endsWith(\":\")) {\n                        inQuote = c;\n                    } else {\n                        token += c;\n                    }\n                } else {\n                    inQuote = c;\n                }\n                // separator\n            } else if (c == ' ') {\n                if (inQuote != 0) {\n                    token += c;\n                } else if (token.length() != 0) {\n                    // space marks token finished\n                    tokens.add(token);\n                    token = \"\";\n                }\n                // nesting\n            } else if (c == '(' || c == ')') {\n                if (inQuote != 0) {\n                    token += c;\n                } else {\n                    if (c == ')' && token.length() != 0) {\n                        tokens.add(token);\n                        token = \"\";\n                    }\n                    tokens.add(String.valueOf(c));\n                }\n                // negation\n            } else if (c == '-') {\n                if (token.length() != 0) {\n                    token += c;\n                } else if (tokens.size() == 0 || !tokens.get(tokens.size() - 1).equals(\"-\")) {\n                    tokens.add(\"-\");\n                }\n                // normal character\n            } else {\n                token += c;\n            }\n        }\n        // if we finished in a token, add it\n        if (token.length() != 0) {\n            tokens.add(token);\n        }\n        return tokens.toArray(new String[] {});\n    }\n\n    // Query building\n    // ///////////////\n    public class SearchState {\n        public boolean isnot;\n        public boolean isor;\n        public boolean join;\n        public String q;\n        public boolean bad;\n\n\n        public SearchState() {\n            isnot = false;\n            isor = false;\n            join = false;\n            q = \"\";\n            bad = false;\n        }\n    }\n\n\n    public Pair<String, String[]> _where(String[] tokens) {\n        // state and query\n        SearchState s = new SearchState();\n        List<String> args = new ArrayList<String>();\n        for (String token : tokens) {\n            if (s.bad) {\n                return new Pair<String, String[]>(null, null);\n            }\n            // special tokens\n            if (token.equals(\"-\")) {\n                s.isnot = true;\n            } else if (token.toLowerCase().equals(\"or\")) {\n                s.isor = true;\n            } else if (token.equals(\"(\")) {\n                addPred(s, token, false);\n                s.join = false;\n            } else if (token.equals(\")\")) {\n                s.q += \")\";\n                // commands\n            } else if (token.contains(\":\")) {\n                String[] spl = token.split(\":\", 2);\n                String cmd = spl[0].toLowerCase();\n                String val = spl[1];\n                if (cmd.equals(\"tag\")) {\n                    addPred(s, _findTag(val, args));\n                } else if (cmd.equals(\"is\")) {\n                    addPred(s, _findCardState(val));\n                } else if (cmd.equals(\"nid\")) {\n                    addPred(s, _findNids(val));\n                } else if (cmd.equals(\"card\")) {\n                    addPred(s, _findTemplate(val));\n                } else if (cmd.equals(\"note\")) {\n                    addPred(s, _findModel(val));\n                } else if (cmd.equals(\"mid\")) {\n                    addPred(s, _findMid(val));\n                } else if (cmd.equals(\"deck\")) {\n                    addPred(s, _findDeck(val));\n                } else if (cmd.equals(\"prop\")) {\n                    addPred(s, _findProp(val));\n                } else if (cmd.equals(\"rated\")) {\n                    addPred(s, _findRated(val));\n                } else if (cmd.equals(\"added\")) {\n                    addPred(s, _findAdded(val));\n                } else {\n                    addPred(s, _findField(cmd, val));\n                }\n                // normal text search\n            } else {\n                addPred(s, _findText(token, args));\n            }\n        }\n        if (s.bad) {\n            return new Pair<String, String[]>(null, null);\n        }\n        return new Pair<String, String[]>(s.q, args.toArray(new String[] {}));\n    }\n\n\n    private void addPred(SearchState s, String txt) {\n        addPred(s, txt, true);\n    }\n\n\n    private void addPred(SearchState s, String txt, boolean wrap) {\n        // failed command\n        if (txt == null || txt.length() == 0) {\n            // if it was to be negated then we can just ignore it\n            if (s.isnot) {\n                s.isnot = false;\n                return;\n            } else {\n                s.bad = true;\n                return;\n            }\n        } else if (txt.equals(\"skip\")) {\n            return;\n        }\n        // do we need a conjunction\n        if (s.join) {\n            if (s.isor) {\n                s.q += \" or \";\n                s.isor = false;\n            } else {\n                s.q += \" and \";\n            }\n        }\n        if (s.isnot) {\n            s.q += \" not \";\n            s.isnot = false;\n        }\n        if (wrap) {\n            txt = \"(\" + txt + \")\";\n        }\n        s.q += txt;\n        s.join = true;\n    }\n\n\n    private String _query(String preds, String order, boolean forCardBrowser) {\n        // can we skip the note table?\n        String sql;\n        if (forCardBrowser) {\n            sql = \"select c.id, n.sfld, c.did, c.queue, n.tags from cards c, notes n where c.nid=n.id and \";\n        } else {\n            if (!preds.contains(\"n.\") && !order.contains(\"n.\")) {\n                sql = \"select c.id from cards c where \";\n            } else {\n                sql = \"select c.id from cards c, notes n where c.nid=n.id and \";\n            }\n        }\n        // combine with preds\n        if (preds.length() != 0) {\n            sql += \"(\" + preds + \")\";\n        } else {\n            sql += \"1\";\n        }\n        // order\n        if (order != null && order.length() != 0) {\n            sql += \" \" + order;\n        }\n        return sql;\n    }\n\n\n    // Ordering\n    // /////////\n\n    private Pair<String, Boolean> _order(String order) {\n        if (order == null || order.length() == 0) {\n            return new Pair<String, Boolean>(\"\", false);\n        } else if (!order.equalsIgnoreCase(\"true\")) {\n            // custom order string provided\n            return new Pair<String, Boolean>(\" order by \" + order, false);\n        }\n        // use deck default\n        String type;\n        try {\n            type = mCol.getConf().getString(\"sortType\");\n            String sort = null;\n            if (type.startsWith(\"note\")) {\n                if (type.startsWith(\"noteCrt\")) {\n                    sort = \"n.id, c.ord\";\n                } else if (type.startsWith(\"noteMod\")) {\n                    sort = \"n.mod, c.ord\";\n                } else if (type.startsWith(\"noteFld\")) {\n                    sort = \"n.sfld COLLATE NOCASE, c.ord\";\n                }\n            } else if (type.startsWith(\"card\")) {\n                if (type.startsWith(\"cardMod\")) {\n                    sort = \"c.mod\";\n                } else if (type.startsWith(\"cardReps\")) {\n                    sort = \"c.reps\";\n                } else if (type.startsWith(\"cardDue\")) {\n                    sort = \"c.type, c.due\";\n                } else if (type.startsWith(\"cardEase\")) {\n                    sort = \"c.factor\";\n                } else if (type.startsWith(\"cardLapses\")) {\n                    sort = \"c.lapses\";\n                } else if (type.startsWith(\"cardIvl\")) {\n                    sort = \"c.ivl\";\n                }\n            }\n            if (sort == null) {\n            \t// deck has invalid sort order; revert to noteCrt\n            \tsort = \"n.id, c.ord\";\n            }\n            boolean sortBackwards = Upgrade.upgradeJSONIfNecessary(mCol, mCol.getConf(), \"sortBackwards\", false);\n            return new Pair<String, Boolean>(\" ORDER BY \" + sort, sortBackwards);\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    // Commands\n    // /////////\n\n    private String _findTag(String val, List<String> args) {\n        if (val.equals(\"none\")) {\n            return \"n.tags = \\\"\\\"\";\n        }\n        val = val.replace(\"*\", \"%\");\n        if (!val.startsWith(\"%\")) {\n            val = \"% \" + val;\n        }\n        if (!val.endsWith(\"%\")) {\n            val += \" %\";\n        }\n        args.add(val);\n        return \"n.tags like ?\";\n    }\n\n\n    private String _findCardState(String val) {\n        int n;\n        if (val.equals(\"review\") || val.equals(\"new\") || val.equals(\"learn\")) {\n            if (val.equals(\"review\")) {\n                n = 2;\n            } else if (val.equals(\"new\")) {\n                n = 0;\n            } else {\n                return \"queue IN (1, 3)\";\n            }\n            return \"type = \" + n;\n        } else if (val.equals(\"suspended\")) {\n            return \"c.queue = -1\";\n        } else if (val.equals(\"buried\")) {\n            return \"c.queue = -2\";\n        } else if (val.equals(\"due\")) {\n            return \"(c.queue in (2,3) and c.due <= \" + mCol.getSched().getToday() +\n                    \") or (c.queue = 1 and c.due <= \" + mCol.getSched().getDayCutoff() + \")\";\n        } else {\n            return null;\n        }\n    }\n\n\n    private String _findRated(String val) {\n        // days(:optional_ease)\n        String[] r = val.split(\":\");\n        int days;\n        try {\n            days = Integer.parseInt(r[0]);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        days = Math.min(days, 31);\n        // ease\n        String ease = \"\";\n        if (r.length > 1) {\n            if (!fValidEases.contains(r[1])) {\n                return \"\";\n            }\n            ease = \"and ease=\" + r[1];\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id in (select cid from revlog where id>\" + cutoff + \" \" + ease + \")\";\n    }\n\n\n    private String _findAdded(String val) {\n        int days;\n        try {\n            days = Integer.parseInt(val);\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n        return \"c.id > \" + cutoff;\n    }\n\n\n    private String _findProp(String _val) {\n        // extract\n        Matcher m = fPropPattern.matcher(_val);\n        if (!m.matches()) {\n            return \"\";\n        }\n        String prop = m.group(1).toLowerCase();\n        String cmp = m.group(2);\n        String sval = m.group(3);\n        int val;\n        // is val valid?\n        try {\n            if (prop.equals(\"ease\")) {\n                // This multiplying and convert to int happens later in libanki, moved it here for efficiency\n                val = (int) (Double.parseDouble(sval) * 1000);\n            } else {\n                val = Integer.parseInt(sval);\n            }\n        } catch (NumberFormatException e) {\n            return \"\";\n        }\n        // is prop valid?\n        if (!fValidProps.contains(prop)) {\n            return \"\";\n        }\n        // query\n        String q = \"\";\n        if (prop.equals(\"due\")) {\n            val += mCol.getSched().getToday();\n            // only valid for review/daily learning\n            q = \"(c.queue in (2,3)) and \";\n        } else if (prop.equals(\"ease\")) {\n            prop = \"factor\";\n            // already done: val = int(val*1000)\n        }\n        q += \"(\" + prop + \" \" + cmp + \" \" + val + \")\";\n        return q;\n    }\n\n\n    private String _findText(String val, List<String> args) {\n        val = val.replace(\"*\", \"%\");\n        args.add(\"%\" + val + \"%\");\n        args.add(\"%\" + val + \"%\");\n        return \"(n.sfld like ? escape '\\\\' or n.flds like ? escape '\\\\')\";\n    }\n\n\n    private String _findNids(String val) {\n        if (fNidsPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.id in (\" + val + \")\";\n    }\n\n    private String _findMid(String val) {\n        if (fMidPattern.matcher(val).find()) {\n            return \"\";\n        }\n        return \"n.mid = \" + val;\n    }\n\n    private String _findModel(String val) {\n        LinkedList<Long> ids = new LinkedList<Long>();\n        val = val.toLowerCase();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                if (m.getString(\"name\").toLowerCase().equals(val)) {\n                    ids.add(m.getLong(\"id\"));\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return \"n.mid in \" + Utils.ids2str(ids);\n    }\n\n\n    private List<Long> dids(long did) {\n        if (did == 0) {\n            return null;\n        }\n        TreeMap<String, Long> children = mCol.getDecks().children(did);\n\n        List<Long> res = new ArrayList<Long>();\n        res.add(did);\n        res.addAll(children.values());\n        return res;\n    }\n\n\n    public String _findDeck(String val) {\n        // if searching for all decks, skip\n        if (val.equals(\"*\")) {\n            return \"skip\";\n            // deck types\n        } else if (val.equals(\"filtered\")) {\n            return \"c.odid\";\n        }\n\n        List<Long> ids = null;\n        // current deck?\n        try {\n            if (val.toLowerCase().equals(\"current\")) {\n                ids = dids(mCol.getDecks().current().getLong(\"id\"));\n            } else if (!val.contains(\"*\")) {\n                // single deck\n                ids = dids(mCol.getDecks().id(val, false));\n            } else {\n                // widlcard\n                ids = new ArrayList<Long>();\n                val = val.replace(\"*\", \".*\");\n                for (JSONObject d : mCol.getDecks().all()) {\n                    if (d.getString(\"name\").matches(\"(?i)\" + val)) {\n                        for (long id : dids(d.getLong(\"id\"))) {\n                            ids.add(id);\n                        }\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (ids == null || ids.size() == 0) {\n            return \"\";\n        }\n        String sids = Utils.ids2str(ids);\n        return \"c.did in \" + sids + \" or c.odid in \" + sids;\n    }\n\n\n    private String _findTemplate(String val) {\n        // were we given an ordinal number?\n        Integer num = null;\n        try {\n            num = Integer.parseInt(val) - 1;\n        } catch (NumberFormatException e) {\n            num = null;\n        }\n        if (num != null) {\n            return \"c.ord = \" + num;\n        }\n        // search for template names\n        List<String> lims = new ArrayList<String>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray tmpls = m.getJSONArray(\"tmpls\");\n                for (int ti = 0; ti < tmpls.length(); ++ti) {\n                    JSONObject t = tmpls.getJSONObject(ti);\n                    if (t.getString(\"name\").equalsIgnoreCase(val)) {\n                        if (m.getInt(\"type\") == Sched.MODEL_CLOZE) {\n                            // if the user has asked for a cloze card, we want\n                            // to give all ordinals, so we just limit to the\n                            // model instead\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \")\");\n                        } else {\n                            lims.add(\"(n.mid = \" + m.getLong(\"id\") + \" and c.ord = \" +\n                                    t.getInt(\"ord\") + \")\");\n                        }\n                    }\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return Utils.join(\" or \", lims.toArray(new String[] {}));\n    }\n\n\n    private String _findField(String field, String val) {\n        /*\n         * We need two expressions to query the cards: One that will use JAVA REGEX syntax and another\n         * that should use SQLITE LIKE clause syntax.\n         */\n        String sqlVal = val\n                .replace(\"%\",\"\\\\%\") // For SQLITE, we escape all % signs\n                .replace(\"*\",\"%\"); // And then convert the * into non-escaped % signs\n\n        /*\n         * The following three lines make sure that only _ and * are valid wildcards. \n         * Any other characters are enclosed inside the \\Q \\E markers, which force  \n         * all meta-characters in between them to lose their special meaning \n         */\n        String javaVal = val\n                    .replace(\"_\",\"\\\\E.\\\\Q\") \n                    .replace(\"*\",\"\\\\E.*\\\\Q\");\n        /*\n         * For the pattern, we use the javaVal expression that uses JAVA REGEX syntax\n         */\n        Pattern pattern = Pattern.compile(\"\\\\Q\" + javaVal + \"\\\\E\", Pattern.CASE_INSENSITIVE);\n\n        // find models that have that field\n        Map<Long, Object[]> mods = new HashMap<Long, Object[]>();\n        try {\n            for (JSONObject m : mCol.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (f.getString(\"name\").equalsIgnoreCase(field)) {\n                        mods.put(m.getLong(\"id\"), new Object[] { m, f.getInt(\"ord\") });\n                    }\n\n                }\n\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (mods.isEmpty()) {\n            // nothing has that field\n            return \"\";\n        }\n        LinkedList<Long> nids = new LinkedList<Long>();\n        Cursor cur = null;\n        try {\n            /*\n             * Here we use the sqlVal expression, that is required for LIKE syntax in sqllite.\n             * There is no problem with special characters, because only % and _ are special\n             * characters in this syntax.\n             */\n            cur = mCol.getDb().getDatabase().rawQuery(\n                    \"select id, mid, flds from notes where mid in \" +\n                            Utils.ids2str(new LinkedList<Long>(mods.keySet())) +\n                            \" and flds like ? escape '\\\\'\", new String[] { \"%\" + sqlVal + \"%\" });\n\n            while (cur.moveToNext()) {\n                String[] flds = Utils.splitFields(cur.getString(2));\n                int ord = (Integer) mods.get(cur.getLong(1))[1];\n                String strg = flds[ord];\n                if (pattern.matcher(strg).matches()) {\n                    nids.add(cur.getLong(0));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (nids.isEmpty()) {\n            return \"\";\n        }\n        return \"n.id in \" + Utils.ids2str(nids);\n    }\n\n\n    // Find and Replace\n    // /////////////////\n    /**\n     * Find and replace fields in a note\n     * \n     * @param col The collection to search into.\n     * @param nids The cards to be searched for.\n     * @param src The original text to find.\n     * @param dst The text to change to.\n     * @param regex If true, the src is treated as a regex. Default = false.\n     * @param field Limit the search to specific field. If null, it searches all fields.\n     * @param fold If true the search is case-insensitive. Default = true.\n     * @return\n     */\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst) {\n        return findReplace(col, nids, src, dst, false, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean regex) {\n        return findReplace(col, nids, src, dst, regex, null, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, String field) {\n        return findReplace(col, nids, src, dst, false, field, true);\n    }\n\n\n    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean isRegex,\n            String field, boolean fold) {\n        Map<Long, Integer> mmap = new HashMap<Long, Integer>();\n        if (field != null) {\n            try {\n                for (JSONObject m : col.getModels().all()) {\n                    JSONArray flds = m.getJSONArray(\"flds\");\n                    for (int fi = 0; fi < flds.length(); ++fi) {\n                        JSONObject f = flds.getJSONObject(fi);\n                        if (f.getString(\"name\").equals(field)) {\n                            mmap.put(m.getLong(\"id\"), f.getInt(\"ord\"));\n                        }\n                    }\n                }\n            } catch (JSONException e) {\n                throw new RuntimeException(e);\n            }\n            if (mmap.isEmpty()) {\n                return 0;\n            }\n        }\n        // find and gather replacements\n        if (!isRegex) {\n            src = Pattern.quote(src);\n        }\n        if (fold) {\n            src = \"(?i)\" + src;\n        }\n        Pattern regex = Pattern.compile(src);\n\n        ArrayList<Object[]> d = new ArrayList<Object[]>();\n        String sql = \"select id, mid, flds from notes where id in \" + Utils.ids2str(nids.toArray(new Long[] {}));\n        nids = new ArrayList<Long>();\n\n        Cursor cur = null;\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                String flds = cur.getString(2);\n                String origFlds = flds;\n                // does it match?\n                String[] sflds = Utils.splitFields(flds);\n                if (field != null) {\n                    long mid = cur.getLong(1);\n                    if (!mmap.containsKey(mid)) {\n                        continue;\n                    }\n                    int ord = mmap.get(mid);\n                    sflds[ord] = regex.matcher(sflds[ord]).replaceAll(dst);\n                } else {\n                    for (int i = 0; i < sflds.length; ++i) {\n                        sflds[i] = regex.matcher(sflds[i]).replaceAll(dst);\n                    }\n                }\n                flds = Utils.joinFields(sflds);\n                if (!flds.equals(origFlds)) {\n                    long nid = cur.getLong(0);\n                    nids.add(nid);\n                    d.add(new Object[] { flds, Utils.intNow(), col.usn(), nid });\n                }\n\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        if (d.isEmpty()) {\n            return 0;\n        }\n        // replace\n        col.getDb().executeMany(\"update notes set flds=?,mod=?,usn=? where id=?\", d);\n        long[] pnids = Utils.toPrimitive(nids);\n        col.updateFieldCache(pnids);\n        col.genCards(pnids);\n        return d.size();\n    }\n\n\n    public List<String> fieldNames(Collection col, boolean downcase) {\n        Set<String> fields = new HashSet<String>();\n        List<String> names = new ArrayList<String>();\n        try {\n            for (JSONObject m : col.getModels().all()) {\n                JSONArray flds = m.getJSONArray(\"flds\");\n                for (int fi = 0; fi < flds.length(); ++fi) {\n                    JSONObject f = flds.getJSONObject(fi);\n                    if (!fields.contains(f.getString(\"name\").toLowerCase())) {\n                        names.add(f.getString(\"name\"));\n                        fields.add(f.getString(\"name\").toLowerCase());\n                    }\n                }\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        if (downcase) {\n            return new ArrayList<String>(fields);\n        }\n        return names;\n    }\n\n\n    // Find Duplicates\n    // ////////////////\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName) {\n        return findDupes(col, fieldName, \"\");\n    }\n\n\n    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName, String search) {\n        // limit search to notes with applicable field name\n    \tif (search != null && search.length() > 0) {\n            search = \"(\" + search + \") \";\n    \t}\n        search += \"'\" + fieldName + \":*'\";\n        // go through notes\n\n        String sql = \"select id, mid, flds from notes where id in \"\n                + Utils.ids2str(col.findNotes(search).toArray(new Long[] {}));\n        Cursor cur = null;\n        Map<Long, Integer> fields = new HashMap<Long, Integer>();\n        Map<String, List<Long>> vals = new HashMap<String, List<Long>>();\n        List<Pair<String, List<Long>>> dupes = new ArrayList<Pair<String, List<Long>>>();\n        try {\n            cur = col.getDb().getDatabase().rawQuery(sql, null);\n            while (cur.moveToNext()) {\n                long nid = cur.getLong(0);\n                long mid = cur.getLong(1);\n                String[] flds = Utils.splitFields(cur.getString(2));\n                // inlined ordForMid(mid)\n                if (!fields.containsKey(mid)) {\n                    JSONObject model = col.getModels().get(mid);\n                    fields.put(mid, col.getModels().fieldMap(model).get(fieldName).first);\n                }\n                String val = flds[fields.get(mid)];\n                // empty does not count as duplicate\n                if (val.equals(\"\")) {\n                    continue;\n                }\n                if (!vals.containsKey(val)) {\n                    vals.put(val, new ArrayList<Long>());\n                }\n                vals.get(val).add(nid);\n                if (vals.get(val).size() == 2) {\n                    dupes.add(new Pair<String, List<Long>>(val, vals.get(val)));\n                }\n            }\n        } finally {\n            if (cur != null) {\n                cur.close();\n            }\n        }\n        return dupes;\n    }\n}\n","lineNo":703}
{"Smelly Sample":"\n/****************************************************************************************\n * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.preferences;\n\nimport android.content.Context;\nimport android.preference.EditTextPreference;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.R;\nimport com.ichi2.themes.Themes;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\n\npublic class StepsPreference extends EditTextPreference {\n\n    private final boolean mAllowEmpty;\n\n\n    public StepsPreference(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context) {\n        super(context);\n        mAllowEmpty = getAllowEmptyFromAttributes(null);\n    }\n\n\n    @Override\n    protected void onDialogClosed(boolean positiveResult) {\n        if (positiveResult) {\n            String validated = getValidatedStepsInput(getEditText().getText().toString());\n            if (validated == null) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_error), false);\n            } else if (TextUtils.isEmpty(validated) && !mAllowEmpty) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_min_error), false);\n            } else {\n                setText(validated);\n            }\n        }\n    }\n\n\n    /**\n     * Check if the string is a valid format for steps and return that string. Some cleanup\n     * is done if needed (e.g., turning 1.0 into 1, trimming whitespace) for better usability.\n     * @param steps User input in text editor.\n     * @return The correctly formatted string or null if the input is not valid.\n     */\n    private String getValidatedStepsInput(String steps) {\n        if (TextUtils.isEmpty(steps)) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String s : steps.split(\"\\\\s+\")) {\n            try {\n                float f = Float.parseFloat(s);\n                // Steps can't be 0, negative, or non-serializable (too large), so it's invalid.\n                if (f <= 0 || Float.isInfinite(f)) {\n                    return null;\n                }\n                // Use whole numbers if we can (but still allow decimals)\n                int i = (int) f;\n                if (i == f) {\n                    sb.append(i).append(\" \");\n                } else {\n                    sb.append(f).append(\" \");\n                }\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        }\n        return sb.toString().trim();\n    }\n\n\n    /**\n     * Convert steps format.\n     * \n     * @param a JSONArray representation of steps.\n     * @return The steps as a space-separated string.\n     */\n    public static String convertFromJSON(JSONArray a) {\n        StringBuilder sb = new StringBuilder();\n        try {\n            for (int i = 0; i < a.length(); i++) {\n                sb.append(a.getString(i)).append(\" \");\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString().trim();\n    }\n\n\n    /**\n     * Convert steps format.\n     * \n     * @param steps String representation of steps.\n     * @return The steps as a JSONArray.\n     */\n    public static JSONArray convertToJSON(String steps) {\n        JSONArray ja = new JSONArray();\n        for (String s : TextUtils.split(steps, \" \")) {\n            ja.put(s);\n        }\n        return ja;\n    }\n\n\n    private boolean getAllowEmptyFromAttributes(AttributeSet attrs) {\n        return attrs == null ? true : attrs.getAttributeBooleanValue(AnkiDroidApp.APP_NAMESPACE, \"allowEmpty\", true);\n    }\n}\n","Method after Refactoring":"\n/****************************************************************************************\n * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.preferences;\n\nimport android.content.Context;\nimport android.preference.EditTextPreference;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.R;\nimport com.ichi2.themes.Themes;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\n\npublic class StepsPreference extends EditTextPreference {\n\n    private final boolean mAllowEmpty;\n\n\n    public StepsPreference(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context) {\n        super(context);\n        mAllowEmpty = getAllowEmptyFromAttributes(null);\n    }\n\n\n    @Override\n    protected void onDialogClosed(boolean positiveResult) {\n        if (positiveResult) {\n            String validated = getValidatedStepsInput(getEditText().getText().toString());\n            if (validated == null) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_error), false);\n            } else if (TextUtils.isEmpty(validated) && !mAllowEmpty) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_min_error), false);\n            } else {\n                setText(validated);\n            }\n        }\n    }\n\n\n    /**\n     * Check if the string is a valid format for steps and return that string, reformatted for better\n     * usability if needed.\n     * @param steps User input in text editor.\n     * @return The correctly formatted string or null if the input is not valid.\n     */\n    private String getValidatedStepsInput(String steps) {\n        JSONArray ja = convertToJSON(steps);\n        if (ja == null) {\n            return null;\n        } else {\n            StringBuilder sb = new StringBuilder();\n            try {\n                for (int i = 0; i < ja.length(); i++) {\n                    sb.append(ja.getString(i)).append(\" \");\n                }\n                return sb.toString().trim();\n            } catch (JSONException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n\n    /**\n     * Convert steps format.\n     * \n     * @param a JSONArray representation of steps.\n     * @return The steps as a space-separated string.\n     */\n    public static String convertFromJSON(JSONArray a) {\n        StringBuilder sb = new StringBuilder();\n        try {\n            for (int i = 0; i < a.length(); i++) {\n                sb.append(a.getString(i)).append(\" \");\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString().trim();\n    }\n\n\n    /**\n     * Convert steps format. For better usability, rounded floats are converted to integers (e.g.,\n     * 1.0 is converted to 1).\n     *\n     * @param steps String representation of steps.\n     * @return The steps as a JSONArray or null if the steps are not valid.\n     */\n    public static JSONArray convertToJSON(String steps) {\n        JSONArray ja = new JSONArray();\n        steps = steps.trim();\n        if (TextUtils.isEmpty(steps)) {\n            return ja;\n        }\n        try {\n            for (String s : steps.split(\"\\\\s+\")) {\n                float f = Float.parseFloat(s);\n                // 0 or less is not a valid step.\n                if (f <= 0) {\n                    return null;\n                }\n                // Use whole numbers if we can (but still allow decimals)\n                int i = (int) f;\n                if (i == f) {\n                    ja.put(i);\n                } else {\n                    ja.put(f);\n                }\n            }\n        } catch (NumberFormatException e) {\n            return null;\n        } catch (JSONException e) {\n            // Can't serialize float. Value likely too big/small.\n            return null;\n        }\n        return ja;\n    }\n\n\n    private boolean getAllowEmptyFromAttributes(AttributeSet attrs) {\n        return attrs == null ? true : attrs.getAttributeBooleanValue(AnkiDroidApp.APP_NAMESPACE, \"allowEmpty\", true);\n    }\n}\n","lineNo":130}
{"Smelly Sample":"\n/****************************************************************************************\n * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.preferences;\n\nimport android.content.Context;\nimport android.preference.EditTextPreference;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.R;\nimport com.ichi2.themes.Themes;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\n\npublic class StepsPreference extends EditTextPreference {\n\n    private final boolean mAllowEmpty;\n\n\n    public StepsPreference(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context) {\n        super(context);\n        mAllowEmpty = getAllowEmptyFromAttributes(null);\n    }\n\n\n    @Override\n    protected void onDialogClosed(boolean positiveResult) {\n        if (positiveResult) {\n            String validated = getValidatedStepsInput(getEditText().getText().toString());\n            if (validated == null) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_error), false);\n            } else if (TextUtils.isEmpty(validated) && !mAllowEmpty) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_min_error), false);\n            } else {\n                setText(validated);\n            }\n        }\n    }\n\n\n    /**\n     * Check if the string is a valid format for steps and return that string. Some cleanup\n     * is done if needed (e.g., turning 1.0 into 1, trimming whitespace) for better usability.\n     * @param steps User input in text editor.\n     * @return The correctly formatted string or null if the input is not valid.\n     */\n    private String getValidatedStepsInput(String steps) {\n        if (TextUtils.isEmpty(steps)) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String s : steps.split(\"\\\\s+\")) {\n            try {\n                float f = Float.parseFloat(s);\n                // Steps can't be 0, negative, or non-serializable (too large), so it's invalid.\n                if (f <= 0 || Float.isInfinite(f)) {\n                    return null;\n                }\n                // Use whole numbers if we can (but still allow decimals)\n                int i = (int) f;\n                if (i == f) {\n                    sb.append(i).append(\" \");\n                } else {\n                    sb.append(f).append(\" \");\n                }\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        }\n        return sb.toString().trim();\n    }\n\n\n    /**\n     * Convert steps format.\n     * \n     * @param a JSONArray representation of steps.\n     * @return The steps as a space-separated string.\n     */\n    public static String convertFromJSON(JSONArray a) {\n        StringBuilder sb = new StringBuilder();\n        try {\n            for (int i = 0; i < a.length(); i++) {\n                sb.append(a.getString(i)).append(\" \");\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString().trim();\n    }\n\n\n    /**\n     * Convert steps format.\n     * \n     * @param steps String representation of steps.\n     * @return The steps as a JSONArray.\n     */\n    public static JSONArray convertToJSON(String steps) {\n        JSONArray ja = new JSONArray();\n        for (String s : TextUtils.split(steps, \" \")) {\n            ja.put(s);\n        }\n        return ja;\n    }\n\n\n    private boolean getAllowEmptyFromAttributes(AttributeSet attrs) {\n        return attrs == null ? true : attrs.getAttributeBooleanValue(AnkiDroidApp.APP_NAMESPACE, \"allowEmpty\", true);\n    }\n}\n","Method after Refactoring":"\n/****************************************************************************************\n * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.preferences;\n\nimport android.content.Context;\nimport android.preference.EditTextPreference;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\n\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.R;\nimport com.ichi2.themes.Themes;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\n\npublic class StepsPreference extends EditTextPreference {\n\n    private final boolean mAllowEmpty;\n\n\n    public StepsPreference(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mAllowEmpty = getAllowEmptyFromAttributes(attrs);\n    }\n\n\n    public StepsPreference(Context context) {\n        super(context);\n        mAllowEmpty = getAllowEmptyFromAttributes(null);\n    }\n\n\n    @Override\n    protected void onDialogClosed(boolean positiveResult) {\n        if (positiveResult) {\n            String validated = getValidatedStepsInput(getEditText().getText().toString());\n            if (validated == null) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_error), false);\n            } else if (TextUtils.isEmpty(validated) && !mAllowEmpty) {\n                Themes.showThemedToast(getContext(),\n                        getContext().getResources().getString(R.string.steps_min_error), false);\n            } else {\n                setText(validated);\n            }\n        }\n    }\n\n\n    /**\n     * Check if the string is a valid format for steps and return that string, reformatted for better\n     * usability if needed.\n     * @param steps User input in text editor.\n     * @return The correctly formatted string or null if the input is not valid.\n     */\n    private String getValidatedStepsInput(String steps) {\n        JSONArray ja = convertToJSON(steps);\n        if (ja == null) {\n            return null;\n        } else {\n            StringBuilder sb = new StringBuilder();\n            try {\n                for (int i = 0; i < ja.length(); i++) {\n                    sb.append(ja.getString(i)).append(\" \");\n                }\n                return sb.toString().trim();\n            } catch (JSONException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n\n    /**\n     * Convert steps format.\n     * \n     * @param a JSONArray representation of steps.\n     * @return The steps as a space-separated string.\n     */\n    public static String convertFromJSON(JSONArray a) {\n        StringBuilder sb = new StringBuilder();\n        try {\n            for (int i = 0; i < a.length(); i++) {\n                sb.append(a.getString(i)).append(\" \");\n            }\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString().trim();\n    }\n\n\n    /**\n     * Convert steps format. For better usability, rounded floats are converted to integers (e.g.,\n     * 1.0 is converted to 1).\n     *\n     * @param steps String representation of steps.\n     * @return The steps as a JSONArray or null if the steps are not valid.\n     */\n    public static JSONArray convertToJSON(String steps) {\n        JSONArray ja = new JSONArray();\n        steps = steps.trim();\n        if (TextUtils.isEmpty(steps)) {\n            return ja;\n        }\n        try {\n            for (String s : steps.split(\"\\\\s+\")) {\n                float f = Float.parseFloat(s);\n                // 0 or less is not a valid step.\n                if (f <= 0) {\n                    return null;\n                }\n                // Use whole numbers if we can (but still allow decimals)\n                int i = (int) f;\n                if (i == f) {\n                    ja.put(i);\n                } else {\n                    ja.put(f);\n                }\n            }\n        } catch (NumberFormatException e) {\n            return null;\n        } catch (JSONException e) {\n            // Can't serialize float. Value likely too big/small.\n            return null;\n        }\n        return ja;\n    }\n\n\n    private boolean getAllowEmptyFromAttributes(AttributeSet attrs) {\n        return attrs == null ? true : attrs.getAttributeBooleanValue(AnkiDroidApp.APP_NAMESPACE, \"allowEmpty\", true);\n    }\n}\n","lineNo":136}
{"Smelly Sample":"/****************************************************************************************\n * Copyright (c) 2009 Daniel Svrd <daniel.svard@gmail.com>                             *\n * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *\n * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *\n * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.libanki;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.net.Uri;\nimport android.text.Html;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.LinearLayout;\nimport com.ichi2.anki.AnkiDb;\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.AnkiFont;\nimport com.ichi2.anki.R;\nimport com.mindprod.common11.BigDate;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.nio.channels.FileChannel;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.sql.Date;\nimport java.text.NumberFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Enumeration;\nimport java.util.GregorianCalendar;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.TimeZone;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n/**\n * TODO comments\n */\npublic class Utils {\n    enum SqlCommandType { SQL_INS, SQL_UPD, SQL_DEL };\n\n    // Used to format doubles with English's decimal separator system\n    public static final Locale ENGLISH_LOCALE = new Locale(\"en_US\");\n\n    public static final int CHUNK_SIZE = 32768;\n\n    private static final int DAYS_BEFORE_1970 = 719163;\n\n    private static NumberFormat mCurrentNumberFormat;\n    private static NumberFormat mCurrentPercentageFormat;\n\n    private static TreeSet<Long> sIdTree;\n    private static long sIdTime;\n\n    private static final int TIME_SECONDS = 0;\n    private static final int TIME_MINUTES = 1;\n    private static final int TIME_HOURS = 2;\n    private static final int TIME_DAYS = 3;\n    private static final int TIME_MONTHS = 4;\n    private static final int TIME_YEARS = 5;\n\n    public static final int TIME_FORMAT_DEFAULT = 0;\n    public static final int TIME_FORMAT_IN = 1;\n    public static final int TIME_FORMAT_BEFORE = 2;\n\n    /* Prevent class from being instantiated */\n    private Utils() { }\n\n    // Regex pattern used in removing tags from text before diff\n    private static final Pattern stylePattern = Pattern.compile(\"(?s)<style.*?>.*?<\/style>\");\n    private static final Pattern scriptPattern = Pattern.compile(\"(?s)<script.*?>.*?<\/script>\");\n    private static final Pattern tagPattern = Pattern.compile(\"<.*?>\");\n    private static final Pattern imgPattern = Pattern.compile(\"<img src=[\\\\\\\"']?([^\\\\\\\"'>]+)[\\\\\\\"']? ?/?>\");\n    private static final Pattern htmlEntitiesPattern = Pattern.compile(\"&#?\\\\w+;\");\n\n    private static final String ALL_CHARACTERS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    private static final String BASE91_EXTRA_CHARS = \"!#$%&()*+,-./:;<=>?@[]^_`{|}~\";\n\n    public static final int FILE_COPY_BUFFER_SIZE = 2048;\n\n    /**The time in integer seconds. Pass scale=1000 to get milliseconds. */\n    public static double now() {\n        return (System.currentTimeMillis() / 1000.0);\n    }\n\n\n    /**The time in integer seconds. Pass scale=1000 to get milliseconds. */\n    public static long intNow() {\n    \treturn intNow(1);\n    }\n\tpublic static long intNow(int scale) {\n        return (long) (now() * scale);\n    }\n\n    // timetable\n    // aftertimetable\n    // shorttimetable\n    \n    /**\n     * Return a string representing a time span (eg '2 days').\n     * @param inFormat: if true, return eg 'in 2 days'\n     */\n    public static String fmtTimeSpan(int time) {\n        return fmtTimeSpan(time, 0, false, false);\n    }\n    public static String fmtTimeSpan(int time, boolean _short) {\n        return fmtTimeSpan(time, 0, _short, false);\n    }\n    public static String fmtTimeSpan(int time, int format, boolean _short, boolean boldNumber) {\n    \tint type;\n    \tint unit = 99;\n    \tint point = 0;\n    \tif (Math.abs(time) < 60 || unit < 1) {\n    \t\ttype = TIME_SECONDS;\n    \t} else if (Math.abs(time) < 3600 || unit < 2) {\n    \t\ttype = TIME_MINUTES;\n    \t} else if (Math.abs(time) < 60 * 60 * 24 || unit < 3) {\n    \t\ttype = TIME_HOURS;\n    \t} else if (Math.abs(time) < 60 * 60 * 24 * 29.5 || unit < 4) {\n    \t\ttype = TIME_DAYS;\n    \t} else if (Math.abs(time) < 60 * 60 * 24 * 30 * 11.95 || unit < 5) {\n    \t\ttype = TIME_MONTHS;\n    \t\tpoint = 1;\n    \t} else {\n    \t\ttype = TIME_YEARS;\n    \t\tpoint = 1;\n    \t}\n    \tdouble ftime = convertSecondsTo(time, type);\n\n    \tint formatId;\n    \tif (false){//_short) {\n    \t    //formatId = R.array.next_review_short;\n    \t} else {\n        \tswitch (format) {\n        \tcase TIME_FORMAT_IN:\n        \t\tif (Math.round(ftime * 10) == 10) {\n        \t\t\tformatId = R.array.next_review_in_s;\n        \t\t} else {\n        \t\t\tformatId = R.array.next_review_in_p;    \t\t\t\n        \t\t}\n        \t\tbreak;\n        \tcase TIME_FORMAT_BEFORE:\n        \t\tif (Math.round(ftime * 10) == 10) {\n        \t\t\tformatId = R.array.next_review_before_s;\n        \t\t} else {\n        \t\t\tformatId = R.array.next_review_before_p;    \t\t\t\n        \t\t}\n        \t\tbreak;\n        \tcase TIME_FORMAT_DEFAULT:\n        \tdefault:\n        \t\tif (Math.round(ftime * 10) == 10) {\n        \t\t\tformatId = R.array.next_review_s;\n        \t\t} else {\n        \t\t\tformatId = R.array.next_review_p;    \t\t\t\n        \t\t}\n        \t\tbreak;\n        \t}\n    \t}\n\n    \tString timeString = String.format(AnkiDroidApp.getAppResources().getStringArray(formatId)[type], boldNumber ? \"<b>\" + fmtDouble(ftime, point) + \"<\/b>\" : fmtDouble(ftime, point));\n\t\tif (boldNumber && time == 1) {\n\t\t\ttimeString = timeString.replace(\"1\", \"<b>1<\/b>\");\n\t\t}\n\t\treturn timeString;\n    }\n\n\n    private static double convertSecondsTo(int seconds, int type) {\n    \tswitch (type) {\n    \tcase TIME_SECONDS:\n    \t\treturn seconds;\n    \tcase TIME_MINUTES:\n    \t\treturn seconds / 60.0;\n    \tcase TIME_HOURS:\n    \t\treturn seconds / 3600.0;    \t\t\n    \tcase TIME_DAYS:\n    \t\treturn seconds / 86400.0;    \t\t\n    \tcase TIME_MONTHS:\n    \t\treturn seconds / 2592000.0;    \t\t\n    \tcase TIME_YEARS:\n    \t\treturn seconds / 31536000.0;\n\t\tdefault:\n    \t\treturn 0;\n    \t}\n    }\n\n    /**\n     * Locale\n     * ***********************************************************************************************\n     */\n\n    /**\n     * @return double with percentage sign\n     */\n    public static String fmtPercentage(Double value) {\n\treturn fmtPercentage(value, 0);\n    }\n    public static String fmtPercentage(Double value, int point) {\n    \t// only retrieve the percentage format the first time\n    \tif (mCurrentPercentageFormat == null) {\n    \t\tmCurrentPercentageFormat = NumberFormat.getPercentInstance(Locale.getDefault());\n    \t}\n    \tmCurrentNumberFormat.setMaximumFractionDigits(point);\n    \treturn mCurrentPercentageFormat.format(value);\n    }\n\n\n    /**\n     * @return a string with decimal separator according to current locale\n     */\n    public static String fmtDouble(Double value) {\n    \treturn fmtDouble(value, 1);\n    }\n    public static String fmtDouble(Double value, int point) {\n    \t// only retrieve the number format the first time\n    \tif (mCurrentNumberFormat == null) {\n    \t\tmCurrentNumberFormat = NumberFormat.getInstance(Locale.getDefault());\n    \t}\n    \tmCurrentNumberFormat.setMaximumFractionDigits(point);\n    \treturn mCurrentNumberFormat.format(value);\n    }\n\n    /**\n     * HTML\n     * ***********************************************************************************************\n     */\n\n    /**\n     * Strips a text from <style>...<\/style>, <script>...<\/script> and <_any_tag_> HTML tags.\n     * @param The HTML text to be cleaned.\n     * @return The text without the aforementioned tags.\n     */\n    public static String stripHTML(String s) {\n        Matcher htmlMatcher = stylePattern.matcher(s);\n        s = htmlMatcher.replaceAll(\"\");\n        htmlMatcher = scriptPattern.matcher(s);\n        s = htmlMatcher.replaceAll(\"\");\n        htmlMatcher = tagPattern.matcher(s);\n        s = htmlMatcher.replaceAll(\"\");\n        return entsToTxt(s);\n    }\n\n\n    /**\n     * Strip HTML but keep media filenames\n     */\n    public static String stripHTMLMedia(String s) {\n        Matcher imgMatcher = imgPattern.matcher(s);\n        return stripHTML(imgMatcher.replaceAll(\" $1 \"));\n    }\n\n\n    private String minimizeHTML(String s) {\n    \t// TODO\n    \treturn s;\n    }\n\n\n    /**\n     * Takes a string and replaces all the HTML symbols in it with their unescaped representation.\n     * This should only affect substrings of the form &something; and not tags.\n     * Internet rumour says that Html.fromHtml() doesn't cover all cases, but it doesn't get less\n     * vague than that.\n     * @param html The HTML escaped text\n     * @return The text with its HTML entities unescaped.\n     */\n    private static String entsToTxt(String html) {\n        Matcher htmlEntities = htmlEntitiesPattern.matcher(html);\n        StringBuffer sb = new StringBuffer();\n        while (htmlEntities.find()) {\n            htmlEntities.appendReplacement(sb, Html.fromHtml(htmlEntities.group()).toString());\n        }\n        htmlEntities.appendTail(sb);\n        return sb.toString();\n    }\n\n    /**\n     * IDs\n     * ***********************************************************************************************\n     */\n\n    public static String hexifyID(long id) {\n        return Long.toHexString(id);\n    }\n\n\n    public static long dehexifyID(String id) {\n    \treturn Long.valueOf(id, 16);\n    }\n\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(int[] ids) {\n    \tStringBuilder sb = new StringBuilder();\n    \tsb.append(\"(\");\n        if (ids != null) {\n        \tString s = Arrays.toString(ids);\n        \tsb.append(s.substring(1, s.length() - 1));\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(long[] ids) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        if (ids != null) {\n            String s = Arrays.toString(ids);\n            sb.append(s.substring(1, s.length() - 1));\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(Long[] ids) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        if (ids != null) {\n            String s = Arrays.toString(ids);\n            sb.append(s.substring(1, s.length() - 1));\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static <T> String ids2str(List<T> ids) {\n        StringBuilder sb = new StringBuilder(512);\n        sb.append(\"(\");\n        boolean isNotFirst = false;\n        for (T id : ids) {\n            if (isNotFirst) {\n                sb.append(\", \");\n            } else {\n                isNotFirst = true;\n            }\n            sb.append(id);\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(JSONArray ids) {\n        StringBuilder str = new StringBuilder(512);\n        str.append(\"(\");\n        if (ids != null) {\n            int len = ids.length();\n            for (int i = 0; i < len; i++) {\n                try {\n                    if (i == (len - 1)) {\n                        str.append(ids.get(i));\n                    } else {\n                        str.append(ids.get(i)).append(\",\");\n                    }\n                } catch (JSONException e) {\n                    Log.e(AnkiDroidApp.TAG, \"JSONException = \" + e.getMessage());\n                }\n            }\n        }\n        str.append(\")\");\n        return str.toString();\n    }\n\n\n    /** LIBANKI: not in libanki */\n    public static long[] arrayList2array(List<Long> list) {\n    \tlong[] ar = new long[list.size()];\n    \tint i = 0;\n    \tfor (long l : list) {\n    \t\tar[i++] = l;\n    \t}\n    \treturn ar;\n    }\n\n    /** Return a non-conflicting timestamp for table. */\n    public static long timestampID(AnkiDb db, String table) {\n    \t// be careful not to create multiple objects without flushing them, or they\n        // may share an ID.\n    \tlong t = intNow(1000);\n    \twhile (db.queryScalar(\"SELECT id FROM \" + table + \" WHERE id = \" + t, false) != 0) {\n    \t\tt += 1;\n    \t}\n    \treturn t;\n    }\n\n\n    /** Return the first safe ID to use. */\n    public static long maxID(AnkiDb db) {\n    \tlong now = intNow(1000);\n    \tnow = Math.max(now, db.queryLongScalar(\"SELECT MAX(id) FROM cards\"));\n    \tnow = Math.max(now, db.queryLongScalar(\"SELECT MAX(id) FROM notes\"));\n    \treturn now + 1;\n    }\n\n\n    // used in ankiweb\n    public static String base62(int num, String extra) {\n    \tString table = ALL_CHARACTERS + extra;\n    \tint len = table.length();\n    \tString buf = \"\";\n    \tint mod = 0;\n    \twhile (num != 0) {\n    \t\tmod = num % len;\n    \t\tbuf = buf + table.substring(mod, mod + 1);\n    \t\tnum = num / len;\n    \t}\n        return buf;\n    }\n\n    // all printable characters minus quotes, backslash and separators\n    public static String base91(int num) {\n    \treturn base62(num, BASE91_EXTRA_CHARS);\n    }\n\n\n    /** return a base91-encoded 64bit random number */\n    public static String guid64() {\n    \treturn base91((new Random()).nextInt((int) (Math.pow(2, 61) - 1)));\n    }\n\n    // increment a guid by one, for note type conflicts\n    public static String incGuid(String guid) {\n    \treturn new StringBuffer(_incGuid(new StringBuffer(guid).reverse().toString())).reverse().toString();\n    }\n\n    private static String _incGuid(String guid) {\n    \tString table = ALL_CHARACTERS + BASE91_EXTRA_CHARS;\n    \tint idx = table.indexOf(guid.substring(0, 1));\n    \tif (idx + 1 == table.length()) {\n    \t\t// overflow\n    \t\tguid = table.substring(0, 1) + _incGuid(guid.substring(1, guid.length()));\n    \t} else {\n    \t\tguid = table.substring(idx + 1) + guid.substring(1, guid.length());\n    \t}\n    \treturn guid;\n    }\n\n//    public static JSONArray listToJSONArray(List<Object> list) {\n//        JSONArray jsonArray = new JSONArray();\n//\n//        for (Object o : list) {\n//            jsonArray.put(o);\n//        }\n//\n//        return jsonArray;\n//    }\n//\n//\n//    public static List<String> jsonArrayToListString(JSONArray jsonArray) throws JSONException {\n//        ArrayList<String> list = new ArrayList<String>();\n//\n//        int len = jsonArray.length();\n//        for (int i = 0; i < len; i++) {\n//            list.add(jsonArray.getString(i));\n//        }\n//\n//        return list;\n//    }\n\n    public static long[] jsonArrayToLongArray(JSONArray jsonArray) throws JSONException {\n    \tlong[] ar = new long[jsonArray.length()];\n        for (int i = 0; i < jsonArray.length(); i++) {\n        \tar[i] = jsonArray.getLong(i);\n        }\n        return ar;\n    }\n        \n    /**\n     * Fields\n     * ***********************************************************************************************\n     */\n\n    public static String joinFields(String[] list) {\n        StringBuilder result = new StringBuilder(128);\n        for (int i = 0; i < list.length - 1; i++) {\n            result.append(list[i]).append(\"\\u001f\");\n        }\n        if (list.length > 0) {\n            result.append(list[list.length - 1]);        \t\n        }\n        return result.toString();\n    }\n\n\n    public static String[] splitFields(String fields) {\n    \t// do not drop empty fields\n    \tfields = fields.replaceAll(\"\\\\x1f\\\\x1f\", \"\\u001f\\u001e\\u001f\");\n    \tfields = fields.replaceAll(\"\\\\x1f$\", \"\\u001f\\u001e\");\n    \tString[] split = fields.split(\"\\\\x1f\");\n    \tfor (int i = 0; i < split.length; i++) {\n    \t\tif (split[i].matches(\"\\\\x1e\")) {\n    \t\t\tsplit[i] = \"\";\n    \t\t}\n    \t}\n    \treturn split;\n    }\n\n    /**\n     * Checksums\n     * ***********************************************************************************************\n     */\n\n    /**\n     * SHA1 checksum.\n     * Equivalent to python sha1.hexdigest()\n     *\n     * @param data the string to generate hash from\n     * @return A string of length 40 containing the hexadecimal representation of the MD5 checksum of data.\n     */\n    public static String checksum(String data) {\n        String result = \"\";\n        if (data != null) {\n            MessageDigest md = null;\n            byte[] digest = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA1\");\n                digest = md.digest(data.getBytes(\"UTF-8\"));\n            } catch (NoSuchAlgorithmException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.checksum: No such algorithm. \" + e.getMessage());\n                throw new RuntimeException(e);\n            } catch (UnsupportedEncodingException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.checksum: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            BigInteger biginteger = new BigInteger(1, digest);\n            result = biginteger.toString(16);\n            \n            // pad with zeros to length of 40 This method used to pad\n            // to the length of 32. As it turns out, sha1 has a digest\n            // size of 160 bits, leading to a hex digest size of 40,\n            // not 32.\n            if (result.length() < 40) {\n                String zeroes = \"0000000000000000000000000000000000000000\";\n                result = zeroes.substring(0, zeroes.length() - result.length()) + result;\n            }\n        }\n        return result;\n    }\n\n\n    /**\n     * @param data the string to generate hash from\n     * @return 32 bit unsigned number from first 8 digits of sha1 hash\n     */\n    public static long fieldChecksum(String data) {\n    \treturn Long.valueOf(checksum(stripHTMLMedia(data)).substring(0, 8), 16);\n    }\n    \n    /**\n     * Generate the SHA1 checksum of a file.\n     * @param file The file to be checked\n     * @return A string of length 32 containing the hexadecimal representation of the SHA1 checksum of the file's contents. \n     */\n    public static String fileChecksum(String file) {\n        byte[] buffer = new byte[1024];\n        byte[] digest = null;\n        try {\n            InputStream fis = new FileInputStream(file);\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            int numRead = 0;\n            do {\n                numRead = fis.read(buffer);\n                if (numRead > 0) {\n                    md.update(buffer, 0, numRead);\n                }\n            } while (numRead != -1);\n            fis.close();\n            digest = md.digest();\n        } catch (FileNotFoundException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.fileChecksum: File not found.\", e);\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.fileChecksum: No such algorithm.\", e);\n        } catch (IOException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.fileChecksum: IO exception.\", e);\n        }\n        BigInteger biginteger = new BigInteger(1, digest);\n        String result = biginteger.toString(16);\n        // pad with zeros to length of 40 - SHA1 is 160bit long\n        if (result.length() < 40) {\n            result = \"0000000000000000000000000000000000000000\".substring(0, 40 - result.length()) + result;\n        }\n        return result;\n    }\n\n\n    /** Replace HTML line break tags with new lines. */\n    public static String replaceLineBreak(String text) {\n        return text.replaceAll(\"<br(\\\\s*\\\\/*)>\", \"\\n\");\n\t}\n\n\n//    /**\n//     * MD5 sum of file.\n//     * Equivalent to checksum(open(os.path.join(mdir, file), \"rb\").read()))\n//     *\n//     * @param path The full path to the file\n//     * @return A string of length 32 containing the hexadecimal representation of the MD5 checksum of the contents\n//     * of the file\n//     */\n//    public static String fileChecksum(String path) {\n//        byte[] bytes = null;\n//        try {\n//            File file = new File(path);\n//            if (file != null && file.isFile()) {\n//                bytes = new byte[(int)file.length()];\n//                FileInputStream fin = new FileInputStream(file);\n//                fin.read(bytes);\n//            }\n//        } catch (FileNotFoundException e) {\n//            Log.e(AnkiDroidApp.TAG, \"Can't find file \" + path + \" to calculate its checksum\");\n//        } catch (IOException e) {\n//            Log.e(AnkiDroidApp.TAG, \"Can't read file \" + path + \" to calculate its checksum\");\n//        }\n//        if (bytes == null) {\n//            Log.w(AnkiDroidApp.TAG, \"File \" + path + \" appears to be empty\");\n//            return \"\";\n//        }\n//        MessageDigest md = null;\n//        byte[] digest = null;\n//        try {\n//            md = MessageDigest.getInstance(\"MD5\");\n//            digest = md.digest(bytes);\n//        } catch (NoSuchAlgorithmException e) {\n//            Log.e(AnkiDroidApp.TAG, \"Utils.checksum: No such algorithm. \" + e.getMessage());\n//            throw new RuntimeException(e);\n//        }\n//        BigInteger biginteger = new BigInteger(1, digest);\n//        String result = biginteger.toString(16);\n//        // pad with zeros to length of 32\n//        if (result.length() < 32) {\n//            result = \"00000000000000000000000000000000\".substring(0, 32 - result.length()) + result;\n//        }\n//        return result;\n//    }\n\n    /**\n     *  Tempo files\n     * ***********************************************************************************************\n     */\n\n    // tmpdir\n    // tmpfile\n    // namedtmp\n    /**\n     * Converts an InputStream to a String.\n     * @param is InputStream to convert\n     * @return String version of the InputStream\n     */\n    public static String convertStreamToString(InputStream is) {\n        String contentOfMyInputStream = \"\";\n        try {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is), 4096);\n            String line;\n            StringBuilder sb = new StringBuilder();\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            rd.close();\n            contentOfMyInputStream = sb.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return contentOfMyInputStream;\n    }\n\n\n    public static boolean unzipFiles(ZipFile zipFile, String targetDirectory, String[] zipEntries, HashMap<String, String> zipEntryToFilenameMap) {\n        byte[] buf = new byte[FILE_COPY_BUFFER_SIZE];\n        File dir = new File(targetDirectory);\n        if (!dir.exists() && !dir.mkdirs()) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Could not create target directory: \" + targetDirectory);\n            return false;\n        }\n        if (zipEntryToFilenameMap == null) {\n            zipEntryToFilenameMap = new HashMap<String, String>();\n        }\n        BufferedInputStream zis = null;\n        BufferedOutputStream bos = null;\n        try {\n            for (String requestedEntry : zipEntries) {\n                ZipEntry ze = zipFile.getEntry(requestedEntry);\n                if (ze != null) {\n                    String name = ze.getName();\n                    if (zipEntryToFilenameMap.containsKey(name)) {\n                        name = zipEntryToFilenameMap.get(name);\n                    }\n                    File destFile = new File(dir, name);\n                    File parentDir = destFile.getParentFile();\n                    if (!parentDir.exists() && !parentDir.mkdirs()) {\n                        return false;\n                    }\n                    if (!ze.isDirectory()) {\n                        Log.i(AnkiDroidApp.TAG, \"uncompress \" + name);\n                        zis = new BufferedInputStream(zipFile.getInputStream(ze));\n                        bos = new BufferedOutputStream(new FileOutputStream(destFile), FILE_COPY_BUFFER_SIZE);\n                        int n;\n                        while ((n = zis.read(buf, 0, FILE_COPY_BUFFER_SIZE)) != -1) {\n                            bos.write(buf, 0, n);\n                        }\n                        bos.flush();\n                        bos.close();\n                        zis.close();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Error while unzipping archive.\", e);\n            return false;\n        } finally {\n            try {\n                if (bos != null) {\n                    bos.close();\n                }\n            } catch (IOException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Error while closing output stream.\", e);\n            }\n            try {\n                if (zis != null) {\n                    zis.close();\n                }\n            } catch (IOException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Error while closing zip input stream.\", e);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compress data.\n     * @param bytesToCompress is the byte array to compress.\n     * @return a compressed byte array.\n     * @throws java.io.IOException\n     */\n    public static byte[] compress(byte[] bytesToCompress, int comp) throws IOException {\n        // Compressor with highest level of compression.\n        Deflater compressor = new Deflater(comp, true);\n        // Give the compressor the data to compress.\n        compressor.setInput(bytesToCompress);\n        compressor.finish();\n\n        // Create an expandable byte array to hold the compressed data.\n        // It is not necessary that the compressed data will be smaller than\n        // the uncompressed data.\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(bytesToCompress.length);\n\n        // Compress the data\n        byte[] buf = new byte[65536];\n        while (!compressor.finished()) {\n            bos.write(buf, 0, compressor.deflate(buf));\n        }\n\n        bos.close();\n\n        // Get the compressed data\n        return bos.toByteArray();\n    }\n\n\n    /**\n     * Utility method to write to a file.\n     * Throws the exception, so we can report it in syncing log\n     * @throws IOException \n     */\n    public static void writeToFile(InputStream source, String destination) throws IOException {\n        Log.i(AnkiDroidApp.TAG, \"Creating new file... = \" + destination);\n        new File(destination).createNewFile();\n\n        long startTimeMillis = System.currentTimeMillis();\n        OutputStream output = new BufferedOutputStream(new FileOutputStream(destination));\n\n        // Transfer bytes, from source to destination.\n        byte[] buf = new byte[CHUNK_SIZE];\n        long sizeBytes = 0;\n        int len;\n        if (source == null) {\n            Log.e(AnkiDroidApp.TAG, \"source is null!\");\n        }\n        while ((len = source.read(buf)) >= 0) {\n            output.write(buf, 0, len);\n            sizeBytes += len;\n        }\n        long endTimeMillis = System.currentTimeMillis();\n\n        Log.i(AnkiDroidApp.TAG, \"Finished writing!\");\n        long durationSeconds = (endTimeMillis - startTimeMillis) / 1000;\n        long sizeKb = sizeBytes / 1024;\n        long speedKbSec = 0;\n        if (endTimeMillis != startTimeMillis) {\n            speedKbSec = sizeKb * 1000 / (endTimeMillis - startTimeMillis);\n        }\n        Log.d(AnkiDroidApp.TAG, \"Utils.writeToFile: \" + \"Size: \" + sizeKb + \"Kb, \" + \"Duration: \" + durationSeconds + \"s, \" + \"Speed: \" + speedKbSec + \"Kb/s\");\n        output.close();\n    }\n\n\n    // Print methods\n    public static void printJSONObject(JSONObject jsonObject) {\n        printJSONObject(jsonObject, \"-\", null);\n    }\n\n\n    public static void printJSONObject(JSONObject jsonObject, boolean writeToFile) {\n        BufferedWriter buff;\n        try {\n            buff = writeToFile ?  \n                    new BufferedWriter(new FileWriter(\"/sdcard/payloadAndroid.txt\"), 8192) : null;\n            try {\n                printJSONObject(jsonObject, \"-\", buff);\n            } finally {\n                if (buff != null)\n                    buff.close();\n            }\n        } catch (IOException ioe) {\n            Log.e(AnkiDroidApp.TAG, \"IOException = \" + ioe.getMessage());\n        }\n    }\n\n\n    private static void printJSONObject(JSONObject jsonObject, String indentation, BufferedWriter buff) {\n        try {\n            @SuppressWarnings(\"unchecked\") Iterator<String> keys = (Iterator<String>) jsonObject.keys();\n            TreeSet<String> orderedKeysSet = new TreeSet<String>();\n            while (keys.hasNext()) {\n                orderedKeysSet.add(keys.next());\n            }\n\n            Iterator<String> orderedKeys = orderedKeysSet.iterator();\n            while (orderedKeys.hasNext()) {\n                String key = orderedKeys.next();\n\n                try {\n                    Object value = jsonObject.get(key);\n                    if (value instanceof JSONObject) {\n                        if (buff != null) {\n                            buff.write(indentation + \" \" + key + \" : \");\n                            buff.newLine();\n                        }\n                        Log.i(AnkiDroidApp.TAG, \"\t\" + indentation + key + \" : \");\n                        printJSONObject((JSONObject) value, indentation + \"-\", buff);\n                    } else {\n                        if (buff != null) {\n                            buff.write(indentation + \" \" + key + \" = \" + jsonObject.get(key).toString());\n                            buff.newLine();\n                        }\n                        Log.i(AnkiDroidApp.TAG, \"\t\" + indentation + key + \" = \" + jsonObject.get(key).toString());\n                    }\n                } catch (JSONException e) {\n                    Log.e(AnkiDroidApp.TAG, \"JSONException = \" + e.getMessage());\n                }\n            }\n        } catch (IOException e1) {\n            Log.e(AnkiDroidApp.TAG, \"IOException = \" + e1.getMessage());\n        }\n    }\n\n\n    /*\n    public static void saveJSONObject(JSONObject jsonObject) throws IOException {\n        Log.i(AnkiDroidApp.TAG, \"saveJSONObject\");\n        BufferedWriter buff = new BufferedWriter(new FileWriter(\"/sdcard/jsonObjectAndroid.txt\", true));\n        buff.write(jsonObject.toString());\n        buff.close();\n    }\n    */\n\n\n    /**\n     * Returns 1 if true, 0 if false\n     *\n     * @param b The boolean to convert to integer\n     * @return 1 if b is true, 0 otherwise\n     */\n    public static int booleanToInt(boolean b) {\n        return (b) ? 1 : 0;\n    }\n\n\n    /**\n     *  Returns the effective date of the present moment.\n     *  If the time is prior the cut-off time (9:00am by default as of 11/02/10) return yesterday,\n     *  otherwise today\n     *  Note that the Date class is java.sql.Date whose constructor sets hours, minutes etc to zero\n     *\n     * @param utcOffset The UTC offset in seconds we are going to use to determine today or yesterday.\n     * @return The date (with time set to 00:00:00) that corresponds to today in Anki terms\n     */\n    public static Date genToday(double utcOffset) {\n        // The result is not adjusted for timezone anymore, following libanki model\n        // Timezone adjustment happens explicitly in Deck.updateCutoff(), but not in Deck.checkDailyStats()\n        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n        df.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n        Calendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT\"));\n        cal.setTimeInMillis(System.currentTimeMillis() - (long) utcOffset * 1000l);\n        Date today = Date.valueOf(df.format(cal.getTime()));\n        return today;\n    }\n\n\n    public static void printDate(String name, double date) {\n    \tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH-mm-ss\");\n    \tdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    \tCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT\"));\n    \tcal.setTimeInMillis((long)date * 1000);\n    \tLog.d(AnkiDroidApp.TAG, \"Value of \" + name + \": \" + cal.getTime().toGMTString());\n\t}\n\n\n    public static String doubleToTime(double value) {\n    \tint time = (int) Math.round(value);\n    \tint seconds = time % 60;\n    \tint minutes = (time - seconds) / 60;\n    \tString formattedTime;\n    \tif (seconds < 10) {\n    \t\tformattedTime = Integer.toString(minutes) + \":0\" + Integer.toString(seconds);\n    \t} else {\n    \t\tformattedTime = Integer.toString(minutes) + \":\" + Integer.toString(seconds);\n    \t}\n    \treturn formattedTime;\n    }\n\n\n    /**\n     * Returns the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1.\n     * @param date Date to convert to ordinal, since 01/01/01\n     * @return The ordinal representing the date\n     */\n    public static int dateToOrdinal(Date date) {\n        // BigDate.toOrdinal returns the ordinal since 1970, so we add up the days from 01/01/01 to 1970\n        return BigDate.toOrdinal(date.getYear() + 1900, date.getMonth() + 1, date.getDate()) + DAYS_BEFORE_1970;\n    }\n\n\n    /**\n     * Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1.\n     * @param ordinal representing the days since 01/01/01\n     * @return Date converted from the ordinal\n     */\n    public static Date ordinalToDate(int ordinal) {\n        return new Date((new BigDate(ordinal - DAYS_BEFORE_1970)).getLocalDate().getTime());\n    }\n\n\n    /**\n     * Indicates whether the specified action can be used as an intent. This method queries the package manager for\n     * installed packages that can respond to an intent with the specified action. If no suitable package is found, this\n     * method returns false.\n     * @param context The application's environment.\n     * @param action The Intent action to check for availability.\n     * @return True if an Intent with the specified action can be sent and responded to, false otherwise.\n     */\n    public static boolean isIntentAvailable(Context context, String action) {\n        return isIntentAvailable(context, action, null);\n    }\n\n\n    public static boolean isIntentAvailable(Context context, String action, ComponentName componentName) {\n        final PackageManager packageManager = context.getPackageManager();\n        final Intent intent = new Intent(action);\n        intent.setComponent(componentName);\n        List<ResolveInfo> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n        return list.size() > 0;\n    }\n\n    /**\n     * @param mediaDir media directory path on SD card\n     * @return path converted to file URL, properly UTF-8 URL encoded\n     */\n    public static String getBaseUrl(String mediaDir) {\n        // Use android.net.Uri class to ensure whole path is properly encoded\n        // File.toURL() does not work here, and URLEncoder class is not directly usable\n        // with existing slashes\n        if (mediaDir.length() != 0 && !mediaDir.equalsIgnoreCase(\"null\")) {\n            Uri mediaDirUri = Uri.fromFile(new File(mediaDir));\n\n            return mediaDirUri.toString() +\"/\";\n        }\n        return \"\";\n    }\n\n\n    /**\n     * Take an array of Long and return an array of long\n     * \n     * @param array The input with type Long[]\n     * @return The output with type long[]\n     */\n    public static long[] toPrimitive(Long[] array) {\n        long[] results = new long[array.length];\n        if (array != null) {\n            for (int i = 0; i < array.length; i++) {\n                results[i] = array[i].longValue();\n            }\n        }\n        return results;\n    }\n    public static long[] toPrimitive(Collection<Long> array) {\n        long[] results = new long[array.size()];\n        if (array != null) {\n            int i = 0;\n            for (Long item : array) {\n                results[i++] = item.longValue();\n            }\n        }\n        return results;\n    }\n  \n\n    public static void updateProgressBars(View view, int x, int y) {\n        if (view == null) {\n            return;\n        }\n        if (view.getParent() instanceof LinearLayout) {\n            LinearLayout.LayoutParams lparam = new LinearLayout.LayoutParams(0, 0);            \n            lparam.height = y;\n            lparam.width = x;\n            view.setLayoutParams(lparam);\n        } else if (view.getParent() instanceof FrameLayout) {\n        \tFrameLayout.LayoutParams lparam = new FrameLayout.LayoutParams(0, 0);            \n            lparam.height = y;\n            lparam.width = x;\n            view.setLayoutParams(lparam);\n        }\n    }  \n\n\n    /**\n     * Calculate the UTC offset\n     */\n    public static double utcOffset() {\n        Calendar cal = Calendar.getInstance();\n        // 4am\n        return 4 * 60 * 60 - (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / 1000;\n    }\n\n    /** Returns the filename without the extension. */\n    public static String removeExtension(String filename) {\n      int dotPosition = filename.lastIndexOf('.');\n      if (dotPosition == -1) {\n        return filename;\n      }\n      return filename.substring(0, dotPosition);\n    }\n\n\n    /** Removes any character that are not valid as deck names. */\n    public static String removeInvalidDeckNameCharacters(String name) {\n        if (name == null) { return null; }\n        // The only characters that we cannot absolutely allow to appear in the filename are the ones reserved in some\n        // file system. Currently these are \\, /, and :, in order to cover Linux, OSX, and Windows.\n        return name.replaceAll(\"[:/\\\\\\\\]\", \"\");\n    }\n\n\n    /** Returns a list of files for the installed custom fonts. */\n    public static List<AnkiFont> getCustomFonts(Context context) {\n        String deckPath = AnkiDroidApp.getCurrentAnkiDroidDirectory();\n        String fontsPath = deckPath + \"/fonts/\";\n        File fontsDir = new File(fontsPath);\n        int fontsCount = 0;\n        File[] fontsList = null;\n        if (fontsDir.exists() && fontsDir.isDirectory()) {\n        \tfontsCount = fontsDir.listFiles().length;\n        \tfontsList = fontsDir.listFiles();\n        }\n        String[] ankiDroidFonts = null;\n\t\ttry {\n\t\t\tankiDroidFonts = context.getAssets().list(\"fonts\");\n\t\t} catch (IOException e) {\n\t\t\tLog.e(AnkiDroidApp.TAG, \"Error on retrieving ankidroid fonts: \" + e);\n\t\t}\n        List<AnkiFont> fonts = new ArrayList<AnkiFont>();\n        for (int i = 0; i < fontsCount; i++) {\n            AnkiFont font = AnkiFont.createAnkiFont(context, fontsList[i].getAbsolutePath(), false);\n            if (font != null) {\n                fonts.add(font);\n            }\n        }\n        for (int i = 0; i < ankiDroidFonts.length; i++) {\n            AnkiFont font = AnkiFont.createAnkiFont(context, ankiDroidFonts[i], true);\n        \tif (font != null) {\n                fonts.add(font);\n            }\n        }\n\n       \treturn fonts;\n    }\n\n    \n    /** Returns a list of apkg-files. */\n    public static List<File> getImportableDecks() {\n        String deckPath = AnkiDroidApp.getCurrentAnkiDroidDirectory();\n        File dir = new File(deckPath);\n        int deckCount = 0;\n        File[] deckList = null;\n        if (dir.exists() && dir.isDirectory()) {\n        \tdeckList = dir.listFiles(new FileFilter(){\n                @Override\n                public boolean accept(File pathname) {\n                    if (pathname.isFile() && pathname.getName().endsWith(\".apkg\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n        \tdeckCount = deckList.length;\n        }\n        List<File> decks = new ArrayList<File>();\n        for (int i = 0; i < deckCount; i++) {\n        \tdecks.add(deckList[i]);\n        }\n       \treturn decks;\n    }\n\n\n    /** Joins the given string values using the delimiter between them. */\n    public static String join(String delimiter, String... values) {\n        StringBuilder sb = new StringBuilder();\n        for (String value : values) {\n            if (sb.length() != 0) {\n                sb.append(delimiter);\n            }\n            sb.append(value);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Simply copy a file to another location\n     * @param sourceFile The source file\n     * @param destFile The destination file, doesn't need to exist yet.\n     * @throws IOException\n     */\n    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if(!destFile.exists()) {\n            destFile.createNewFile();\n        }\n\n        FileChannel source = null;\n        FileChannel destination = null;\n\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n\n    /**\n     * Like org.json.JSONObject except that it doesn't escape forward slashes\n     * The necessity for this method is due to python's 2.7 json.dumps() function that doesn't escape chracter '/'.\n     * The org.json.JSONObject parser accepts both escaped and unescaped forward slashes, so we only need to worry for\n     * our output, when we write to the database or syncing.\n     *\n     * @param json a json object to serialize\n     * @return the json serialization of the object\n     * @see org.json.JSONObject#toString()\n     */\n    public static String jsonToString(JSONObject json) {\n        return json.toString().replaceAll(\"\\\\\\\\/\", \"/\");\n    }\n\n    /**\n     * Like org.json.JSONArray except that it doesn't escape forward slashes\n     * The necessity for this method is due to python's 2.7 json.dumps() function that doesn't escape chracter '/'.\n     * The org.json.JSONArray parser accepts both escaped and unescaped forward slashes, so we only need to worry for\n     * our output, when we write to the database or syncing.\n     *\n     * @param json a json object to serialize\n     * @return the json serialization of the object\n     * @see org.json.JSONArray#toString()\n     */\n    public static String jsonToString(JSONArray json) {\n        return json.toString().replaceAll(\"\\\\\\\\/\", \"/\");\n    }\n}\n","Method after Refactoring":"/****************************************************************************************\n * Copyright (c) 2009 Daniel Svrd <daniel.svard@gmail.com>                             *\n * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *\n * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *\n * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage com.ichi2.libanki;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.net.Uri;\nimport android.text.Html;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.LinearLayout;\nimport com.ichi2.anki.AnkiDb;\nimport com.ichi2.anki.AnkiDroidApp;\nimport com.ichi2.anki.AnkiFont;\nimport com.ichi2.anki.R;\nimport com.mindprod.common11.BigDate;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.nio.channels.FileChannel;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.sql.Date;\nimport java.text.NumberFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Enumeration;\nimport java.util.GregorianCalendar;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.TimeZone;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n/**\n * TODO comments\n */\npublic class Utils {\n    enum SqlCommandType { SQL_INS, SQL_UPD, SQL_DEL };\n\n    // Used to format doubles with English's decimal separator system\n    public static final Locale ENGLISH_LOCALE = new Locale(\"en_US\");\n\n    public static final int CHUNK_SIZE = 32768;\n\n    private static final int DAYS_BEFORE_1970 = 719163;\n\n    private static NumberFormat mCurrentNumberFormat;\n    private static NumberFormat mCurrentPercentageFormat;\n\n    private static TreeSet<Long> sIdTree;\n    private static long sIdTime;\n\n    private static final int TIME_SECONDS = 0;\n    private static final int TIME_MINUTES = 1;\n    private static final int TIME_HOURS = 2;\n    private static final int TIME_DAYS = 3;\n    private static final int TIME_MONTHS = 4;\n    private static final int TIME_YEARS = 5;\n\n    public static final int TIME_FORMAT_DEFAULT = 0;\n    public static final int TIME_FORMAT_IN = 1;\n    public static final int TIME_FORMAT_BEFORE = 2;\n\n    /* Prevent class from being instantiated */\n    private Utils() { }\n\n    // Regex pattern used in removing tags from text before diff\n    private static final Pattern stylePattern = Pattern.compile(\"(?s)<style.*?>.*?<\/style>\");\n    private static final Pattern scriptPattern = Pattern.compile(\"(?s)<script.*?>.*?<\/script>\");\n    private static final Pattern tagPattern = Pattern.compile(\"<.*?>\");\n    private static final Pattern imgPattern = Pattern.compile(\"<img src=[\\\\\\\"']?([^\\\\\\\"'>]+)[\\\\\\\"']? ?/?>\");\n    private static final Pattern htmlEntitiesPattern = Pattern.compile(\"&#?\\\\w+;\");\n\n    private static final String ALL_CHARACTERS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    private static final String BASE91_EXTRA_CHARS = \"!#$%&()*+,-./:;<=>?@[]^_`{|}~\";\n\n    public static final int FILE_COPY_BUFFER_SIZE = 2048;\n\n    /**The time in integer seconds. Pass scale=1000 to get milliseconds. */\n    public static double now() {\n        return (System.currentTimeMillis() / 1000.0);\n    }\n\n\n    /**The time in integer seconds. Pass scale=1000 to get milliseconds. */\n    public static long intNow() {\n    \treturn intNow(1);\n    }\n\tpublic static long intNow(int scale) {\n        return (long) (now() * scale);\n    }\n\n    // timetable\n    // aftertimetable\n    // shorttimetable\n    \n    /**\n     * Return a string representing a time span (eg '2 days').\n     * @param inFormat: if true, return eg 'in 2 days'\n     */\n    public static String fmtTimeSpan(int time) {\n        return fmtTimeSpan(time, 0, false, false);\n    }\n    public static String fmtTimeSpan(int time, boolean _short) {\n        return fmtTimeSpan(time, 0, _short, false);\n    }\n    public static String fmtTimeSpan(int time, int format, boolean _short, boolean boldNumber) {\n    \tint type;\n    \tint unit = 99;\n    \tint point = 0;\n    \tif (Math.abs(time) < 60 || unit < 1) {\n    \t\ttype = TIME_SECONDS;\n    \t} else if (Math.abs(time) < 3600 || unit < 2) {\n    \t\ttype = TIME_MINUTES;\n    \t} else if (Math.abs(time) < 60 * 60 * 24 || unit < 3) {\n    \t\ttype = TIME_HOURS;\n    \t} else if (Math.abs(time) < 60 * 60 * 24 * 29.5 || unit < 4) {\n    \t\ttype = TIME_DAYS;\n    \t} else if (Math.abs(time) < 60 * 60 * 24 * 30 * 11.95 || unit < 5) {\n    \t\ttype = TIME_MONTHS;\n    \t\tpoint = 1;\n    \t} else {\n    \t\ttype = TIME_YEARS;\n    \t\tpoint = 1;\n    \t}\n    \tdouble ftime = convertSecondsTo(time, type);\n\n    \tint formatId;\n    \tif (false){//_short) {\n    \t    //formatId = R.array.next_review_short;\n    \t} else {\n        \tswitch (format) {\n        \tcase TIME_FORMAT_IN:\n        \t\tif (Math.round(ftime * 10) == 10) {\n        \t\t\tformatId = R.array.next_review_in_s;\n        \t\t} else {\n        \t\t\tformatId = R.array.next_review_in_p;    \t\t\t\n        \t\t}\n        \t\tbreak;\n        \tcase TIME_FORMAT_BEFORE:\n        \t\tif (Math.round(ftime * 10) == 10) {\n        \t\t\tformatId = R.array.next_review_before_s;\n        \t\t} else {\n        \t\t\tformatId = R.array.next_review_before_p;    \t\t\t\n        \t\t}\n        \t\tbreak;\n        \tcase TIME_FORMAT_DEFAULT:\n        \tdefault:\n        \t\tif (Math.round(ftime * 10) == 10) {\n        \t\t\tformatId = R.array.next_review_s;\n        \t\t} else {\n        \t\t\tformatId = R.array.next_review_p;    \t\t\t\n        \t\t}\n        \t\tbreak;\n        \t}\n    \t}\n\n    \tString timeString = String.format(AnkiDroidApp.getAppResources().getStringArray(formatId)[type], boldNumber ? \"<b>\" + fmtDouble(ftime, point) + \"<\/b>\" : fmtDouble(ftime, point));\n\t\tif (boldNumber && time == 1) {\n\t\t\ttimeString = timeString.replace(\"1\", \"<b>1<\/b>\");\n\t\t}\n\t\treturn timeString;\n    }\n\n\n    private static double convertSecondsTo(int seconds, int type) {\n    \tswitch (type) {\n    \tcase TIME_SECONDS:\n    \t\treturn seconds;\n    \tcase TIME_MINUTES:\n    \t\treturn seconds / 60.0;\n    \tcase TIME_HOURS:\n    \t\treturn seconds / 3600.0;    \t\t\n    \tcase TIME_DAYS:\n    \t\treturn seconds / 86400.0;    \t\t\n    \tcase TIME_MONTHS:\n    \t\treturn seconds / 2592000.0;    \t\t\n    \tcase TIME_YEARS:\n    \t\treturn seconds / 31536000.0;\n\t\tdefault:\n    \t\treturn 0;\n    \t}\n    }\n\n    /**\n     * Locale\n     * ***********************************************************************************************\n     */\n\n    /**\n     * @return double with percentage sign\n     */\n    public static String fmtPercentage(Double value) {\n\treturn fmtPercentage(value, 0);\n    }\n    public static String fmtPercentage(Double value, int point) {\n    \t// only retrieve the percentage format the first time\n    \tif (mCurrentPercentageFormat == null) {\n    \t\tmCurrentPercentageFormat = NumberFormat.getPercentInstance(Locale.getDefault());\n    \t}\n    \tmCurrentNumberFormat.setMaximumFractionDigits(point);\n    \treturn mCurrentPercentageFormat.format(value);\n    }\n\n\n    /**\n     * @return a string with decimal separator according to current locale\n     */\n    public static String fmtDouble(Double value) {\n    \treturn fmtDouble(value, 1);\n    }\n    public static String fmtDouble(Double value, int point) {\n    \t// only retrieve the number format the first time\n    \tif (mCurrentNumberFormat == null) {\n    \t\tmCurrentNumberFormat = NumberFormat.getInstance(Locale.getDefault());\n    \t}\n    \tmCurrentNumberFormat.setMaximumFractionDigits(point);\n    \treturn mCurrentNumberFormat.format(value);\n    }\n\n    /**\n     * HTML\n     * ***********************************************************************************************\n     */\n\n    /**\n     * Strips a text from <style>...<\/style>, <script>...<\/script> and <_any_tag_> HTML tags.\n     * @param The HTML text to be cleaned.\n     * @return The text without the aforementioned tags.\n     */\n    public static String stripHTML(String s) {\n        Matcher htmlMatcher = stylePattern.matcher(s);\n        s = htmlMatcher.replaceAll(\"\");\n        htmlMatcher = scriptPattern.matcher(s);\n        s = htmlMatcher.replaceAll(\"\");\n        htmlMatcher = tagPattern.matcher(s);\n        s = htmlMatcher.replaceAll(\"\");\n        return entsToTxt(s);\n    }\n\n\n    /**\n     * Strip HTML but keep media filenames\n     */\n    public static String stripHTMLMedia(String s) {\n        Matcher imgMatcher = imgPattern.matcher(s);\n        return stripHTML(imgMatcher.replaceAll(\" $1 \"));\n    }\n\n\n    private String minimizeHTML(String s) {\n    \t// TODO\n    \treturn s;\n    }\n\n\n    /**\n     * Takes a string and replaces all the HTML symbols in it with their unescaped representation.\n     * This should only affect substrings of the form &something; and not tags.\n     * Internet rumour says that Html.fromHtml() doesn't cover all cases, but it doesn't get less\n     * vague than that.\n     * @param html The HTML escaped text\n     * @return The text with its HTML entities unescaped.\n     */\n    private static String entsToTxt(String html) {\n        Matcher htmlEntities = htmlEntitiesPattern.matcher(html);\n        StringBuffer sb = new StringBuffer();\n        while (htmlEntities.find()) {\n            htmlEntities.appendReplacement(sb, Html.fromHtml(htmlEntities.group()).toString());\n        }\n        htmlEntities.appendTail(sb);\n        return sb.toString();\n    }\n\n    /**\n     * IDs\n     * ***********************************************************************************************\n     */\n\n    public static String hexifyID(long id) {\n        return Long.toHexString(id);\n    }\n\n\n    public static long dehexifyID(String id) {\n    \treturn Long.valueOf(id, 16);\n    }\n\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(int[] ids) {\n    \tStringBuilder sb = new StringBuilder();\n    \tsb.append(\"(\");\n        if (ids != null) {\n        \tString s = Arrays.toString(ids);\n        \tsb.append(s.substring(1, s.length() - 1));\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(long[] ids) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        if (ids != null) {\n            String s = Arrays.toString(ids);\n            sb.append(s.substring(1, s.length() - 1));\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(Long[] ids) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        if (ids != null) {\n            String s = Arrays.toString(ids);\n            sb.append(s.substring(1, s.length() - 1));\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static <T> String ids2str(List<T> ids) {\n        StringBuilder sb = new StringBuilder(512);\n        sb.append(\"(\");\n        boolean isNotFirst = false;\n        for (T id : ids) {\n            if (isNotFirst) {\n                sb.append(\", \");\n            } else {\n                isNotFirst = true;\n            }\n            sb.append(id);\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n\n    /** Given a list of integers, return a string '(int1,int2,...)'. */\n    public static String ids2str(JSONArray ids) {\n        StringBuilder str = new StringBuilder(512);\n        str.append(\"(\");\n        if (ids != null) {\n            int len = ids.length();\n            for (int i = 0; i < len; i++) {\n                try {\n                    if (i == (len - 1)) {\n                        str.append(ids.get(i));\n                    } else {\n                        str.append(ids.get(i)).append(\",\");\n                    }\n                } catch (JSONException e) {\n                    Log.e(AnkiDroidApp.TAG, \"JSONException = \" + e.getMessage());\n                }\n            }\n        }\n        str.append(\")\");\n        return str.toString();\n    }\n\n\n    /** LIBANKI: not in libanki */\n    public static long[] arrayList2array(List<Long> list) {\n    \tlong[] ar = new long[list.size()];\n    \tint i = 0;\n    \tfor (long l : list) {\n    \t\tar[i++] = l;\n    \t}\n    \treturn ar;\n    }\n\n    /** Return a non-conflicting timestamp for table. */\n    public static long timestampID(AnkiDb db, String table) {\n    \t// be careful not to create multiple objects without flushing them, or they\n        // may share an ID.\n    \tlong t = intNow(1000);\n    \twhile (db.queryScalar(\"SELECT id FROM \" + table + \" WHERE id = \" + t, false) != 0) {\n    \t\tt += 1;\n    \t}\n    \treturn t;\n    }\n\n\n    /** Return the first safe ID to use. */\n    public static long maxID(AnkiDb db) {\n    \tlong now = intNow(1000);\n    \tnow = Math.max(now, db.queryLongScalar(\"SELECT MAX(id) FROM cards\"));\n    \tnow = Math.max(now, db.queryLongScalar(\"SELECT MAX(id) FROM notes\"));\n    \treturn now + 1;\n    }\n\n\n    // used in ankiweb\n    public static String base62(int num, String extra) {\n    \tString table = ALL_CHARACTERS + extra;\n    \tint len = table.length();\n    \tString buf = \"\";\n    \tint mod = 0;\n    \twhile (num != 0) {\n    \t\tmod = num % len;\n    \t\tbuf = buf + table.substring(mod, mod + 1);\n    \t\tnum = num / len;\n    \t}\n        return buf;\n    }\n\n    // all printable characters minus quotes, backslash and separators\n    public static String base91(int num) {\n    \treturn base62(num, BASE91_EXTRA_CHARS);\n    }\n\n\n    /** return a base91-encoded 64bit random number */\n    public static String guid64() {\n    \treturn base91((new Random()).nextInt((int) (Math.pow(2, 61) - 1)));\n    }\n\n    // increment a guid by one, for note type conflicts\n    public static String incGuid(String guid) {\n    \treturn new StringBuffer(_incGuid(new StringBuffer(guid).reverse().toString())).reverse().toString();\n    }\n\n    private static String _incGuid(String guid) {\n    \tString table = ALL_CHARACTERS + BASE91_EXTRA_CHARS;\n    \tint idx = table.indexOf(guid.substring(0, 1));\n    \tif (idx + 1 == table.length()) {\n    \t\t// overflow\n    \t\tguid = table.substring(0, 1) + _incGuid(guid.substring(1, guid.length()));\n    \t} else {\n    \t\tguid = table.substring(idx + 1) + guid.substring(1, guid.length());\n    \t}\n    \treturn guid;\n    }\n\n//    public static JSONArray listToJSONArray(List<Object> list) {\n//        JSONArray jsonArray = new JSONArray();\n//\n//        for (Object o : list) {\n//            jsonArray.put(o);\n//        }\n//\n//        return jsonArray;\n//    }\n//\n//\n//    public static List<String> jsonArrayToListString(JSONArray jsonArray) throws JSONException {\n//        ArrayList<String> list = new ArrayList<String>();\n//\n//        int len = jsonArray.length();\n//        for (int i = 0; i < len; i++) {\n//            list.add(jsonArray.getString(i));\n//        }\n//\n//        return list;\n//    }\n\n    public static long[] jsonArrayToLongArray(JSONArray jsonArray) throws JSONException {\n    \tlong[] ar = new long[jsonArray.length()];\n        for (int i = 0; i < jsonArray.length(); i++) {\n        \tar[i] = jsonArray.getLong(i);\n        }\n        return ar;\n    }\n        \n    /**\n     * Fields\n     * ***********************************************************************************************\n     */\n\n    public static String joinFields(String[] list) {\n        StringBuilder result = new StringBuilder(128);\n        for (int i = 0; i < list.length - 1; i++) {\n            result.append(list[i]).append(\"\\u001f\");\n        }\n        if (list.length > 0) {\n            result.append(list[list.length - 1]);        \t\n        }\n        return result.toString();\n    }\n\n\n    public static String[] splitFields(String fields) {\n    \t// do not drop empty fields\n    \tfields = fields.replaceAll(\"\\\\x1f\\\\x1f\", \"\\u001f\\u001e\\u001f\");\n    \tfields = fields.replaceAll(\"\\\\x1f$\", \"\\u001f\\u001e\");\n    \tString[] split = fields.split(\"\\\\x1f\");\n    \tfor (int i = 0; i < split.length; i++) {\n    \t\tif (split[i].matches(\"\\\\x1e\")) {\n    \t\t\tsplit[i] = \"\";\n    \t\t}\n    \t}\n    \treturn split;\n    }\n\n    /**\n     * Checksums\n     * ***********************************************************************************************\n     */\n\n    /**\n     * SHA1 checksum.\n     * Equivalent to python sha1.hexdigest()\n     *\n     * @param data the string to generate hash from\n     * @return A string of length 40 containing the hexadecimal representation of the MD5 checksum of data.\n     */\n    public static String checksum(String data) {\n        String result = \"\";\n        if (data != null) {\n            MessageDigest md = null;\n            byte[] digest = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA1\");\n                digest = md.digest(data.getBytes(\"UTF-8\"));\n            } catch (NoSuchAlgorithmException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.checksum: No such algorithm. \" + e.getMessage());\n                throw new RuntimeException(e);\n            } catch (UnsupportedEncodingException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.checksum: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            BigInteger biginteger = new BigInteger(1, digest);\n            result = biginteger.toString(16);\n            \n            // pad with zeros to length of 40 This method used to pad\n            // to the length of 32. As it turns out, sha1 has a digest\n            // size of 160 bits, leading to a hex digest size of 40,\n            // not 32.\n            if (result.length() < 40) {\n                String zeroes = \"0000000000000000000000000000000000000000\";\n                result = zeroes.substring(0, zeroes.length() - result.length()) + result;\n            }\n        }\n        return result;\n    }\n\n\n    /**\n     * @param data the string to generate hash from\n     * @return 32 bit unsigned number from first 8 digits of sha1 hash\n     */\n    public static long fieldChecksum(String data) {\n    \treturn Long.valueOf(checksum(stripHTMLMedia(data)).substring(0, 8), 16);\n    }\n    \n    /**\n     * Generate the SHA1 checksum of a file.\n     * @param file The file to be checked\n     * @return A string of length 32 containing the hexadecimal representation of the SHA1 checksum of the file's contents. \n     */\n    public static String fileChecksum(String file) {\n        byte[] buffer = new byte[1024];\n        byte[] digest = null;\n        try {\n            InputStream fis = new FileInputStream(file);\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            int numRead = 0;\n            do {\n                numRead = fis.read(buffer);\n                if (numRead > 0) {\n                    md.update(buffer, 0, numRead);\n                }\n            } while (numRead != -1);\n            fis.close();\n            digest = md.digest();\n        } catch (FileNotFoundException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.fileChecksum: File not found.\", e);\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.fileChecksum: No such algorithm.\", e);\n        } catch (IOException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.fileChecksum: IO exception.\", e);\n        }\n        BigInteger biginteger = new BigInteger(1, digest);\n        String result = biginteger.toString(16);\n        // pad with zeros to length of 40 - SHA1 is 160bit long\n        if (result.length() < 40) {\n            result = \"0000000000000000000000000000000000000000\".substring(0, 40 - result.length()) + result;\n        }\n        return result;\n    }\n\n\n    /** Replace HTML line break tags with new lines. */\n    public static String replaceLineBreak(String text) {\n        return text.replaceAll(\"<br(\\\\s*\\\\/*)>\", \"\\n\");\n\t}\n\n\n//    /**\n//     * MD5 sum of file.\n//     * Equivalent to checksum(open(os.path.join(mdir, file), \"rb\").read()))\n//     *\n//     * @param path The full path to the file\n//     * @return A string of length 32 containing the hexadecimal representation of the MD5 checksum of the contents\n//     * of the file\n//     */\n//    public static String fileChecksum(String path) {\n//        byte[] bytes = null;\n//        try {\n//            File file = new File(path);\n//            if (file != null && file.isFile()) {\n//                bytes = new byte[(int)file.length()];\n//                FileInputStream fin = new FileInputStream(file);\n//                fin.read(bytes);\n//            }\n//        } catch (FileNotFoundException e) {\n//            Log.e(AnkiDroidApp.TAG, \"Can't find file \" + path + \" to calculate its checksum\");\n//        } catch (IOException e) {\n//            Log.e(AnkiDroidApp.TAG, \"Can't read file \" + path + \" to calculate its checksum\");\n//        }\n//        if (bytes == null) {\n//            Log.w(AnkiDroidApp.TAG, \"File \" + path + \" appears to be empty\");\n//            return \"\";\n//        }\n//        MessageDigest md = null;\n//        byte[] digest = null;\n//        try {\n//            md = MessageDigest.getInstance(\"MD5\");\n//            digest = md.digest(bytes);\n//        } catch (NoSuchAlgorithmException e) {\n//            Log.e(AnkiDroidApp.TAG, \"Utils.checksum: No such algorithm. \" + e.getMessage());\n//            throw new RuntimeException(e);\n//        }\n//        BigInteger biginteger = new BigInteger(1, digest);\n//        String result = biginteger.toString(16);\n//        // pad with zeros to length of 32\n//        if (result.length() < 32) {\n//            result = \"00000000000000000000000000000000\".substring(0, 32 - result.length()) + result;\n//        }\n//        return result;\n//    }\n\n    /**\n     *  Tempo files\n     * ***********************************************************************************************\n     */\n\n    // tmpdir\n    // tmpfile\n    // namedtmp\n    /**\n     * Converts an InputStream to a String.\n     * @param is InputStream to convert\n     * @return String version of the InputStream\n     */\n    public static String convertStreamToString(InputStream is) {\n        String contentOfMyInputStream = \"\";\n        try {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is), 4096);\n            String line;\n            StringBuilder sb = new StringBuilder();\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            rd.close();\n            contentOfMyInputStream = sb.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return contentOfMyInputStream;\n    }\n\n\n    public static boolean unzipFiles(ZipFile zipFile, String targetDirectory, String[] zipEntries, HashMap<String, String> zipEntryToFilenameMap) {\n        byte[] buf = new byte[FILE_COPY_BUFFER_SIZE];\n        File dir = new File(targetDirectory);\n        if (!dir.exists() && !dir.mkdirs()) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Could not create target directory: \" + targetDirectory);\n            return false;\n        }\n        if (zipEntryToFilenameMap == null) {\n            zipEntryToFilenameMap = new HashMap<String, String>();\n        }\n        BufferedInputStream zis = null;\n        BufferedOutputStream bos = null;\n        try {\n            for (String requestedEntry : zipEntries) {\n                ZipEntry ze = zipFile.getEntry(requestedEntry);\n                if (ze != null) {\n                    String name = ze.getName();\n                    if (zipEntryToFilenameMap.containsKey(name)) {\n                        name = zipEntryToFilenameMap.get(name);\n                    }\n                    File destFile = new File(dir, name);\n                    File parentDir = destFile.getParentFile();\n                    if (!parentDir.exists() && !parentDir.mkdirs()) {\n                        return false;\n                    }\n                    if (!ze.isDirectory()) {\n                        Log.i(AnkiDroidApp.TAG, \"uncompress \" + name);\n                        zis = new BufferedInputStream(zipFile.getInputStream(ze));\n                        bos = new BufferedOutputStream(new FileOutputStream(destFile), FILE_COPY_BUFFER_SIZE);\n                        int n;\n                        while ((n = zis.read(buf, 0, FILE_COPY_BUFFER_SIZE)) != -1) {\n                            bos.write(buf, 0, n);\n                        }\n                        bos.flush();\n                        bos.close();\n                        zis.close();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Error while unzipping archive.\", e);\n            return false;\n        } finally {\n            try {\n                if (bos != null) {\n                    bos.close();\n                }\n            } catch (IOException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Error while closing output stream.\", e);\n            }\n            try {\n                if (zis != null) {\n                    zis.close();\n                }\n            } catch (IOException e) {\n                Log.e(AnkiDroidApp.TAG, \"Utils.unzipFiles: Error while closing zip input stream.\", e);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compress data.\n     * @param bytesToCompress is the byte array to compress.\n     * @return a compressed byte array.\n     * @throws java.io.IOException\n     */\n    public static byte[] compress(byte[] bytesToCompress, int comp) throws IOException {\n        // Compressor with highest level of compression.\n        Deflater compressor = new Deflater(comp, true);\n        // Give the compressor the data to compress.\n        compressor.setInput(bytesToCompress);\n        compressor.finish();\n\n        // Create an expandable byte array to hold the compressed data.\n        // It is not necessary that the compressed data will be smaller than\n        // the uncompressed data.\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(bytesToCompress.length);\n\n        // Compress the data\n        byte[] buf = new byte[65536];\n        while (!compressor.finished()) {\n            bos.write(buf, 0, compressor.deflate(buf));\n        }\n\n        bos.close();\n\n        // Get the compressed data\n        return bos.toByteArray();\n    }\n\n\n    /**\n     * Utility method to write to a file.\n     * Throws the exception, so we can report it in syncing log\n     * @throws IOException \n     */\n    public static void writeToFile(InputStream source, String destination) throws IOException {\n        Log.i(AnkiDroidApp.TAG, \"Creating new file... = \" + destination);\n        new File(destination).createNewFile();\n\n        long startTimeMillis = System.currentTimeMillis();\n        OutputStream output = new BufferedOutputStream(new FileOutputStream(destination));\n\n        // Transfer bytes, from source to destination.\n        byte[] buf = new byte[CHUNK_SIZE];\n        long sizeBytes = 0;\n        int len;\n        if (source == null) {\n            Log.e(AnkiDroidApp.TAG, \"source is null!\");\n        }\n        while ((len = source.read(buf)) >= 0) {\n            output.write(buf, 0, len);\n            sizeBytes += len;\n        }\n        long endTimeMillis = System.currentTimeMillis();\n\n        Log.i(AnkiDroidApp.TAG, \"Finished writing!\");\n        long durationSeconds = (endTimeMillis - startTimeMillis) / 1000;\n        long sizeKb = sizeBytes / 1024;\n        long speedKbSec = 0;\n        if (endTimeMillis != startTimeMillis) {\n            speedKbSec = sizeKb * 1000 / (endTimeMillis - startTimeMillis);\n        }\n        Log.d(AnkiDroidApp.TAG, \"Utils.writeToFile: \" + \"Size: \" + sizeKb + \"Kb, \" + \"Duration: \" + durationSeconds + \"s, \" + \"Speed: \" + speedKbSec + \"Kb/s\");\n        output.close();\n    }\n\n\n    // Print methods\n    public static void printJSONObject(JSONObject jsonObject) {\n        printJSONObject(jsonObject, \"-\", null);\n    }\n\n\n    public static void printJSONObject(JSONObject jsonObject, boolean writeToFile) {\n        BufferedWriter buff;\n        try {\n            buff = writeToFile ?  \n                    new BufferedWriter(new FileWriter(\"/sdcard/payloadAndroid.txt\"), 8192) : null;\n            try {\n                printJSONObject(jsonObject, \"-\", buff);\n            } finally {\n                if (buff != null)\n                    buff.close();\n            }\n        } catch (IOException ioe) {\n            Log.e(AnkiDroidApp.TAG, \"IOException = \" + ioe.getMessage());\n        }\n    }\n\n\n    private static void printJSONObject(JSONObject jsonObject, String indentation, BufferedWriter buff) {\n        try {\n            @SuppressWarnings(\"unchecked\") Iterator<String> keys = (Iterator<String>) jsonObject.keys();\n            TreeSet<String> orderedKeysSet = new TreeSet<String>();\n            while (keys.hasNext()) {\n                orderedKeysSet.add(keys.next());\n            }\n\n            Iterator<String> orderedKeys = orderedKeysSet.iterator();\n            while (orderedKeys.hasNext()) {\n                String key = orderedKeys.next();\n\n                try {\n                    Object value = jsonObject.get(key);\n                    if (value instanceof JSONObject) {\n                        if (buff != null) {\n                            buff.write(indentation + \" \" + key + \" : \");\n                            buff.newLine();\n                        }\n                        Log.i(AnkiDroidApp.TAG, \"\t\" + indentation + key + \" : \");\n                        printJSONObject((JSONObject) value, indentation + \"-\", buff);\n                    } else {\n                        if (buff != null) {\n                            buff.write(indentation + \" \" + key + \" = \" + jsonObject.get(key).toString());\n                            buff.newLine();\n                        }\n                        Log.i(AnkiDroidApp.TAG, \"\t\" + indentation + key + \" = \" + jsonObject.get(key).toString());\n                    }\n                } catch (JSONException e) {\n                    Log.e(AnkiDroidApp.TAG, \"JSONException = \" + e.getMessage());\n                }\n            }\n        } catch (IOException e1) {\n            Log.e(AnkiDroidApp.TAG, \"IOException = \" + e1.getMessage());\n        }\n    }\n\n\n    /*\n    public static void saveJSONObject(JSONObject jsonObject) throws IOException {\n        Log.i(AnkiDroidApp.TAG, \"saveJSONObject\");\n        BufferedWriter buff = new BufferedWriter(new FileWriter(\"/sdcard/jsonObjectAndroid.txt\", true));\n        buff.write(jsonObject.toString());\n        buff.close();\n    }\n    */\n\n\n    /**\n     * Returns 1 if true, 0 if false\n     *\n     * @param b The boolean to convert to integer\n     * @return 1 if b is true, 0 otherwise\n     */\n    public static int booleanToInt(boolean b) {\n        return (b) ? 1 : 0;\n    }\n\n\n    /**\n     *  Returns the effective date of the present moment.\n     *  If the time is prior the cut-off time (9:00am by default as of 11/02/10) return yesterday,\n     *  otherwise today\n     *  Note that the Date class is java.sql.Date whose constructor sets hours, minutes etc to zero\n     *\n     * @param utcOffset The UTC offset in seconds we are going to use to determine today or yesterday.\n     * @return The date (with time set to 00:00:00) that corresponds to today in Anki terms\n     */\n    public static Date genToday(double utcOffset) {\n        // The result is not adjusted for timezone anymore, following libanki model\n        // Timezone adjustment happens explicitly in Deck.updateCutoff(), but not in Deck.checkDailyStats()\n        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n        df.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n        Calendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT\"));\n        cal.setTimeInMillis(System.currentTimeMillis() - (long) utcOffset * 1000l);\n        Date today = Date.valueOf(df.format(cal.getTime()));\n        return today;\n    }\n\n\n    public static void printDate(String name, double date) {\n    \tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH-mm-ss\");\n    \tdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    \tCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT\"));\n    \tcal.setTimeInMillis((long)date * 1000);\n    \tLog.d(AnkiDroidApp.TAG, \"Value of \" + name + \": \" + cal.getTime().toGMTString());\n\t}\n\n\n    public static String doubleToTime(double value) {\n    \tint time = (int) Math.round(value);\n    \tint seconds = time % 60;\n    \tint minutes = (time - seconds) / 60;\n    \tString formattedTime;\n    \tif (seconds < 10) {\n    \t\tformattedTime = Integer.toString(minutes) + \":0\" + Integer.toString(seconds);\n    \t} else {\n    \t\tformattedTime = Integer.toString(minutes) + \":\" + Integer.toString(seconds);\n    \t}\n    \treturn formattedTime;\n    }\n\n\n    /**\n     * Returns the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1.\n     * @param date Date to convert to ordinal, since 01/01/01\n     * @return The ordinal representing the date\n     */\n    public static int dateToOrdinal(Date date) {\n        // BigDate.toOrdinal returns the ordinal since 1970, so we add up the days from 01/01/01 to 1970\n        return BigDate.toOrdinal(date.getYear() + 1900, date.getMonth() + 1, date.getDate()) + DAYS_BEFORE_1970;\n    }\n\n\n    /**\n     * Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1.\n     * @param ordinal representing the days since 01/01/01\n     * @return Date converted from the ordinal\n     */\n    public static Date ordinalToDate(int ordinal) {\n        return new Date((new BigDate(ordinal - DAYS_BEFORE_1970)).getLocalDate().getTime());\n    }\n\n\n    /**\n     * Indicates whether the specified action can be used as an intent. This method queries the package manager for\n     * installed packages that can respond to an intent with the specified action. If no suitable package is found, this\n     * method returns false.\n     * @param context The application's environment.\n     * @param action The Intent action to check for availability.\n     * @return True if an Intent with the specified action can be sent and responded to, false otherwise.\n     */\n    public static boolean isIntentAvailable(Context context, String action) {\n        return isIntentAvailable(context, action, null);\n    }\n\n\n    public static boolean isIntentAvailable(Context context, String action, ComponentName componentName) {\n        final PackageManager packageManager = context.getPackageManager();\n        final Intent intent = new Intent(action);\n        intent.setComponent(componentName);\n        List<ResolveInfo> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n        return list.size() > 0;\n    }\n\n    /**\n     * @param mediaDir media directory path on SD card\n     * @return path converted to file URL, properly UTF-8 URL encoded\n     */\n    public static String getBaseUrl(String mediaDir) {\n        // Use android.net.Uri class to ensure whole path is properly encoded\n        // File.toURL() does not work here, and URLEncoder class is not directly usable\n        // with existing slashes\n        if (mediaDir.length() != 0 && !mediaDir.equalsIgnoreCase(\"null\")) {\n            Uri mediaDirUri = Uri.fromFile(new File(mediaDir));\n\n            return mediaDirUri.toString() +\"/\";\n        }\n        return \"\";\n    }\n\n\n    /**\n     * Take an array of Long and return an array of long\n     * \n     * @param array The input with type Long[]\n     * @return The output with type long[]\n     */\n    public static long[] toPrimitive(Long[] array) {\n        long[] results = new long[array.length];\n        if (array != null) {\n            for (int i = 0; i < array.length; i++) {\n                results[i] = array[i].longValue();\n            }\n        }\n        return results;\n    }\n    public static long[] toPrimitive(Collection<Long> array) {\n        long[] results = new long[array.size()];\n        if (array != null) {\n            int i = 0;\n            for (Long item : array) {\n                results[i++] = item.longValue();\n            }\n        }\n        return results;\n    }\n  \n\n    public static void updateProgressBars(View view, int x, int y) {\n        if (view == null) {\n            return;\n        }\n        if (view.getParent() instanceof LinearLayout) {\n            LinearLayout.LayoutParams lparam = new LinearLayout.LayoutParams(0, 0);            \n            lparam.height = y;\n            lparam.width = x;\n            view.setLayoutParams(lparam);\n        } else if (view.getParent() instanceof FrameLayout) {\n        \tFrameLayout.LayoutParams lparam = new FrameLayout.LayoutParams(0, 0);            \n            lparam.height = y;\n            lparam.width = x;\n            view.setLayoutParams(lparam);\n        }\n    }  \n\n\n    /**\n     * Calculate the UTC offset\n     */\n    public static double utcOffset() {\n        Calendar cal = Calendar.getInstance();\n        // 4am\n        return 4 * 60 * 60 - (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / 1000;\n    }\n\n    /** Returns the filename without the extension. */\n    public static String removeExtension(String filename) {\n      int dotPosition = filename.lastIndexOf('.');\n      if (dotPosition == -1) {\n        return filename;\n      }\n      return filename.substring(0, dotPosition);\n    }\n\n\n    /** Removes any character that are not valid as deck names. */\n    public static String removeInvalidDeckNameCharacters(String name) {\n        if (name == null) { return null; }\n        // The only characters that we cannot absolutely allow to appear in the filename are the ones reserved in some\n        // file system. Currently these are \\, /, and :, in order to cover Linux, OSX, and Windows.\n        return name.replaceAll(\"[:/\\\\\\\\]\", \"\");\n    }\n\n\n    /** Returns a list of files for the installed custom fonts. */\n    public static List<AnkiFont> getCustomFonts(Context context) {\n        String deckPath = AnkiDroidApp.getCurrentAnkiDroidDirectory();\n        String fontsPath = deckPath + \"/fonts/\";\n        File fontsDir = new File(fontsPath);\n        int fontsCount = 0;\n        File[] fontsList = null;\n        if (fontsDir.exists() && fontsDir.isDirectory()) {\n        \tfontsCount = fontsDir.listFiles().length;\n        \tfontsList = fontsDir.listFiles();\n        }\n        String[] ankiDroidFonts = null;\n\t\ttry {\n\t\t\tankiDroidFonts = context.getAssets().list(\"fonts\");\n\t\t} catch (IOException e) {\n\t\t\tLog.e(AnkiDroidApp.TAG, \"Error on retrieving ankidroid fonts: \" + e);\n\t\t}\n        List<AnkiFont> fonts = new ArrayList<AnkiFont>();\n        for (int i = 0; i < fontsCount; i++) {\n            String filePath = fontsList[i].getAbsolutePath();\n            if (!filePath.endsWith(\".ttf\") && !filePath.endsWith(\".ttc\")) {\n                // Ignore files that do not look like fonts.\n                continue;\n            }\n            AnkiFont font = AnkiFont.createAnkiFont(context, filePath, false);\n            if (font != null) {\n                fonts.add(font);\n            }\n        }\n        for (int i = 0; i < ankiDroidFonts.length; i++) {\n            // Assume all files in the assets directory are actually fonts.\n            AnkiFont font = AnkiFont.createAnkiFont(context, ankiDroidFonts[i], true);\n        \tif (font != null) {\n                fonts.add(font);\n            }\n        }\n\n       \treturn fonts;\n    }\n\n    \n    /** Returns a list of apkg-files. */\n    public static List<File> getImportableDecks() {\n        String deckPath = AnkiDroidApp.getCurrentAnkiDroidDirectory();\n        File dir = new File(deckPath);\n        int deckCount = 0;\n        File[] deckList = null;\n        if (dir.exists() && dir.isDirectory()) {\n        \tdeckList = dir.listFiles(new FileFilter(){\n                @Override\n                public boolean accept(File pathname) {\n                    if (pathname.isFile() && pathname.getName().endsWith(\".apkg\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n        \tdeckCount = deckList.length;\n        }\n        List<File> decks = new ArrayList<File>();\n        for (int i = 0; i < deckCount; i++) {\n        \tdecks.add(deckList[i]);\n        }\n       \treturn decks;\n    }\n\n\n    /** Joins the given string values using the delimiter between them. */\n    public static String join(String delimiter, String... values) {\n        StringBuilder sb = new StringBuilder();\n        for (String value : values) {\n            if (sb.length() != 0) {\n                sb.append(delimiter);\n            }\n            sb.append(value);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Simply copy a file to another location\n     * @param sourceFile The source file\n     * @param destFile The destination file, doesn't need to exist yet.\n     * @throws IOException\n     */\n    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if(!destFile.exists()) {\n            destFile.createNewFile();\n        }\n\n        FileChannel source = null;\n        FileChannel destination = null;\n\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n\n    /**\n     * Like org.json.JSONObject except that it doesn't escape forward slashes\n     * The necessity for this method is due to python's 2.7 json.dumps() function that doesn't escape chracter '/'.\n     * The org.json.JSONObject parser accepts both escaped and unescaped forward slashes, so we only need to worry for\n     * our output, when we write to the database or syncing.\n     *\n     * @param json a json object to serialize\n     * @return the json serialization of the object\n     * @see org.json.JSONObject#toString()\n     */\n    public static String jsonToString(JSONObject json) {\n        return json.toString().replaceAll(\"\\\\\\\\/\", \"/\");\n    }\n\n    /**\n     * Like org.json.JSONArray except that it doesn't escape forward slashes\n     * The necessity for this method is due to python's 2.7 json.dumps() function that doesn't escape chracter '/'.\n     * The org.json.JSONArray parser accepts both escaped and unescaped forward slashes, so we only need to worry for\n     * our output, when we write to the database or syncing.\n     *\n     * @param json a json object to serialize\n     * @return the json serialization of the object\n     * @see org.json.JSONArray#toString()\n     */\n    public static String jsonToString(JSONArray json) {\n        return json.toString().replaceAll(\"\\\\\\\\/\", \"/\");\n    }\n}\n","lineNo":1127}
